From 7f67e08d4511bb8350a855838e59f02c7f62e72a Mon Sep 17 00:00:00 2001
From: Johannes Doerfert <johannes@jdoerfert.de>
Date: Tue, 6 Mar 2018 18:14:15 +0100
Subject: [PATCH 09/29] Update isl

---
 lib/Analysis/isl/AUTHORS                           |     3 +-
 lib/Analysis/isl/CMakeLists.txt                    |    15 +-
 lib/Analysis/isl/ChangeLog                         |    10 +
 lib/Analysis/isl/GIT_HEAD_ID                       |     2 +-
 lib/Analysis/isl/Makefile.am                       |    39 +-
 lib/Analysis/isl/Makefile.in                       |   155 +-
 lib/Analysis/isl/aclocal.m4                        |     3 +
 lib/Analysis/isl/basis_reduction_templ.c           |     2 +-
 lib/Analysis/isl/bound.c                           |     4 +-
 lib/Analysis/isl/bound_test.sh.in                  |     1 +
 lib/Analysis/isl/bset_from_bmap.c                  |     8 +
 lib/Analysis/isl/bset_to_bmap.c                    |    10 +
 lib/Analysis/isl/config.guess                      |   152 +-
 lib/Analysis/isl/config.sub                        |    48 +-
 lib/Analysis/isl/configure                         |  4468 ++++--
 lib/Analysis/isl/configure.ac                      |   163 +-
 lib/Analysis/isl/doc/Makefile.in                   |     7 +
 lib/Analysis/isl/doc/implementation.tex            |    14 +-
 lib/Analysis/isl/doc/manual.pdf                    |   Bin 473515 -> 0 bytes
 lib/Analysis/isl/doc/user.pod                      |   374 +-
 lib/Analysis/isl/extract_key.c                     |    62 +
 lib/Analysis/isl/flow.c                            |    44 +
 lib/Analysis/isl/flow_cmp.c                        |   140 +
 lib/Analysis/isl/flow_test.sh.in                   |    18 +
 lib/Analysis/isl/imath/gmp_compat.c                |   155 +-
 lib/Analysis/isl/imath/imath.c                     |   168 +-
 lib/Analysis/isl/imath_wrap/wrap.h                 |     1 -
 lib/Analysis/isl/include/isl/aff.h                 |    64 +-
 lib/Analysis/isl/include/isl/aff_type.h            |     6 +-
 lib/Analysis/isl/include/isl/ast.h                 |     6 +
 lib/Analysis/isl/include/isl/ast_build.h           |    11 +-
 lib/Analysis/isl/include/isl/ast_type.h            |     4 +-
 lib/Analysis/isl/include/isl/constraint.h          |    13 +-
 lib/Analysis/isl/include/isl/deprecated/aff_int.h  |     2 +-
 lib/Analysis/isl/include/isl/deprecated/map_int.h  |     4 +-
 lib/Analysis/isl/include/isl/deprecated/set_int.h  |     2 +-
 lib/Analysis/isl/include/isl/flow.h                |    10 +
 lib/Analysis/isl/include/isl/id.h                  |     1 +
 lib/Analysis/isl/include/isl/isl-noexceptions.h    | 15252 +++++++++++++++++++
 lib/Analysis/isl/include/isl/list.h                |     5 +
 lib/Analysis/isl/include/isl/map.h                 |    72 +-
 lib/Analysis/isl/include/isl/mat.h                 |    42 +-
 lib/Analysis/isl/include/isl/multi.h               |     6 +
 lib/Analysis/isl/include/isl/point.h               |     3 +-
 lib/Analysis/isl/include/isl/polynomial.h          |    29 +-
 lib/Analysis/isl/include/isl/schedule.h            |    30 +-
 lib/Analysis/isl/include/isl/set.h                 |    46 +-
 lib/Analysis/isl/include/isl/space.h               |    31 +-
 lib/Analysis/isl/include/isl/stream.h              |     1 +
 lib/Analysis/isl/include/isl/union_map.h           |     8 +-
 lib/Analysis/isl/include/isl/union_set.h           |     8 +-
 lib/Analysis/isl/include/isl/val.h                 |     1 +
 lib/Analysis/isl/include/isl/vec.h                 |     2 +-
 lib/Analysis/isl/include/isl/vertices.h            |     2 +-
 lib/Analysis/isl/install-sh                        |    23 +-
 lib/Analysis/isl/interface/all.h                   |     1 +
 lib/Analysis/isl/interface/isl.h.top               |    95 +
 lib/Analysis/isl/interface/isl.py.top              |     2 +-
 lib/Analysis/isl/isl_aff.c                         |   521 +-
 lib/Analysis/isl/isl_aff_private.h                 |    15 +-
 lib/Analysis/isl/isl_affine_hull.c                 |   294 +-
 lib/Analysis/isl/isl_ast.c                         |   370 +-
 lib/Analysis/isl/isl_ast_build.c                   |     3 +-
 lib/Analysis/isl/isl_ast_build_expr.c              |    45 +-
 lib/Analysis/isl/isl_bernstein.c                   |    21 +-
 lib/Analysis/isl/isl_bernstein.h                   |     5 +-
 lib/Analysis/isl/isl_bound.c                       |    12 +-
 lib/Analysis/isl/isl_coalesce.c                    |  1114 +-
 lib/Analysis/isl/isl_config.h.in                   |    18 +-
 lib/Analysis/isl/isl_constraint.c                  |   122 +-
 lib/Analysis/isl/isl_constraint_private.h          |     2 +
 lib/Analysis/isl/isl_convex_hull.c                 |   352 +-
 lib/Analysis/isl/isl_dim_map.c                     |     6 +-
 lib/Analysis/isl/isl_dim_map.h                     |     4 +-
 lib/Analysis/isl/isl_equalities.c                  |    49 +-
 lib/Analysis/isl/isl_equalities.h                  |     4 +-
 lib/Analysis/isl/isl_factorization.h               |     5 +
 lib/Analysis/isl/isl_farkas.c                      |    22 +-
 lib/Analysis/isl/isl_flow.c                        |   890 +-
 lib/Analysis/isl/isl_fold.c                        |    48 +-
 lib/Analysis/isl/isl_ilp.c                         |    45 +-
 lib/Analysis/isl/isl_imath.c                       |    28 +
 lib/Analysis/isl/isl_imath.h                       |     2 +
 lib/Analysis/isl/isl_input.c                       |   220 +-
 lib/Analysis/isl/isl_int_gmp.h                     |     1 +
 lib/Analysis/isl/isl_int_imath.h                   |     3 +-
 lib/Analysis/isl/isl_int_sioimath.c                |     2 +
 lib/Analysis/isl/isl_int_sioimath.h                |    31 +
 lib/Analysis/isl/isl_list_templ.c                  |   109 +-
 lib/Analysis/isl/isl_local.c                       |    59 +-
 lib/Analysis/isl/isl_local.h                       |     1 +
 lib/Analysis/isl/isl_local_space.c                 |   119 +-
 lib/Analysis/isl/isl_local_space_private.h         |     6 +-
 lib/Analysis/isl/isl_lp.c                          |    30 +-
 lib/Analysis/isl/isl_map.c                         |  3502 +++--
 lib/Analysis/isl/isl_map_lexopt_templ.c            |   124 +-
 lib/Analysis/isl/isl_map_private.h                 |   253 +-
 lib/Analysis/isl/isl_map_simplify.c                |   890 +-
 lib/Analysis/isl/isl_map_subtract.c                |   100 +-
 lib/Analysis/isl/isl_mat.c                         |   444 +-
 lib/Analysis/isl/isl_mat_private.h                 |    12 +
 lib/Analysis/isl/isl_maybe_map.h                   |    10 +
 lib/Analysis/isl/isl_morph.c                       |    43 +-
 lib/Analysis/isl/isl_morph.h                       |     5 +-
 lib/Analysis/isl/isl_multi_apply_templ.c           |     7 +-
 lib/Analysis/isl/isl_multi_templ.c                 |    42 +-
 lib/Analysis/isl/isl_options.c                     |     7 +
 lib/Analysis/isl/isl_options_private.h             |     1 +
 lib/Analysis/isl/isl_output.c                      |   374 +-
 lib/Analysis/isl/isl_point.c                       |    27 +-
 lib/Analysis/isl/isl_polynomial.c                  |   216 +-
 lib/Analysis/isl/isl_polynomial_private.h          |     5 +-
 lib/Analysis/isl/isl_printer.c                     |    12 +-
 lib/Analysis/isl/isl_pw_templ.c                    |    87 +-
 lib/Analysis/isl/isl_range.c                       |    13 +-
 lib/Analysis/isl/isl_range.h                       |     2 +-
 lib/Analysis/isl/isl_sample.c                      |    43 +-
 lib/Analysis/isl/isl_sample.h                      |     3 +-
 lib/Analysis/isl/isl_scan.c                        |    19 +-
 lib/Analysis/isl/isl_scan.h                        |     5 +-
 lib/Analysis/isl/isl_schedule.c                    |    36 +-
 lib/Analysis/isl/isl_schedule_band.c               |    15 +-
 lib/Analysis/isl/isl_schedule_constraints.c        |   725 +
 lib/Analysis/isl/isl_schedule_constraints.h        |    30 +
 lib/Analysis/isl/isl_schedule_node.c               |    14 +-
 lib/Analysis/isl/isl_schedule_read.c               |   105 +-
 lib/Analysis/isl/isl_schedule_tree.c               |     5 +-
 lib/Analysis/isl/isl_scheduler.c                   |  2486 +--
 lib/Analysis/isl/isl_seq.c                         |    31 +
 lib/Analysis/isl/isl_seq.h                         |     3 +
 lib/Analysis/isl/isl_space.c                       |   537 +-
 lib/Analysis/isl/isl_space_private.h               |    17 +-
 lib/Analysis/isl/isl_srcdir.c.cmake                |     1 +
 lib/Analysis/isl/isl_srcdir.c.in                   |     1 +
 lib/Analysis/isl/isl_tab.c                         |   741 +-
 lib/Analysis/isl/isl_tab.h                         |    54 +-
 lib/Analysis/isl/isl_tab_lexopt_templ.c            |   230 +
 lib/Analysis/isl/isl_tab_pip.c                     |  1667 +-
 lib/Analysis/isl/isl_test.c                        |   925 +-
 lib/Analysis/isl/isl_test_int.c                    |    43 +
 lib/Analysis/isl/isl_transitive_closure.c          |    78 +-
 lib/Analysis/isl/isl_union_map.c                   |  1372 +-
 lib/Analysis/isl/isl_union_map_private.h           |     2 +
 lib/Analysis/isl/isl_union_set_private.h           |    11 +
 lib/Analysis/isl/isl_union_templ.c                 |    45 +-
 lib/Analysis/isl/isl_val.c                         |    47 +-
 lib/Analysis/isl/isl_val_private.h                 |     7 +-
 lib/Analysis/isl/isl_vec.c                         |    15 +-
 lib/Analysis/isl/isl_vec_private.h                 |     2 +
 lib/Analysis/isl/isl_vertices.c                    |   155 +-
 lib/Analysis/isl/isl_vertices_private.h            |    15 +-
 lib/Analysis/isl/ltmain.sh                         |  5533 ++++---
 lib/Analysis/isl/m4/ax_cxx_compile_stdcxx.m4       |   982 ++
 lib/Analysis/isl/m4/ax_cxx_compile_stdcxx_11.m4    |    39 +
 lib/Analysis/isl/m4/ax_detect_clang.m4             |   168 +
 lib/Analysis/isl/m4/libtool.m4                     |  2522 +--
 lib/Analysis/isl/m4/ltoptions.m4                   |   127 +-
 lib/Analysis/isl/m4/ltsugar.m4                     |     7 +-
 lib/Analysis/isl/m4/ltversion.m4                   |    12 +-
 lib/Analysis/isl/m4/lt~obsolete.m4                 |     7 +-
 lib/Analysis/isl/pip.c                             |    45 +-
 lib/Analysis/isl/pip_test.sh.in                    |     3 +
 lib/Analysis/isl/print.c                           |     4 +-
 lib/Analysis/isl/print_templ_yaml.c                |    39 +
 lib/Analysis/isl/read_in_string_templ.c            |    38 +
 lib/Analysis/isl/schedule.c                        |    42 +
 lib/Analysis/isl/schedule_cmp.c                    |    85 +
 lib/Analysis/isl/schedule_test.sh.in               |    21 +
 lib/Analysis/isl/set_from_map.c                    |     8 +
 lib/Analysis/isl/set_to_map.c                      |    10 +
 lib/Analysis/isl/test-driver                       |   148 +
 lib/Analysis/isl/test_inputs/affine.polylib        |     9 +
 lib/Analysis/isl/test_inputs/affine2.polylib       |     9 +
 lib/Analysis/isl/test_inputs/affine3.polylib       |     7 +
 lib/Analysis/isl/test_inputs/application.omega     |     3 +
 lib/Analysis/isl/test_inputs/application2.omega    |     3 +
 lib/Analysis/isl/test_inputs/basicLinear.pwqp      |     1 +
 lib/Analysis/isl/test_inputs/basicLinear2.pwqp     |     1 +
 lib/Analysis/isl/test_inputs/basicTest.pwqp        |     1 +
 .../isl/test_inputs/basicTestParameterPosNeg.pwqp  |     1 +
 lib/Analysis/isl/test_inputs/boulet.pip            |    13 +
 lib/Analysis/isl/test_inputs/brisebarre.pip        |    34 +
 lib/Analysis/isl/test_inputs/cg1.pip               |    15 +
 lib/Analysis/isl/test_inputs/codegen/atomic.c      |     6 +
 lib/Analysis/isl/test_inputs/codegen/atomic.in     |     3 +
 lib/Analysis/isl/test_inputs/codegen/atomic.st     |     8 +
 lib/Analysis/isl/test_inputs/codegen/atomic2.c     |     2 +
 lib/Analysis/isl/test_inputs/codegen/atomic2.in    |     4 +
 lib/Analysis/isl/test_inputs/codegen/atomic3.c     |     9 +
 lib/Analysis/isl/test_inputs/codegen/atomic3.in    |     5 +
 lib/Analysis/isl/test_inputs/codegen/atomic4.c     |     2 +
 lib/Analysis/isl/test_inputs/codegen/atomic4.in    |     4 +
 lib/Analysis/isl/test_inputs/codegen/cholesky.c    |     4 +
 lib/Analysis/isl/test_inputs/codegen/cholesky.st   |     9 +
 lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.c  |     1 +
 lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.st |     3 +
 lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.c  |     2 +
 lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.st |     3 +
 lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.c  |     1 +
 lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.st |     3 +
 .../isl/test_inputs/codegen/cloog/1point-1.c       |     1 +
 .../isl/test_inputs/codegen/cloog/1point-1.st      |     6 +
 .../isl/test_inputs/codegen/cloog/1point-2.c       |     1 +
 .../isl/test_inputs/codegen/cloog/1point-2.st      |     6 +
 .../isl/test_inputs/codegen/cloog/4-param.c        |    14 +
 .../isl/test_inputs/codegen/cloog/4-param.st       |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/README  |     2 +
 .../isl/test_inputs/codegen/cloog/backtrack.c      |     1 +
 .../isl/test_inputs/codegen/cloog/backtrack.st     |     6 +
 .../isl/test_inputs/codegen/cloog/basic-bounds-1.c |     2 +
 .../test_inputs/codegen/cloog/basic-bounds-1.st    |     6 +
 .../isl/test_inputs/codegen/cloog/basic-bounds-2.c |     1 +
 .../test_inputs/codegen/cloog/basic-bounds-2.st    |     6 +
 .../isl/test_inputs/codegen/cloog/basic-bounds-3.c |     2 +
 .../test_inputs/codegen/cloog/basic-bounds-3.st    |     6 +
 .../isl/test_inputs/codegen/cloog/basic-bounds-4.c |     2 +
 .../test_inputs/codegen/cloog/basic-bounds-4.st    |     6 +
 .../isl/test_inputs/codegen/cloog/basic-bounds-5.c |     1 +
 .../test_inputs/codegen/cloog/basic-bounds-5.st    |     6 +
 .../isl/test_inputs/codegen/cloog/basic-bounds-6.c |     1 +
 .../test_inputs/codegen/cloog/basic-bounds-6.st    |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/block.c |     6 +
 .../isl/test_inputs/codegen/cloog/block.st         |    10 +
 .../isl/test_inputs/codegen/cloog/block2.c         |     5 +
 .../isl/test_inputs/codegen/cloog/block2.st        |    11 +
 .../isl/test_inputs/codegen/cloog/block3.c         |     6 +
 .../isl/test_inputs/codegen/cloog/block3.st        |     6 +
 .../isl/test_inputs/codegen/cloog/byu98-1-2-3.c    |    18 +
 .../isl/test_inputs/codegen/cloog/byu98-1-2-3.st   |    10 +
 .../isl/test_inputs/codegen/cloog/cholesky.c       |    12 +
 .../isl/test_inputs/codegen/cloog/cholesky.st      |    26 +
 .../isl/test_inputs/codegen/cloog/cholesky2.c      |    17 +
 .../isl/test_inputs/codegen/cloog/cholesky2.st     |     6 +
 .../isl/test_inputs/codegen/cloog/christian.c      |     6 +
 .../isl/test_inputs/codegen/cloog/christian.st     |     6 +
 .../isl/test_inputs/codegen/cloog/classen.c        |    86 +
 .../isl/test_inputs/codegen/cloog/classen.st       |    24 +
 .../isl/test_inputs/codegen/cloog/classen2.c       |     4 +
 .../isl/test_inputs/codegen/cloog/classen2.st      |     6 +
 .../isl/test_inputs/codegen/cloog/constant.c       |    18 +
 .../isl/test_inputs/codegen/cloog/constant.st      |    11 +
 .../isl/test_inputs/codegen/cloog/constbound.c     |     8 +
 .../isl/test_inputs/codegen/cloog/constbound.st    |    16 +
 lib/Analysis/isl/test_inputs/codegen/cloog/darte.c |    14 +
 .../isl/test_inputs/codegen/cloog/darte.st         |     6 +
 .../isl/test_inputs/codegen/cloog/dealII.c         |    18 +
 .../isl/test_inputs/codegen/cloog/dealII.st        |    10 +
 .../isl/test_inputs/codegen/cloog/donotsimp.c      |     6 +
 .../isl/test_inputs/codegen/cloog/donotsimp.st     |     9 +
 lib/Analysis/isl/test_inputs/codegen/cloog/dot.c   |     7 +
 lib/Analysis/isl/test_inputs/codegen/cloog/dot.st  |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/dot2.c  |    12 +
 lib/Analysis/isl/test_inputs/codegen/cloog/dot2.st |    10 +
 .../isl/test_inputs/codegen/cloog/durbin_e_s.c     |    23 +
 .../isl/test_inputs/codegen/cloog/durbin_e_s.st    |    16 +
 .../isl/test_inputs/codegen/cloog/emploi.c         |     5 +
 .../isl/test_inputs/codegen/cloog/emploi.st        |    10 +
 .../isl/test_inputs/codegen/cloog/equality.c       |     7 +
 .../isl/test_inputs/codegen/cloog/equality.st      |    10 +
 .../isl/test_inputs/codegen/cloog/equality2.c      |     8 +
 .../isl/test_inputs/codegen/cloog/equality2.st     |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/esced.c |     5 +
 .../isl/test_inputs/codegen/cloog/esced.st         |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/ex1.c   |    15 +
 lib/Analysis/isl/test_inputs/codegen/cloog/ex1.st  |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/faber.c |   149 +
 .../isl/test_inputs/codegen/cloog/faber.st         |    18 +
 .../test_inputs/codegen/cloog/forwardsub-1-1-2.c   |     9 +
 .../test_inputs/codegen/cloog/forwardsub-1-1-2.st  |    12 +
 .../test_inputs/codegen/cloog/forwardsub-2-1-2-3.c |    10 +
 .../codegen/cloog/forwardsub-2-1-2-3.st            |    12 +
 .../test_inputs/codegen/cloog/forwardsub-3-1-2.c   |    17 +
 .../test_inputs/codegen/cloog/forwardsub-3-1-2.st  |    12 +
 lib/Analysis/isl/test_inputs/codegen/cloog/gauss.c |     7 +
 .../isl/test_inputs/codegen/cloog/gauss.st         |     6 +
 .../isl/test_inputs/codegen/cloog/gesced.c         |    16 +
 .../isl/test_inputs/codegen/cloog/gesced.st        |     6 +
 .../isl/test_inputs/codegen/cloog/gesced2.c        |    20 +
 .../isl/test_inputs/codegen/cloog/gesced2.st       |     6 +
 .../isl/test_inputs/codegen/cloog/gesced3.c        |    10 +
 .../isl/test_inputs/codegen/cloog/gesced3.st       |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/guide.c |     6 +
 .../isl/test_inputs/codegen/cloog/guide.st         |    10 +
 .../isl/test_inputs/codegen/cloog/iftest.c         |     2 +
 .../isl/test_inputs/codegen/cloog/iftest.st        |     6 +
 .../isl/test_inputs/codegen/cloog/iftest2.c        |     3 +
 .../isl/test_inputs/codegen/cloog/iftest2.st       |     6 +
 .../isl/test_inputs/codegen/cloog/infinite2.c      |     9 +
 .../isl/test_inputs/codegen/cloog/infinite2.st     |    10 +
 .../isl/test_inputs/codegen/cloog/jacobi-shared.c  |     3 +
 .../isl/test_inputs/codegen/cloog/jacobi-shared.st |     6 +
 .../isl/test_inputs/codegen/cloog/largeur.c        |     3 +
 .../isl/test_inputs/codegen/cloog/largeur.st       |     6 +
 .../test_inputs/codegen/cloog/levenshtein-1-2-3.c  |    32 +
 .../test_inputs/codegen/cloog/levenshtein-1-2-3.st |    16 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lex.c   |     4 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lex.st  |    10 +
 .../isl/test_inputs/codegen/cloog/lineality-1-2.c  |     8 +
 .../isl/test_inputs/codegen/cloog/lineality-1-2.st |    10 +
 .../test_inputs/codegen/cloog/lineality-2-1-2.c    |    12 +
 .../test_inputs/codegen/cloog/lineality-2-1-2.st   |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/logo.c  |    17 +
 lib/Analysis/isl/test_inputs/codegen/cloog/logo.st |    10 +
 .../isl/test_inputs/codegen/cloog/logopar.c        |    17 +
 .../isl/test_inputs/codegen/cloog/logopar.st       |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lu.c    |     7 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lu.st   |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lu2.c   |     7 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lu2.st  |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lux.c   |     7 +
 lib/Analysis/isl/test_inputs/codegen/cloog/lux.st  |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/merge.c |     8 +
 .../isl/test_inputs/codegen/cloog/merge.st         |    11 +
 .../isl/test_inputs/codegen/cloog/min-1-1.c        |     3 +
 .../isl/test_inputs/codegen/cloog/min-1-1.st       |     6 +
 .../isl/test_inputs/codegen/cloog/min-2-1.c        |     4 +
 .../isl/test_inputs/codegen/cloog/min-2-1.st       |     6 +
 .../isl/test_inputs/codegen/cloog/min-3-1.c        |     3 +
 .../isl/test_inputs/codegen/cloog/min-3-1.st       |     6 +
 .../isl/test_inputs/codegen/cloog/min-4-1.c        |     2 +
 .../isl/test_inputs/codegen/cloog/min-4-1.st       |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod.c   |     3 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod.st  |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod2.c  |     3 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod2.st |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod3.c  |     4 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod3.st |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod4.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mod4.st |    11 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mode.c  |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/mode.st |    10 +
 .../isl/test_inputs/codegen/cloog/multi-mm-1.c     |     8 +
 .../isl/test_inputs/codegen/cloog/multi-mm-1.st    |    10 +
 .../isl/test_inputs/codegen/cloog/multi-stride.c   |     2 +
 .../isl/test_inputs/codegen/cloog/multi-stride.st  |     6 +
 .../isl/test_inputs/codegen/cloog/multi-stride2.c  |     2 +
 .../isl/test_inputs/codegen/cloog/multi-stride2.st |     6 +
 .../isl/test_inputs/codegen/cloog/mxm-shared.c     |     3 +
 .../isl/test_inputs/codegen/cloog/mxm-shared.st    |     6 +
 .../isl/test_inputs/codegen/cloog/no_lindep.c      |     1 +
 .../isl/test_inputs/codegen/cloog/no_lindep.st     |     6 +
 .../isl/test_inputs/codegen/cloog/nul_basic1.c     |     2 +
 .../isl/test_inputs/codegen/cloog/nul_basic1.st    |     6 +
 .../isl/test_inputs/codegen/cloog/nul_basic2.c     |     5 +
 .../isl/test_inputs/codegen/cloog/nul_basic2.st    |    10 +
 .../isl/test_inputs/codegen/cloog/nul_complex1.c   |     3 +
 .../isl/test_inputs/codegen/cloog/nul_complex1.st  |     6 +
 .../isl/test_inputs/codegen/cloog/nul_lcpc.c       |    13 +
 .../isl/test_inputs/codegen/cloog/nul_lcpc.st      |    10 +
 lib/Analysis/isl/test_inputs/codegen/cloog/orc.c   |    16 +
 lib/Analysis/isl/test_inputs/codegen/cloog/orc.st  |    13 +
 lib/Analysis/isl/test_inputs/codegen/cloog/otl.c   |     7 +
 lib/Analysis/isl/test_inputs/codegen/cloog/otl.st  |     6 +
 .../isl/test_inputs/codegen/cloog/param-split.c    |     6 +
 .../isl/test_inputs/codegen/cloog/param-split.st   |    10 +
 .../isl/test_inputs/codegen/cloog/pouchet.c        |    12 +
 .../isl/test_inputs/codegen/cloog/pouchet.st       |     6 +
 .../isl/test_inputs/codegen/cloog/rectangle.c      |     3 +
 .../isl/test_inputs/codegen/cloog/rectangle.st     |     6 +
 .../isl/test_inputs/codegen/cloog/reservoir-QR.c   |    54 +
 .../isl/test_inputs/codegen/cloog/reservoir-QR.st  |    36 +
 .../test_inputs/codegen/cloog/reservoir-bastoul3.c |     3 +
 .../codegen/cloog/reservoir-bastoul3.st            |     6 +
 .../codegen/cloog/reservoir-cholesky2.c            |     9 +
 .../codegen/cloog/reservoir-cholesky2.st           |    20 +
 .../test_inputs/codegen/cloog/reservoir-fusion1.c  |     8 +
 .../test_inputs/codegen/cloog/reservoir-fusion1.st |    17 +
 .../test_inputs/codegen/cloog/reservoir-fusion2.c  |    12 +
 .../test_inputs/codegen/cloog/reservoir-fusion2.st |    16 +
 .../test_inputs/codegen/cloog/reservoir-jacobi2.c  |     3 +
 .../test_inputs/codegen/cloog/reservoir-jacobi2.st |     9 +
 .../test_inputs/codegen/cloog/reservoir-jacobi3.c  |     8 +
 .../test_inputs/codegen/cloog/reservoir-jacobi3.st |    22 +
 .../test_inputs/codegen/cloog/reservoir-lim-lam1.c |    10 +
 .../codegen/cloog/reservoir-lim-lam1.st            |    13 +
 .../test_inputs/codegen/cloog/reservoir-lim-lam2.c |    10 +
 .../codegen/cloog/reservoir-lim-lam2.st            |    23 +
 .../test_inputs/codegen/cloog/reservoir-lim-lam3.c |    11 +
 .../codegen/cloog/reservoir-lim-lam3.st            |    23 +
 .../test_inputs/codegen/cloog/reservoir-lim-lam4.c |    10 +
 .../codegen/cloog/reservoir-lim-lam4.st            |    19 +
 .../test_inputs/codegen/cloog/reservoir-lim-lam5.c |    11 +
 .../codegen/cloog/reservoir-lim-lam5.st            |    26 +
 .../test_inputs/codegen/cloog/reservoir-lim-lam6.c |     8 +
 .../codegen/cloog/reservoir-lim-lam6.st            |    19 +
 .../codegen/cloog/reservoir-liu-zhuge1.c           |    19 +
 .../codegen/cloog/reservoir-liu-zhuge1.st          |    16 +
 .../codegen/cloog/reservoir-loechner3.c            |     4 +
 .../codegen/cloog/reservoir-loechner3.st           |    12 +
 .../codegen/cloog/reservoir-loechner4.c            |     5 +
 .../codegen/cloog/reservoir-loechner4.st           |    15 +
 .../codegen/cloog/reservoir-loechner5.c            |     5 +
 .../codegen/cloog/reservoir-loechner5.st           |    15 +
 .../isl/test_inputs/codegen/cloog/reservoir-long.c |    14 +
 .../test_inputs/codegen/cloog/reservoir-long.st    |    36 +
 .../codegen/cloog/reservoir-mg-interp.c            |    85 +
 .../codegen/cloog/reservoir-mg-interp.st           |   115 +
 .../codegen/cloog/reservoir-mg-interp2.c           |    18 +
 .../codegen/cloog/reservoir-mg-interp2.st          |    45 +
 .../test_inputs/codegen/cloog/reservoir-mg-psinv.c |     9 +
 .../codegen/cloog/reservoir-mg-psinv.st            |    23 +
 .../test_inputs/codegen/cloog/reservoir-mg-resid.c |     9 +
 .../codegen/cloog/reservoir-mg-resid.st            |    23 +
 .../test_inputs/codegen/cloog/reservoir-mg-rprj3.c |    35 +
 .../codegen/cloog/reservoir-mg-rprj3.st            |    28 +
 .../test_inputs/codegen/cloog/reservoir-pingali1.c |     7 +
 .../codegen/cloog/reservoir-pingali1.st            |    16 +
 .../test_inputs/codegen/cloog/reservoir-pingali2.c |     8 +
 .../codegen/cloog/reservoir-pingali2.st            |    19 +
 .../test_inputs/codegen/cloog/reservoir-pingali3.c |     9 +
 .../codegen/cloog/reservoir-pingali3.st            |    22 +
 .../test_inputs/codegen/cloog/reservoir-pingali4.c |     8 +
 .../codegen/cloog/reservoir-pingali4.st            |    19 +
 .../test_inputs/codegen/cloog/reservoir-pingali5.c |    10 +
 .../codegen/cloog/reservoir-pingali5.st            |    26 +
 .../test_inputs/codegen/cloog/reservoir-pingali6.c |     8 +
 .../codegen/cloog/reservoir-pingali6.st            |    22 +
 .../test_inputs/codegen/cloog/reservoir-stride.c   |     2 +
 .../test_inputs/codegen/cloog/reservoir-stride.st  |     6 +
 .../test_inputs/codegen/cloog/reservoir-stride2.c  |     2 +
 .../test_inputs/codegen/cloog/reservoir-stride2.st |     6 +
 .../codegen/cloog/reservoir-tang-xue1.c            |     5 +
 .../codegen/cloog/reservoir-tang-xue1.st           |    15 +
 .../isl/test_inputs/codegen/cloog/reservoir-two.c  |     1 +
 .../isl/test_inputs/codegen/cloog/reservoir-two.st |     6 +
 .../isl/test_inputs/codegen/cloog/singleton.c      |     4 +
 .../isl/test_inputs/codegen/cloog/singleton.st     |     7 +
 lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.c |    13 +
 .../isl/test_inputs/codegen/cloog/sor1d.st         |    24 +
 .../codegen/cloog/square+triangle-1-1-2-3.c        |     9 +
 .../codegen/cloog/square+triangle-1-1-2-3.st       |    10 +
 .../isl/test_inputs/codegen/cloog/stride.c         |     7 +
 .../isl/test_inputs/codegen/cloog/stride.st        |     6 +
 .../isl/test_inputs/codegen/cloog/stride2.c        |     8 +
 .../isl/test_inputs/codegen/cloog/stride2.st       |     6 +
 .../isl/test_inputs/codegen/cloog/stride3.c        |     2 +
 .../isl/test_inputs/codegen/cloog/stride3.st       |     6 +
 .../isl/test_inputs/codegen/cloog/stride4.c        |     3 +
 .../isl/test_inputs/codegen/cloog/stride4.st       |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/swim.c  |   159 +
 lib/Analysis/isl/test_inputs/codegen/cloog/swim.st |   223 +
 lib/Analysis/isl/test_inputs/codegen/cloog/test.c  |    17 +
 lib/Analysis/isl/test_inputs/codegen/cloog/test.st |    10 +
 .../isl/test_inputs/codegen/cloog/thomasset.c      |     9 +
 .../isl/test_inputs/codegen/cloog/thomasset.st     |     6 +
 .../isl/test_inputs/codegen/cloog/tiling.c         |     3 +
 .../isl/test_inputs/codegen/cloog/tiling.st        |     6 +
 .../isl/test_inputs/codegen/cloog/uday_scalars.c   |     6 +
 .../isl/test_inputs/codegen/cloog/uday_scalars.st  |    13 +
 lib/Analysis/isl/test_inputs/codegen/cloog/union.c |     7 +
 .../isl/test_inputs/codegen/cloog/union.st         |     6 +
 .../isl/test_inputs/codegen/cloog/unroll.c         |    13 +
 .../isl/test_inputs/codegen/cloog/unroll.st        |     6 +
 .../isl/test_inputs/codegen/cloog/unroll2.c        |     5 +
 .../isl/test_inputs/codegen/cloog/unroll2.st       |     6 +
 .../isl/test_inputs/codegen/cloog/usvd_e_t.c       |   348 +
 .../isl/test_inputs/codegen/cloog/usvd_e_t.st      |    34 +
 .../isl/test_inputs/codegen/cloog/vasilache.c      |    24 +
 .../isl/test_inputs/codegen/cloog/vasilache.st     |    37 +
 .../isl/test_inputs/codegen/cloog/vivien.c         |    88 +
 .../isl/test_inputs/codegen/cloog/vivien.st        |     6 +
 .../isl/test_inputs/codegen/cloog/vivien2.c        |    80 +
 .../isl/test_inputs/codegen/cloog/vivien2.st       |     6 +
 .../isl/test_inputs/codegen/cloog/walters.c        |    16 +
 .../isl/test_inputs/codegen/cloog/walters.st       |    12 +
 .../isl/test_inputs/codegen/cloog/walters2.c       |    12 +
 .../isl/test_inputs/codegen/cloog/walters2.st      |    10 +
 .../isl/test_inputs/codegen/cloog/walters3.c       |     7 +
 .../isl/test_inputs/codegen/cloog/walters3.st      |    10 +
 .../isl/test_inputs/codegen/cloog/wavefront.c      |     3 +
 .../isl/test_inputs/codegen/cloog/wavefront.st     |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/yosr.c  |    12 +
 lib/Analysis/isl/test_inputs/codegen/cloog/yosr.st |     6 +
 lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.c |    13 +
 .../isl/test_inputs/codegen/cloog/yosr2.st         |     6 +
 .../isl/test_inputs/codegen/cloog/youcef.c         |     6 +
 .../isl/test_inputs/codegen/cloog/youcef.st        |    11 +
 .../isl/test_inputs/codegen/cloog/youcefn.c        |    10 +
 .../isl/test_inputs/codegen/cloog/youcefn.st       |    11 +
 lib/Analysis/isl/test_inputs/codegen/component0.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/component0.st |     3 +
 lib/Analysis/isl/test_inputs/codegen/component1.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/component1.st |     7 +
 lib/Analysis/isl/test_inputs/codegen/component2.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/component2.st |     7 +
 lib/Analysis/isl/test_inputs/codegen/component3.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/component3.st |     7 +
 lib/Analysis/isl/test_inputs/codegen/component4.c  |     7 +
 lib/Analysis/isl/test_inputs/codegen/component4.st |     7 +
 lib/Analysis/isl/test_inputs/codegen/component5.c  |     6 +
 lib/Analysis/isl/test_inputs/codegen/component5.st |     9 +
 lib/Analysis/isl/test_inputs/codegen/component6.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/component6.st |    10 +
 lib/Analysis/isl/test_inputs/codegen/correlation.c |    45 +
 .../isl/test_inputs/codegen/correlation.st         |    18 +
 lib/Analysis/isl/test_inputs/codegen/disjuncts.c   |    10 +
 lib/Analysis/isl/test_inputs/codegen/disjuncts.in  |     7 +
 lib/Analysis/isl/test_inputs/codegen/disjuncts2.c  |     3 +
 lib/Analysis/isl/test_inputs/codegen/disjuncts2.st |     4 +
 lib/Analysis/isl/test_inputs/codegen/dwt.c         |     9 +
 lib/Analysis/isl/test_inputs/codegen/dwt.in        |     3 +
 lib/Analysis/isl/test_inputs/codegen/empty.c       |     6 +
 lib/Analysis/isl/test_inputs/codegen/empty.in      |     5 +
 lib/Analysis/isl/test_inputs/codegen/filter.c      |     9 +
 lib/Analysis/isl/test_inputs/codegen/filter.st     |    18 +
 lib/Analysis/isl/test_inputs/codegen/gemm.c        |     6 +
 lib/Analysis/isl/test_inputs/codegen/gemm.st       |    12 +
 lib/Analysis/isl/test_inputs/codegen/hoist.c       |    45 +
 lib/Analysis/isl/test_inputs/codegen/hoist.in      |    10 +
 lib/Analysis/isl/test_inputs/codegen/hoist2.c      |     5 +
 lib/Analysis/isl/test_inputs/codegen/hoist2.in     |     5 +
 lib/Analysis/isl/test_inputs/codegen/isolate1.c    |     8 +
 lib/Analysis/isl/test_inputs/codegen/isolate1.st   |     5 +
 lib/Analysis/isl/test_inputs/codegen/isolate2.c    |     9 +
 lib/Analysis/isl/test_inputs/codegen/isolate2.st   |     7 +
 lib/Analysis/isl/test_inputs/codegen/isolate3.c    |    17 +
 lib/Analysis/isl/test_inputs/codegen/isolate3.st   |     5 +
 lib/Analysis/isl/test_inputs/codegen/isolate4.c    |    13 +
 lib/Analysis/isl/test_inputs/codegen/isolate4.st   |     5 +
 lib/Analysis/isl/test_inputs/codegen/isolate5.c    |    29 +
 lib/Analysis/isl/test_inputs/codegen/isolate5.st   |     5 +
 lib/Analysis/isl/test_inputs/codegen/isolate6.c    |    26 +
 lib/Analysis/isl/test_inputs/codegen/isolate6.st   |     8 +
 lib/Analysis/isl/test_inputs/codegen/isolate7.c    |    29 +
 lib/Analysis/isl/test_inputs/codegen/isolate7.st   |    16 +
 .../isl/test_inputs/codegen/jacobi_kernel4.c       |     2 +
 .../isl/test_inputs/codegen/jacobi_kernel4.in      |     4 +
 lib/Analysis/isl/test_inputs/codegen/lu.c          |    18 +
 lib/Analysis/isl/test_inputs/codegen/lu.in         |     4 +
 lib/Analysis/isl/test_inputs/codegen/mod.c         |     2 +
 lib/Analysis/isl/test_inputs/codegen/mod.in        |     4 +
 lib/Analysis/isl/test_inputs/codegen/omega/README  |     5 +
 .../isl/test_inputs/codegen/omega/basics-0.c       |     8 +
 .../isl/test_inputs/codegen/omega/basics-0.in      |     3 +
 .../isl/test_inputs/codegen/omega/basics-1.c       |     3 +
 .../isl/test_inputs/codegen/omega/basics-1.in      |     3 +
 .../isl/test_inputs/codegen/omega/chosol-0.c       |     9 +
 .../isl/test_inputs/codegen/omega/chosol-0.in      |     3 +
 .../isl/test_inputs/codegen/omega/chosol-1.c       |     9 +
 .../isl/test_inputs/codegen/omega/chosol-1.in      |     3 +
 .../isl/test_inputs/codegen/omega/code_gen-0.c     |     7 +
 .../isl/test_inputs/codegen/omega/code_gen-0.in    |     3 +
 .../isl/test_inputs/codegen/omega/code_gen-1.c     |    16 +
 .../isl/test_inputs/codegen/omega/code_gen-1.in    |     3 +
 .../isl/test_inputs/codegen/omega/code_gen-2.c     |    17 +
 .../isl/test_inputs/codegen/omega/code_gen-2.in    |     3 +
 .../isl/test_inputs/codegen/omega/collard-0.c      |    16 +
 .../isl/test_inputs/codegen/omega/collard-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/dagstuhl1-0.c    |     2 +
 .../isl/test_inputs/codegen/omega/dagstuhl1-0.in   |     3 +
 .../isl/test_inputs/codegen/omega/dagstuhl1-1.c    |     2 +
 .../isl/test_inputs/codegen/omega/dagstuhl1-1.in   |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.c |     7 +
 .../isl/test_inputs/codegen/omega/fc1-0.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.c |    17 +
 .../isl/test_inputs/codegen/omega/fc1-1.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.c |    17 +
 .../isl/test_inputs/codegen/omega/fc1-2.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.c |     7 +
 .../isl/test_inputs/codegen/omega/fc2-0.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.c |    17 +
 .../isl/test_inputs/codegen/omega/fc2-1.in         |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-0.c  |     2 +
 .../isl/test_inputs/codegen/omega/floor_bound-0.in |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-1.c  |     2 +
 .../isl/test_inputs/codegen/omega/floor_bound-1.in |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-2.c  |     2 +
 .../isl/test_inputs/codegen/omega/floor_bound-2.in |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-3.c  |     2 +
 .../isl/test_inputs/codegen/omega/floor_bound-3.in |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-4.c  |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-4.in |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-5.c  |     2 +
 .../isl/test_inputs/codegen/omega/floor_bound-5.in |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-6.c  |     3 +
 .../isl/test_inputs/codegen/omega/floor_bound-6.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/gc-0.c  |     2 +
 lib/Analysis/isl/test_inputs/codegen/omega/gc-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/ge-0.c  |     7 +
 lib/Analysis/isl/test_inputs/codegen/omega/ge-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/ge-1.c  |     7 +
 lib/Analysis/isl/test_inputs/codegen/omega/ge-1.in |     3 +
 .../isl/test_inputs/codegen/omega/gist-0.c         |     3 +
 .../isl/test_inputs/codegen/omega/gist-0.in        |     3 +
 .../isl/test_inputs/codegen/omega/gist-1.c         |     3 +
 .../isl/test_inputs/codegen/omega/gist-1.in        |     3 +
 .../isl/test_inputs/codegen/omega/gist-2.c         |     3 +
 .../isl/test_inputs/codegen/omega/gist-2.in        |     3 +
 .../isl/test_inputs/codegen/omega/gist-3.c         |     3 +
 .../isl/test_inputs/codegen/omega/gist-3.in        |     3 +
 .../isl/test_inputs/codegen/omega/gist-4.c         |     3 +
 .../isl/test_inputs/codegen/omega/gist-4.in        |     3 +
 .../isl/test_inputs/codegen/omega/gist-5.c         |     3 +
 .../isl/test_inputs/codegen/omega/gist-5.in        |     3 +
 .../isl/test_inputs/codegen/omega/guard1-0.c       |     2 +
 .../isl/test_inputs/codegen/omega/guard1-0.in      |     3 +
 .../isl/test_inputs/codegen/omega/guard1-1.c       |     2 +
 .../isl/test_inputs/codegen/omega/guard1-1.in      |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.c |     4 +
 .../isl/test_inputs/codegen/omega/hpf-0.in         |     3 +
 .../isl/test_inputs/codegen/omega/if_then-0.c      |    13 +
 .../isl/test_inputs/codegen/omega/if_then-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/if_then-1.c      |     9 +
 .../isl/test_inputs/codegen/omega/if_then-1.in     |     3 +
 .../isl/test_inputs/codegen/omega/if_then-2.c      |    12 +
 .../isl/test_inputs/codegen/omega/if_then-2.in     |     3 +
 .../isl/test_inputs/codegen/omega/if_then-3.c      |    13 +
 .../isl/test_inputs/codegen/omega/if_then-3.in     |     3 +
 .../isl/test_inputs/codegen/omega/if_then-4.c      |     7 +
 .../isl/test_inputs/codegen/omega/if_then-4.in     |     3 +
 .../isl/test_inputs/codegen/omega/if_then-5.c      |     7 +
 .../isl/test_inputs/codegen/omega/if_then-5.in     |     3 +
 .../isl/test_inputs/codegen/omega/iter1-0.c        |     2 +
 .../isl/test_inputs/codegen/omega/iter1-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter2-0.c        |     3 +
 .../isl/test_inputs/codegen/omega/iter2-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter3-0.c        |     3 +
 .../isl/test_inputs/codegen/omega/iter3-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter4-0.c        |     3 +
 .../isl/test_inputs/codegen/omega/iter4-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter5-0.c        |     3 +
 .../isl/test_inputs/codegen/omega/iter5-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter6-0.c        |     3 +
 .../isl/test_inputs/codegen/omega/iter6-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter6-1.c        |     2 +
 .../isl/test_inputs/codegen/omega/iter6-1.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter7-0.c        |     2 +
 .../isl/test_inputs/codegen/omega/iter7-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter8-0.c        |     2 +
 .../isl/test_inputs/codegen/omega/iter8-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/iter9-0.c        |    11 +
 .../isl/test_inputs/codegen/omega/iter9-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/lefur00-0.c      |     5 +
 .../isl/test_inputs/codegen/omega/lefur00-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/lefur01-0.c      |     5 +
 .../isl/test_inputs/codegen/omega/lefur01-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/lefur01-1.c      |     5 +
 .../isl/test_inputs/codegen/omega/lefur01-1.in     |     3 +
 .../isl/test_inputs/codegen/omega/lefur03-0.c      |     7 +
 .../isl/test_inputs/codegen/omega/lefur03-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/lefur04-0.c      |     8 +
 .../isl/test_inputs/codegen/omega/lefur04-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/lift1-0.c        |     9 +
 .../isl/test_inputs/codegen/omega/lift1-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift1-1.c        |    14 +
 .../isl/test_inputs/codegen/omega/lift1-1.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift1-2.c        |    15 +
 .../isl/test_inputs/codegen/omega/lift1-2.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift1-3.c        |    16 +
 .../isl/test_inputs/codegen/omega/lift1-3.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift1-4.c        |    17 +
 .../isl/test_inputs/codegen/omega/lift1-4.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift1-5.c        |    16 +
 .../isl/test_inputs/codegen/omega/lift1-5.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift2-0.c        |     9 +
 .../isl/test_inputs/codegen/omega/lift2-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift2-1.c        |    17 +
 .../isl/test_inputs/codegen/omega/lift2-1.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift2-2.c        |    19 +
 .../isl/test_inputs/codegen/omega/lift2-2.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift2-3.c        |    21 +
 .../isl/test_inputs/codegen/omega/lift2-3.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift2-4.c        |    23 +
 .../isl/test_inputs/codegen/omega/lift2-4.in       |     3 +
 .../isl/test_inputs/codegen/omega/lift2-5.c        |    22 +
 .../isl/test_inputs/codegen/omega/lift2-5.in       |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-0.c  |    10 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-1.c  |    10 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-1.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-2.c  |    10 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-2.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-3.c  |    14 +
 lib/Analysis/isl/test_inputs/codegen/omega/lu-3.in |     3 +
 .../isl/test_inputs/codegen/omega/lu_ijk-0.c       |     7 +
 .../isl/test_inputs/codegen/omega/lu_ijk-0.in      |     3 +
 .../isl/test_inputs/codegen/omega/lu_ijk-1.c       |     7 +
 .../isl/test_inputs/codegen/omega/lu_ijk-1.in      |     3 +
 .../isl/test_inputs/codegen/omega/lu_ijk-2.c       |    11 +
 .../isl/test_inputs/codegen/omega/lu_ijk-2.in      |     3 +
 .../isl/test_inputs/codegen/omega/lu_spmd-0.c      |    13 +
 .../isl/test_inputs/codegen/omega/lu_spmd-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/lu_spmd-1.c      |    13 +
 .../isl/test_inputs/codegen/omega/lu_spmd-1.in     |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m1-0.c  |     6 +
 lib/Analysis/isl/test_inputs/codegen/omega/m1-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m1-1.c  |    14 +
 lib/Analysis/isl/test_inputs/codegen/omega/m1-1.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m10-0.c |     7 +
 .../isl/test_inputs/codegen/omega/m10-0.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m10-1.c |    15 +
 .../isl/test_inputs/codegen/omega/m10-1.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m11-0.c |     6 +
 .../isl/test_inputs/codegen/omega/m11-0.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m12-0.c |     3 +
 .../isl/test_inputs/codegen/omega/m12-0.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m12-1.c |    25 +
 .../isl/test_inputs/codegen/omega/m12-1.in         |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m2-0.c  |    12 +
 lib/Analysis/isl/test_inputs/codegen/omega/m2-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m2-1.c  |    12 +
 lib/Analysis/isl/test_inputs/codegen/omega/m2-1.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m3-0.c  |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m3-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m4-0.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/omega/m4-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m4-1.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/omega/m4-1.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m7-0.c  |     6 +
 lib/Analysis/isl/test_inputs/codegen/omega/m7-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m7-1.c  |    11 +
 lib/Analysis/isl/test_inputs/codegen/omega/m7-1.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m8-0.c  |     6 +
 lib/Analysis/isl/test_inputs/codegen/omega/m8-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m8-1.c  |    11 +
 lib/Analysis/isl/test_inputs/codegen/omega/m8-1.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m9-0.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/omega/m9-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/m9-1.c  |     5 +
 lib/Analysis/isl/test_inputs/codegen/omega/m9-1.in |     3 +
 .../isl/test_inputs/codegen/omega/olda-0.c         |     8 +
 .../isl/test_inputs/codegen/omega/olda-0.in        |     3 +
 .../isl/test_inputs/codegen/omega/olda-1.c         |     9 +
 .../isl/test_inputs/codegen/omega/olda-1.in        |     3 +
 .../isl/test_inputs/codegen/omega/p.delft-0.c      |     4 +
 .../isl/test_inputs/codegen/omega/p.delft-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/p.delft2-0.c     |    11 +
 .../isl/test_inputs/codegen/omega/p.delft2-0.in    |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/p6-0.c  |     8 +
 lib/Analysis/isl/test_inputs/codegen/omega/p6-0.in |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/p6-1.c  |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/p6-1.in |     3 +
 .../isl/test_inputs/codegen/omega/stride1-0.c      |     2 +
 .../isl/test_inputs/codegen/omega/stride1-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride2-0.c      |     3 +
 .../isl/test_inputs/codegen/omega/stride2-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride3-0.c      |     3 +
 .../isl/test_inputs/codegen/omega/stride3-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride4-0.c      |     2 +
 .../isl/test_inputs/codegen/omega/stride4-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride5-0.c      |     3 +
 .../isl/test_inputs/codegen/omega/stride5-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride6-0.c      |     3 +
 .../isl/test_inputs/codegen/omega/stride6-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride6-1.c      |     3 +
 .../isl/test_inputs/codegen/omega/stride6-1.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride6-2.c      |     3 +
 .../isl/test_inputs/codegen/omega/stride6-2.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride7-0.c      |    15 +
 .../isl/test_inputs/codegen/omega/stride7-0.in     |     3 +
 .../isl/test_inputs/codegen/omega/stride7-1.c      |    14 +
 .../isl/test_inputs/codegen/omega/stride7-1.in     |     3 +
 .../isl/test_inputs/codegen/omega/substitution-0.c |     3 +
 .../test_inputs/codegen/omega/substitution-0.in    |     3 +
 .../isl/test_inputs/codegen/omega/substitution-1.c |     3 +
 .../test_inputs/codegen/omega/substitution-1.in    |     3 +
 .../isl/test_inputs/codegen/omega/substitution-2.c |     2 +
 .../test_inputs/codegen/omega/substitution-2.in    |     3 +
 .../isl/test_inputs/codegen/omega/substitution-3.c |     1 +
 .../test_inputs/codegen/omega/substitution-3.in    |     3 +
 .../isl/test_inputs/codegen/omega/substitution-4.c |     1 +
 .../test_inputs/codegen/omega/substitution-4.in    |     3 +
 .../isl/test_inputs/codegen/omega/syr2k-0.c        |     4 +
 .../isl/test_inputs/codegen/omega/syr2k-0.in       |     3 +
 .../isl/test_inputs/codegen/omega/syr2k-1.c        |     4 +
 .../isl/test_inputs/codegen/omega/syr2k-1.in       |     3 +
 .../isl/test_inputs/codegen/omega/syr2k-2.c        |     4 +
 .../isl/test_inputs/codegen/omega/syr2k-2.in       |     3 +
 .../isl/test_inputs/codegen/omega/syr2k-3.c        |     4 +
 .../isl/test_inputs/codegen/omega/syr2k-3.in       |     3 +
 .../codegen/omega/ts1d-check-sblock-0.c            |    15 +
 .../codegen/omega/ts1d-check-sblock-0.in           |     3 +
 .../isl/test_inputs/codegen/omega/ts1d-check0-0.c  |    13 +
 .../isl/test_inputs/codegen/omega/ts1d-check0-0.in |     3 +
 .../test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.c |    36 +
 .../codegen/omega/ts1d-mp-i_ts-m_b-0.in            |     3 +
 .../isl/test_inputs/codegen/omega/ts1d-orig0-0.c   |    10 +
 .../isl/test_inputs/codegen/omega/ts1d-orig0-0.in  |     3 +
 .../isl/test_inputs/codegen/omega/wak1-0.c         |    27 +
 .../isl/test_inputs/codegen/omega/wak1-0.in        |     3 +
 .../isl/test_inputs/codegen/omega/wak1-1.c         |    55 +
 .../isl/test_inputs/codegen/omega/wak1-1.in        |     3 +
 .../isl/test_inputs/codegen/omega/wak2-0.c         |    25 +
 .../isl/test_inputs/codegen/omega/wak2-0.in        |     3 +
 .../isl/test_inputs/codegen/omega/wak2-1.c         |    34 +
 .../isl/test_inputs/codegen/omega/wak2-1.in        |     3 +
 .../isl/test_inputs/codegen/omega/wak3-0.c         |     8 +
 .../isl/test_inputs/codegen/omega/wak3-0.in        |     3 +
 .../isl/test_inputs/codegen/omega/wak3-1.c         |    21 +
 .../isl/test_inputs/codegen/omega/wak3-1.in        |     3 +
 .../isl/test_inputs/codegen/omega/wak4-0.c         |     4 +
 .../isl/test_inputs/codegen/omega/wak4-0.in        |     3 +
 .../isl/test_inputs/codegen/omega/wak4-1.c         |     4 +
 .../isl/test_inputs/codegen/omega/wak4-1.in        |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/x-0.c   |    14 +
 lib/Analysis/isl/test_inputs/codegen/omega/x-0.in  |     3 +
 lib/Analysis/isl/test_inputs/codegen/omega/x-1.c   |    14 +
 lib/Analysis/isl/test_inputs/codegen/omega/x-1.in  |     3 +
 .../isl/test_inputs/codegen/pldi2012/README        |     2 +
 .../isl/test_inputs/codegen/pldi2012/figure7_b.c   |     9 +
 .../isl/test_inputs/codegen/pldi2012/figure7_b.in  |     5 +
 .../isl/test_inputs/codegen/pldi2012/figure7_c.c   |    12 +
 .../isl/test_inputs/codegen/pldi2012/figure7_c.in  |     5 +
 .../isl/test_inputs/codegen/pldi2012/figure7_d.c   |    13 +
 .../isl/test_inputs/codegen/pldi2012/figure7_d.in  |     5 +
 .../isl/test_inputs/codegen/pldi2012/figure8_a.c   |     3 +
 .../isl/test_inputs/codegen/pldi2012/figure8_a.in  |     4 +
 .../isl/test_inputs/codegen/pldi2012/figure8_b.c   |     8 +
 .../isl/test_inputs/codegen/pldi2012/figure8_b.in  |     4 +
 lib/Analysis/isl/test_inputs/codegen/redundant.c   |    11 +
 lib/Analysis/isl/test_inputs/codegen/redundant.st  |     6 +
 lib/Analysis/isl/test_inputs/codegen/roman.c       |    32 +
 lib/Analysis/isl/test_inputs/codegen/roman.in      |     5 +
 lib/Analysis/isl/test_inputs/codegen/separate.c    |     8 +
 lib/Analysis/isl/test_inputs/codegen/separate.in   |     3 +
 lib/Analysis/isl/test_inputs/codegen/separate.st   |     8 +
 lib/Analysis/isl/test_inputs/codegen/separate2.c   |     8 +
 lib/Analysis/isl/test_inputs/codegen/separate2.in  |     4 +
 .../isl/test_inputs/codegen/separation_class.c     |    17 +
 .../isl/test_inputs/codegen/separation_class.in    |     6 +
 .../isl/test_inputs/codegen/separation_class2.c    |    15 +
 .../isl/test_inputs/codegen/separation_class2.in   |     3 +
 .../isl/test_inputs/codegen/separation_class3.c    |    31 +
 .../isl/test_inputs/codegen/separation_class3.in   |     4 +
 .../isl/test_inputs/codegen/separation_class4.c    |    22 +
 .../isl/test_inputs/codegen/separation_class4.in   |    10 +
 lib/Analysis/isl/test_inputs/codegen/shift.c       |     4 +
 lib/Analysis/isl/test_inputs/codegen/shift.in      |     3 +
 lib/Analysis/isl/test_inputs/codegen/shift2.c      |    56 +
 lib/Analysis/isl/test_inputs/codegen/shift2.in     |     5 +
 .../isl/test_inputs/codegen/shift_unroll.c         |    14 +
 .../isl/test_inputs/codegen/shift_unroll.in        |     3 +
 .../isl/test_inputs/codegen/single_valued.c        |     2 +
 .../isl/test_inputs/codegen/single_valued.in       |     5 +
 lib/Analysis/isl/test_inputs/codegen/sor1d-part.c  |     3 +
 lib/Analysis/isl/test_inputs/codegen/sor1d-part.st |    10 +
 lib/Analysis/isl/test_inputs/codegen/stride.c      |     6 +
 lib/Analysis/isl/test_inputs/codegen/stride.in     |     6 +
 lib/Analysis/isl/test_inputs/codegen/stride5.c     |     3 +
 lib/Analysis/isl/test_inputs/codegen/stride5.in    |     3 +
 lib/Analysis/isl/test_inputs/codegen/stride6.c     |     4 +
 lib/Analysis/isl/test_inputs/codegen/stride6.in    |     3 +
 lib/Analysis/isl/test_inputs/codegen/stride7.c     |     6 +
 lib/Analysis/isl/test_inputs/codegen/stride7.in    |     7 +
 lib/Analysis/isl/test_inputs/codegen/unroll.c      |     5 +
 lib/Analysis/isl/test_inputs/codegen/unroll.in     |     5 +
 lib/Analysis/isl/test_inputs/codegen/unroll10.c    |    29 +
 lib/Analysis/isl/test_inputs/codegen/unroll10.in   |     4 +
 lib/Analysis/isl/test_inputs/codegen/unroll10.st   |     7 +
 lib/Analysis/isl/test_inputs/codegen/unroll11.c    |     8 +
 lib/Analysis/isl/test_inputs/codegen/unroll11.in   |    10 +
 lib/Analysis/isl/test_inputs/codegen/unroll2.c     |    11 +
 lib/Analysis/isl/test_inputs/codegen/unroll2.in    |     5 +
 lib/Analysis/isl/test_inputs/codegen/unroll3.c     |     2 +
 lib/Analysis/isl/test_inputs/codegen/unroll3.in    |     6 +
 lib/Analysis/isl/test_inputs/codegen/unroll4.c     |    16 +
 lib/Analysis/isl/test_inputs/codegen/unroll4.in    |     5 +
 lib/Analysis/isl/test_inputs/codegen/unroll6.c     |     8 +
 lib/Analysis/isl/test_inputs/codegen/unroll6.in    |     7 +
 lib/Analysis/isl/test_inputs/codegen/unroll7.c     |    10 +
 lib/Analysis/isl/test_inputs/codegen/unroll7.in    |     5 +
 lib/Analysis/isl/test_inputs/codegen/unroll8.c     |     6 +
 lib/Analysis/isl/test_inputs/codegen/unroll8.st    |     5 +
 lib/Analysis/isl/test_inputs/codegen/unroll9.c     |     7 +
 lib/Analysis/isl/test_inputs/codegen/unroll9.st    |     7 +
 lib/Analysis/isl/test_inputs/convex0.polylib       |    11 +
 lib/Analysis/isl/test_inputs/convex1.polylib       |    17 +
 lib/Analysis/isl/test_inputs/convex10.polylib      |    17 +
 lib/Analysis/isl/test_inputs/convex11.polylib      |    14 +
 lib/Analysis/isl/test_inputs/convex12.polylib      |    12 +
 lib/Analysis/isl/test_inputs/convex13.polylib      |    17 +
 lib/Analysis/isl/test_inputs/convex14.polylib      |    14 +
 lib/Analysis/isl/test_inputs/convex15.polylib      |    66 +
 lib/Analysis/isl/test_inputs/convex2.polylib       |    24 +
 lib/Analysis/isl/test_inputs/convex3.polylib       |    10 +
 lib/Analysis/isl/test_inputs/convex4.polylib       |     9 +
 lib/Analysis/isl/test_inputs/convex5.polylib       |    12 +
 lib/Analysis/isl/test_inputs/convex6.polylib       |    17 +
 lib/Analysis/isl/test_inputs/convex7.polylib       |     9 +
 lib/Analysis/isl/test_inputs/convex8.polylib       |    24 +
 lib/Analysis/isl/test_inputs/convex9.polylib       |    14 +
 lib/Analysis/isl/test_inputs/devos.pwqp            |     1 +
 lib/Analysis/isl/test_inputs/equality1.pwqp        |     1 +
 lib/Analysis/isl/test_inputs/equality2.pwqp        |     1 +
 lib/Analysis/isl/test_inputs/equality3.pwqp        |     1 +
 lib/Analysis/isl/test_inputs/equality4.pwqp        |     1 +
 lib/Analysis/isl/test_inputs/equality5.pwqp        |     1 +
 lib/Analysis/isl/test_inputs/esced.pip             |    27 +
 lib/Analysis/isl/test_inputs/ex.pip                |     9 +
 lib/Analysis/isl/test_inputs/ex2.pip               |     9 +
 lib/Analysis/isl/test_inputs/exist.pip             |     5 +
 lib/Analysis/isl/test_inputs/exist2.pip            |     5 +
 lib/Analysis/isl/test_inputs/faddeev.pwqp          |     1 +
 lib/Analysis/isl/test_inputs/fimmel.pip            |    12 +
 .../isl/test_inputs/flow/kill_loop-tree.ai         |    11 +
 .../isl/test_inputs/flow/kill_loop-tree.flow       |     4 +
 lib/Analysis/isl/test_inputs/flow/kill_loop.ai     |     4 +
 lib/Analysis/isl/test_inputs/flow/kill_loop.flow   |     4 +
 .../isl/test_inputs/flow/kill_loop2-tree.ai        |    11 +
 .../isl/test_inputs/flow/kill_loop2-tree.flow      |     4 +
 lib/Analysis/isl/test_inputs/flow/kill_loop2.ai    |     4 +
 lib/Analysis/isl/test_inputs/flow/kill_loop2.flow  |     4 +
 .../isl/test_inputs/flow/kill_loop3-tree.ai        |    11 +
 .../isl/test_inputs/flow/kill_loop3-tree.flow      |     4 +
 lib/Analysis/isl/test_inputs/flow/kill_loop3.ai    |     4 +
 lib/Analysis/isl/test_inputs/flow/kill_loop3.flow  |     4 +
 .../isl/test_inputs/flow/kill_may_loop-tree.ai     |    11 +
 .../isl/test_inputs/flow/kill_may_loop-tree.flow   |     4 +
 lib/Analysis/isl/test_inputs/flow/kill_may_loop.ai |     4 +
 .../isl/test_inputs/flow/kill_may_loop.flow        |     4 +
 .../isl/test_inputs/flow/kill_may_loop2-tree.ai    |    11 +
 .../isl/test_inputs/flow/kill_may_loop2-tree.flow  |     4 +
 .../isl/test_inputs/flow/kill_may_loop2.ai         |     4 +
 .../isl/test_inputs/flow/kill_may_loop2.flow       |     4 +
 .../isl/test_inputs/flow/kill_may_loop3-tree.ai    |    11 +
 .../isl/test_inputs/flow/kill_may_loop3-tree.flow  |     4 +
 .../isl/test_inputs/flow/kill_may_loop3.ai         |     4 +
 .../isl/test_inputs/flow/kill_may_loop3.flow       |     4 +
 lib/Analysis/isl/test_inputs/flow/loop-tree.ai     |    10 +
 lib/Analysis/isl/test_inputs/flow/loop-tree.flow   |     4 +
 lib/Analysis/isl/test_inputs/flow/loop.ai          |     3 +
 lib/Analysis/isl/test_inputs/flow/loop.flow        |     4 +
 lib/Analysis/isl/test_inputs/flow/may_loop-tree.ai |    10 +
 .../isl/test_inputs/flow/may_loop-tree.flow        |     4 +
 lib/Analysis/isl/test_inputs/flow/may_loop.ai      |     3 +
 lib/Analysis/isl/test_inputs/flow/may_loop.flow    |     4 +
 .../isl/test_inputs/flow/mixed_loop-tree.ai        |    11 +
 .../isl/test_inputs/flow/mixed_loop-tree.flow      |     4 +
 lib/Analysis/isl/test_inputs/flow/mixed_loop.ai    |     4 +
 lib/Analysis/isl/test_inputs/flow/mixed_loop.flow  |     4 +
 lib/Analysis/isl/test_inputs/flow/multi.ai         |    10 +
 lib/Analysis/isl/test_inputs/flow/multi.flow       |     4 +
 .../isl/test_inputs/flow/multi_source-tree.ai      |     8 +
 .../isl/test_inputs/flow/multi_source-tree.flow    |     4 +
 lib/Analysis/isl/test_inputs/flow/multi_source.ai  |     3 +
 .../isl/test_inputs/flow/multi_source.flow         |     4 +
 .../isl/test_inputs/flow/multi_source2-tree.ai     |     9 +
 .../isl/test_inputs/flow/multi_source2-tree.flow   |     4 +
 lib/Analysis/isl/test_inputs/flow/multi_source2.ai |     4 +
 .../isl/test_inputs/flow/multi_source2.flow        |     4 +
 .../isl/test_inputs/flow/multi_source3-tree.ai     |    13 +
 .../isl/test_inputs/flow/multi_source3-tree.flow   |     4 +
 lib/Analysis/isl/test_inputs/flow/multi_source3.ai |     4 +
 .../isl/test_inputs/flow/multi_source3.flow        |     4 +
 .../isl/test_inputs/flow/multi_source4-tree.ai     |    13 +
 .../isl/test_inputs/flow/multi_source4-tree.flow   |     4 +
 lib/Analysis/isl/test_inputs/flow/multi_source4.ai |     4 +
 .../isl/test_inputs/flow/multi_source4.flow        |     4 +
 .../isl/test_inputs/flow/no_source-tree.ai         |     3 +
 .../isl/test_inputs/flow/no_source-tree.flow       |     4 +
 lib/Analysis/isl/test_inputs/flow/no_source.ai     |     2 +
 lib/Analysis/isl/test_inputs/flow/no_source.flow   |     4 +
 .../isl/test_inputs/flow/no_source2-tree.ai        |     8 +
 .../isl/test_inputs/flow/no_source2-tree.flow      |     4 +
 lib/Analysis/isl/test_inputs/flow/no_source2.ai    |     3 +
 lib/Analysis/isl/test_inputs/flow/no_source2.flow  |     4 +
 .../isl/test_inputs/flow/single_may_source-tree.ai |     8 +
 .../test_inputs/flow/single_may_source-tree.flow   |     4 +
 .../isl/test_inputs/flow/single_may_source.ai      |     3 +
 .../isl/test_inputs/flow/single_may_source.flow    |     4 +
 .../isl/test_inputs/flow/single_source-tree.ai     |     8 +
 .../isl/test_inputs/flow/single_source-tree.flow   |     4 +
 lib/Analysis/isl/test_inputs/flow/single_source.ai |     3 +
 .../isl/test_inputs/flow/single_source.flow        |     4 +
 lib/Analysis/isl/test_inputs/gist1.polylib         |    14 +
 lib/Analysis/isl/test_inputs/linearExample.pwqp    |     1 +
 lib/Analysis/isl/test_inputs/max.pip               |     9 +
 lib/Analysis/isl/test_inputs/neg.pwqp              |     1 +
 lib/Analysis/isl/test_inputs/negative.pip          |     9 +
 lib/Analysis/isl/test_inputs/philippe.pwqp         |     1 +
 lib/Analysis/isl/test_inputs/philippe3vars.pwqp    |     1 +
 .../isl/test_inputs/philippe3vars3pars.pwqp        |     1 +
 lib/Analysis/isl/test_inputs/philippeNeg.pwqp      |     1 +
 .../isl/test_inputs/philippePolynomialCoeff.pwqp   |     1 +
 .../isl/test_inputs/philippePolynomialCoeff1P.pwqp |     1 +
 lib/Analysis/isl/test_inputs/product.pwqp          |     1 +
 .../test_inputs/schedule/feautrier_compressed.sc   |     5 +
 .../test_inputs/schedule/feautrier_compressed.st   |    11 +
 lib/Analysis/isl/test_inputs/seghir-vd.pip         |    17 +
 lib/Analysis/isl/test_inputs/set.omega             |     1 +
 lib/Analysis/isl/test_inputs/small.pip             |     9 +
 lib/Analysis/isl/test_inputs/sor1d.pip             |    28 +
 lib/Analysis/isl/test_inputs/split.pwqp            |     1 +
 lib/Analysis/isl/test_inputs/square.pip            |     9 +
 lib/Analysis/isl/test_inputs/sven.pip              |     7 +
 lib/Analysis/isl/test_inputs/test3Deg3Var.pwqp     |     1 +
 lib/Analysis/isl/test_inputs/tobi.pip              |    15 +
 lib/Analysis/isl/test_inputs/toplas.pwqp           |     1 +
 lib/Analysis/isl/test_inputs/unexpanded.pwqp       |     1 +
 989 files changed, 47210 insertions(+), 12530 deletions(-)
 create mode 100644 lib/Analysis/isl/bset_from_bmap.c
 create mode 100644 lib/Analysis/isl/bset_to_bmap.c
 delete mode 100644 lib/Analysis/isl/doc/manual.pdf
 create mode 100644 lib/Analysis/isl/extract_key.c
 create mode 100644 lib/Analysis/isl/flow.c
 create mode 100644 lib/Analysis/isl/flow_cmp.c
 create mode 100644 lib/Analysis/isl/flow_test.sh.in
 create mode 100644 lib/Analysis/isl/include/isl/isl-noexceptions.h
 create mode 100644 lib/Analysis/isl/interface/isl.h.top
 create mode 100644 lib/Analysis/isl/isl_maybe_map.h
 create mode 100644 lib/Analysis/isl/isl_schedule_constraints.c
 create mode 100644 lib/Analysis/isl/isl_schedule_constraints.h
 create mode 100644 lib/Analysis/isl/isl_srcdir.c.cmake
 create mode 100644 lib/Analysis/isl/isl_srcdir.c.in
 create mode 100644 lib/Analysis/isl/isl_tab_lexopt_templ.c
 create mode 100644 lib/Analysis/isl/isl_union_set_private.h
 create mode 100644 lib/Analysis/isl/m4/ax_cxx_compile_stdcxx.m4
 create mode 100644 lib/Analysis/isl/m4/ax_cxx_compile_stdcxx_11.m4
 create mode 100644 lib/Analysis/isl/m4/ax_detect_clang.m4
 create mode 100644 lib/Analysis/isl/print_templ_yaml.c
 create mode 100644 lib/Analysis/isl/read_in_string_templ.c
 create mode 100644 lib/Analysis/isl/schedule.c
 create mode 100644 lib/Analysis/isl/schedule_cmp.c
 create mode 100644 lib/Analysis/isl/schedule_test.sh.in
 create mode 100644 lib/Analysis/isl/set_from_map.c
 create mode 100644 lib/Analysis/isl/set_to_map.c
 create mode 100755 lib/Analysis/isl/test-driver
 create mode 100644 lib/Analysis/isl/test_inputs/affine.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/affine2.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/affine3.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/application.omega
 create mode 100644 lib/Analysis/isl/test_inputs/application2.omega
 create mode 100644 lib/Analysis/isl/test_inputs/basicLinear.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/basicLinear2.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/basicTest.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/basicTestParameterPosNeg.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/boulet.pip
 create mode 100644 lib/Analysis/isl/test_inputs/brisebarre.pip
 create mode 100644 lib/Analysis/isl/test_inputs/cg1.pip
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/atomic4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cholesky.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cholesky.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/4-param.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/4-param.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/README
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/block.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/block.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/block2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/block2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/block3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/block3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/christian.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/christian.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/classen.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/classen.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/classen2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/classen2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/constant.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/constant.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/constbound.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/constbound.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/darte.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/darte.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/dealII.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/dealII.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/dot.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/dot.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/dot2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/dot2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/emploi.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/emploi.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/equality.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/equality.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/equality2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/equality2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/esced.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/esced.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/ex1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/ex1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/faber.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/faber.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gauss.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gauss.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gesced.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gesced.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/guide.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/guide.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/iftest.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/iftest.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/largeur.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/largeur.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lex.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lex.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/logo.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/logo.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/logopar.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/logopar.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lu.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lu.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lu2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lu2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lux.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/lux.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/merge.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/merge.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mod4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mode.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mode.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/orc.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/orc.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/otl.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/otl.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/param-split.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/param-split.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/singleton.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/singleton.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/stride4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/swim.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/swim.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/test.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/test.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/tiling.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/tiling.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/union.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/union.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/unroll.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/unroll.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/vivien.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/vivien.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/walters.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/walters.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/walters2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/walters2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/walters3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/walters3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/yosr.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/yosr.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/youcef.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/youcef.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component0.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component5.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/component6.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/correlation.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/correlation.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/disjuncts.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/disjuncts.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/disjuncts2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/disjuncts2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/dwt.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/dwt.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/empty.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/empty.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/filter.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/filter.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/gemm.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/gemm.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/hoist.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/hoist.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/hoist2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/hoist2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate1.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate2.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate3.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate4.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate5.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate6.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate7.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/isolate7.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/lu.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/lu.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/mod.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/mod.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/README
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/basics-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/basics-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/basics-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/basics-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/collard-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/collard-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gc-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gc-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ge-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ge-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ge-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ge-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/gist-5.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m1-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m1-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m10-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m10-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m10-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m10-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m11-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m11-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m12-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m12-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m12-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m12-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m2-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m2-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m2-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m2-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m3-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m3-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m4-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m4-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m4-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m4-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m7-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m7-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m7-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m7-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m8-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m8-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m8-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m8-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m9-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m9-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m9-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/m9-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/olda-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/olda-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/olda-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/olda-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p6-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p6-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p6-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/p6-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/x-0.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/x-0.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/x-1.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/omega/x-1.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/README
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/redundant.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/redundant.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/roman.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/roman.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separate.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separate.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separate.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separate2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separate2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/separation_class4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/shift.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/shift.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/shift2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/shift2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/shift_unroll.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/shift_unroll.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/single_valued.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/single_valued.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/sor1d-part.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/sor1d-part.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride5.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride5.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride6.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride7.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/stride7.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll10.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll10.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll10.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll11.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll11.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll2.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll2.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll3.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll3.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll4.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll4.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll6.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll6.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll7.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll7.in
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll8.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll8.st
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll9.c
 create mode 100644 lib/Analysis/isl/test_inputs/codegen/unroll9.st
 create mode 100644 lib/Analysis/isl/test_inputs/convex0.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex1.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex10.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex11.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex12.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex13.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex14.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex15.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex2.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex3.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex4.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex5.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex6.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex7.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex8.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/convex9.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/devos.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/equality1.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/equality2.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/equality3.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/equality4.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/equality5.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/esced.pip
 create mode 100644 lib/Analysis/isl/test_inputs/ex.pip
 create mode 100644 lib/Analysis/isl/test_inputs/ex2.pip
 create mode 100644 lib/Analysis/isl/test_inputs/exist.pip
 create mode 100644 lib/Analysis/isl/test_inputs/exist2.pip
 create mode 100644 lib/Analysis/isl/test_inputs/faddeev.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/fimmel.pip
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop2.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop2.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop3.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_loop3.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop2.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop2.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop3.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/kill_may_loop3.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/loop-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/loop-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/loop.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/loop.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/may_loop-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/may_loop-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/may_loop.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/may_loop.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/mixed_loop.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/mixed_loop.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source2-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source2-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source2.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source2.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source3-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source3-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source3.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source3.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source4-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source4-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source4.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/multi_source4.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source2-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source2-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source2.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/no_source2.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_may_source-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_may_source-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_may_source.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_may_source.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_source-tree.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_source-tree.flow
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_source.ai
 create mode 100644 lib/Analysis/isl/test_inputs/flow/single_source.flow
 create mode 100644 lib/Analysis/isl/test_inputs/gist1.polylib
 create mode 100644 lib/Analysis/isl/test_inputs/linearExample.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/max.pip
 create mode 100644 lib/Analysis/isl/test_inputs/neg.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/negative.pip
 create mode 100644 lib/Analysis/isl/test_inputs/philippe.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/philippe3vars.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/philippe3vars3pars.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/philippeNeg.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/philippePolynomialCoeff.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/philippePolynomialCoeff1P.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/product.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.sc
 create mode 100644 lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.st
 create mode 100644 lib/Analysis/isl/test_inputs/seghir-vd.pip
 create mode 100644 lib/Analysis/isl/test_inputs/set.omega
 create mode 100644 lib/Analysis/isl/test_inputs/small.pip
 create mode 100644 lib/Analysis/isl/test_inputs/sor1d.pip
 create mode 100644 lib/Analysis/isl/test_inputs/split.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/square.pip
 create mode 100644 lib/Analysis/isl/test_inputs/sven.pip
 create mode 100644 lib/Analysis/isl/test_inputs/test3Deg3Var.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/tobi.pip
 create mode 100644 lib/Analysis/isl/test_inputs/toplas.pwqp
 create mode 100644 lib/Analysis/isl/test_inputs/unexpanded.pwqp

diff --git a/lib/Analysis/isl/AUTHORS b/lib/Analysis/isl/AUTHORS
index 9135d8f..975d5b6 100644
--- a/lib/Analysis/isl/AUTHORS
+++ b/lib/Analysis/isl/AUTHORS
@@ -23,7 +23,7 @@ isl was written by
 	    Domaine de Voluceau - Rocquencourt, B.P. 105
 	    78153 Le Chesnay
 	    France
-2015	    LLPT Labs
+2015-2016   Polly Labs
 
 Contributions by
 
@@ -38,6 +38,7 @@ Andreas Kloeckner
 Michael Kruse
 Sebastian Pop
 Louis-Noel Pouchet
+Benoit Pradelle
 Uday Kumar Reddy
 Andreas Simbuerger
 Sven van Haastregt
diff --git a/lib/Analysis/isl/CMakeLists.txt b/lib/Analysis/isl/CMakeLists.txt
index c4648bd..ab27038 100644
--- a/lib/Analysis/isl/CMakeLists.txt
+++ b/lib/Analysis/isl/CMakeLists.txt
@@ -191,6 +191,19 @@ set (ISL_INTERNAL_FILES
   polyhedron_sample.c
   polytope_scan.c
   print_templ.c
+  set_to_map.c
+  schedule.c
+  pip.c
+  isl_tab_lexopt_templ.c
+  flow_cmp.c
+  flow.c
+  extract_key.c
+  read_in_string_templ.c
+  print_templ_yaml.c
+  schedule_cmp.c
+  set_from_map.c
+  bset_to_bmap.c
+  bset_from_bmap.c
 )
 
 set(LLVM_OPTIONAL_SOURCES ISLInternal ${ISL_INTERNAL_FILES})
@@ -253,6 +266,7 @@ set (ISL_FILES
     isl_scan.c
     isl_schedule.c
     isl_schedule_band.c
+    isl_schedule_constraints.c
     isl_schedule_node.c
     isl_schedule_read.c
     isl_schedule_tree.c
@@ -272,7 +286,6 @@ set (ISL_FILES
     isl_vec.c
     isl_version.c
     isl_vertices.c
-    pip.c
     print.c
     imath/gmp_compat.c
     imath/imath.c
diff --git a/lib/Analysis/isl/ChangeLog b/lib/Analysis/isl/ChangeLog
index 14ff1b4..249acdf 100644
--- a/lib/Analysis/isl/ChangeLog
+++ b/lib/Analysis/isl/ChangeLog
@@ -1,3 +1,13 @@
+version: 0.18
+date: Sun Dec 18 11:01:58 CET 2016
+changes:
+	- improve elimination of redundant existentially quantified variables
+	- improve coalescing
+	- improve parametric integer programming
+	- preserve isolate option in isl_schedule_node_band_split
+	- print AST nodes in YAML format
+	- minor improvements to Python bindings
+---
 version: 0.17.1
 date: Fri May  6 12:02:48 CEST 2016
 changes:
diff --git a/lib/Analysis/isl/GIT_HEAD_ID b/lib/Analysis/isl/GIT_HEAD_ID
index e49f3f3..a2665ce 100644
--- a/lib/Analysis/isl/GIT_HEAD_ID
+++ b/lib/Analysis/isl/GIT_HEAD_ID
@@ -1 +1 @@
-isl-0.17.1-84-g72ffe88
+isl-0.18-812-g565da6e
diff --git a/lib/Analysis/isl/Makefile.am b/lib/Analysis/isl/Makefile.am
index 1b2f117..4000277 100644
--- a/lib/Analysis/isl/Makefile.am
+++ b/lib/Analysis/isl/Makefile.am
@@ -11,8 +11,10 @@ lib_LTLIBRARIES = libisl.la
 noinst_PROGRAMS = isl_test isl_polyhedron_sample isl_pip \
 	isl_polyhedron_minimize isl_polytope_scan \
 	isl_polyhedron_detect_equalities isl_cat \
-	isl_closure isl_bound isl_codegen isl_test_int
-TESTS = isl_test codegen_test.sh pip_test.sh bound_test.sh isl_test_int
+	isl_closure isl_bound isl_schedule isl_codegen isl_test_int \
+	isl_flow isl_flow_cmp isl_schedule_cmp
+TESTS = isl_test codegen_test.sh pip_test.sh bound_test.sh isl_test_int \
+	flow_test.sh schedule_test.sh
 
 if IMATH_FOR_MP
 
@@ -161,6 +163,8 @@ libisl_la_SOURCES = \
 	isl_schedule_tree.c \
 	isl_schedule_tree.h \
 	isl_schedule_private.h \
+	isl_schedule_constraints.c \
+	isl_schedule_constraints.h \
 	isl_scheduler.c \
 	isl_set_list.c \
 	isl_sort.c \
@@ -179,6 +183,7 @@ libisl_la_SOURCES = \
 	isl_transitive_closure.c \
 	isl_union_map.c \
 	isl_union_map_private.h \
+	isl_union_set_private.h \
 	isl_val.c \
 	isl_val_private.h \
 	isl_vec_private.h \
@@ -211,6 +216,26 @@ isl_pip_LDADD = libisl.la @MP_LIBS@
 isl_pip_SOURCES = \
 	pip.c
 
+isl_schedule_LDFLAGS = @MP_LDFLAGS@
+isl_schedule_LDADD = libisl.la @MP_LIBS@
+isl_schedule_SOURCES = \
+	schedule.c
+
+isl_schedule_cmp_LDFLAGS = @MP_LDFLAGS@
+isl_schedule_cmp_LDADD = libisl.la @MP_LIBS@
+isl_schedule_cmp_SOURCES = \
+	schedule_cmp.c
+
+isl_flow_LDFLAGS = @MP_LDFLAGS@
+isl_flow_LDADD = libisl.la @MP_LIBS@
+isl_flow_SOURCES = \
+	flow.c
+
+isl_flow_cmp_LDFLAGS = @MP_LDFLAGS@
+isl_flow_cmp_LDADD = libisl.la @MP_LIBS@
+isl_flow_cmp_SOURCES = \
+	flow_cmp.c
+
 isl_codegen_LDFLAGS = @MP_LDFLAGS@
 isl_codegen_LDADD = libisl.la @MP_LIBS@
 isl_codegen_SOURCES = \
@@ -332,9 +357,13 @@ EXTRA_DIST = \
 	LICENSE \
 	isl_config_post.h \
 	basis_reduction_templ.c \
+	bset_to_bmap.c \
+	bset_from_bmap.c \
+	extract_key.c \
 	isl_list_templ.c \
 	isl_list_templ.h \
 	isl_map_lexopt_templ.c \
+	isl_maybe_map.h \
 	isl_multi_macro.h \
 	isl_multi_templ.c \
 	isl_multi_templ.h \
@@ -348,11 +377,16 @@ EXTRA_DIST = \
 	isl_multi_hash.c \
 	isl_multi_intersect.c \
 	print_templ.c \
+	print_templ_yaml.c \
 	isl_power_templ.c \
 	isl_pw_macro.h \
 	isl_pw_templ.c \
 	isl_pw_hash.c \
 	isl_pw_union_opt.c \
+	read_in_string_templ.c \
+	set_to_map.c \
+	set_from_map.c \
+	isl_tab_lexopt_templ.c \
 	isl_union_macro.h \
 	isl_union_templ.c \
 	isl_union_single.c \
@@ -375,6 +409,7 @@ EXTRA_DIST = \
 	imath/imrat.c \
 	imath/imrat.h \
 	interface/all.h \
+	interface/isl.h.top \
 	interface/isl.py.top \
 	test_inputs
 
diff --git a/lib/Analysis/isl/Makefile.in b/lib/Analysis/isl/Makefile.in
index 9204bbc..3ea3a2f 100644
--- a/lib/Analysis/isl/Makefile.in
+++ b/lib/Analysis/isl/Makefile.in
@@ -95,10 +95,13 @@ noinst_PROGRAMS = isl_test$(EXEEXT) isl_polyhedron_sample$(EXEEXT) \
 	isl_pip$(EXEEXT) isl_polyhedron_minimize$(EXEEXT) \
 	isl_polytope_scan$(EXEEXT) \
 	isl_polyhedron_detect_equalities$(EXEEXT) isl_cat$(EXEEXT) \
-	isl_closure$(EXEEXT) isl_bound$(EXEEXT) isl_codegen$(EXEEXT) \
-	isl_test_int$(EXEEXT) $(am__EXEEXT_1)
+	isl_closure$(EXEEXT) isl_bound$(EXEEXT) isl_schedule$(EXEEXT) \
+	isl_codegen$(EXEEXT) isl_test_int$(EXEEXT) isl_flow$(EXEEXT) \
+	isl_flow_cmp$(EXEEXT) isl_schedule_cmp$(EXEEXT) \
+	$(am__EXEEXT_1)
 TESTS = isl_test$(EXEEXT) codegen_test.sh pip_test.sh bound_test.sh \
-	isl_test_int$(EXEEXT) $(am__EXEEXT_1)
+	isl_test_int$(EXEEXT) flow_test.sh schedule_test.sh \
+	$(am__EXEEXT_1)
 @IMATH_FOR_MP_TRUE@am__append_1 = isl_test_imath
 @IMATH_FOR_MP_TRUE@am__append_2 = isl_test_imath
 @IMATH_FOR_MP_TRUE@@SMALL_INT_OPT_TRUE@am__append_3 = isl_int_sioimath.h \
@@ -114,6 +117,9 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/ax_c___attribute__.m4 \
 	$(top_srcdir)/m4/ax_compiler_vendor.m4 \
 	$(top_srcdir)/m4/ax_create_pkgconfig_info.m4 \
 	$(top_srcdir)/m4/ax_create_stdint_h.m4 \
+	$(top_srcdir)/m4/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/m4/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/m4/ax_detect_clang.m4 \
 	$(top_srcdir)/m4/ax_detect_git_head.m4 \
 	$(top_srcdir)/m4/ax_detect_gmp.m4 \
 	$(top_srcdir)/m4/ax_detect_imath.m4 \
@@ -134,7 +140,8 @@ am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = isl_config.h
-CONFIG_CLEAN_FILES = bound_test.sh codegen_test.sh pip_test.sh
+CONFIG_CLEAN_FILES = isl_srcdir.c bound_test.sh codegen_test.sh \
+	pip_test.sh flow_test.sh schedule_test.sh
 CONFIG_CLEAN_VPATH_FILES =
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
@@ -201,13 +208,14 @@ am__libisl_la_SOURCES_DIST = mp_get_memory_functions.c isl_int_gmp.h \
 	isl_schedule_band.c isl_schedule_band.h isl_schedule_node.c \
 	isl_schedule_node_private.h isl_schedule_read.c \
 	isl_schedule_tree.c isl_schedule_tree.h isl_schedule_private.h \
+	isl_schedule_constraints.c isl_schedule_constraints.h \
 	isl_scheduler.c isl_set_list.c isl_sort.c isl_sort.h \
 	isl_space.c isl_space_private.h isl_stream.c \
 	isl_stream_private.h isl_seq.c isl_seq.h isl_tab.c isl_tab.h \
 	isl_tab_pip.c isl_tarjan.c isl_tarjan.h \
 	isl_transitive_closure.c isl_union_map.c \
-	isl_union_map_private.h isl_val.c isl_val_private.h \
-	isl_vec_private.h isl_vec.c isl_version.c \
+	isl_union_map_private.h isl_union_set_private.h isl_val.c \
+	isl_val_private.h isl_vec_private.h isl_vec.c isl_version.c \
 	isl_vertices_private.h isl_vertices.c isl_yaml.h
 @GMP_FOR_MP_TRUE@@NEED_GET_MEMORY_FUNCTIONS_TRUE@am__objects_1 = mp_get_memory_functions.lo
 am__dirstamp = $(am__leading_dot)dirstamp
@@ -241,11 +249,12 @@ am_libisl_la_OBJECTS = $(am__objects_4) $(am__objects_5) isl_aff.lo \
 	isl_point.lo isl_polynomial.lo isl_printer.lo print.lo \
 	isl_range.lo isl_reordering.lo isl_sample.lo isl_scan.lo \
 	isl_schedule.lo isl_schedule_band.lo isl_schedule_node.lo \
-	isl_schedule_read.lo isl_schedule_tree.lo isl_scheduler.lo \
-	isl_set_list.lo isl_sort.lo isl_space.lo isl_stream.lo \
-	isl_seq.lo isl_tab.lo isl_tab_pip.lo isl_tarjan.lo \
-	isl_transitive_closure.lo isl_union_map.lo isl_val.lo \
-	isl_vec.lo isl_version.lo isl_vertices.lo
+	isl_schedule_read.lo isl_schedule_tree.lo \
+	isl_schedule_constraints.lo isl_scheduler.lo isl_set_list.lo \
+	isl_sort.lo isl_space.lo isl_stream.lo isl_seq.lo isl_tab.lo \
+	isl_tab_pip.lo isl_tarjan.lo isl_transitive_closure.lo \
+	isl_union_map.lo isl_val.lo isl_vec.lo isl_version.lo \
+	isl_vertices.lo
 libisl_la_OBJECTS = $(am_libisl_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -274,6 +283,18 @@ isl_codegen_DEPENDENCIES = libisl.la
 isl_codegen_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(isl_codegen_LDFLAGS) $(LDFLAGS) -o $@
+am_isl_flow_OBJECTS = flow.$(OBJEXT)
+isl_flow_OBJECTS = $(am_isl_flow_OBJECTS)
+isl_flow_DEPENDENCIES = libisl.la
+isl_flow_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(isl_flow_LDFLAGS) $(LDFLAGS) -o $@
+am_isl_flow_cmp_OBJECTS = flow_cmp.$(OBJEXT)
+isl_flow_cmp_OBJECTS = $(am_isl_flow_cmp_OBJECTS)
+isl_flow_cmp_DEPENDENCIES = libisl.la
+isl_flow_cmp_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(isl_flow_cmp_LDFLAGS) $(LDFLAGS) -o $@
 am_isl_pip_OBJECTS = pip.$(OBJEXT)
 isl_pip_OBJECTS = $(am_isl_pip_OBJECTS)
 isl_pip_DEPENDENCIES = libisl.la
@@ -299,6 +320,19 @@ isl_polyhedron_sample_DEPENDENCIES = libisl.la
 am_isl_polytope_scan_OBJECTS = polytope_scan.$(OBJEXT)
 isl_polytope_scan_OBJECTS = $(am_isl_polytope_scan_OBJECTS)
 isl_polytope_scan_DEPENDENCIES = libisl.la
+am_isl_schedule_OBJECTS = schedule.$(OBJEXT)
+isl_schedule_OBJECTS = $(am_isl_schedule_OBJECTS)
+isl_schedule_DEPENDENCIES = libisl.la
+isl_schedule_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(isl_schedule_LDFLAGS) $(LDFLAGS) -o $@
+am_isl_schedule_cmp_OBJECTS = schedule_cmp.$(OBJEXT)
+isl_schedule_cmp_OBJECTS = $(am_isl_schedule_cmp_OBJECTS)
+isl_schedule_cmp_DEPENDENCIES = libisl.la
+isl_schedule_cmp_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(isl_schedule_cmp_LDFLAGS) $(LDFLAGS) \
+	-o $@
 isl_test_SOURCES = isl_test.c
 isl_test_OBJECTS = isl_test.$(OBJEXT)
 isl_test_DEPENDENCIES = libisl.la
@@ -354,17 +388,21 @@ am__v_CCLD_0 = @echo "  CCLD    " $@;
 am__v_CCLD_1 = 
 SOURCES = $(libisl_la_SOURCES) $(isl_bound_SOURCES) $(isl_cat_SOURCES) \
 	$(isl_closure_SOURCES) $(isl_codegen_SOURCES) \
-	$(isl_pip_SOURCES) $(isl_polyhedron_detect_equalities_SOURCES) \
+	$(isl_flow_SOURCES) $(isl_flow_cmp_SOURCES) $(isl_pip_SOURCES) \
+	$(isl_polyhedron_detect_equalities_SOURCES) \
 	$(isl_polyhedron_minimize_SOURCES) \
 	$(isl_polyhedron_sample_SOURCES) $(isl_polytope_scan_SOURCES) \
-	isl_test.c isl_test_imath.c isl_test_int.c
+	$(isl_schedule_SOURCES) $(isl_schedule_cmp_SOURCES) isl_test.c \
+	isl_test_imath.c isl_test_int.c
 DIST_SOURCES = $(am__libisl_la_SOURCES_DIST) $(isl_bound_SOURCES) \
 	$(isl_cat_SOURCES) $(isl_closure_SOURCES) \
-	$(isl_codegen_SOURCES) $(isl_pip_SOURCES) \
+	$(isl_codegen_SOURCES) $(isl_flow_SOURCES) \
+	$(isl_flow_cmp_SOURCES) $(isl_pip_SOURCES) \
 	$(isl_polyhedron_detect_equalities_SOURCES) \
 	$(isl_polyhedron_minimize_SOURCES) \
 	$(isl_polyhedron_sample_SOURCES) $(isl_polytope_scan_SOURCES) \
-	isl_test.c isl_test_imath.c isl_test_int.c
+	$(isl_schedule_SOURCES) $(isl_schedule_cmp_SOURCES) isl_test.c \
+	isl_test_imath.c isl_test_int.c
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
 	install-data-recursive install-dvi-recursive \
@@ -611,10 +649,11 @@ TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)/test-driver
 TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \
 	$(TEST_LOG_FLAGS)
 am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/bound_test.sh.in \
-	$(srcdir)/codegen_test.sh.in $(srcdir)/isl_config.h.in \
-	$(srcdir)/pip_test.sh.in AUTHORS ChangeLog README compile \
-	config.guess config.sub depcomp install-sh ltmain.sh missing \
-	test-driver
+	$(srcdir)/codegen_test.sh.in $(srcdir)/flow_test.sh.in \
+	$(srcdir)/isl_config.h.in $(srcdir)/isl_srcdir.c.in \
+	$(srcdir)/pip_test.sh.in $(srcdir)/schedule_test.sh.in AUTHORS \
+	ChangeLog README compile config.guess config.sub depcomp \
+	install-sh ltmain.sh missing test-driver
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -674,6 +713,7 @@ CLANG_LIBS = @CLANG_LIBS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXX11FLAGS = @CXX11FLAGS@
 CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -693,6 +733,7 @@ GIT_HEAD = @GIT_HEAD@
 GIT_HEAD_ID = @GIT_HEAD_ID@
 GIT_HEAD_VERSION = @GIT_HEAD_VERSION@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -707,6 +748,7 @@ LIB_CLANG_EDIT = @LIB_CLANG_EDIT@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MKDIR_P = @MKDIR_P@
@@ -786,6 +828,7 @@ pkgconfig_libfile = @pkgconfig_libfile@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
@@ -920,6 +963,8 @@ libisl_la_SOURCES = \
 	isl_schedule_tree.c \
 	isl_schedule_tree.h \
 	isl_schedule_private.h \
+	isl_schedule_constraints.c \
+	isl_schedule_constraints.h \
 	isl_scheduler.c \
 	isl_set_list.c \
 	isl_sort.c \
@@ -938,6 +983,7 @@ libisl_la_SOURCES = \
 	isl_transitive_closure.c \
 	isl_union_map.c \
 	isl_union_map_private.h \
+	isl_union_set_private.h \
 	isl_val.c \
 	isl_val_private.h \
 	isl_vec_private.h \
@@ -966,6 +1012,26 @@ isl_pip_LDADD = libisl.la @MP_LIBS@
 isl_pip_SOURCES = \
 	pip.c
 
+isl_schedule_LDFLAGS = @MP_LDFLAGS@
+isl_schedule_LDADD = libisl.la @MP_LIBS@
+isl_schedule_SOURCES = \
+	schedule.c
+
+isl_schedule_cmp_LDFLAGS = @MP_LDFLAGS@
+isl_schedule_cmp_LDADD = libisl.la @MP_LIBS@
+isl_schedule_cmp_SOURCES = \
+	schedule_cmp.c
+
+isl_flow_LDFLAGS = @MP_LDFLAGS@
+isl_flow_LDADD = libisl.la @MP_LIBS@
+isl_flow_SOURCES = \
+	flow.c
+
+isl_flow_cmp_LDFLAGS = @MP_LDFLAGS@
+isl_flow_cmp_LDADD = libisl.la @MP_LIBS@
+isl_flow_cmp_SOURCES = \
+	flow_cmp.c
+
 isl_codegen_LDFLAGS = @MP_LDFLAGS@
 isl_codegen_LDADD = libisl.la @MP_LIBS@
 isl_codegen_SOURCES = \
@@ -1088,9 +1154,13 @@ EXTRA_DIST = \
 	LICENSE \
 	isl_config_post.h \
 	basis_reduction_templ.c \
+	bset_to_bmap.c \
+	bset_from_bmap.c \
+	extract_key.c \
 	isl_list_templ.c \
 	isl_list_templ.h \
 	isl_map_lexopt_templ.c \
+	isl_maybe_map.h \
 	isl_multi_macro.h \
 	isl_multi_templ.c \
 	isl_multi_templ.h \
@@ -1104,11 +1174,16 @@ EXTRA_DIST = \
 	isl_multi_hash.c \
 	isl_multi_intersect.c \
 	print_templ.c \
+	print_templ_yaml.c \
 	isl_power_templ.c \
 	isl_pw_macro.h \
 	isl_pw_templ.c \
 	isl_pw_hash.c \
 	isl_pw_union_opt.c \
+	read_in_string_templ.c \
+	set_to_map.c \
+	set_from_map.c \
+	isl_tab_lexopt_templ.c \
 	isl_union_macro.h \
 	isl_union_templ.c \
 	isl_union_single.c \
@@ -1131,6 +1206,7 @@ EXTRA_DIST = \
 	imath/imrat.c \
 	imath/imrat.h \
 	interface/all.h \
+	interface/isl.h.top \
 	interface/isl.py.top \
 	test_inputs
 
@@ -1189,12 +1265,18 @@ $(srcdir)/isl_config.h.in:  $(am__configure_deps)
 
 distclean-hdr:
 	-rm -f isl_config.h stamp-h1
+isl_srcdir.c: $(top_builddir)/config.status $(srcdir)/isl_srcdir.c.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
 bound_test.sh: $(top_builddir)/config.status $(srcdir)/bound_test.sh.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
 codegen_test.sh: $(top_builddir)/config.status $(srcdir)/codegen_test.sh.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
 pip_test.sh: $(top_builddir)/config.status $(srcdir)/pip_test.sh.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
+flow_test.sh: $(top_builddir)/config.status $(srcdir)/flow_test.sh.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
+schedule_test.sh: $(top_builddir)/config.status $(srcdir)/schedule_test.sh.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
 
 install-libLTLIBRARIES: $(lib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
@@ -1271,6 +1353,14 @@ isl_codegen$(EXEEXT): $(isl_codegen_OBJECTS) $(isl_codegen_DEPENDENCIES) $(EXTRA
 	@rm -f isl_codegen$(EXEEXT)
 	$(AM_V_CCLD)$(isl_codegen_LINK) $(isl_codegen_OBJECTS) $(isl_codegen_LDADD) $(LIBS)
 
+isl_flow$(EXEEXT): $(isl_flow_OBJECTS) $(isl_flow_DEPENDENCIES) $(EXTRA_isl_flow_DEPENDENCIES) 
+	@rm -f isl_flow$(EXEEXT)
+	$(AM_V_CCLD)$(isl_flow_LINK) $(isl_flow_OBJECTS) $(isl_flow_LDADD) $(LIBS)
+
+isl_flow_cmp$(EXEEXT): $(isl_flow_cmp_OBJECTS) $(isl_flow_cmp_DEPENDENCIES) $(EXTRA_isl_flow_cmp_DEPENDENCIES) 
+	@rm -f isl_flow_cmp$(EXEEXT)
+	$(AM_V_CCLD)$(isl_flow_cmp_LINK) $(isl_flow_cmp_OBJECTS) $(isl_flow_cmp_LDADD) $(LIBS)
+
 isl_pip$(EXEEXT): $(isl_pip_OBJECTS) $(isl_pip_DEPENDENCIES) $(EXTRA_isl_pip_DEPENDENCIES) 
 	@rm -f isl_pip$(EXEEXT)
 	$(AM_V_CCLD)$(isl_pip_LINK) $(isl_pip_OBJECTS) $(isl_pip_LDADD) $(LIBS)
@@ -1291,6 +1381,14 @@ isl_polytope_scan$(EXEEXT): $(isl_polytope_scan_OBJECTS) $(isl_polytope_scan_DEP
 	@rm -f isl_polytope_scan$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(isl_polytope_scan_OBJECTS) $(isl_polytope_scan_LDADD) $(LIBS)
 
+isl_schedule$(EXEEXT): $(isl_schedule_OBJECTS) $(isl_schedule_DEPENDENCIES) $(EXTRA_isl_schedule_DEPENDENCIES) 
+	@rm -f isl_schedule$(EXEEXT)
+	$(AM_V_CCLD)$(isl_schedule_LINK) $(isl_schedule_OBJECTS) $(isl_schedule_LDADD) $(LIBS)
+
+isl_schedule_cmp$(EXEEXT): $(isl_schedule_cmp_OBJECTS) $(isl_schedule_cmp_DEPENDENCIES) $(EXTRA_isl_schedule_cmp_DEPENDENCIES) 
+	@rm -f isl_schedule_cmp$(EXEEXT)
+	$(AM_V_CCLD)$(isl_schedule_cmp_LINK) $(isl_schedule_cmp_OBJECTS) $(isl_schedule_cmp_LDADD) $(LIBS)
+
 isl_test$(EXEEXT): $(isl_test_OBJECTS) $(isl_test_DEPENDENCIES) $(EXTRA_isl_test_DEPENDENCIES) 
 	@rm -f isl_test$(EXEEXT)
 	$(AM_V_CCLD)$(isl_test_LINK) $(isl_test_OBJECTS) $(isl_test_LDADD) $(LIBS)
@@ -1316,6 +1414,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cat.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/closure.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/codegen.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flow.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flow_cmp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_aff.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_affine_hull.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_arg.Plo@am__quote@
@@ -1373,6 +1473,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_scan.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_schedule.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_schedule_band.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_schedule_constraints.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_schedule_node.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_schedule_read.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/isl_schedule_tree.Plo@am__quote@
@@ -1404,6 +1505,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/polyhedron_sample.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/polytope_scan.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/print.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/schedule.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/schedule_cmp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@imath_wrap/$(DEPDIR)/gmp_compat.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@imath_wrap/$(DEPDIR)/imath.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@imath_wrap/$(DEPDIR)/imrat.Plo@am__quote@
@@ -1808,6 +1911,20 @@ isl_test_int.log: isl_test_int$(EXEEXT)
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
+flow_test.sh.log: flow_test.sh
+	@p='flow_test.sh'; \
+	b='flow_test.sh'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+schedule_test.sh.log: schedule_test.sh
+	@p='schedule_test.sh'; \
+	b='schedule_test.sh'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 isl_test_imath.log: isl_test_imath$(EXEEXT)
 	@p='isl_test_imath$(EXEEXT)'; \
 	b='isl_test_imath'; \
diff --git a/lib/Analysis/isl/aclocal.m4 b/lib/Analysis/isl/aclocal.m4
index 8652138..638fadd 100644
--- a/lib/Analysis/isl/aclocal.m4
+++ b/lib/Analysis/isl/aclocal.m4
@@ -1156,6 +1156,9 @@ m4_include([m4/ax_check_compiler_flags.m4])
 m4_include([m4/ax_compiler_vendor.m4])
 m4_include([m4/ax_create_pkgconfig_info.m4])
 m4_include([m4/ax_create_stdint_h.m4])
+m4_include([m4/ax_cxx_compile_stdcxx.m4])
+m4_include([m4/ax_cxx_compile_stdcxx_11.m4])
+m4_include([m4/ax_detect_clang.m4])
 m4_include([m4/ax_detect_git_head.m4])
 m4_include([m4/ax_detect_gmp.m4])
 m4_include([m4/ax_detect_imath.m4])
diff --git a/lib/Analysis/isl/basis_reduction_templ.c b/lib/Analysis/isl/basis_reduction_templ.c
index 4ce2d78..a5da1e6 100644
--- a/lib/Analysis/isl/basis_reduction_templ.c
+++ b/lib/Analysis/isl/basis_reduction_templ.c
@@ -314,7 +314,7 @@ error:
  * basis with the equalities first.  Otherwise, we start off with
  * the identity matrix.
  */
-struct isl_mat *isl_basic_set_reduced_basis(struct isl_basic_set *bset)
+__isl_give isl_mat *isl_basic_set_reduced_basis(__isl_keep isl_basic_set *bset)
 {
 	struct isl_mat *basis;
 	struct isl_tab *tab;
diff --git a/lib/Analysis/isl/bound.c b/lib/Analysis/isl/bound.c
index e0eeaa8..00b643d 100644
--- a/lib/Analysis/isl/bound.c
+++ b/lib/Analysis/isl/bound.c
@@ -61,7 +61,6 @@ struct verify_point_bound {
 static isl_stat verify_point(__isl_take isl_point *pnt, void *user)
 {
 	int i;
-	unsigned nvar;
 	unsigned nparam;
 	struct verify_point_bound *vpb = (struct verify_point_bound *) user;
 	isl_int t;
@@ -72,7 +71,7 @@ static isl_stat verify_point(__isl_take isl_point *pnt, void *user)
 	isl_set *dom = NULL;
 	isl_printer *p;
 	const char *minmax;
-	int bounded;
+	isl_bool bounded;
 	int sign;
 	int ok;
 	FILE *out = vpb->options->print_all ? stdout : stderr;
@@ -119,7 +118,6 @@ static isl_stat verify_point(__isl_take isl_point *pnt, void *user)
 	else
 		opt = isl_pw_qpolynomial_fold_min(isl_pw_qpolynomial_fold_copy(pwf));
 
-	nvar = isl_set_dim(dom, isl_dim_set);
 	if (vpb->exact && bounded)
 		ok = isl_val_eq(opt, bound);
 	else if (sign > 0)
diff --git a/lib/Analysis/isl/bound_test.sh.in b/lib/Analysis/isl/bound_test.sh.in
index e3fc037..8f2f1ff 100755
--- a/lib/Analysis/isl/bound_test.sh.in
+++ b/lib/Analysis/isl/bound_test.sh.in
@@ -1,6 +1,7 @@
 #!/bin/sh
 
 EXEEXT=@EXEEXT@
+srcdir=@srcdir@
 
 BOUND_TESTS="\
 	basicLinear2.pwqp \
diff --git a/lib/Analysis/isl/bset_from_bmap.c b/lib/Analysis/isl/bset_from_bmap.c
new file mode 100644
index 0000000..9585080
--- /dev/null
+++ b/lib/Analysis/isl/bset_from_bmap.c
@@ -0,0 +1,8 @@
+#include <isl/map_type.h>
+
+/* Return the basic set that was treated as the basic map "bmap".
+ */
+static __isl_give isl_basic_set *bset_from_bmap(__isl_take isl_basic_map *bmap)
+{
+	return (isl_basic_set *) bmap;
+}
diff --git a/lib/Analysis/isl/bset_to_bmap.c b/lib/Analysis/isl/bset_to_bmap.c
new file mode 100644
index 0000000..874fe71
--- /dev/null
+++ b/lib/Analysis/isl/bset_to_bmap.c
@@ -0,0 +1,10 @@
+#include <isl/map_type.h>
+
+/* Treat "bset" as a basic map.
+ * Internally, isl_basic_set is defined to isl_basic_map, so in practice,
+ * this function performs a redundant cast.
+ */
+static __isl_give isl_basic_map *bset_to_bmap(__isl_take isl_basic_set *bset)
+{
+	return (isl_basic_map *) bset;
+}
diff --git a/lib/Analysis/isl/config.guess b/lib/Analysis/isl/config.guess
index 1f5c50c..0967f2a 100755
--- a/lib/Analysis/isl/config.guess
+++ b/lib/Analysis/isl/config.guess
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2014 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2014-03-23'
+timestamp='2016-04-02'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -24,12 +24,12 @@ timestamp='2014-03-23'
 # program.  This Exception is an additional permission under section 7
 # of the GNU General Public License, version 3 ("GPLv3").
 #
-# Originally written by Per Bothner.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 #
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 
 
 me=`echo "$0" | sed -e 's,.*/,,'`
@@ -50,7 +50,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2014 Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -168,20 +168,27 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
+	    echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
 	case "${UNAME_MACHINE_ARCH}" in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+	    arm*|earm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
@@ -197,6 +204,13 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
@@ -207,13 +221,13 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "${machine}-${os}${release}${abi}"
 	exit ;;
     *:Bitrig:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
@@ -223,6 +237,10 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-libertybsd${UNAME_RELEASE}
+	exit ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
 	exit ;;
@@ -235,6 +253,9 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:MirBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
 	exit ;;
+    *:Sortix:*:*)
+	echo ${UNAME_MACHINE}-unknown-sortix
+	exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -251,42 +272,42 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
@@ -359,16 +380,16 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
 	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
@@ -393,7 +414,7 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	test "x${UNAME_RELEASE}" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
@@ -579,8 +600,9 @@ EOF
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
@@ -617,13 +639,13 @@ EOF
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
 		    case "${sc_cpu_version}" in
-		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
 			case "${sc_kernel_bits}" in
-			  32) HP_ARCH="hppa2.0n" ;;
-			  64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
@@ -662,11 +684,11 @@ EOF
 		    exit (0);
 		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if [ ${HP_ARCH} = hppa2.0w ]
 	then
 	    eval $set_cc_for_build
 
@@ -679,12 +701,12 @@ EOF
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
 		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
@@ -789,14 +811,14 @@ EOF
 	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
 	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
@@ -878,7 +900,7 @@ EOF
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
@@ -901,7 +923,7 @@ EOF
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arc:Linux:*:* | arceb:Linux:*:*)
@@ -932,6 +954,9 @@ EOF
     crisv32:Linux:*:*)
 	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
+    e2k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     frv:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
@@ -944,6 +969,9 @@ EOF
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
+    k1om:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     m32r*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
@@ -1020,7 +1048,7 @@ EOF
 	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
@@ -1099,7 +1127,7 @@ EOF
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
 	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
+	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
 	exit ;;
@@ -1248,6 +1276,9 @@ EOF
     SX-8R:SUPER-UX:*:*)
 	echo sx8r-nec-superux${UNAME_RELEASE}
 	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
@@ -1261,9 +1292,9 @@ EOF
 	    UNAME_PROCESSOR=powerpc
 	fi
 	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
-	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		    grep IS_64BIT_ARCH >/dev/null
 		then
 		    case $UNAME_PROCESSOR in
@@ -1285,7 +1316,7 @@ EOF
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
@@ -1316,7 +1347,7 @@ EOF
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
@@ -1358,7 +1389,7 @@ EOF
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE} | sed -e 's/ .*$//'`
 	exit ;;
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
@@ -1369,6 +1400,9 @@ EOF
     x86_64:VMkernel:*:*)
 	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
+	exit ;;
 esac
 
 cat >&2 <<EOF
@@ -1378,9 +1412,9 @@ This script, last modified $timestamp, has failed to recognize
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
diff --git a/lib/Analysis/isl/config.sub b/lib/Analysis/isl/config.sub
index bba4efb..8d39c4b 100755
--- a/lib/Analysis/isl/config.sub
+++ b/lib/Analysis/isl/config.sub
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2014 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2014-09-11'
+timestamp='2016-03-30'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@ timestamp='2014-09-11'
 # of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -33,7 +33,7 @@ timestamp='2014-09-11'
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
@@ -53,8 +53,7 @@ timestamp='2014-09-11'
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
 
 Canonicalize a configuration name.
 
@@ -68,7 +67,7 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2014 Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -117,7 +116,7 @@ maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
-  knetbsd*-gnu* | netbsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
   kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
@@ -255,12 +254,13 @@ case $basic_machine in
 	| arc | arceb \
 	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
 	| avr | avr32 \
+	| ba \
 	| be32 | be64 \
 	| bfin \
 	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| epiphany \
-	| fido | fr30 | frv \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
 	| i370 | i860 | i960 | ia64 \
@@ -305,7 +305,7 @@ case $basic_machine in
 	| riscv32 | riscv64 \
 	| rl78 | rx \
 	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
@@ -313,6 +313,7 @@ case $basic_machine in
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -327,6 +328,9 @@ case $basic_machine in
 	c6x)
 		basic_machine=tic6x-unknown
 		;;
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
 	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -372,12 +376,13 @@ case $basic_machine in
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| ba-* \
 	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
 	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
+	| e2k-* | elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
@@ -424,12 +429,13 @@ case $basic_machine in
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
+	| riscv32-* | riscv64-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
 	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tile*-* \
@@ -437,6 +443,7 @@ case $basic_machine in
 	| ubicom32-* \
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
+	| visium-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -513,6 +520,9 @@ case $basic_machine in
 		basic_machine=i386-pc
 		os=-aros
 		;;
+	asmjs)
+		basic_machine=asmjs-unknown
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -774,6 +784,9 @@ case $basic_machine in
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
@@ -1365,11 +1378,11 @@ case $os in
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
 	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
+	      | -aos* | -aros* | -cloudabi* | -sortix* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -bitrig* | -openbsd* | -solidbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
@@ -1385,7 +1398,8 @@ case $os in
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \
+	      | -onefs* | -tirtos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1517,6 +1531,8 @@ case $os in
 		;;
 	-nacl*)
 		;;
+	-ios)
+		;;
 	-none)
 		;;
 	*)
diff --git a/lib/Analysis/isl/configure b/lib/Analysis/isl/configure
index 893b4c2..d208abc 100755
--- a/lib/Analysis/isl/configure
+++ b/lib/Analysis/isl/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for isl 0.17.1.
+# Generated by GNU Autoconf 2.69 for isl 0.18.
 #
 # Report bugs to <isl-development@googlegroups.com>.
 #
@@ -198,6 +198,7 @@ test -x / || exit 1"
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
   test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1
 
   test -n \"\${ZSH_VERSION+set}\${BASH_VERSION+set}\" || (
     ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
@@ -205,8 +206,7 @@ test -x / || exit 1"
     ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
     PATH=/empty FPATH=/empty; export PATH FPATH
     test \"X\`printf %s \$ECHO\`\" = \"X\$ECHO\" \\
-      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1
-test \$(( 1 + 1 )) = 2 || exit 1"
+      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1"
   if (eval "$as_required") 2>/dev/null; then :
   as_have_required=yes
 else
@@ -590,8 +590,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='isl'
 PACKAGE_TARNAME='isl'
-PACKAGE_VERSION='0.17.1'
-PACKAGE_STRING='isl 0.17.1'
+PACKAGE_VERSION='0.18'
+PACKAGE_STRING='isl 0.18'
 PACKAGE_BUGREPORT='isl-development@googlegroups.com'
 PACKAGE_URL=''
 
@@ -650,6 +650,8 @@ CLANG_LDFLAGS
 CLANG_CXXFLAGS
 SMALL_INT_OPT_FALSE
 SMALL_INT_OPT_TRUE
+HAVE_CXX11_FALSE
+HAVE_CXX11_TRUE
 GMP_FOR_MP_FALSE
 GMP_FOR_MP_TRUE
 IMATH_FOR_MP_FALSE
@@ -666,6 +668,7 @@ PDFLATEX
 PERL
 CXXCPP
 CPP
+LT_SYS_LIBRARY_PATH
 OTOOL64
 OTOOL
 LIPO
@@ -684,9 +687,11 @@ DUMPBIN
 LD
 FGREP
 EGREP
-GREP
 SED
 LIBTOOL
+GREP
+HAVE_CXX11
+CXX11FLAGS
 PRTDIAG
 host_os
 host_vendor
@@ -766,6 +771,7 @@ infodir
 docdir
 oldincludedir
 includedir
+runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
@@ -796,6 +802,7 @@ enable_shared
 enable_static
 with_pic
 enable_fast_install
+with_aix_soname
 with_gnu_ld
 with_sysroot
 enable_libtool_lock
@@ -819,6 +826,7 @@ CPPFLAGS
 CXX
 CXXFLAGS
 CCC
+LT_SYS_LIBRARY_PATH
 CPP
 CXXCPP'
 
@@ -859,6 +867,7 @@ datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1111,6 +1120,15 @@ do
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
@@ -1248,7 +1266,7 @@ fi
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+		libdir localedir mandir runstatedir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
@@ -1361,7 +1379,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures isl 0.17.1 to adapt to many kinds of systems.
+\`configure' configures isl 0.18 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1401,6 +1419,7 @@ Fine tuning of the installation directories:
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
@@ -1431,7 +1450,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of isl 0.17.1:";;
+     short | recursive ) echo "Configuration of isl 0.18:";;
    esac
   cat <<\_ACEOF
 
@@ -1461,9 +1480,12 @@ Optional Packages:
                           instead of guessing
   --with-pic[=PKGS]       try to use only PIC/non-PIC objects [default=use
                           both]
+  --with-aix-soname=aix|svr4|both
+                          shared library versioning (aka "SONAME") variant to
+                          provide on AIX, [default=aix].
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
-  --with-sysroot=DIR Search for dependent libraries within DIR
-                        (or the compiler's sysroot if not specified).
+  --with-sysroot[=DIR]    Search for dependent libraries within DIR (or the
+                          compiler's sysroot if not specified).
   --with-int=gmp|imath|imath-32
                           Which package to use to represent multi-precision
                           integers [default=gmp]
@@ -1487,6 +1509,8 @@ Some influential environment variables:
               you have headers in a nonstandard directory <include dir>
   CXX         C++ compiler command
   CXXFLAGS    C++ compiler flags
+  LT_SYS_LIBRARY_PATH
+              User-defined run-time library search path.
   CPP         C preprocessor
   CXXCPP      C++ preprocessor
 
@@ -1556,7 +1580,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-isl configure 0.17.1
+isl configure 0.18
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -2416,11 +2440,42 @@ fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_cxx_check_header_mongrel
+
+# ac_fn_cxx_check_header_compile LINENO HEADER VAR INCLUDES
+# ---------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_cxx_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_cxx_check_header_compile
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by isl $as_me 0.17.1, which was
+It was created by isl $as_me 0.18, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -3284,7 +3339,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='isl'
- VERSION='0.17.1'
+ VERSION='0.18'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -3417,7 +3472,7 @@ fi
 AM_BACKSLASH='\'
 
 
-versioninfo=17:1:2
+versioninfo=18:0:3
 
 if test "x$prefix" != "xNONE"; then
 	prefix_wd=`cd $prefix && pwd`
@@ -5870,203 +5925,703 @@ $as_echo "#define HAVE___ATTRIBUTE__ 1" >>confdefs.h
   fi
 
 
-case `pwd` in
-  *\ * | *\	*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
-$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
-esac
+# CXX11FLAGS contains the flags (if any) added by AX_CXX_COMPILE_STDCXX_11
+# Original state of CXX and CXXCPP is preserved because CXX11FLAGS
+# is only needed for compiling interface/isl_test_cpp
 
+ac_save_CXX="$CXX"
+ac_save_CXXCPP="$CXXCPP"
 
+  ax_cxx_compile_alternatives="11 0x"    ax_cxx_compile_cxx11_required=false
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+  ac_success=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features by default" >&5
+$as_echo_n "checking whether $CXX supports C++11 features by default... " >&6; }
+if ${ax_cv_cxx_compile_cxx11+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-macro_version='2.4.2'
-macro_revision='1.3337'
 
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
 
+#ifndef __cplusplus
 
+#error "This is not a C++ compiler"
 
+#elif __cplusplus < 201103L
 
+#error "This is not a C++11 compiler"
 
+#else
 
+namespace cxx11
+{
 
+  namespace test_static_assert
+  {
 
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
 
+  }
 
+  namespace test_final_override
+  {
 
+    struct Base
+    {
+      virtual void f() {}
+    };
 
-ltmain="$ac_aux_dir/ltmain.sh"
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
 
-# Backslashify metacharacters that are still active within
-# double-quoted strings.
-sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+  }
 
-# Same as above, but do not quote variable references.
-double_quote_subst='s/\(["`\\]\)/\\\1/g'
+  namespace test_double_right_angle_brackets
+  {
 
-# Sed substitution to delay expansion of an escaped shell variable in a
-# double_quote_subst'ed string.
-delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+    template < typename T >
+    struct check {};
 
-# Sed substitution to delay expansion of an escaped single quote.
-delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
 
-# Sed substitution to avoid accidental globbing in evaled expressions
-no_glob_subst='s/\*/\\\*/g'
+  }
 
-ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+  namespace test_decltype
+  {
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
-$as_echo_n "checking how to print strings... " >&6; }
-# Test print first, because it will be a builtin if present.
-if test "X`( print -r -- -n ) 2>/dev/null`" = X-n && \
-   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='print -r --'
-elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='printf %s\n'
-else
-  # Use this function as a fallback that always works.
-  func_fallback_echo ()
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
   {
-    eval 'cat <<_LTECHO_EOF
-$1
-_LTECHO_EOF'
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
   }
-  ECHO='func_fallback_echo'
-fi
 
-# func_echo_all arg...
-# Invoke $ECHO with all args, space-separated.
-func_echo_all ()
-{
-    $ECHO ""
-}
+  namespace test_noexcept
+  {
 
-case "$ECHO" in
-  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
-$as_echo "printf" >&6; } ;;
-  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
-$as_echo "print -r" >&6; } ;;
-  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
-$as_echo "cat" >&6; } ;;
-esac
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
 
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
 
+  }
 
+  namespace test_rvalue_references
+  {
 
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
 
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
 
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
 
+  }
 
+  namespace test_uniform_initialization
+  {
 
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
 
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
 
+  }
 
+  namespace test_lambdas
+  {
 
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
-$as_echo_n "checking for a sed that does not truncate output... " >&6; }
-if ${ac_cv_path_SED+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
-     for ac_i in 1 2 3 4 5 6 7; do
-       ac_script="$ac_script$as_nl$ac_script"
-     done
-     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
-     { ac_script=; unset ac_script;}
-     if test -z "$SED"; then
-  ac_path_SED_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in sed gsed; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
-      as_fn_executable_p "$ac_path_SED" || continue
-# Check for GNU ac_path_SED and select it if it is found.
-  # Check for GNU $ac_path_SED
-case `"$ac_path_SED" --version 2>&1` in
-*GNU*)
-  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo '' >> "conftest.nl"
-    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_SED_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_SED="$ac_path_SED"
-      ac_path_SED_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
 
-      $ac_path_SED_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_SED"; then
-    as_fn_error $? "no acceptable sed could be found in \$PATH" "$LINENO" 5
-  fi
-else
-  ac_cv_path_SED=$SED
-fi
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
-$as_echo "$ac_cv_path_SED" >&6; }
- SED="$ac_cv_path_SED"
-  rm -f conftest.sed
+  }
 
-test -z "$SED" && SED=sed
-Xsed="$SED -e 1s/^X//"
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
 
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
 
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
 
+  }
 
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
 
+    struct foo {};
 
+    template<typename T>
+    using member = typename T::member_type;
 
+    template<typename T>
+    void func(...) {}
 
+    template<typename T>
+    void func(member<T>*) {}
 
+    void test();
 
+    void test() { func<foo>(0); }
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if ${ac_cv_path_GREP+:} false; then :
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+
+
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ax_cv_cxx_compile_cxx11=yes
+else
+  ax_cv_cxx_compile_cxx11=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx11" >&5
+$as_echo "$ax_cv_cxx_compile_cxx11" >&6; }
+  if test x$ax_cv_cxx_compile_cxx11 = xyes; then
+    ac_success=yes
+  fi
+
+
+
+    if test x$ac_success = xno; then
+                for alternative in ${ax_cxx_compile_alternatives}; do
+      for switch in -std=c++${alternative} +std=c++${alternative} "-h std=c++${alternative}"; do
+        cachevar=`$as_echo "ax_cv_cxx_compile_cxx11_$switch" | $as_tr_sh`
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch" >&5
+$as_echo_n "checking whether $CXX supports C++11 features with $switch... " >&6; }
+if eval \${$cachevar+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      as_fn_executable_p "$ac_path_GREP" || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
+  ac_save_CXX="$CXX"
+           CXX="$CXX $switch"
+           cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+
+
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  eval $cachevar=yes
+else
+  eval $cachevar=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+           CXX="$ac_save_CXX"
+fi
+eval ac_res=\$$cachevar
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+        if eval test x\$$cachevar = xyes; then
+          CXX="$CXX $switch"
+          if test -n "$CXXCPP" ; then
+            CXXCPP="$CXXCPP $switch"
+          fi
+          ac_success=yes
+          break
+        fi
+      done
+      if test x$ac_success = xyes; then
+        break
+      fi
+    done
+  fi
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+  if test x$ax_cxx_compile_cxx11_required = xtrue; then
+    if test x$ac_success = xno; then
+      as_fn_error $? "*** A compiler with support for C++11 language features is required." "$LINENO" 5
+    fi
+  fi
+  if test x$ac_success = xno; then
+    HAVE_CXX11=0
+    { $as_echo "$as_me:${as_lineno-$LINENO}: No compiler with C++11 support was found" >&5
+$as_echo "$as_me: No compiler with C++11 support was found" >&6;}
+  else
+    HAVE_CXX11=1
+
+$as_echo "#define HAVE_CXX11 1" >>confdefs.h
+
+  fi
+
+
+
+CXX11FLAGS=${CXX#$ac_save_CXX}
+CXX="$ac_save_CXX"
+CXXCPP="$ac_save_CXXCPP"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if ${ac_cv_path_GREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_GREP" || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
   ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
 *)
   ac_count=0
@@ -6109,6 +6664,182 @@ $as_echo "$ac_cv_path_GREP" >&6; }
  GREP="$ac_cv_path_GREP"
 
 
+case `pwd` in
+  *\ * | *\	*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
+esac
+
+
+
+macro_version='2.4.6'
+macro_revision='2.4.6'
+
+
+
+
+
+
+
+
+
+
+
+
+
+ltmain=$ac_aux_dir/ltmain.sh
+
+# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
+$as_echo_n "checking how to print strings... " >&6; }
+# Test print first, because it will be a builtin if present.
+if test "X`( print -r -- -n ) 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO ""
+}
+
+case $ECHO in
+  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
+$as_echo "printf" >&6; } ;;
+  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
+$as_echo "print -r" >&6; } ;;
+  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
+$as_echo "cat" >&6; } ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if ${ac_cv_path_SED+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_SED" || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error $? "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
+else
+  ac_cv_path_SED=$SED
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+
+
+
+
+
+
+
+
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
 $as_echo_n "checking for egrep... " >&6; }
 if ${ac_cv_path_EGREP+:} false; then :
@@ -6265,19 +6996,19 @@ test -z "$GREP" && GREP=grep
 
 # Check whether --with-gnu-ld was given.
 if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+  withval=$with_gnu_ld; test no = "$withval" || with_gnu_ld=yes
 else
   with_gnu_ld=no
 fi
 
 ac_prog=ld
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   # Check if gcc -print-prog-name=ld gives a path.
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
   *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
+    # gcc leaves a trailing carriage return, which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
     ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
@@ -6291,7 +7022,7 @@ $as_echo_n "checking for ld used by $CC... " >&6; }
       while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
 	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
       done
-      test -z "$LD" && LD="$ac_prog"
+      test -z "$LD" && LD=$ac_prog
       ;;
   "")
     # If it fails, then pretend we aren't using GCC.
@@ -6302,7 +7033,7 @@ $as_echo_n "checking for ld used by $CC... " >&6; }
     with_gnu_ld=unknown
     ;;
   esac
-elif test "$with_gnu_ld" = yes; then
+elif test yes = "$with_gnu_ld"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
 $as_echo_n "checking for GNU ld... " >&6; }
 else
@@ -6313,32 +7044,32 @@ if ${lt_cv_path_LD+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
   for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
     test -z "$ac_dir" && ac_dir=.
     if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
+      lt_cv_path_LD=$ac_dir/$ac_prog
       # Check to see if the program is GNU ld.  I'd rather use --version,
       # but apparently some variants of GNU ld only accept -v.
       # Break only if it was the GNU/non-GNU ld that we prefer.
       case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
       *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
+	test no != "$with_gnu_ld" && break
 	;;
       *)
-	test "$with_gnu_ld" != yes && break
+	test yes != "$with_gnu_ld" && break
 	;;
       esac
     fi
   done
-  IFS="$lt_save_ifs"
+  IFS=$lt_save_ifs
 else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+  lt_cv_path_LD=$LD # Let the user override the test with a path.
 fi
 fi
 
-LD="$lt_cv_path_LD"
+LD=$lt_cv_path_LD
 if test -n "$LD"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
 $as_echo "$LD" >&6; }
@@ -6381,33 +7112,38 @@ if ${lt_cv_path_NM+:} false; then :
 else
   if test -n "$NM"; then
   # Let the user override the test.
-  lt_cv_path_NM="$NM"
+  lt_cv_path_NM=$NM
 else
-  lt_nm_to_check="${ac_tool_prefix}nm"
+  lt_nm_to_check=${ac_tool_prefix}nm
   if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
     lt_nm_to_check="$lt_nm_to_check nm"
   fi
   for lt_tmp_nm in $lt_nm_to_check; do
-    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
     for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       test -z "$ac_dir" && ac_dir=.
-      tmp_nm="$ac_dir/$lt_tmp_nm"
-      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+      tmp_nm=$ac_dir/$lt_tmp_nm
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext"; then
 	# Check to see if the nm accepts a BSD-compat flag.
-	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	# Adding the 'sed 1q' prevents false positives on HP-UX, which says:
 	#   nm: unknown option "B" ignored
 	# Tru64's nm complains that /dev/null is an invalid object file
-	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
-	*/dev/null* | *'Invalid file or object type'*)
+	# MSYS converts /dev/null to NUL, MinGW nm treats NUL as empty
+	case $build_os in
+	mingw*) lt_bad_file=conftest.nm/nofile ;;
+	*) lt_bad_file=/dev/null ;;
+	esac
+	case `"$tmp_nm" -B $lt_bad_file 2>&1 | sed '1q'` in
+	*$lt_bad_file* | *'Invalid file or object type'*)
 	  lt_cv_path_NM="$tmp_nm -B"
-	  break
+	  break 2
 	  ;;
 	*)
 	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
 	  */dev/null*)
 	    lt_cv_path_NM="$tmp_nm -p"
-	    break
+	    break 2
 	    ;;
 	  *)
 	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
@@ -6418,15 +7154,15 @@ else
 	esac
       fi
     done
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
   done
   : ${lt_cv_path_NM=no}
 fi
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
 $as_echo "$lt_cv_path_NM" >&6; }
-if test "$lt_cv_path_NM" != "no"; then
-  NM="$lt_cv_path_NM"
+if test no != "$lt_cv_path_NM"; then
+  NM=$lt_cv_path_NM
 else
   # Didn't find any BSD compatible name lister, look for dumpbin.
   if test -n "$DUMPBIN"; then :
@@ -6532,9 +7268,9 @@ esac
   fi
 fi
 
-    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    case `$DUMPBIN -symbols -headers /dev/null 2>&1 | sed '1q'` in
     *COFF*)
-      DUMPBIN="$DUMPBIN -symbols"
+      DUMPBIN="$DUMPBIN -symbols -headers"
       ;;
     *)
       DUMPBIN=:
@@ -6542,8 +7278,8 @@ fi
     esac
   fi
 
-  if test "$DUMPBIN" != ":"; then
-    NM="$DUMPBIN"
+  if test : != "$DUMPBIN"; then
+    NM=$DUMPBIN
   fi
 fi
 test -z "$NM" && NM=nm
@@ -6594,7 +7330,7 @@ if ${lt_cv_sys_max_cmd_len+:} false; then :
   $as_echo_n "(cached) " >&6
 else
     i=0
-  teststring="ABCD"
+  teststring=ABCD
 
   case $build_os in
   msdosdjgpp*)
@@ -6634,7 +7370,7 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+  bitrig* | darwin* | dragonfly* | freebsd* | netbsd* | openbsd*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
       lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
@@ -6685,22 +7421,22 @@ else
   *)
     lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
     if test -n "$lt_cv_sys_max_cmd_len" && \
-	test undefined != "$lt_cv_sys_max_cmd_len"; then
+       test undefined != "$lt_cv_sys_max_cmd_len"; then
       lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
       lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
     else
       # Make teststring a little bigger before we do anything with it.
       # a 1K string should be a reasonable start.
-      for i in 1 2 3 4 5 6 7 8 ; do
+      for i in 1 2 3 4 5 6 7 8; do
         teststring=$teststring$teststring
       done
       SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
       # If test is not a shell built-in, we'll probably end up computing a
       # maximum length that is only half of the actual maximum length, but
       # we can't tell.
-      while { test "X"`env echo "$teststring$teststring" 2>/dev/null` \
+      while { test X`env echo "$teststring$teststring" 2>/dev/null` \
 	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
-	      test $i != 17 # 1/2 MB should be enough
+	      test 17 != "$i" # 1/2 MB should be enough
       do
         i=`expr $i + 1`
         teststring=$teststring$teststring
@@ -6718,7 +7454,7 @@ else
 
 fi
 
-if test -n $lt_cv_sys_max_cmd_len ; then
+if test -n "$lt_cv_sys_max_cmd_len"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
 $as_echo "$lt_cv_sys_max_cmd_len" >&6; }
 else
@@ -6736,30 +7472,6 @@ max_cmd_len=$lt_cv_sys_max_cmd_len
 : ${MV="mv -f"}
 : ${RM="rm -f"}
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
-$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
-# Try some XSI features
-xsi_shell=no
-( _lt_dummy="a/b/c"
-  test "${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}"${_lt_dummy%"$_lt_dummy"}, \
-      = c,a/b,b/c, \
-    && eval 'test $(( 1 + 1 )) -eq 2 \
-    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
-  && xsi_shell=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
-$as_echo "$xsi_shell" >&6; }
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
-$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
-lt_shell_append=no
-( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
-    >/dev/null 2>&1 \
-  && lt_shell_append=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
-$as_echo "$lt_shell_append" >&6; }
-
-
 if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   lt_unset=unset
 else
@@ -6882,13 +7594,13 @@ esac
 reload_cmds='$LD$reload_flag -o $output$reload_objs'
 case $host_os in
   cygwin* | mingw* | pw32* | cegcc*)
-    if test "$GCC" != yes; then
+    if test yes != "$GCC"; then
       reload_cmds=false
     fi
     ;;
   darwin*)
-    if test "$GCC" = yes; then
-      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    if test yes = "$GCC"; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib $wl-r -o $output$reload_objs'
     else
       reload_cmds='$LD$reload_flag -o $output$reload_objs'
     fi
@@ -7016,13 +7728,13 @@ lt_cv_deplibs_check_method='unknown'
 # Need to set the preceding variable on all platforms that support
 # interlibrary dependencies.
 # 'none' -- dependencies not supported.
-# `unknown' -- same as none, but documents that we really don't know.
+# 'unknown' -- same as none, but documents that we really don't know.
 # 'pass_all' -- all dependencies passed with no checks.
 # 'test_compile' -- check by making test program.
 # 'file_magic [[regex]]' -- check by looking for files in library path
-# which responds to the $file_magic_cmd with a given extended regex.
-# If you have `file' or equivalent on your system and you're not sure
-# whether `pass_all' will *always* work, you probably want this one.
+# that responds to the $file_magic_cmd with a given extended regex.
+# If you have 'file' or equivalent on your system and you're not sure
+# whether 'pass_all' will *always* work, you probably want this one.
 
 case $host_os in
 aix[4-9]*)
@@ -7049,8 +7761,7 @@ mingw* | pw32*)
   # Base MSYS/MinGW do not provide the 'file' command needed by
   # func_win32_libid shell function, so use a weaker test based on 'objdump',
   # unless we find 'file', for example because we are cross-compiling.
-  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
-  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+  if ( file / ) >/dev/null 2>&1; then
     lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
     lt_cv_file_magic_cmd='func_win32_libid'
   else
@@ -7146,8 +7857,8 @@ newos6*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-openbsd*)
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+openbsd* | bitrig*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`"; then
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
   else
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
@@ -7200,6 +7911,9 @@ sysv4 | sysv4.3*)
 tpf*)
   lt_cv_deplibs_check_method=pass_all
   ;;
+os2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 esac
 
 fi
@@ -7357,8 +8071,8 @@ else
 
 case $host_os in
 cygwin* | mingw* | pw32* | cegcc*)
-  # two different shell functions defined in ltmain.sh
-  # decide which to use based on capabilities of $DLLTOOL
+  # two different shell functions defined in ltmain.sh;
+  # decide which one to use based on capabilities of $DLLTOOL
   case `$DLLTOOL --help 2>&1` in
   *--identify-strict*)
     lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib
@@ -7370,7 +8084,7 @@ cygwin* | mingw* | pw32* | cegcc*)
   ;;
 *)
   # fallback: assume linklib IS sharedlib
-  lt_cv_sharedlib_from_linklib_cmd="$ECHO"
+  lt_cv_sharedlib_from_linklib_cmd=$ECHO
   ;;
 esac
 
@@ -7524,7 +8238,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
-      if test "$ac_status" -eq 0; then
+      if test 0 -eq "$ac_status"; then
 	# Ensure the archiver fails upon bogus file names.
 	rm -f conftest.$ac_objext libconftest.a
 	{ { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$lt_ar_try\""; } >&5
@@ -7532,7 +8246,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
-	if test "$ac_status" -ne 0; then
+	if test 0 -ne "$ac_status"; then
           lt_cv_ar_at_file=@
         fi
       fi
@@ -7545,7 +8259,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ar_at_file" >&5
 $as_echo "$lt_cv_ar_at_file" >&6; }
 
-if test "x$lt_cv_ar_at_file" = xno; then
+if test no = "$lt_cv_ar_at_file"; then
   archiver_list_spec=
 else
   archiver_list_spec=$lt_cv_ar_at_file
@@ -7762,7 +8476,7 @@ old_postuninstall_cmds=
 
 if test -n "$RANLIB"; then
   case $host_os in
-  openbsd*)
+  bitrig* | openbsd*)
     old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$tool_oldlib"
     ;;
   *)
@@ -7852,7 +8566,7 @@ cygwin* | mingw* | pw32* | cegcc*)
   symcode='[ABCDGISTW]'
   ;;
 hpux*)
-  if test "$host_cpu" = ia64; then
+  if test ia64 = "$host_cpu"; then
     symcode='[ABCDEGRST]'
   fi
   ;;
@@ -7885,14 +8599,44 @@ case `$NM -V 2>&1` in
   symcode='[ABCDGIRSTW]' ;;
 esac
 
+if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+  # Gets list of data symbols to import.
+  lt_cv_sys_global_symbol_to_import="sed -n -e 's/^I .* \(.*\)$/\1/p'"
+  # Adjust the below global symbol transforms to fixup imported variables.
+  lt_cdecl_hook=" -e 's/^I .* \(.*\)$/extern __declspec(dllimport) char \1;/p'"
+  lt_c_name_hook=" -e 's/^I .* \(.*\)$/  {\"\1\", (void *) 0},/p'"
+  lt_c_name_lib_hook="\
+  -e 's/^I .* \(lib.*\)$/  {\"\1\", (void *) 0},/p'\
+  -e 's/^I .* \(.*\)$/  {\"lib\1\", (void *) 0},/p'"
+else
+  # Disable hooks by default.
+  lt_cv_sys_global_symbol_to_import=
+  lt_cdecl_hook=
+  lt_c_name_hook=
+  lt_c_name_lib_hook=
+fi
+
 # Transform an extracted symbol line into a proper C declaration.
 # Some systems (esp. on ia64) link data and code symbols differently,
 # so use this general approach.
-lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+lt_cv_sys_global_symbol_to_cdecl="sed -n"\
+$lt_cdecl_hook\
+" -e 's/^T .* \(.*\)$/extern int \1();/p'"\
+" -e 's/^$symcode$symcode* .* \(.*\)$/extern char \1;/p'"
 
 # Transform an extracted symbol line into symbol name and symbol address
-lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\)[ ]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\)[ ]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address="sed -n"\
+$lt_c_name_hook\
+" -e 's/^: \(.*\) .*$/  {\"\1\", (void *) 0},/p'"\
+" -e 's/^$symcode$symcode* .* \(.*\)$/  {\"\1\", (void *) \&\1},/p'"
+
+# Transform an extracted symbol line into symbol name with lib prefix and
+# symbol address.
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n"\
+$lt_c_name_lib_hook\
+" -e 's/^: \(.*\) .*$/  {\"\1\", (void *) 0},/p'"\
+" -e 's/^$symcode$symcode* .* \(lib.*\)$/  {\"\1\", (void *) \&\1},/p'"\
+" -e 's/^$symcode$symcode* .* \(.*\)$/  {\"lib\1\", (void *) \&\1},/p'"
 
 # Handle CRLF in mingw tool chain
 opt_cr=
@@ -7910,21 +8654,24 @@ for ac_symprfx in "" "_"; do
 
   # Write the raw and C identifiers.
   if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-    # Fake it for dumpbin and say T for any non-static function
-    # and D for any global variable.
+    # Fake it for dumpbin and say T for any non-static function,
+    # D for any global variable and I for any imported variable.
     # Also find C++ and __fastcall symbols from MSVC++,
     # which start with @ or ?.
     lt_cv_sys_global_symbol_pipe="$AWK '"\
 "     {last_section=section; section=\$ 3};"\
 "     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};"\
 "     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     /^ *Symbol name *: /{split(\$ 0,sn,\":\"); si=substr(sn[2],2)};"\
+"     /^ *Type *: code/{print \"T\",si,substr(si,length(prfx))};"\
+"     /^ *Type *: data/{print \"I\",si,substr(si,length(prfx))};"\
 "     \$ 0!~/External *\|/{next};"\
 "     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
 "     {if(hide[section]) next};"\
-"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
-"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
-"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
-"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     {f=\"D\"}; \$ 0~/\(\).*\|/{f=\"T\"};"\
+"     {split(\$ 0,a,/\||\r/); split(a[2],s)};"\
+"     s[1]~/^[@?]/{print f,s[1],s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print f,t[1],substr(t[1],length(prfx))}"\
 "     ' prfx=^$ac_symprfx"
   else
     lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
@@ -7972,11 +8719,11 @@ _LT_EOF
 	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
 	  cat <<_LT_EOF > conftest.$ac_ext
 /* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
-#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
-/* DATA imports from DLLs on WIN32 con't be const, because runtime
+#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE
+/* DATA imports from DLLs on WIN32 can't be const, because runtime
    relocations are performed -- see ld's documentation on pseudo-relocs.  */
 # define LT_DLSYM_CONST
-#elif defined(__osf__)
+#elif defined __osf__
 /* This system does not cope well with relocations in const data.  */
 # define LT_DLSYM_CONST
 #else
@@ -8002,7 +8749,7 @@ lt__PROGRAM__LTX_preloaded_symbols[] =
 {
   { "@PROGRAM@", (void *) 0 },
 _LT_EOF
-	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  $SED "s/^$symcode$symcode* .* \(.*\)$/  {\"\1\", (void *) \&\1},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
 	  cat <<\_LT_EOF >> conftest.$ac_ext
   {0, (void *) 0}
 };
@@ -8022,13 +8769,13 @@ _LT_EOF
 	  mv conftest.$ac_objext conftstm.$ac_objext
 	  lt_globsym_save_LIBS=$LIBS
 	  lt_globsym_save_CFLAGS=$CFLAGS
-	  LIBS="conftstm.$ac_objext"
+	  LIBS=conftstm.$ac_objext
 	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
 	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
   (eval $ac_link) 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
+  test $ac_status = 0; } && test -s conftest$ac_exeext; then
 	    pipe_works=yes
 	  fi
 	  LIBS=$lt_globsym_save_LIBS
@@ -8049,7 +8796,7 @@ _LT_EOF
   rm -rf conftest* conftst*
 
   # Do not use the global_symbol_pipe unless it works.
-  if test "$pipe_works" = yes; then
+  if test yes = "$pipe_works"; then
     break
   else
     lt_cv_sys_global_symbol_pipe=
@@ -8102,6 +8849,16 @@ fi
 
 
 
+
+
+
+
+
+
+
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysroot" >&5
 $as_echo_n "checking for sysroot... " >&6; }
 
@@ -8114,9 +8871,9 @@ fi
 
 
 lt_sysroot=
-case ${with_sysroot} in #(
+case $with_sysroot in #(
  yes)
-   if test "$GCC" = yes; then
+   if test yes = "$GCC"; then
      lt_sysroot=`$CC --print-sysroot 2>/dev/null`
    fi
    ;; #(
@@ -8126,8 +8883,8 @@ case ${with_sysroot} in #(
  no|'')
    ;; #(
  *)
-   { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${with_sysroot}" >&5
-$as_echo "${with_sysroot}" >&6; }
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $with_sysroot" >&5
+$as_echo "$with_sysroot" >&6; }
    as_fn_error $? "The sysroot must be an absolute path." "$LINENO" 5
    ;;
 esac
@@ -8139,18 +8896,99 @@ $as_echo "${lt_sysroot:-no}" >&6; }
 
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a working dd" >&5
+$as_echo_n "checking for a working dd... " >&6; }
+if ${ac_cv_path_lt_DD+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  printf 0123456789abcdef0123456789abcdef >conftest.i
+cat conftest.i conftest.i >conftest2.i
+: ${lt_DD:=$DD}
+if test -z "$lt_DD"; then
+  ac_path_lt_DD_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in dd; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_lt_DD="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_lt_DD" || continue
+if "$ac_path_lt_DD" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then
+  cmp -s conftest.i conftest.out \
+  && ac_cv_path_lt_DD="$ac_path_lt_DD" ac_path_lt_DD_found=:
+fi
+      $ac_path_lt_DD_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_lt_DD"; then
+    :
+  fi
+else
+  ac_cv_path_lt_DD=$lt_DD
+fi
+
+rm -f conftest.i conftest2.i conftest.out
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_lt_DD" >&5
+$as_echo "$ac_cv_path_lt_DD" >&6; }
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to truncate binary pipes" >&5
+$as_echo_n "checking how to truncate binary pipes... " >&6; }
+if ${lt_cv_truncate_bin+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  printf 0123456789abcdef0123456789abcdef >conftest.i
+cat conftest.i conftest.i >conftest2.i
+lt_cv_truncate_bin=
+if "$ac_cv_path_lt_DD" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then
+  cmp -s conftest.i conftest.out \
+  && lt_cv_truncate_bin="$ac_cv_path_lt_DD bs=4096 count=1"
+fi
+rm -f conftest.i conftest2.i conftest.out
+test -z "$lt_cv_truncate_bin" && lt_cv_truncate_bin="$SED -e 4q"
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_truncate_bin" >&5
+$as_echo "$lt_cv_truncate_bin" >&6; }
+
+
+
+
+
+
+
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+func_cc_basename ()
+{
+    for cc_temp in $*""; do
+      case $cc_temp in
+        compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+        distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+        \-*) ;;
+        *) break;;
+      esac
+    done
+    func_cc_basename_result=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+}
+
 # Check whether --enable-libtool-lock was given.
 if test "${enable_libtool_lock+set}" = set; then :
   enableval=$enable_libtool_lock;
 fi
 
-test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+test no = "$enable_libtool_lock" || enable_libtool_lock=yes
 
 # Some flags need to be propagated to the compiler or linker for good
 # libtool support.
 case $host in
 ia64-*-hpux*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set mode
+  # options accordingly.
   echo 'int i;' > conftest.$ac_ext
   if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
@@ -8159,24 +8997,25 @@ ia64-*-hpux*)
   test $ac_status = 0; }; then
     case `/usr/bin/file conftest.$ac_objext` in
       *ELF-32*)
-	HPUX_IA64_MODE="32"
+	HPUX_IA64_MODE=32
 	;;
       *ELF-64*)
-	HPUX_IA64_MODE="64"
+	HPUX_IA64_MODE=64
 	;;
     esac
   fi
   rm -rf conftest*
   ;;
 *-*-irix6*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.
   echo '#line '$LINENO' "configure"' > conftest.$ac_ext
   if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
-    if test "$lt_cv_prog_gnu_ld" = yes; then
+    if test yes = "$lt_cv_prog_gnu_ld"; then
       case `/usr/bin/file conftest.$ac_objext` in
 	*32-bit*)
 	  LD="${LD-ld} -melf32bsmip"
@@ -8205,9 +9044,50 @@ ia64-*-hpux*)
   rm -rf conftest*
   ;;
 
+mips64*-*linux*)
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.
+  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    emul=elf
+    case `/usr/bin/file conftest.$ac_objext` in
+      *32-bit*)
+	emul="${emul}32"
+	;;
+      *64-bit*)
+	emul="${emul}64"
+	;;
+    esac
+    case `/usr/bin/file conftest.$ac_objext` in
+      *MSB*)
+	emul="${emul}btsmip"
+	;;
+      *LSB*)
+	emul="${emul}ltsmip"
+	;;
+    esac
+    case `/usr/bin/file conftest.$ac_objext` in
+      *N32*)
+	emul="${emul}n32"
+	;;
+    esac
+    LD="${LD-ld} -m $emul"
+  fi
+  rm -rf conftest*
+  ;;
+
 x86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \
 s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.  Note that the listed cases only cover the
+  # situations where additional linker options are needed (such as when
+  # doing 32-bit compilation for a host where ld defaults to 64-bit, or
+  # vice versa); the common cases where no linker options are needed do
+  # not appear in the list.
   echo 'int i;' > conftest.$ac_ext
   if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
@@ -8230,10 +9110,10 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
 		;;
 	    esac
 	    ;;
-	  powerpc64le-*)
+	  powerpc64le-*linux*)
 	    LD="${LD-ld} -m elf32lppclinux"
 	    ;;
-	  powerpc64-*)
+	  powerpc64-*linux*)
 	    LD="${LD-ld} -m elf32ppclinux"
 	    ;;
 	  s390x-*linux*)
@@ -8252,10 +9132,10 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
 	  x86_64-*linux*)
 	    LD="${LD-ld} -m elf_x86_64"
 	    ;;
-	  powerpcle-*)
+	  powerpcle-*linux*)
 	    LD="${LD-ld} -m elf64lppc"
 	    ;;
-	  powerpc-*)
+	  powerpc-*linux*)
 	    LD="${LD-ld} -m elf64ppc"
 	    ;;
 	  s390*-*linux*|s390*-*tpf*)
@@ -8273,7 +9153,7 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
 
 *-*-sco3.2v5*)
   # On SCO OpenServer 5, we need -belf to get full-featured binaries.
-  SAVE_CFLAGS="$CFLAGS"
+  SAVE_CFLAGS=$CFLAGS
   CFLAGS="$CFLAGS -belf"
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
 $as_echo_n "checking whether the C compiler needs -belf... " >&6; }
@@ -8313,13 +9193,14 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
 $as_echo "$lt_cv_cc_needs_belf" >&6; }
-  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+  if test yes != "$lt_cv_cc_needs_belf"; then
     # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
-    CFLAGS="$SAVE_CFLAGS"
+    CFLAGS=$SAVE_CFLAGS
   fi
   ;;
 *-*solaris*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.
   echo 'int i;' > conftest.$ac_ext
   if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
@@ -8331,7 +9212,7 @@ $as_echo "$lt_cv_cc_needs_belf" >&6; }
       case $lt_cv_prog_gnu_ld in
       yes*)
         case $host in
-        i?86-*-solaris*)
+        i?86-*-solaris*|x86_64-*-solaris*)
           LD="${LD-ld} -m elf_x86_64"
           ;;
         sparc*-*-solaris*)
@@ -8340,7 +9221,7 @@ $as_echo "$lt_cv_cc_needs_belf" >&6; }
         esac
         # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.
         if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then
-          LD="${LD-ld}_sol2"
+          LD=${LD-ld}_sol2
         fi
         ;;
       *)
@@ -8356,7 +9237,7 @@ $as_echo "$lt_cv_cc_needs_belf" >&6; }
   ;;
 esac
 
-need_locks="$enable_libtool_lock"
+need_locks=$enable_libtool_lock
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}mt", so it can be a program name with args.
@@ -8467,7 +9348,7 @@ else
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_mainfest_tool" >&5
 $as_echo "$lt_cv_path_mainfest_tool" >&6; }
-if test "x$lt_cv_path_mainfest_tool" != xyes; then
+if test yes != "$lt_cv_path_mainfest_tool"; then
   MANIFEST_TOOL=:
 fi
 
@@ -8970,7 +9851,7 @@ if ${lt_cv_apple_cc_single_mod+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
+      if test -z "$LT_MULTI_MODULE"; then
 	# By default we will add the -single_module flag. You can override
 	# by either setting the environment variable LT_MULTI_MODULE
 	# non-empty at configure time, or by adding -multi_module to the
@@ -8988,7 +9869,7 @@ else
 	  cat conftest.err >&5
 	# Otherwise, if the output was created with a 0 exit code from
 	# the compiler, it worked.
-	elif test -f libconftest.dylib && test $_lt_result -eq 0; then
+	elif test -f libconftest.dylib && test 0 = "$_lt_result"; then
 	  lt_cv_apple_cc_single_mod=yes
 	else
 	  cat conftest.err >&5
@@ -9027,7 +9908,7 @@ else
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-	LDFLAGS="$save_LDFLAGS"
+	LDFLAGS=$save_LDFLAGS
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
@@ -9056,7 +9937,7 @@ _LT_EOF
       _lt_result=$?
       if test -s conftest.err && $GREP force_load conftest.err; then
 	cat conftest.err >&5
-      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then
+      elif test -f conftest && test 0 = "$_lt_result" && $GREP forced_load conftest >/dev/null 2>&1; then
 	lt_cv_ld_force_load=yes
       else
 	cat conftest.err >&5
@@ -9069,32 +9950,32 @@ fi
 $as_echo "$lt_cv_ld_force_load" >&6; }
     case $host_os in
     rhapsody* | darwin1.[012])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+      _lt_dar_allow_undefined='$wl-undefined ${wl}suppress' ;;
     darwin1.*)
-      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+      _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;
     darwin*) # darwin 5.x on
       # if running on 10.5 or later, the deployment target defaults
       # to the OS version, if on x86, and 10.4, the deployment
       # target defaults to 10.4. Don't you love it?
       case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
 	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-	10.[012]*)
-	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;
+	10.[012][,.]*)
+	  _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;
 	10.*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;
       esac
     ;;
   esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+    if test yes = "$lt_cv_apple_cc_single_mod"; then
       _lt_dar_single_mod='$single_module'
     fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    if test yes = "$lt_cv_ld_exported_symbols_list"; then
+      _lt_dar_export_syms=' $wl-exported_symbols_list,$output_objdir/$libname-symbols.expsym'
     else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/$libname-symbols.expsym $lib'
     fi
-    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+    if test : != "$DSYMUTIL" && test no = "$lt_cv_ld_force_load"; then
       _lt_dsymutil='~$DSYMUTIL $lib || :'
     else
       _lt_dsymutil=
@@ -9102,6 +9983,41 @@ $as_echo "$lt_cv_ld_force_load" >&6; }
     ;;
   esac
 
+# func_munge_path_list VARIABLE PATH
+# -----------------------------------
+# VARIABLE is name of variable containing _space_ separated list of
+# directories to be munged by the contents of PATH, which is string
+# having a format:
+# "DIR[:DIR]:"
+#       string "DIR[ DIR]" will be prepended to VARIABLE
+# ":DIR[:DIR]"
+#       string "DIR[ DIR]" will be appended to VARIABLE
+# "DIRP[:DIRP]::[DIRA:]DIRA"
+#       string "DIRP[ DIRP]" will be prepended to VARIABLE and string
+#       "DIRA[ DIRA]" will be appended to VARIABLE
+# "DIR[:DIR]"
+#       VARIABLE will be replaced by "DIR[ DIR]"
+func_munge_path_list ()
+{
+    case x$2 in
+    x)
+        ;;
+    *:)
+        eval $1=\"`$ECHO $2 | $SED 's/:/ /g'` \$$1\"
+        ;;
+    x:*)
+        eval $1=\"\$$1 `$ECHO $2 | $SED 's/:/ /g'`\"
+        ;;
+    *::*)
+        eval $1=\"\$$1\ `$ECHO $2 | $SED -e 's/.*:://' -e 's/:/ /g'`\"
+        eval $1=\"`$ECHO $2 | $SED -e 's/::.*//' -e 's/:/ /g'`\ \$$1\"
+        ;;
+    *)
+        eval $1=\"`$ECHO $2 | $SED 's/:/ /g'`\"
+        ;;
+    esac
+}
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -9384,12 +10300,11 @@ done
 
 
 
-
 func_stripname_cnf ()
 {
-  case ${2} in
-  .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
-  *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+  case $2 in
+  .*) func_stripname_result=`$ECHO "$3" | $SED "s%^$1%%; s%\\\\$2\$%%"`;;
+  *)  func_stripname_result=`$ECHO "$3" | $SED "s%^$1%%; s%$2\$%%"`;;
   esac
 } # func_stripname_cnf
 
@@ -9416,14 +10331,14 @@ if test "${enable_shared+set}" = set; then :
     *)
       enable_shared=no
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for pkg in $enableval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$pkg" = "X$p"; then
 	  enable_shared=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       ;;
     esac
 else
@@ -9447,14 +10362,14 @@ if test "${enable_static+set}" = set; then :
     *)
      enable_static=no
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for pkg in $enableval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$pkg" = "X$p"; then
 	  enable_static=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       ;;
     esac
 else
@@ -9478,14 +10393,14 @@ if test "${with_pic+set}" = set; then :
     *)
       pic_mode=default
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for lt_pkg in $withval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$lt_pkg" = "X$lt_p"; then
 	  pic_mode=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       ;;
     esac
 else
@@ -9493,8 +10408,6 @@ else
 fi
 
 
-test -z "$pic_mode" && pic_mode=default
-
 
 
 
@@ -9510,20 +10423,72 @@ if test "${enable_fast_install+set}" = set; then :
     *)
       enable_fast_install=no
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for pkg in $enableval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$pkg" = "X$p"; then
 	  enable_fast_install=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
+      ;;
+    esac
+else
+  enable_fast_install=yes
+fi
+
+
+
+
+
+
+
+
+  shared_archive_member_spec=
+case $host,$enable_shared in
+power*-*-aix[5-9]*,yes)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking which variant of shared library versioning to provide" >&5
+$as_echo_n "checking which variant of shared library versioning to provide... " >&6; }
+
+# Check whether --with-aix-soname was given.
+if test "${with_aix_soname+set}" = set; then :
+  withval=$with_aix_soname; case $withval in
+    aix|svr4|both)
+      ;;
+    *)
+      as_fn_error $? "Unknown argument to --with-aix-soname" "$LINENO" 5
       ;;
     esac
+    lt_cv_with_aix_soname=$with_aix_soname
 else
-  enable_fast_install=yes
+  if ${lt_cv_with_aix_soname+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_with_aix_soname=aix
+fi
+
+    with_aix_soname=$lt_cv_with_aix_soname
 fi
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $with_aix_soname" >&5
+$as_echo "$with_aix_soname" >&6; }
+  if test aix != "$with_aix_soname"; then
+    # For the AIX way of multilib, we name the shared archive member
+    # based on the bitwidth used, traditionally 'shr.o' or 'shr_64.o',
+    # and 'shr.imp' or 'shr_64.imp', respectively, for the Import File.
+    # Even when GNU compilers ignore OBJECT_MODE but need '-maix64' flag,
+    # the AIX toolchain works better with OBJECT_MODE set (default 32).
+    if test 64 = "${OBJECT_MODE-32}"; then
+      shared_archive_member_spec=shr_64
+    else
+      shared_archive_member_spec=shr
+    fi
+  fi
+  ;;
+*)
+  with_aix_soname=aix
+  ;;
+esac
 
 
 
@@ -9535,7 +10500,7 @@ fi
 
 
 # This can be used to rebuild libtool when needed
-LIBTOOL_DEPS="$ltmain"
+LIBTOOL_DEPS=$ltmain
 
 # Always use our own libtool.
 LIBTOOL='$(SHELL) $(top_builddir)/libtool'
@@ -9584,7 +10549,7 @@ test -z "$LN_S" && LN_S="ln -s"
 
 
 
-if test -n "${ZSH_VERSION+set}" ; then
+if test -n "${ZSH_VERSION+set}"; then
    setopt NO_GLOB_SUBST
 fi
 
@@ -9623,7 +10588,7 @@ aix3*)
   # AIX sometimes has problems with the GCC collect2 program.  For some
   # reason, if we set the COLLECT_NAMES environment variable, the problems
   # vanish in a puff of smoke.
-  if test "X${COLLECT_NAMES+set}" != Xset; then
+  if test set != "${COLLECT_NAMES+set}"; then
     COLLECT_NAMES=
     export COLLECT_NAMES
   fi
@@ -9634,14 +10599,14 @@ esac
 ofile=libtool
 can_build_shared=yes
 
-# All known linkers require a `.a' archive for static linking (except MSVC,
+# All known linkers require a '.a' archive for static linking (except MSVC,
 # which needs '.lib').
 libext=a
 
-with_gnu_ld="$lt_cv_prog_gnu_ld"
+with_gnu_ld=$lt_cv_prog_gnu_ld
 
-old_CC="$CC"
-old_CFLAGS="$CFLAGS"
+old_CC=$CC
+old_CFLAGS=$CFLAGS
 
 # Set sane defaults for various variables
 test -z "$CC" && CC=cc
@@ -9650,15 +10615,8 @@ test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
 test -z "$LD" && LD=ld
 test -z "$ac_objext" && ac_objext=o
 
-for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+func_cc_basename $compiler
+cc_basename=$func_cc_basename_result
 
 
 # Only perform the check for file, if the check method requires it
@@ -9673,22 +10631,22 @@ if ${lt_cv_path_MAGIC_CMD+:} false; then :
 else
   case $MAGIC_CMD in
 [\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  lt_cv_path_MAGIC_CMD=$MAGIC_CMD # Let the user override the test with a path.
   ;;
 *)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  lt_save_MAGIC_CMD=$MAGIC_CMD
+  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
   ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
   for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/${ac_tool_prefix}file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+    if test -f "$ac_dir/${ac_tool_prefix}file"; then
+      lt_cv_path_MAGIC_CMD=$ac_dir/"${ac_tool_prefix}file"
       if test -n "$file_magic_test_file"; then
 	case $deplibs_check_method in
 	"file_magic "*)
 	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  MAGIC_CMD=$lt_cv_path_MAGIC_CMD
 	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
 	    $EGREP "$file_magic_regex" > /dev/null; then
 	    :
@@ -9711,13 +10669,13 @@ _LT_EOF
       break
     fi
   done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  IFS=$lt_save_ifs
+  MAGIC_CMD=$lt_save_MAGIC_CMD
   ;;
 esac
 fi
 
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+MAGIC_CMD=$lt_cv_path_MAGIC_CMD
 if test -n "$MAGIC_CMD"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
 $as_echo "$MAGIC_CMD" >&6; }
@@ -9739,22 +10697,22 @@ if ${lt_cv_path_MAGIC_CMD+:} false; then :
 else
   case $MAGIC_CMD in
 [\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  lt_cv_path_MAGIC_CMD=$MAGIC_CMD # Let the user override the test with a path.
   ;;
 *)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  lt_save_MAGIC_CMD=$MAGIC_CMD
+  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
   ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
   for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+    if test -f "$ac_dir/file"; then
+      lt_cv_path_MAGIC_CMD=$ac_dir/"file"
       if test -n "$file_magic_test_file"; then
 	case $deplibs_check_method in
 	"file_magic "*)
 	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  MAGIC_CMD=$lt_cv_path_MAGIC_CMD
 	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
 	    $EGREP "$file_magic_regex" > /dev/null; then
 	    :
@@ -9777,13 +10735,13 @@ _LT_EOF
       break
     fi
   done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  IFS=$lt_save_ifs
+  MAGIC_CMD=$lt_save_MAGIC_CMD
   ;;
 esac
 fi
 
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+MAGIC_CMD=$lt_cv_path_MAGIC_CMD
 if test -n "$MAGIC_CMD"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
 $as_echo "$MAGIC_CMD" >&6; }
@@ -9804,7 +10762,7 @@ esac
 
 # Use C for the default configuration in the libtool script
 
-lt_save_CC="$CC"
+lt_save_CC=$CC
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -9866,7 +10824,7 @@ if test -n "$compiler"; then
 
 lt_prog_compiler_no_builtin_flag=
 
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   case $cc_basename in
   nvcc*)
     lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
@@ -9882,7 +10840,7 @@ else
   lt_cv_prog_compiler_rtti_exceptions=no
    ac_outfile=conftest.$ac_objext
    echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   lt_compiler_flag="-fno-rtti -fno-exceptions"  ## exclude from sc_useless_quotes_in_assignment
    # Insert the option either (1) after the last *FLAGS variable, or
    # (2) before a word containing "conftest.", or (3) at the end.
    # Note that $ac_compile itself does not contain backslashes and begins
@@ -9912,7 +10870,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
 $as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
 
-if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+if test yes = "$lt_cv_prog_compiler_rtti_exceptions"; then
     lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
 else
     :
@@ -9930,17 +10888,18 @@ lt_prog_compiler_pic=
 lt_prog_compiler_static=
 
 
-  if test "$GCC" = yes; then
+  if test yes = "$GCC"; then
     lt_prog_compiler_wl='-Wl,'
     lt_prog_compiler_static='-static'
 
     case $host_os in
       aix*)
       # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# AIX 5 now supports IA64 processor
 	lt_prog_compiler_static='-Bstatic'
       fi
+      lt_prog_compiler_pic='-fPIC'
       ;;
 
     amigaos*)
@@ -9951,8 +10910,8 @@ lt_prog_compiler_static=
         ;;
       m68k)
             # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
+            # adding the '-m68020' flag to GCC prevents building anything better,
+            # like '-m68040'.
             lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
         ;;
       esac
@@ -9968,6 +10927,11 @@ lt_prog_compiler_static=
       # Although the cygwin gcc ignores -fPIC, still need this for old-style
       # (--disable-auto-import) libraries
       lt_prog_compiler_pic='-DDLL_EXPORT'
+      case $host_os in
+      os2*)
+	lt_prog_compiler_static='$wl-static'
+	;;
+      esac
       ;;
 
     darwin* | rhapsody*)
@@ -10038,7 +11002,7 @@ lt_prog_compiler_static=
     case $host_os in
     aix*)
       lt_prog_compiler_wl='-Wl,'
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# AIX 5 now supports IA64 processor
 	lt_prog_compiler_static='-Bstatic'
       else
@@ -10046,10 +11010,29 @@ lt_prog_compiler_static=
       fi
       ;;
 
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      case $cc_basename in
+      nagfor*)
+        # NAG Fortran compiler
+        lt_prog_compiler_wl='-Wl,-Wl,,'
+        lt_prog_compiler_pic='-PIC'
+        lt_prog_compiler_static='-Bstatic'
+        ;;
+      esac
+      ;;
+
     mingw* | cygwin* | pw32* | os2* | cegcc*)
       # This hack is so that the source file can tell whether it is being
       # built for inclusion in a dll (and should export symbols for example).
       lt_prog_compiler_pic='-DDLL_EXPORT'
+      case $host_os in
+      os2*)
+	lt_prog_compiler_static='$wl-static'
+	;;
+      esac
       ;;
 
     hpux9* | hpux10* | hpux11*)
@@ -10065,7 +11048,7 @@ lt_prog_compiler_static=
 	;;
       esac
       # Is there a better lt_prog_compiler_static that works with the bundled CC?
-      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      lt_prog_compiler_static='$wl-a ${wl}archive'
       ;;
 
     irix5* | irix6* | nonstopux*)
@@ -10076,7 +11059,7 @@ lt_prog_compiler_static=
 
     linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
       case $cc_basename in
-      # old Intel for x86_64 which still supported -KPIC.
+      # old Intel for x86_64, which still supported -KPIC.
       ecc*)
 	lt_prog_compiler_wl='-Wl,'
 	lt_prog_compiler_pic='-KPIC'
@@ -10101,6 +11084,12 @@ lt_prog_compiler_static=
 	lt_prog_compiler_pic='-PIC'
 	lt_prog_compiler_static='-Bstatic'
 	;;
+      tcc*)
+	# Fabrice Bellard et al's Tiny C Compiler
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fPIC'
+	lt_prog_compiler_static='-static'
+	;;
       pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
         # Portland Group compilers (*not* the Pentium gcc compiler,
 	# which looks to be a dead project)
@@ -10198,7 +11187,7 @@ lt_prog_compiler_static=
       ;;
 
     sysv4*MP*)
-      if test -d /usr/nec ;then
+      if test -d /usr/nec; then
 	lt_prog_compiler_pic='-Kconform_pic'
 	lt_prog_compiler_static='-Bstatic'
       fi
@@ -10227,7 +11216,7 @@ lt_prog_compiler_static=
   fi
 
 case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
+  # For platforms that do not support PIC, -DPIC is meaningless:
   *djgpp*)
     lt_prog_compiler_pic=
     ;;
@@ -10259,7 +11248,7 @@ else
   lt_cv_prog_compiler_pic_works=no
    ac_outfile=conftest.$ac_objext
    echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"  ## exclude from sc_useless_quotes_in_assignment
    # Insert the option either (1) after the last *FLAGS variable, or
    # (2) before a word containing "conftest.", or (3) at the end.
    # Note that $ac_compile itself does not contain backslashes and begins
@@ -10289,7 +11278,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
 $as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
 
-if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
+if test yes = "$lt_cv_prog_compiler_pic_works"; then
     case $lt_prog_compiler_pic in
      "" | " "*) ;;
      *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
@@ -10321,7 +11310,7 @@ if ${lt_cv_prog_compiler_static_works+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler_static_works=no
-   save_LDFLAGS="$LDFLAGS"
+   save_LDFLAGS=$LDFLAGS
    LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
    echo "$lt_simple_link_test_code" > conftest.$ac_ext
    if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
@@ -10340,13 +11329,13 @@ else
      fi
    fi
    $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+   LDFLAGS=$save_LDFLAGS
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
 $as_echo "$lt_cv_prog_compiler_static_works" >&6; }
 
-if test x"$lt_cv_prog_compiler_static_works" = xyes; then
+if test yes = "$lt_cv_prog_compiler_static_works"; then
     :
 else
     lt_prog_compiler_static=
@@ -10466,8 +11455,8 @@ $as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
 
 
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+hard_links=nottested
+if test no = "$lt_cv_prog_compiler_c_o" && test no != "$need_locks"; then
   # do not overwrite the value of need_locks provided by the user
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
 $as_echo_n "checking if we can lock with hard links... " >&6; }
@@ -10479,9 +11468,9 @@ $as_echo_n "checking if we can lock with hard links... " >&6; }
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
 $as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+  if test no = "$hard_links"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: '$CC' does not support '-c -o', so 'make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: '$CC' does not support '-c -o', so 'make -j' may be unsafe" >&2;}
     need_locks=warn
   fi
 else
@@ -10524,9 +11513,9 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
   # included in the symbol list
   include_expsyms=
   # exclude_expsyms can be an extended regexp of symbols to exclude
-  # it will be wrapped by ` (' and `)$', so one must not match beginning or
-  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
-  # as well as any symbol that contains `d'.
+  # it will be wrapped by ' (' and ')$', so one must not match beginning or
+  # end of line.  Example: 'a|bc|.*d.*' will exclude the symbols 'a' and 'bc',
+  # as well as any symbol that contains 'd'.
   exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
   # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
   # platforms (ab)use it in PIC code, but their linkers get confused if
@@ -10541,7 +11530,7 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
     # FIXME: the MSVC++ port hasn't been tested in a loooong time
     # When not using gcc, we currently assume that we are using
     # Microsoft Visual C++.
-    if test "$GCC" != yes; then
+    if test yes != "$GCC"; then
       with_gnu_ld=no
     fi
     ;;
@@ -10549,7 +11538,7 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
     # we just hope/assume this is gcc and not c89 (= MSVC++)
     with_gnu_ld=yes
     ;;
-  openbsd*)
+  openbsd* | bitrig*)
     with_gnu_ld=no
     ;;
   linux* | k*bsd*-gnu | gnu*)
@@ -10562,7 +11551,7 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
   # On some targets, GNU ld is compatible enough with the native linker
   # that we're better off using the native interface for both.
   lt_use_gnu_ld_interface=no
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     case $host_os in
       aix*)
 	# The AIX port of GNU ld has always aspired to compatibility
@@ -10584,24 +11573,24 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
     esac
   fi
 
-  if test "$lt_use_gnu_ld_interface" = yes; then
+  if test yes = "$lt_use_gnu_ld_interface"; then
     # If archive_cmds runs LD, not CC, wlarc should be empty
-    wlarc='${wl}'
+    wlarc='$wl'
 
     # Set some defaults for GNU ld with shared library support. These
     # are reset later if shared libraries are not supported. Putting them
     # here allows them to be overridden if necessary.
     runpath_var=LD_RUN_PATH
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-    export_dynamic_flag_spec='${wl}--export-dynamic'
+    hardcode_libdir_flag_spec='$wl-rpath $wl$libdir'
+    export_dynamic_flag_spec='$wl--export-dynamic'
     # ancient GNU ld didn't support --whole-archive et. al.
     if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
-      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+      whole_archive_flag_spec=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'
     else
       whole_archive_flag_spec=
     fi
     supports_anon_versioning=no
-    case `$LD -v 2>&1` in
+    case `$LD -v | $SED -e 's/(^)\+)\s\+//' 2>&1` in
       *GNU\ gold*) supports_anon_versioning=yes ;;
       *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
       *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
@@ -10614,7 +11603,7 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
     case $host_os in
     aix[3-9]*)
       # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
+      if test ia64 != "$host_cpu"; then
 	ld_shlibs=no
 	cat <<_LT_EOF 1>&2
 
@@ -10633,7 +11622,7 @@ _LT_EOF
       case $host_cpu in
       powerpc)
             # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
             archive_expsym_cmds=''
         ;;
       m68k)
@@ -10649,7 +11638,7 @@ _LT_EOF
 	allow_undefined_flag=unsupported
 	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
 	# support --undefined.  This deserves some investigation.  FIXME
-	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
       else
 	ld_shlibs=no
       fi
@@ -10659,7 +11648,7 @@ _LT_EOF
       # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
       # as there is no search path for DLLs.
       hardcode_libdir_flag_spec='-L$libdir'
-      export_dynamic_flag_spec='${wl}--export-all-symbols'
+      export_dynamic_flag_spec='$wl--export-all-symbols'
       allow_undefined_flag=unsupported
       always_export_symbols=no
       enable_shared_with_static_runtimes=yes
@@ -10667,61 +11656,89 @@ _LT_EOF
       exclude_expsyms='[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname'
 
       if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	# If the export-symbols file already is a .def file (1st line
-	# is EXPORTS), use it as is; otherwise, prepend...
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	  cp $export_symbols $output_objdir/$soname.def;
-	else
-	  echo EXPORTS > $output_objdir/$soname.def;
-	  cat $export_symbols >> $output_objdir/$soname.def;
-	fi~
-	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file, use it as
+	# is; otherwise, prepend EXPORTS...
+	archive_expsym_cmds='if   test DEF = "`$SED -n     -e '\''s/^[	 ]*//'\''     -e '\''/^\(;.*\)*$/d'\''     -e '\''s/^\(EXPORTS\|LIBRARY\)\([	 ].*\)*$/DEF/p'\''     -e q     $export_symbols`" ; then
+          cp $export_symbols $output_objdir/$soname.def;
+        else
+          echo EXPORTS > $output_objdir/$soname.def;
+          cat $export_symbols >> $output_objdir/$soname.def;
+        fi~
+        $CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
       else
 	ld_shlibs=no
       fi
       ;;
 
     haiku*)
-      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
       link_all_deplibs=yes
       ;;
 
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      shrext_cmds=.dll
+      archive_cmds='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	emxexp $libobjs | $SED /"_DLL_InitTerm"/d >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      archive_expsym_cmds='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	prefix_cmds="$SED"~
+	if test EXPORTS = "`$SED 1q $export_symbols`"; then
+	  prefix_cmds="$prefix_cmds -e 1d";
+	fi~
+	prefix_cmds="$prefix_cmds -e \"s/^\(.*\)$/_\1/g\""~
+	cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      old_archive_From_new_cmds='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'
+      enable_shared_with_static_runtimes=yes
+      ;;
+
     interix[3-9]*)
       hardcode_direct=no
       hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      export_dynamic_flag_spec='${wl}-E'
+      hardcode_libdir_flag_spec='$wl-rpath,$libdir'
+      export_dynamic_flag_spec='$wl-E'
       # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
       # Instead, shared libraries are loaded at an image base (0x10000000 by
       # default) and relocated if they conflict, which is a slow very memory
       # consuming and fragmenting process.  To avoid this, we pick a random,
       # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
       # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s|^|_|" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
       ;;
 
     gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
       tmp_diet=no
-      if test "$host_os" = linux-dietlibc; then
+      if test linux-dietlibc = "$host_os"; then
 	case $cc_basename in
 	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
 	esac
       fi
       if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
-	 && test "$tmp_diet" = no
+	 && test no = "$tmp_diet"
       then
 	tmp_addflag=' $pic_flag'
 	tmp_sharedflag='-shared'
 	case $cc_basename,$host_cpu in
         pgcc*)				# Portland Group C compiler
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  whole_archive_flag_spec='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  tmp_addflag=' $pic_flag'
 	  ;;
 	pgf77* | pgf90* | pgf95* | pgfortran*)
 					# Portland Group f77 and f90 compilers
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  whole_archive_flag_spec='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  tmp_addflag=' $pic_flag -Mnomain' ;;
 	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
 	  tmp_addflag=' -i_dynamic' ;;
@@ -10732,42 +11749,47 @@ _LT_EOF
 	lf95*)				# Lahey Fortran 8.1
 	  whole_archive_flag_spec=
 	  tmp_sharedflag='--shared' ;;
+        nagfor*)                        # NAGFOR 5.3
+          tmp_sharedflag='-Wl,-shared' ;;
 	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
 	  tmp_sharedflag='-qmkshrobj'
 	  tmp_addflag= ;;
 	nvcc*)	# Cuda Compiler Driver 2.2
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  whole_archive_flag_spec='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  compiler_needs_object=yes
 	  ;;
 	esac
 	case `$CC -V 2>&1 | sed 5q` in
 	*Sun\ C*)			# Sun C 5.9
-	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  whole_archive_flag_spec='$wl--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  compiler_needs_object=yes
 	  tmp_sharedflag='-G' ;;
 	*Sun\ F*)			# Sun Fortran 8.3
 	  tmp_sharedflag='-G' ;;
 	esac
-	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
 
-        if test "x$supports_anon_versioning" = xyes; then
+        if test yes = "$supports_anon_versioning"; then
           archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	    echo "local: *; };" >> $output_objdir/$libname.ver~
-	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+            cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+            echo "local: *; };" >> $output_objdir/$libname.ver~
+            $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'
         fi
 
 	case $cc_basename in
+	tcc*)
+	  export_dynamic_flag_spec='-rdynamic'
+	  ;;
 	xlf* | bgf* | bgxlf* | mpixlf*)
 	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
 	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
-	  hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	  hardcode_libdir_flag_spec='$wl-rpath $wl$libdir'
 	  archive_cmds='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
-	  if test "x$supports_anon_versioning" = xyes; then
+	  if test yes = "$supports_anon_versioning"; then
 	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	      echo "local: *; };" >> $output_objdir/$libname.ver~
-	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+              cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+              echo "local: *; };" >> $output_objdir/$libname.ver~
+              $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
 	  fi
 	  ;;
 	esac
@@ -10781,8 +11803,8 @@ _LT_EOF
 	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
       else
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
       fi
       ;;
 
@@ -10800,8 +11822,8 @@ _LT_EOF
 
 _LT_EOF
       elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
       else
 	ld_shlibs=no
       fi
@@ -10813,7 +11835,7 @@ _LT_EOF
 	ld_shlibs=no
 	cat <<_LT_EOF 1>&2
 
-*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 cannot
 *** reliably create shared libraries on SCO systems.  Therefore, libtool
 *** is disabling shared libraries support.  We urge you to upgrade GNU
 *** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
@@ -10828,9 +11850,9 @@ _LT_EOF
 	  # DT_RUNPATH tag from executables and libraries.  But doing so
 	  # requires that you compile everything twice, which is a pain.
 	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	    hardcode_libdir_flag_spec='$wl-rpath $wl$libdir'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 	  else
 	    ld_shlibs=no
 	  fi
@@ -10847,15 +11869,15 @@ _LT_EOF
 
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
       else
 	ld_shlibs=no
       fi
       ;;
     esac
 
-    if test "$ld_shlibs" = no; then
+    if test no = "$ld_shlibs"; then
       runpath_var=
       hardcode_libdir_flag_spec=
       export_dynamic_flag_spec=
@@ -10871,7 +11893,7 @@ _LT_EOF
       # Note: this linker hardcodes the directories in LIBPATH if there
       # are no directories specified by -L.
       hardcode_minus_L=yes
-      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+      if test yes = "$GCC" && test -z "$lt_prog_compiler_static"; then
 	# Neither direct hardcoding nor static linking is supported with a
 	# broken collect2.
 	hardcode_direct=unsupported
@@ -10879,34 +11901,57 @@ _LT_EOF
       ;;
 
     aix[4-9]*)
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# On IA64, the linker does run time linking by default, so we don't
 	# have to do anything special.
 	aix_use_runtimelinking=no
 	exp_sym_flag='-Bexport'
-	no_entry_flag=""
+	no_entry_flag=
       else
 	# If we're using GNU nm, then we don't want the "-C" option.
-	# -C means demangle to AIX nm, but means don't demangle with GNU nm
-	# Also, AIX nm treats weak defined symbols like other global
-	# defined symbols, whereas GNU nm marks them as "W".
+	# -C means demangle to GNU nm, but means don't demangle to AIX nm.
+	# Without the "-l" option, or with the "-B" option, AIX nm treats
+	# weak defined symbols like other global defined symbols, whereas
+	# GNU nm marks them as "W".
+	# While the 'weak' keyword is ignored in the Export File, we need
+	# it in the Import File for the 'aix-soname' feature, so we have
+	# to replace the "-B" option with "-P" for AIX nm.
 	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { if (\$ 2 == "W") { print \$ 3 " weak" } else { print \$ 3 } } }'\'' | sort -u > $export_symbols'
 	else
-	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	  export_symbols_cmds='`func_echo_all $NM | $SED -e '\''s/B\([^B]*\)$/P\1/'\''` -PCpgl $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) && (substr(\$ 1,1,1) != ".")) { if ((\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) { print \$ 1 " weak" } else { print \$ 1 } } }'\'' | sort -u > $export_symbols'
 	fi
 	aix_use_runtimelinking=no
 
 	# Test if we are trying to use run time linking or normal
 	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
-	# need to do runtime linking.
+	# have runtime linking enabled, and use it for executables.
+	# For shared libraries, we enable/disable runtime linking
+	# depending on the kind of the shared library created -
+	# when "with_aix_soname,aix_use_runtimelinking" is:
+	# "aix,no"   lib.a(lib.so.V) shared, rtl:no,  for executables
+	# "aix,yes"  lib.so          shared, rtl:yes, for executables
+	#            lib.a           static archive
+	# "both,no"  lib.so.V(shr.o) shared, rtl:yes
+	#            lib.a(lib.so.V) shared, rtl:no,  for executables
+	# "both,yes" lib.so.V(shr.o) shared, rtl:yes, for executables
+	#            lib.a(lib.so.V) shared, rtl:no
+	# "svr4,*"   lib.so.V(shr.o) shared, rtl:yes, for executables
+	#            lib.a           static archive
 	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
 	  for ld_flag in $LDFLAGS; do
-	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	  if (test x-brtl = "x$ld_flag" || test x-Wl,-brtl = "x$ld_flag"); then
 	    aix_use_runtimelinking=yes
 	    break
 	  fi
 	  done
+	  if test svr4,no = "$with_aix_soname,$aix_use_runtimelinking"; then
+	    # With aix-soname=svr4, we create the lib.so.V shared archives only,
+	    # so we don't have lib.a shared libs to link our executables.
+	    # We have to force runtime linking in this case.
+	    aix_use_runtimelinking=yes
+	    LDFLAGS="$LDFLAGS -Wl,-brtl"
+	  fi
 	  ;;
 	esac
 
@@ -10925,13 +11970,21 @@ _LT_EOF
       hardcode_direct_absolute=yes
       hardcode_libdir_separator=':'
       link_all_deplibs=yes
-      file_list_spec='${wl}-f,'
+      file_list_spec='$wl-f,'
+      case $with_aix_soname,$aix_use_runtimelinking in
+      aix,*) ;; # traditional, no import file
+      svr4,* | *,yes) # use import file
+	# The Import File defines what to hardcode.
+	hardcode_direct=no
+	hardcode_direct_absolute=no
+	;;
+      esac
 
-      if test "$GCC" = yes; then
+      if test yes = "$GCC"; then
 	case $host_os in aix4.[012]|aix4.[012].*)
 	# We only want to do this on AIX 4.2 and lower, the check
 	# below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
+	  collect2name=`$CC -print-prog-name=collect2`
 	  if test -f "$collect2name" &&
 	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
 	  then
@@ -10950,36 +12003,42 @@ _LT_EOF
 	  ;;
 	esac
 	shared_flag='-shared'
-	if test "$aix_use_runtimelinking" = yes; then
-	  shared_flag="$shared_flag "'${wl}-G'
+	if test yes = "$aix_use_runtimelinking"; then
+	  shared_flag="$shared_flag "'$wl-G'
 	fi
-	link_all_deplibs=no
+	# Need to ensure runtime linking is disabled for the traditional
+	# shared library, or the linker may eventually find shared libraries
+	# /with/ Import File - we do not want to mix them.
+	shared_flag_aix='-shared'
+	shared_flag_svr4='-shared $wl-G'
       else
 	# not using gcc
-	if test "$host_cpu" = ia64; then
+	if test ia64 = "$host_cpu"; then
 	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
 	# chokes on -Wl,-G. The following line is correct:
 	  shared_flag='-G'
 	else
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag='${wl}-G'
+	  if test yes = "$aix_use_runtimelinking"; then
+	    shared_flag='$wl-G'
 	  else
-	    shared_flag='${wl}-bM:SRE'
+	    shared_flag='$wl-bM:SRE'
 	  fi
+	  shared_flag_aix='$wl-bM:SRE'
+	  shared_flag_svr4='$wl-G'
 	fi
       fi
 
-      export_dynamic_flag_spec='${wl}-bexpall'
+      export_dynamic_flag_spec='$wl-bexpall'
       # It seems that -bexpall does not export symbols beginning with
       # underscore (_), so it is better to generate a list of symbols to export.
       always_export_symbols=yes
-      if test "$aix_use_runtimelinking" = yes; then
+      if test aix,yes = "$with_aix_soname,$aix_use_runtimelinking"; then
 	# Warning - without using the other runtime loading flags (-brtl),
 	# -berok will link without error, but may produce a broken library.
 	allow_undefined_flag='-berok'
         # Determine the default libpath from the value encoded in an
         # empty executable.
-        if test "${lt_cv_aix_libpath+set}" = set; then
+        if test set = "${lt_cv_aix_libpath+set}"; then
   aix_libpath=$lt_cv_aix_libpath
 else
   if ${lt_cv_aix_libpath_+:} false; then :
@@ -11014,7 +12073,7 @@ fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
   if test -z "$lt_cv_aix_libpath_"; then
-    lt_cv_aix_libpath_="/usr/lib:/lib"
+    lt_cv_aix_libpath_=/usr/lib:/lib
   fi
 
 fi
@@ -11022,17 +12081,17 @@ fi
   aix_libpath=$lt_cv_aix_libpath_
 fi
 
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        hardcode_libdir_flag_spec='$wl-blibpath:$libdir:'"$aix_libpath"
+        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n "$allow_undefined_flag"; then func_echo_all "$wl$allow_undefined_flag"; else :; fi` $wl'$exp_sym_flag:\$export_symbols' '$shared_flag
       else
-	if test "$host_cpu" = ia64; then
-	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	if test ia64 = "$host_cpu"; then
+	  hardcode_libdir_flag_spec='$wl-R $libdir:/usr/lib:/lib'
 	  allow_undefined_flag="-z nodefs"
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\$wl$no_entry_flag"' $compiler_flags $wl$allow_undefined_flag '"\$wl$exp_sym_flag:\$export_symbols"
 	else
 	 # Determine the default libpath from the value encoded in an
 	 # empty executable.
-	 if test "${lt_cv_aix_libpath+set}" = set; then
+	 if test set = "${lt_cv_aix_libpath+set}"; then
   aix_libpath=$lt_cv_aix_libpath
 else
   if ${lt_cv_aix_libpath_+:} false; then :
@@ -11067,7 +12126,7 @@ fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
   if test -z "$lt_cv_aix_libpath_"; then
-    lt_cv_aix_libpath_="/usr/lib:/lib"
+    lt_cv_aix_libpath_=/usr/lib:/lib
   fi
 
 fi
@@ -11075,21 +12134,33 @@ fi
   aix_libpath=$lt_cv_aix_libpath_
 fi
 
-	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	 hardcode_libdir_flag_spec='$wl-blibpath:$libdir:'"$aix_libpath"
 	  # Warning - without using the other run time loading flags,
 	  # -berok will link without error, but may produce a broken library.
-	  no_undefined_flag=' ${wl}-bernotok'
-	  allow_undefined_flag=' ${wl}-berok'
-	  if test "$with_gnu_ld" = yes; then
+	  no_undefined_flag=' $wl-bernotok'
+	  allow_undefined_flag=' $wl-berok'
+	  if test yes = "$with_gnu_ld"; then
 	    # We only use this code for GNU lds that support --whole-archive.
-	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    whole_archive_flag_spec='$wl--whole-archive$convenience $wl--no-whole-archive'
 	  else
 	    # Exported symbols can be pulled into shared objects from archives
 	    whole_archive_flag_spec='$convenience'
 	  fi
 	  archive_cmds_need_lc=yes
-	  # This is similar to how AIX traditionally builds its shared libraries.
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	  archive_expsym_cmds='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'
+	  # -brtl affects multiple linker settings, -berok does not and is overridden later
+	  compiler_flags_filtered='`func_echo_all "$compiler_flags " | $SED -e "s%-brtl\\([, ]\\)%-berok\\1%g"`'
+	  if test svr4 != "$with_aix_soname"; then
+	    # This is similar to how AIX traditionally builds its shared libraries.
+	    archive_expsym_cmds="$archive_expsym_cmds"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'
+	  fi
+	  if test aix != "$with_aix_soname"; then
+	    archive_expsym_cmds="$archive_expsym_cmds"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all "#! $soname($shared_archive_member_spec.o)"; if test shr_64 = "$shared_archive_member_spec"; then func_echo_all "# 64"; else func_echo_all "# 32"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'
+	  else
+	    # used by -dlpreopen to get the symbols
+	    archive_expsym_cmds="$archive_expsym_cmds"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'
+	  fi
+	  archive_expsym_cmds="$archive_expsym_cmds"'~$RM -r $output_objdir/$realname.d'
 	fi
       fi
       ;;
@@ -11098,7 +12169,7 @@ fi
       case $host_cpu in
       powerpc)
             # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
             archive_expsym_cmds=''
         ;;
       m68k)
@@ -11128,16 +12199,17 @@ fi
 	# Tell ltmain to make .lib files, not .a files.
 	libext=lib
 	# Tell ltmain to make .dll files, not .so files.
-	shrext_cmds=".dll"
+	shrext_cmds=.dll
 	# FIXME: Setting linknames here is a bad hack.
-	archive_cmds='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
-	  else
-	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
-	  fi~
-	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
-	  linknames='
+	archive_cmds='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~linknames='
+	archive_expsym_cmds='if   test DEF = "`$SED -n     -e '\''s/^[	 ]*//'\''     -e '\''/^\(;.*\)*$/d'\''     -e '\''s/^\(EXPORTS\|LIBRARY\)\([	 ].*\)*$/DEF/p'\''     -e q     $export_symbols`" ; then
+            cp "$export_symbols" "$output_objdir/$soname.def";
+            echo "$tool_output_objdir$soname.def" > "$output_objdir/$soname.exp";
+          else
+            $SED -e '\''s/^/-link -EXPORT:/'\'' < $export_symbols > $output_objdir/$soname.exp;
+          fi~
+          $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+          linknames='
 	# The linker will not automatically build a static lib if we build a DLL.
 	# _LT_TAGVAR(old_archive_from_new_cmds, )='true'
 	enable_shared_with_static_runtimes=yes
@@ -11146,18 +12218,18 @@ fi
 	# Don't use ranlib
 	old_postinstall_cmds='chmod 644 $oldlib'
 	postlink_cmds='lt_outputfile="@OUTPUT@"~
-	  lt_tool_outputfile="@TOOL_OUTPUT@"~
-	  case $lt_outputfile in
-	    *.exe|*.EXE) ;;
-	    *)
-	      lt_outputfile="$lt_outputfile.exe"
-	      lt_tool_outputfile="$lt_tool_outputfile.exe"
-	      ;;
-	  esac~
-	  if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
-	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
-	    $RM "$lt_outputfile.manifest";
-	  fi'
+          lt_tool_outputfile="@TOOL_OUTPUT@"~
+          case $lt_outputfile in
+            *.exe|*.EXE) ;;
+            *)
+              lt_outputfile=$lt_outputfile.exe
+              lt_tool_outputfile=$lt_tool_outputfile.exe
+              ;;
+          esac~
+          if test : != "$MANIFEST_TOOL" && test -f "$lt_outputfile.manifest"; then
+            $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+            $RM "$lt_outputfile.manifest";
+          fi'
 	;;
       *)
 	# Assume MSVC wrapper
@@ -11166,7 +12238,7 @@ fi
 	# Tell ltmain to make .lib files, not .a files.
 	libext=lib
 	# Tell ltmain to make .dll files, not .so files.
-	shrext_cmds=".dll"
+	shrext_cmds=.dll
 	# FIXME: Setting linknames here is a bad hack.
 	archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
 	# The linker will automatically build a .lib file if we build a DLL.
@@ -11185,24 +12257,24 @@ fi
   hardcode_direct=no
   hardcode_automatic=yes
   hardcode_shlibpath_var=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  if test yes = "$lt_cv_ld_force_load"; then
+    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience $wl-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
 
   else
     whole_archive_flag_spec=''
   fi
   link_all_deplibs=yes
-  allow_undefined_flag="$_lt_dar_allow_undefined"
+  allow_undefined_flag=$_lt_dar_allow_undefined
   case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
+     ifort*|nagfor*) _lt_dar_can_shared=yes ;;
      *) _lt_dar_can_shared=$GCC ;;
   esac
-  if test "$_lt_dar_can_shared" = "yes"; then
+  if test yes = "$_lt_dar_can_shared"; then
     output_verbose_link_cmd=func_echo_all
-    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod$_lt_dsymutil"
+    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags$_lt_dsymutil"
+    archive_expsym_cmds="sed 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod$_lt_dar_export_syms$_lt_dsymutil"
+    module_expsym_cmds="sed -e 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags$_lt_dar_export_syms$_lt_dsymutil"
 
   else
   ld_shlibs=no
@@ -11244,33 +12316,33 @@ fi
       ;;
 
     hpux9*)
-      if test "$GCC" = yes; then
-	archive_cmds='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      if test yes = "$GCC"; then
+	archive_cmds='$RM $output_objdir/$soname~$CC -shared $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
       else
-	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
       fi
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_flag_spec='$wl+b $wl$libdir'
       hardcode_libdir_separator=:
       hardcode_direct=yes
 
       # hardcode_minus_L: Not really in the search PATH,
       # but as the default location of the library.
       hardcode_minus_L=yes
-      export_dynamic_flag_spec='${wl}-E'
+      export_dynamic_flag_spec='$wl-E'
       ;;
 
     hpux10*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes,no = "$GCC,$with_gnu_ld"; then
+	archive_cmds='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
       else
 	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
       fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      if test no = "$with_gnu_ld"; then
+	hardcode_libdir_flag_spec='$wl+b $wl$libdir'
 	hardcode_libdir_separator=:
 	hardcode_direct=yes
 	hardcode_direct_absolute=yes
-	export_dynamic_flag_spec='${wl}-E'
+	export_dynamic_flag_spec='$wl-E'
 	# hardcode_minus_L: Not really in the search PATH,
 	# but as the default location of the library.
 	hardcode_minus_L=yes
@@ -11278,25 +12350,25 @@ fi
       ;;
 
     hpux11*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+      if test yes,no = "$GCC,$with_gnu_ld"; then
 	case $host_cpu in
 	hppa*64*)
-	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_cmds='$CC -shared $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	ia64*)
-	  archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_cmds='$CC -shared $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	*)
-	  archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_cmds='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	esac
       else
 	case $host_cpu in
 	hppa*64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_cmds='$CC -b $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	ia64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_cmds='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	*)
 
@@ -11308,7 +12380,7 @@ if ${lt_cv_prog_compiler__b+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler__b=no
-   save_LDFLAGS="$LDFLAGS"
+   save_LDFLAGS=$LDFLAGS
    LDFLAGS="$LDFLAGS -b"
    echo "$lt_simple_link_test_code" > conftest.$ac_ext
    if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
@@ -11327,14 +12399,14 @@ else
      fi
    fi
    $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+   LDFLAGS=$save_LDFLAGS
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
 $as_echo "$lt_cv_prog_compiler__b" >&6; }
 
-if test x"$lt_cv_prog_compiler__b" = xyes; then
-    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+if test yes = "$lt_cv_prog_compiler__b"; then
+    archive_cmds='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
 else
     archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
 fi
@@ -11342,8 +12414,8 @@ fi
 	  ;;
 	esac
       fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      if test no = "$with_gnu_ld"; then
+	hardcode_libdir_flag_spec='$wl+b $wl$libdir'
 	hardcode_libdir_separator=:
 
 	case $host_cpu in
@@ -11354,7 +12426,7 @@ fi
 	*)
 	  hardcode_direct=yes
 	  hardcode_direct_absolute=yes
-	  export_dynamic_flag_spec='${wl}-E'
+	  export_dynamic_flag_spec='$wl-E'
 
 	  # hardcode_minus_L: Not really in the search PATH,
 	  # but as the default location of the library.
@@ -11365,8 +12437,8 @@ fi
       ;;
 
     irix5* | irix6* | nonstopux*)
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      if test yes = "$GCC"; then
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 	# Try to use the -exported_symbol ld option, if it does not
 	# work, assume that -exports_file does not work either and
 	# implicitly export all symbols.
@@ -11376,8 +12448,8 @@ $as_echo_n "checking whether the $host_os linker accepts -exported_symbol... " >
 if ${lt_cv_irix_exported_symbol+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  save_LDFLAGS="$LDFLAGS"
-	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+  save_LDFLAGS=$LDFLAGS
+	   LDFLAGS="$LDFLAGS -shared $wl-exported_symbol ${wl}foo $wl-update_registry $wl/dev/null"
 	   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int foo (void) { return 0; }
@@ -11389,24 +12461,35 @@ else
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-           LDFLAGS="$save_LDFLAGS"
+           LDFLAGS=$save_LDFLAGS
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_irix_exported_symbol" >&5
 $as_echo "$lt_cv_irix_exported_symbol" >&6; }
-	if test "$lt_cv_irix_exported_symbol" = yes; then
-          archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+	if test yes = "$lt_cv_irix_exported_symbol"; then
+          archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations $wl-exports_file $wl$export_symbols -o $lib'
 	fi
+	link_all_deplibs=no
       else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -exports_file $export_symbols -o $lib'
       fi
       archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_flag_spec='$wl-rpath $wl$libdir'
       hardcode_libdir_separator=:
       inherit_rpath=yes
       link_all_deplibs=yes
       ;;
 
+    linux*)
+      case $cc_basename in
+      tcc*)
+	# Fabrice Bellard et al's Tiny C Compiler
+	ld_shlibs=yes
+	archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	;;
+      esac
+      ;;
+
     netbsd* | netbsdelf*-gnu)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
@@ -11421,7 +12504,7 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
     newsos6)
       archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
       hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_flag_spec='$wl-rpath $wl$libdir'
       hardcode_libdir_separator=:
       hardcode_shlibpath_var=no
       ;;
@@ -11429,27 +12512,19 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
     *nto* | *qnx*)
       ;;
 
-    openbsd*)
+    openbsd* | bitrig*)
       if test -f /usr/libexec/ld.so; then
 	hardcode_direct=yes
 	hardcode_shlibpath_var=no
 	hardcode_direct_absolute=yes
-	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`"; then
 	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
-	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	  export_dynamic_flag_spec='${wl}-E'
+	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags $wl-retain-symbols-file,$export_symbols'
+	  hardcode_libdir_flag_spec='$wl-rpath,$libdir'
+	  export_dynamic_flag_spec='$wl-E'
 	else
-	  case $host_os in
-	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-	     hardcode_libdir_flag_spec='-R$libdir'
-	     ;;
-	   *)
-	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	     ;;
-	  esac
+	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  hardcode_libdir_flag_spec='$wl-rpath,$libdir'
 	fi
       else
 	ld_shlibs=no
@@ -11460,33 +12535,53 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
       hardcode_libdir_flag_spec='-L$libdir'
       hardcode_minus_L=yes
       allow_undefined_flag=unsupported
-      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
-      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      shrext_cmds=.dll
+      archive_cmds='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	emxexp $libobjs | $SED /"_DLL_InitTerm"/d >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      archive_expsym_cmds='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	prefix_cmds="$SED"~
+	if test EXPORTS = "`$SED 1q $export_symbols`"; then
+	  prefix_cmds="$prefix_cmds -e 1d";
+	fi~
+	prefix_cmds="$prefix_cmds -e \"s/^\(.*\)$/_\1/g\""~
+	cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      old_archive_From_new_cmds='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'
+      enable_shared_with_static_runtimes=yes
       ;;
 
     osf3*)
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      if test yes = "$GCC"; then
+	allow_undefined_flag=' $wl-expect_unresolved $wl\*'
+	archive_cmds='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
       else
 	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_cmds='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
       fi
       archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_flag_spec='$wl-rpath $wl$libdir'
       hardcode_libdir_separator=:
       ;;
 
     osf4* | osf5*)	# as osf3* with the addition of -msym flag
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      if test yes = "$GCC"; then
+	allow_undefined_flag=' $wl-expect_unresolved $wl\*'
+	archive_cmds='$CC -shared$allow_undefined_flag $pic_flag $libobjs $deplibs $compiler_flags $wl-msym $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
+	hardcode_libdir_flag_spec='$wl-rpath $wl$libdir'
       else
 	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_cmds='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
 	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
-	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+          $CC -shared$allow_undefined_flag $wl-input $wl$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib~$RM $lib.exp'
 
 	# Both c and cxx compiler support -rpath directly
 	hardcode_libdir_flag_spec='-rpath $libdir'
@@ -11497,24 +12592,24 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
 
     solaris*)
       no_undefined_flag=' -z defs'
-      if test "$GCC" = yes; then
-	wlarc='${wl}'
-	archive_cmds='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes = "$GCC"; then
+	wlarc='$wl'
+	archive_cmds='$CC -shared $pic_flag $wl-z ${wl}text $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'
 	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+          $CC -shared $pic_flag $wl-z ${wl}text $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
       else
 	case `$CC -V 2>&1` in
 	*"Compilers 5.0"*)
 	  wlarc=''
-	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  archive_cmds='$LD -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $linker_flags'
 	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+            $LD -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
 	  ;;
 	*)
-	  wlarc='${wl}'
-	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  wlarc='$wl'
+	  archive_cmds='$CC -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $compiler_flags'
 	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+            $CC -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
 	  ;;
 	esac
       fi
@@ -11524,11 +12619,11 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
       solaris2.[0-5] | solaris2.[0-5].*) ;;
       *)
 	# The compiler driver will combine and reorder linker options,
-	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but understands '-z linker_flag'.  GCC discards it without '$wl',
 	# but is careful enough not to reorder.
 	# Supported since Solaris 2.6 (maybe 2.5.1?)
-	if test "$GCC" = yes; then
-	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	if test yes = "$GCC"; then
+	  whole_archive_flag_spec='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'
 	else
 	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
 	fi
@@ -11538,10 +12633,10 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
       ;;
 
     sunos4*)
-      if test "x$host_vendor" = xsequent; then
+      if test sequent = "$host_vendor"; then
 	# Use $CC to link under sequent, because it throws in some extra .o
 	# files that make .init and .fini sections work.
-	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_cmds='$CC -G $wl-h $soname -o $lib $libobjs $deplibs $compiler_flags'
       else
 	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
       fi
@@ -11590,43 +12685,43 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
       ;;
 
     sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag='${wl}-z,text'
+      no_undefined_flag='$wl-z,text'
       archive_cmds_need_lc=no
       hardcode_shlibpath_var=no
       runpath_var='LD_RUN_PATH'
 
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes = "$GCC"; then
+	archive_cmds='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_cmds='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       fi
       ;;
 
     sysv5* | sco3.2v5* | sco5v6*)
-      # Note: We can NOT use -z defs as we might desire, because we do not
+      # Note: We CANNOT use -z defs as we might desire, because we do not
       # link with -lc, and that would cause any symbols used from libc to
       # always be unresolved, which means just about no library would
       # ever link correctly.  If we're not using GNU ld we use -z text
       # though, which does catch some bad symbols but isn't as heavy-handed
       # as -z defs.
-      no_undefined_flag='${wl}-z,text'
-      allow_undefined_flag='${wl}-z,nodefs'
+      no_undefined_flag='$wl-z,text'
+      allow_undefined_flag='$wl-z,nodefs'
       archive_cmds_need_lc=no
       hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-R,$libdir'
+      hardcode_libdir_flag_spec='$wl-R,$libdir'
       hardcode_libdir_separator=':'
       link_all_deplibs=yes
-      export_dynamic_flag_spec='${wl}-Bexport'
+      export_dynamic_flag_spec='$wl-Bexport'
       runpath_var='LD_RUN_PATH'
 
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes = "$GCC"; then
+	archive_cmds='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_cmds='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       fi
       ;;
 
@@ -11641,10 +12736,10 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
       ;;
     esac
 
-    if test x$host_vendor = xsni; then
+    if test sni = "$host_vendor"; then
       case $host in
       sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-	export_dynamic_flag_spec='${wl}-Blargedynsym'
+	export_dynamic_flag_spec='$wl-Blargedynsym'
 	;;
       esac
     fi
@@ -11652,7 +12747,7 @@ $as_echo "$lt_cv_irix_exported_symbol" >&6; }
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
 $as_echo "$ld_shlibs" >&6; }
-test "$ld_shlibs" = no && can_build_shared=no
+test no = "$ld_shlibs" && can_build_shared=no
 
 with_gnu_ld=$with_gnu_ld
 
@@ -11678,7 +12773,7 @@ x|xyes)
   # Assume -lc should be added
   archive_cmds_need_lc=yes
 
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
+  if test yes,yes = "$GCC,$enable_shared"; then
     case $archive_cmds in
     *'~'*)
       # FIXME: we may have to deal with multi-command sequences.
@@ -11893,14 +12988,14 @@ esac
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
 $as_echo_n "checking dynamic linker characteristics... " >&6; }
 
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   case $host_os in
-    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
-    *) lt_awk_arg="/^libraries:/" ;;
+    darwin*) lt_awk_arg='/^libraries:/,/LR/' ;;
+    *) lt_awk_arg='/^libraries:/' ;;
   esac
   case $host_os in
-    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
-    *) lt_sed_strip_eq="s,=/,/,g" ;;
+    mingw* | cegcc*) lt_sed_strip_eq='s|=\([A-Za-z]:\)|\1|g' ;;
+    *) lt_sed_strip_eq='s|=/|/|g' ;;
   esac
   lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
   case $lt_search_path_spec in
@@ -11916,28 +13011,35 @@ if test "$GCC" = yes; then
     ;;
   esac
   # Ok, now we have the path, separated by spaces, we can step through it
-  # and add multilib dir if necessary.
+  # and add multilib dir if necessary...
   lt_tmp_lt_search_path_spec=
-  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  lt_multi_os_dir=/`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  # ...but if some path component already ends with the multilib dir we assume
+  # that all is fine and trust -print-search-dirs as is (GCC 4.2? or newer).
+  case "$lt_multi_os_dir; $lt_search_path_spec " in
+  "/; "* | "/.; "* | "/./; "* | *"$lt_multi_os_dir "* | *"$lt_multi_os_dir/ "*)
+    lt_multi_os_dir=
+    ;;
+  esac
   for lt_sys_path in $lt_search_path_spec; do
-    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
-      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
-    else
+    if test -d "$lt_sys_path$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path$lt_multi_os_dir"
+    elif test -n "$lt_multi_os_dir"; then
       test -d "$lt_sys_path" && \
 	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
     fi
   done
   lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
-BEGIN {RS=" "; FS="/|\n";} {
-  lt_foo="";
-  lt_count=0;
+BEGIN {RS = " "; FS = "/|\n";} {
+  lt_foo = "";
+  lt_count = 0;
   for (lt_i = NF; lt_i > 0; lt_i--) {
     if ($lt_i != "" && $lt_i != ".") {
       if ($lt_i == "..") {
         lt_count++;
       } else {
         if (lt_count == 0) {
-          lt_foo="/" $lt_i lt_foo;
+          lt_foo = "/" $lt_i lt_foo;
         } else {
           lt_count--;
         }
@@ -11951,7 +13053,7 @@ BEGIN {RS=" "; FS="/|\n";} {
   # for these hosts.
   case $host_os in
     mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
-      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
+      $SED 's|/\([A-Za-z]:\)|\1|g'` ;;
   esac
   sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
 else
@@ -11960,7 +13062,7 @@ fi
 library_names_spec=
 libname_spec='lib$name'
 soname_spec=
-shrext_cmds=".so"
+shrext_cmds=.so
 postinstall_cmds=
 postuninstall_cmds=
 finish_cmds=
@@ -11977,14 +13079,16 @@ hardcode_into_libs=no
 # flags to be left without arguments
 need_version=unknown
 
+
+
 case $host_os in
 aix3*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname.a'
   shlibpath_var=LIBPATH
 
   # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
+  soname_spec='$libname$release$shared_ext$major'
   ;;
 
 aix[4-9]*)
@@ -11992,41 +13096,91 @@ aix[4-9]*)
   need_lib_prefix=no
   need_version=no
   hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
+  if test ia64 = "$host_cpu"; then
     # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    library_names_spec='$libname$release$shared_ext$major $libname$release$shared_ext$versuffix $libname$shared_ext'
     shlibpath_var=LD_LIBRARY_PATH
   else
     # With GCC up to 2.95.x, collect2 would create an import file
     # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
+    # the line '#! .'.  This would cause the generated library to
+    # depend on '.', always an invalid library.  This was fixed in
     # development snapshots of GCC prior to 3.0.
     case $host_os in
       aix4 | aix4.[01] | aix4.[01].*)
       if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
 	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	   echo '#endif'; } | $CC -E - | $GREP yes > /dev/null; then
 	:
       else
 	can_build_shared=no
       fi
       ;;
     esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # Using Import Files as archive members, it is possible to support
+    # filename-based versioning of shared library archives on AIX. While
+    # this would work for both with and without runtime linking, it will
+    # prevent static linking of such archives. So we do filename-based
+    # shared library versioning with .so extension only, which is used
+    # when both runtime linking and shared linking is enabled.
+    # Unfortunately, runtime linking may impact performance, so we do
+    # not want this to be the default eventually. Also, we use the
+    # versioned .so libs for executables only if there is the -brtl
+    # linker flag in LDFLAGS as well, or --with-aix-soname=svr4 only.
+    # To allow for filename-based versioning support, we need to create
+    # libNAME.so.V as an archive file, containing:
+    # *) an Import File, referring to the versioned filename of the
+    #    archive as well as the shared archive member, telling the
+    #    bitwidth (32 or 64) of that shared object, and providing the
+    #    list of exported symbols of that shared object, eventually
+    #    decorated with the 'weak' keyword
+    # *) the shared object with the F_LOADONLY flag set, to really avoid
+    #    it being seen by the linker.
+    # At run time we better use the real file rather than another symlink,
+    # but for link time we create the symlink libNAME.so -> libNAME.so.V
+
+    case $with_aix_soname,$aix_use_runtimelinking in
+    # AIX (on Power*) has no versioning support, so currently we cannot hardcode correct
     # soname into executable. Probably we can add versioning support to
     # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
+    aix,yes) # traditional libtool
+      dynamic_linker='AIX unversionable lib.so'
       # If using run time linking (on AIX 4.2 or later) use lib<name>.so
       # instead of lib<name>.a to let people know that these are not
       # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+      ;;
+    aix,no) # traditional AIX only
+      dynamic_linker='AIX lib.a(lib.so.V)'
       # We preserve .a as extension for shared libraries through AIX4.2
       # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
+      library_names_spec='$libname$release.a $libname.a'
+      soname_spec='$libname$release$shared_ext$major'
+      ;;
+    svr4,*) # full svr4 only
+      dynamic_linker="AIX lib.so.V($shared_archive_member_spec.o)"
+      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'
+      # We do not specify a path in Import Files, so LIBPATH fires.
+      shlibpath_overrides_runpath=yes
+      ;;
+    *,yes) # both, prefer svr4
+      dynamic_linker="AIX lib.so.V($shared_archive_member_spec.o), lib.a(lib.so.V)"
+      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'
+      # unpreferred sharedlib libNAME.a needs extra handling
+      postinstall_cmds='test -n "$linkname" || linkname="$realname"~func_stripname "" ".so" "$linkname"~$install_shared_prog "$dir/$func_stripname_result.$libext" "$destdir/$func_stripname_result.$libext"~test -z "$tstripme" || test -z "$striplib" || $striplib "$destdir/$func_stripname_result.$libext"'
+      postuninstall_cmds='for n in $library_names $old_library; do :; done~func_stripname "" ".so" "$n"~test "$func_stripname_result" = "$n" || func_append rmfiles " $odir/$func_stripname_result.$libext"'
+      # We do not specify a path in Import Files, so LIBPATH fires.
+      shlibpath_overrides_runpath=yes
+      ;;
+    *,no) # both, prefer aix
+      dynamic_linker="AIX lib.a(lib.so.V), lib.so.V($shared_archive_member_spec.o)"
+      library_names_spec='$libname$release.a $libname.a'
+      soname_spec='$libname$release$shared_ext$major'
+      # unpreferred sharedlib libNAME.so.V and symlink libNAME.so need extra handling
+      postinstall_cmds='test -z "$dlname" || $install_shared_prog $dir/$dlname $destdir/$dlname~test -z "$tstripme" || test -z "$striplib" || $striplib $destdir/$dlname~test -n "$linkname" || linkname=$realname~func_stripname "" ".a" "$linkname"~(cd "$destdir" && $LN_S -f $dlname $func_stripname_result.so)'
+      postuninstall_cmds='test -z "$dlname" || func_append rmfiles " $odir/$dlname"~for n in $old_library $library_names; do :; done~func_stripname "" ".a" "$n"~func_append rmfiles " $odir/$func_stripname_result.so"'
+      ;;
+    esac
     shlibpath_var=LIBPATH
   fi
   ;;
@@ -12036,18 +13190,18 @@ amigaos*)
   powerpc)
     # Since July 2007 AmigaOS4 officially supports .so libraries.
     # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
     ;;
   m68k)
     library_names_spec='$libname.ixlibrary $libname.a'
     # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
     ;;
   esac
   ;;
 
 beos*)
-  library_names_spec='${libname}${shared_ext}'
+  library_names_spec='$libname$shared_ext'
   dynamic_linker="$host_os ld.so"
   shlibpath_var=LIBRARY_PATH
   ;;
@@ -12055,8 +13209,8 @@ beos*)
 bsdi[45]*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
@@ -12068,7 +13222,7 @@ bsdi[45]*)
 
 cygwin* | mingw* | pw32* | cegcc*)
   version_type=windows
-  shrext_cmds=".dll"
+  shrext_cmds=.dll
   need_version=no
   need_lib_prefix=no
 
@@ -12077,8 +13231,8 @@ cygwin* | mingw* | pw32* | cegcc*)
     # gcc
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+    postinstall_cmds='base_file=`basename \$file`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; echo \$dlname'\''`~
       dldir=$destdir/`dirname \$dlpath`~
       test -d \$dldir || mkdir -p \$dldir~
       $install_prog $dir/$dlname \$dldir/$dlname~
@@ -12094,17 +13248,17 @@ cygwin* | mingw* | pw32* | cegcc*)
     case $host_os in
     cygwin*)
       # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      soname_spec='`echo $libname | sed -e 's/^lib/cyg/'``echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
 
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
       ;;
     mingw* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      soname_spec='$libname`echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
       ;;
     pw32*)
       # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      library_names_spec='`echo $libname | sed -e 's/^lib/pw/'``echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
       ;;
     esac
     dynamic_linker='Win32 ld.exe'
@@ -12113,8 +13267,8 @@ cygwin* | mingw* | pw32* | cegcc*)
   *,cl*)
     # Native MSVC
     libname_spec='$name'
-    soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-    library_names_spec='${libname}.dll.lib'
+    soname_spec='$libname`echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
+    library_names_spec='$libname.dll.lib'
 
     case $build_os in
     mingw*)
@@ -12141,7 +13295,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
       ;;
     *)
-      sys_lib_search_path_spec="$LIB"
+      sys_lib_search_path_spec=$LIB
       if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
         # It is most probably a Windows format PATH.
         sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
@@ -12154,8 +13308,8 @@ cygwin* | mingw* | pw32* | cegcc*)
     esac
 
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+    postinstall_cmds='base_file=`basename \$file`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; echo \$dlname'\''`~
       dldir=$destdir/`dirname \$dlpath`~
       test -d \$dldir || mkdir -p \$dldir~
       $install_prog $dir/$dlname \$dldir/$dlname'
@@ -12168,7 +13322,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
   *)
     # Assume MSVC wrapper
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    library_names_spec='$libname`echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext $libname.lib'
     dynamic_linker='Win32 ld.exe'
     ;;
   esac
@@ -12181,8 +13335,8 @@ darwin* | rhapsody*)
   version_type=darwin
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
+  library_names_spec='$libname$release$major$shared_ext $libname$shared_ext'
+  soname_spec='$libname$release$major$shared_ext'
   shlibpath_overrides_runpath=yes
   shlibpath_var=DYLD_LIBRARY_PATH
   shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
@@ -12195,8 +13349,8 @@ dgux*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
@@ -12214,12 +13368,13 @@ freebsd* | dragonfly*)
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+      soname_spec='$libname$release$shared_ext$major'
       need_version=no
       need_lib_prefix=no
       ;;
     freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
       need_version=yes
       ;;
   esac
@@ -12249,10 +13404,10 @@ haiku*)
   need_lib_prefix=no
   need_version=no
   dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
+  shlibpath_overrides_runpath=no
   sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
   hardcode_into_libs=yes
   ;;
@@ -12270,14 +13425,15 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.so"
     shlibpath_var=LD_LIBRARY_PATH
     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
+    if test 32 = "$HPUX_IA64_MODE"; then
       sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+      sys_lib_dlsearch_path_spec=/usr/lib/hpux32
     else
       sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+      sys_lib_dlsearch_path_spec=/usr/lib/hpux64
     fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
     ;;
   hppa*64*)
     shrext_cmds='.sl'
@@ -12285,8 +13441,8 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.sl"
     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
     ;;
@@ -12295,8 +13451,8 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.sl"
     shlibpath_var=SHLIB_PATH
     shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     ;;
   esac
   # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
@@ -12309,8 +13465,8 @@ interix[3-9]*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
@@ -12321,7 +13477,7 @@ irix5* | irix6* | nonstopux*)
   case $host_os in
     nonstopux*) version_type=nonstopux ;;
     *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
+	if test yes = "$lt_cv_prog_gnu_ld"; then
 		version_type=linux # correct to gnu/linux during the next big refactor
 	else
 		version_type=irix
@@ -12329,8 +13485,8 @@ irix5* | irix6* | nonstopux*)
   esac
   need_lib_prefix=no
   need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='$libname$release$shared_ext$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$release$shared_ext $libname$shared_ext'
   case $host_os in
   irix5* | nonstopux*)
     libsuff= shlibsuff=
@@ -12349,8 +13505,8 @@ irix5* | irix6* | nonstopux*)
   esac
   shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
   shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  sys_lib_search_path_spec="/usr/lib$libsuff /lib$libsuff /usr/local/lib$libsuff"
+  sys_lib_dlsearch_path_spec="/usr/lib$libsuff /lib$libsuff"
   hardcode_into_libs=yes
   ;;
 
@@ -12359,13 +13515,33 @@ linux*oldld* | linux*aout* | linux*coff*)
   dynamic_linker=no
   ;;
 
+linux*android*)
+  version_type=none # Android doesn't support versioned libraries.
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='$libname$release$shared_ext'
+  soname_spec='$libname$release$shared_ext'
+  finish_cmds=
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  dynamic_linker='Android linker'
+  # Don't embed -rpath directories since the linker doesn't support them.
+  hardcode_libdir_flag_spec='-L$libdir'
+  ;;
+
 # This must be glibc/ELF.
 linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
@@ -12409,7 +13585,12 @@ fi
   # before this can be enabled.
   hardcode_into_libs=yes
 
-  # Append ld.so.conf contents to the search path
+  # Ideally, we could use ldconfig to report *all* directores which are
+  # searched for libraries, however this is still not possible.  Aside from not
+  # being certain /sbin/ldconfig is available, command
+  # 'ldconfig -N -X -v | grep ^/' on 64bit Fedora does not report /usr/lib64,
+  # even though it is searched at run-time.  Try to do the best guess by
+  # appending ld.so.conf contents (and includes) to the search path.
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
@@ -12441,12 +13622,12 @@ netbsd*)
   need_lib_prefix=no
   need_version=no
   if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
     finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
     dynamic_linker='NetBSD (a.out) ld.so'
   else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     dynamic_linker='NetBSD ld.elf_so'
   fi
   shlibpath_var=LD_LIBRARY_PATH
@@ -12456,7 +13637,7 @@ netbsd*)
 
 newsos6)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   ;;
@@ -12465,58 +13646,68 @@ newsos6)
   version_type=qnx
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
   hardcode_into_libs=yes
   dynamic_linker='ldqnx.so'
   ;;
 
-openbsd*)
+openbsd* | bitrig*)
   version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
+  sys_lib_dlsearch_path_spec=/usr/lib
   need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`"; then
+    need_version=no
   else
-    shlibpath_overrides_runpath=yes
+    need_version=yes
   fi
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
   ;;
 
 os2*)
   libname_spec='$name'
-  shrext_cmds=".dll"
+  version_type=windows
+  shrext_cmds=.dll
+  need_version=no
   need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
+  # OS/2 can only load a DLL with a base name of 8 characters or less.
+  soname_spec='`test -n "$os2dllname" && libname="$os2dllname";
+    v=$($ECHO $release$versuffix | tr -d .-);
+    n=$($ECHO $libname | cut -b -$((8 - ${#v})) | tr . _);
+    $ECHO $n$v`$shared_ext'
+  library_names_spec='${libname}_dll.$libext'
   dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
+  shlibpath_var=BEGINLIBPATH
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+  postinstall_cmds='base_file=`basename \$file`~
+    dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; $ECHO \$dlname'\''`~
+    dldir=$destdir/`dirname \$dlpath`~
+    test -d \$dldir || mkdir -p \$dldir~
+    $install_prog $dir/$dlname \$dldir/$dlname~
+    chmod a+x \$dldir/$dlname~
+    if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+      eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+    fi'
+  postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; $ECHO \$dlname'\''`~
+    dlpath=$dir/\$dldll~
+    $RM \$dlpath'
   ;;
 
 osf3* | osf4* | osf5*)
   version_type=osf
   need_lib_prefix=no
   need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='$libname$release$shared_ext$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
   ;;
 
 rdos*)
@@ -12527,8 +13718,8 @@ solaris*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   hardcode_into_libs=yes
@@ -12538,11 +13729,11 @@ solaris*)
 
 sunos4*)
   version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
   finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     need_lib_prefix=no
   fi
   need_version=yes
@@ -12550,8 +13741,8 @@ sunos4*)
 
 sysv4 | sysv4.3*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   case $host_vendor in
     sni)
@@ -12572,24 +13763,24 @@ sysv4 | sysv4.3*)
   ;;
 
 sysv4*MP*)
-  if test -d /usr/nec ;then
+  if test -d /usr/nec; then
     version_type=linux # correct to gnu/linux during the next big refactor
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
+    library_names_spec='$libname$shared_ext.$versuffix $libname$shared_ext.$major $libname$shared_ext'
+    soname_spec='$libname$shared_ext.$major'
     shlibpath_var=LD_LIBRARY_PATH
   fi
   ;;
 
 sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
+  version_type=sco
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
   else
     sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
@@ -12607,7 +13798,7 @@ tpf*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
   hardcode_into_libs=yes
@@ -12615,8 +13806,8 @@ tpf*)
 
 uts4*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
@@ -12626,20 +13817,35 @@ uts4*)
 esac
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
 $as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
+test no = "$dynamic_linker" && can_build_shared=no
 
 variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
 fi
 
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+if test set = "${lt_cv_sys_lib_search_path_spec+set}"; then
+  sys_lib_search_path_spec=$lt_cv_sys_lib_search_path_spec
 fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+
+if test set = "${lt_cv_sys_lib_dlsearch_path_spec+set}"; then
+  sys_lib_dlsearch_path_spec=$lt_cv_sys_lib_dlsearch_path_spec
 fi
 
+# remember unaugmented sys_lib_dlsearch_path content for libtool script decls...
+configure_time_dlsearch_path=$sys_lib_dlsearch_path_spec
+
+# ... but it needs LT_SYS_LIBRARY_PATH munging for other configure-time code
+func_munge_path_list sys_lib_dlsearch_path_spec "$LT_SYS_LIBRARY_PATH"
+
+# to be used as default LT_SYS_LIBRARY_PATH value in generated libtool
+configure_time_lt_sys_library_path=$LT_SYS_LIBRARY_PATH
+
+
+
+
+
+
 
 
 
@@ -12736,15 +13942,15 @@ $as_echo_n "checking how to hardcode library paths into programs... " >&6; }
 hardcode_action=
 if test -n "$hardcode_libdir_flag_spec" ||
    test -n "$runpath_var" ||
-   test "X$hardcode_automatic" = "Xyes" ; then
+   test yes = "$hardcode_automatic"; then
 
   # We can hardcode non-existent directories.
-  if test "$hardcode_direct" != no &&
+  if test no != "$hardcode_direct" &&
      # If the only mechanism to avoid hardcoding is shlibpath_var, we
      # have to relink, otherwise we might link with an installed library
      # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
-     test "$hardcode_minus_L" != no; then
+     ## test no != "$_LT_TAGVAR(hardcode_shlibpath_var, )" &&
+     test no != "$hardcode_minus_L"; then
     # Linking always hardcodes the temporary library directory.
     hardcode_action=relink
   else
@@ -12759,12 +13965,12 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
 $as_echo "$hardcode_action" >&6; }
 
-if test "$hardcode_action" = relink ||
-   test "$inherit_rpath" = yes; then
+if test relink = "$hardcode_action" ||
+   test yes = "$inherit_rpath"; then
   # Fast installation is not supported
   enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
+elif test yes = "$shlibpath_overrides_runpath" ||
+     test no = "$enable_shared"; then
   # Fast installation is not necessary
   enable_fast_install=needless
 fi
@@ -12774,7 +13980,7 @@ fi
 
 
 
-  if test "x$enable_dlopen" != xyes; then
+  if test yes != "$enable_dlopen"; then
   enable_dlopen=unknown
   enable_dlopen_self=unknown
   enable_dlopen_self_static=unknown
@@ -12784,23 +13990,23 @@ else
 
   case $host_os in
   beos*)
-    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen=load_add_on
     lt_cv_dlopen_libs=
     lt_cv_dlopen_self=yes
     ;;
 
   mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen=LoadLibrary
     lt_cv_dlopen_libs=
     ;;
 
   cygwin*)
-    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen=dlopen
     lt_cv_dlopen_libs=
     ;;
 
   darwin*)
-  # if libdl is installed we need to link against it
+    # if libdl is installed we need to link against it
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
 $as_echo_n "checking for dlopen in -ldl... " >&6; }
 if ${ac_cv_lib_dl_dlopen+:} false; then :
@@ -12838,10 +14044,10 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
 $as_echo "$ac_cv_lib_dl_dlopen" >&6; }
 if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+  lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl
 else
 
-    lt_cv_dlopen="dyld"
+    lt_cv_dlopen=dyld
     lt_cv_dlopen_libs=
     lt_cv_dlopen_self=yes
 
@@ -12849,10 +14055,18 @@ fi
 
     ;;
 
+  tpf*)
+    # Don't try to run any link tests for TPF.  We know it's impossible
+    # because TPF is a cross-compiler, and we know how we open DSOs.
+    lt_cv_dlopen=dlopen
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=no
+    ;;
+
   *)
     ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
 if test "x$ac_cv_func_shl_load" = xyes; then :
-  lt_cv_dlopen="shl_load"
+  lt_cv_dlopen=shl_load
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
 $as_echo_n "checking for shl_load in -ldld... " >&6; }
@@ -12891,11 +14105,11 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
 $as_echo "$ac_cv_lib_dld_shl_load" >&6; }
 if test "x$ac_cv_lib_dld_shl_load" = xyes; then :
-  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+  lt_cv_dlopen=shl_load lt_cv_dlopen_libs=-ldld
 else
   ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
 if test "x$ac_cv_func_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen"
+  lt_cv_dlopen=dlopen
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
 $as_echo_n "checking for dlopen in -ldl... " >&6; }
@@ -12934,7 +14148,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
 $as_echo "$ac_cv_lib_dl_dlopen" >&6; }
 if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+  lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
 $as_echo_n "checking for dlopen in -lsvld... " >&6; }
@@ -12973,7 +14187,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
 $as_echo "$ac_cv_lib_svld_dlopen" >&6; }
 if test "x$ac_cv_lib_svld_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+  lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-lsvld
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
 $as_echo_n "checking for dld_link in -ldld... " >&6; }
@@ -13012,7 +14226,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
 $as_echo "$ac_cv_lib_dld_dld_link" >&6; }
 if test "x$ac_cv_lib_dld_dld_link" = xyes; then :
-  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+  lt_cv_dlopen=dld_link lt_cv_dlopen_libs=-ldld
 fi
 
 
@@ -13033,21 +14247,21 @@ fi
     ;;
   esac
 
-  if test "x$lt_cv_dlopen" != xno; then
-    enable_dlopen=yes
-  else
+  if test no = "$lt_cv_dlopen"; then
     enable_dlopen=no
+  else
+    enable_dlopen=yes
   fi
 
   case $lt_cv_dlopen in
   dlopen)
-    save_CPPFLAGS="$CPPFLAGS"
-    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+    save_CPPFLAGS=$CPPFLAGS
+    test yes = "$ac_cv_header_dlfcn_h" && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
 
-    save_LDFLAGS="$LDFLAGS"
+    save_LDFLAGS=$LDFLAGS
     wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
 
-    save_LIBS="$LIBS"
+    save_LIBS=$LIBS
     LIBS="$lt_cv_dlopen_libs $LIBS"
 
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
@@ -13055,7 +14269,7 @@ $as_echo_n "checking whether a program can dlopen itself... " >&6; }
 if ${lt_cv_dlopen_self+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  	  if test "$cross_compiling" = yes; then :
+  	  if test yes = "$cross_compiling"; then :
   lt_cv_dlopen_self=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
@@ -13102,9 +14316,9 @@ else
 #  endif
 #endif
 
-/* When -fvisbility=hidden is used, assume the code has been annotated
+/* When -fvisibility=hidden is used, assume the code has been annotated
    correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+#if defined __GNUC__ && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
 int fnord () __attribute__((visibility("default")));
 #endif
 
@@ -13134,7 +14348,7 @@ _LT_EOF
   (eval $ac_link) 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+  test $ac_status = 0; } && test -s "conftest$ac_exeext" 2>/dev/null; then
     (./conftest; exit; ) >&5 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -13154,14 +14368,14 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
 $as_echo "$lt_cv_dlopen_self" >&6; }
 
-    if test "x$lt_cv_dlopen_self" = xyes; then
+    if test yes = "$lt_cv_dlopen_self"; then
       wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
 $as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
 if ${lt_cv_dlopen_self_static+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  	  if test "$cross_compiling" = yes; then :
+  	  if test yes = "$cross_compiling"; then :
   lt_cv_dlopen_self_static=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
@@ -13208,9 +14422,9 @@ else
 #  endif
 #endif
 
-/* When -fvisbility=hidden is used, assume the code has been annotated
+/* When -fvisibility=hidden is used, assume the code has been annotated
    correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+#if defined __GNUC__ && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
 int fnord () __attribute__((visibility("default")));
 #endif
 
@@ -13240,7 +14454,7 @@ _LT_EOF
   (eval $ac_link) 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+  test $ac_status = 0; } && test -s "conftest$ac_exeext" 2>/dev/null; then
     (./conftest; exit; ) >&5 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -13261,9 +14475,9 @@ fi
 $as_echo "$lt_cv_dlopen_self_static" >&6; }
     fi
 
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
+    CPPFLAGS=$save_CPPFLAGS
+    LDFLAGS=$save_LDFLAGS
+    LIBS=$save_LIBS
     ;;
   esac
 
@@ -13307,7 +14521,7 @@ else
 # FIXME - insert some real tests, host_os isn't really good enough
   case $host_os in
   darwin*)
-    if test -n "$STRIP" ; then
+    if test -n "$STRIP"; then
       striplib="$STRIP -x"
       old_striplib="$STRIP -S"
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
@@ -13335,7 +14549,7 @@ fi
 
 
 
-  # Report which library types will actually be built
+  # Report what library types will actually be built
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
 $as_echo_n "checking if libtool supports shared libraries... " >&6; }
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
@@ -13343,13 +14557,13 @@ $as_echo "$can_build_shared" >&6; }
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
 $as_echo_n "checking whether to build shared libraries... " >&6; }
-  test "$can_build_shared" = "no" && enable_shared=no
+  test no = "$can_build_shared" && enable_shared=no
 
   # On AIX, shared libraries and static libraries use the same namespace, and
   # are all built from PIC.
   case $host_os in
   aix3*)
-    test "$enable_shared" = yes && enable_static=no
+    test yes = "$enable_shared" && enable_static=no
     if test -n "$RANLIB"; then
       archive_cmds="$archive_cmds~\$RANLIB \$lib"
       postinstall_cmds='$RANLIB $lib'
@@ -13357,8 +14571,12 @@ $as_echo_n "checking whether to build shared libraries... " >&6; }
     ;;
 
   aix[4-9]*)
-    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-      test "$enable_shared" = yes && enable_static=no
+    if test ia64 != "$host_cpu"; then
+      case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in
+      yes,aix,yes) ;;			# shared object as lib.so file only
+      yes,svr4,*) ;;			# shared object as lib.so archive member only
+      yes,*) enable_static=no ;;	# shared object in lib.a archive as well
+      esac
     fi
     ;;
   esac
@@ -13368,7 +14586,7 @@ $as_echo "$enable_shared" >&6; }
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
 $as_echo_n "checking whether to build static libraries... " >&6; }
   # Make sure either enable_shared or enable_static is yes.
-  test "$enable_shared" = yes || enable_static=yes
+  test yes = "$enable_shared" || enable_static=yes
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
 $as_echo "$enable_static" >&6; }
 
@@ -13382,11 +14600,11 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-CC="$lt_save_CC"
+CC=$lt_save_CC
 
-      if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
-    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
-    (test "X$CXX" != "Xg++"))) ; then
+      if test -n "$CXX" && ( test no != "$CXX" &&
+    ( (test g++ = "$CXX" && `g++ -v >/dev/null 2>&1` ) ||
+    (test g++ != "$CXX"))); then
   ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -13565,7 +14783,7 @@ objext_CXX=$objext
 # the CXX compiler isn't working.  Some variables (like enable_shared)
 # are currently assumed to apply to all compilers on this platform,
 # and will be corrupted by setting them based on a non-working compiler.
-if test "$_lt_caught_CXX_error" != yes; then
+if test yes != "$_lt_caught_CXX_error"; then
   # Code to be used in simple compile tests
   lt_simple_compile_test_code="int some_variable = 0;"
 
@@ -13626,46 +14844,39 @@ $RM -r conftest*
   CFLAGS=$CXXFLAGS
   compiler=$CC
   compiler_CXX=$CC
-  for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+  func_cc_basename $compiler
+cc_basename=$func_cc_basename_result
 
 
   if test -n "$compiler"; then
     # We don't want -fno-exception when compiling C++ code, so set the
     # no_builtin_flag separately
-    if test "$GXX" = yes; then
+    if test yes = "$GXX"; then
       lt_prog_compiler_no_builtin_flag_CXX=' -fno-builtin'
     else
       lt_prog_compiler_no_builtin_flag_CXX=
     fi
 
-    if test "$GXX" = yes; then
+    if test yes = "$GXX"; then
       # Set up default GNU C++ configuration
 
 
 
 # Check whether --with-gnu-ld was given.
 if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+  withval=$with_gnu_ld; test no = "$withval" || with_gnu_ld=yes
 else
   with_gnu_ld=no
 fi
 
 ac_prog=ld
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   # Check if gcc -print-prog-name=ld gives a path.
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
   *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
+    # gcc leaves a trailing carriage return, which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
     ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
@@ -13679,7 +14890,7 @@ $as_echo_n "checking for ld used by $CC... " >&6; }
       while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
 	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
       done
-      test -z "$LD" && LD="$ac_prog"
+      test -z "$LD" && LD=$ac_prog
       ;;
   "")
     # If it fails, then pretend we aren't using GCC.
@@ -13690,7 +14901,7 @@ $as_echo_n "checking for ld used by $CC... " >&6; }
     with_gnu_ld=unknown
     ;;
   esac
-elif test "$with_gnu_ld" = yes; then
+elif test yes = "$with_gnu_ld"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
 $as_echo_n "checking for GNU ld... " >&6; }
 else
@@ -13701,32 +14912,32 @@ if ${lt_cv_path_LD+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
   for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
     test -z "$ac_dir" && ac_dir=.
     if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
+      lt_cv_path_LD=$ac_dir/$ac_prog
       # Check to see if the program is GNU ld.  I'd rather use --version,
       # but apparently some variants of GNU ld only accept -v.
       # Break only if it was the GNU/non-GNU ld that we prefer.
       case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
       *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
+	test no != "$with_gnu_ld" && break
 	;;
       *)
-	test "$with_gnu_ld" != yes && break
+	test yes != "$with_gnu_ld" && break
 	;;
       esac
     fi
   done
-  IFS="$lt_save_ifs"
+  IFS=$lt_save_ifs
 else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+  lt_cv_path_LD=$LD # Let the user override the test with a path.
 fi
 fi
 
-LD="$lt_cv_path_LD"
+LD=$lt_cv_path_LD
 if test -n "$LD"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
 $as_echo "$LD" >&6; }
@@ -13762,22 +14973,22 @@ with_gnu_ld=$lt_cv_prog_gnu_ld
 
       # Check if GNU C++ uses GNU ld as the underlying linker, since the
       # archiving commands below assume that GNU ld is being used.
-      if test "$with_gnu_ld" = yes; then
-        archive_cmds_CXX='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-        archive_expsym_cmds_CXX='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      if test yes = "$with_gnu_ld"; then
+        archive_cmds_CXX='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+        archive_expsym_cmds_CXX='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 
-        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-        export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+        hardcode_libdir_flag_spec_CXX='$wl-rpath $wl$libdir'
+        export_dynamic_flag_spec_CXX='$wl--export-dynamic'
 
         # If archive_cmds runs LD, not CC, wlarc should be empty
         # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
         #     investigate it a little bit more. (MM)
-        wlarc='${wl}'
+        wlarc='$wl'
 
         # ancient GNU ld didn't support --whole-archive et. al.
         if eval "`$CC -print-prog-name=ld` --help 2>&1" |
 	  $GREP 'no-whole-archive' > /dev/null; then
-          whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+          whole_archive_flag_spec_CXX=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'
         else
           whole_archive_flag_spec_CXX=
         fi
@@ -13814,18 +15025,30 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
         ld_shlibs_CXX=no
         ;;
       aix[4-9]*)
-        if test "$host_cpu" = ia64; then
+        if test ia64 = "$host_cpu"; then
           # On IA64, the linker does run time linking by default, so we don't
           # have to do anything special.
           aix_use_runtimelinking=no
           exp_sym_flag='-Bexport'
-          no_entry_flag=""
+          no_entry_flag=
         else
           aix_use_runtimelinking=no
 
           # Test if we are trying to use run time linking or normal
           # AIX style linking. If -brtl is somewhere in LDFLAGS, we
-          # need to do runtime linking.
+          # have runtime linking enabled, and use it for executables.
+          # For shared libraries, we enable/disable runtime linking
+          # depending on the kind of the shared library created -
+          # when "with_aix_soname,aix_use_runtimelinking" is:
+          # "aix,no"   lib.a(lib.so.V) shared, rtl:no,  for executables
+          # "aix,yes"  lib.so          shared, rtl:yes, for executables
+          #            lib.a           static archive
+          # "both,no"  lib.so.V(shr.o) shared, rtl:yes
+          #            lib.a(lib.so.V) shared, rtl:no,  for executables
+          # "both,yes" lib.so.V(shr.o) shared, rtl:yes, for executables
+          #            lib.a(lib.so.V) shared, rtl:no
+          # "svr4,*"   lib.so.V(shr.o) shared, rtl:yes, for executables
+          #            lib.a           static archive
           case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
 	    for ld_flag in $LDFLAGS; do
 	      case $ld_flag in
@@ -13835,6 +15058,13 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
 	        ;;
 	      esac
 	    done
+	    if test svr4,no = "$with_aix_soname,$aix_use_runtimelinking"; then
+	      # With aix-soname=svr4, we create the lib.so.V shared archives only,
+	      # so we don't have lib.a shared libs to link our executables.
+	      # We have to force runtime linking in this case.
+	      aix_use_runtimelinking=yes
+	      LDFLAGS="$LDFLAGS -Wl,-brtl"
+	    fi
 	    ;;
           esac
 
@@ -13853,13 +15083,21 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
         hardcode_direct_absolute_CXX=yes
         hardcode_libdir_separator_CXX=':'
         link_all_deplibs_CXX=yes
-        file_list_spec_CXX='${wl}-f,'
+        file_list_spec_CXX='$wl-f,'
+        case $with_aix_soname,$aix_use_runtimelinking in
+        aix,*) ;;	# no import file
+        svr4,* | *,yes) # use import file
+          # The Import File defines what to hardcode.
+          hardcode_direct_CXX=no
+          hardcode_direct_absolute_CXX=no
+          ;;
+        esac
 
-        if test "$GXX" = yes; then
+        if test yes = "$GXX"; then
           case $host_os in aix4.[012]|aix4.[012].*)
           # We only want to do this on AIX 4.2 and lower, the check
           # below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
+	  collect2name=`$CC -print-prog-name=collect2`
 	  if test -f "$collect2name" &&
 	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
 	  then
@@ -13877,36 +15115,44 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
 	  fi
           esac
           shared_flag='-shared'
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag="$shared_flag "'${wl}-G'
+	  if test yes = "$aix_use_runtimelinking"; then
+	    shared_flag=$shared_flag' $wl-G'
 	  fi
+	  # Need to ensure runtime linking is disabled for the traditional
+	  # shared library, or the linker may eventually find shared libraries
+	  # /with/ Import File - we do not want to mix them.
+	  shared_flag_aix='-shared'
+	  shared_flag_svr4='-shared $wl-G'
         else
           # not using gcc
-          if test "$host_cpu" = ia64; then
+          if test ia64 = "$host_cpu"; then
 	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
 	  # chokes on -Wl,-G. The following line is correct:
 	  shared_flag='-G'
           else
-	    if test "$aix_use_runtimelinking" = yes; then
-	      shared_flag='${wl}-G'
+	    if test yes = "$aix_use_runtimelinking"; then
+	      shared_flag='$wl-G'
 	    else
-	      shared_flag='${wl}-bM:SRE'
+	      shared_flag='$wl-bM:SRE'
 	    fi
+	    shared_flag_aix='$wl-bM:SRE'
+	    shared_flag_svr4='$wl-G'
           fi
         fi
 
-        export_dynamic_flag_spec_CXX='${wl}-bexpall'
+        export_dynamic_flag_spec_CXX='$wl-bexpall'
         # It seems that -bexpall does not export symbols beginning with
         # underscore (_), so it is better to generate a list of symbols to
 	# export.
         always_export_symbols_CXX=yes
-        if test "$aix_use_runtimelinking" = yes; then
+	if test aix,yes = "$with_aix_soname,$aix_use_runtimelinking"; then
           # Warning - without using the other runtime loading flags (-brtl),
           # -berok will link without error, but may produce a broken library.
-          allow_undefined_flag_CXX='-berok'
+          # The "-G" linker flag allows undefined symbols.
+          no_undefined_flag_CXX='-bernotok'
           # Determine the default libpath from the value encoded in an empty
           # executable.
-          if test "${lt_cv_aix_libpath+set}" = set; then
+          if test set = "${lt_cv_aix_libpath+set}"; then
   aix_libpath=$lt_cv_aix_libpath
 else
   if ${lt_cv_aix_libpath__CXX+:} false; then :
@@ -13941,7 +15187,7 @@ fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
   if test -z "$lt_cv_aix_libpath__CXX"; then
-    lt_cv_aix_libpath__CXX="/usr/lib:/lib"
+    lt_cv_aix_libpath__CXX=/usr/lib:/lib
   fi
 
 fi
@@ -13949,18 +15195,18 @@ fi
   aix_libpath=$lt_cv_aix_libpath__CXX
 fi
 
-          hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+          hardcode_libdir_flag_spec_CXX='$wl-blibpath:$libdir:'"$aix_libpath"
 
-          archive_expsym_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+          archive_expsym_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n "$allow_undefined_flag"; then func_echo_all "$wl$allow_undefined_flag"; else :; fi` $wl'$exp_sym_flag:\$export_symbols' '$shared_flag
         else
-          if test "$host_cpu" = ia64; then
-	    hardcode_libdir_flag_spec_CXX='${wl}-R $libdir:/usr/lib:/lib'
+          if test ia64 = "$host_cpu"; then
+	    hardcode_libdir_flag_spec_CXX='$wl-R $libdir:/usr/lib:/lib'
 	    allow_undefined_flag_CXX="-z nodefs"
-	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\$wl$no_entry_flag"' $compiler_flags $wl$allow_undefined_flag '"\$wl$exp_sym_flag:\$export_symbols"
           else
 	    # Determine the default libpath from the value encoded in an
 	    # empty executable.
-	    if test "${lt_cv_aix_libpath+set}" = set; then
+	    if test set = "${lt_cv_aix_libpath+set}"; then
   aix_libpath=$lt_cv_aix_libpath
 else
   if ${lt_cv_aix_libpath__CXX+:} false; then :
@@ -13995,7 +15241,7 @@ fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
   if test -z "$lt_cv_aix_libpath__CXX"; then
-    lt_cv_aix_libpath__CXX="/usr/lib:/lib"
+    lt_cv_aix_libpath__CXX=/usr/lib:/lib
   fi
 
 fi
@@ -14003,22 +15249,34 @@ fi
   aix_libpath=$lt_cv_aix_libpath__CXX
 fi
 
-	    hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    hardcode_libdir_flag_spec_CXX='$wl-blibpath:$libdir:'"$aix_libpath"
 	    # Warning - without using the other run time loading flags,
 	    # -berok will link without error, but may produce a broken library.
-	    no_undefined_flag_CXX=' ${wl}-bernotok'
-	    allow_undefined_flag_CXX=' ${wl}-berok'
-	    if test "$with_gnu_ld" = yes; then
+	    no_undefined_flag_CXX=' $wl-bernotok'
+	    allow_undefined_flag_CXX=' $wl-berok'
+	    if test yes = "$with_gnu_ld"; then
 	      # We only use this code for GNU lds that support --whole-archive.
-	      whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	      whole_archive_flag_spec_CXX='$wl--whole-archive$convenience $wl--no-whole-archive'
 	    else
 	      # Exported symbols can be pulled into shared objects from archives
 	      whole_archive_flag_spec_CXX='$convenience'
 	    fi
 	    archive_cmds_need_lc_CXX=yes
-	    # This is similar to how AIX traditionally builds its shared
-	    # libraries.
-	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	    archive_expsym_cmds_CXX='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'
+	    # -brtl affects multiple linker settings, -berok does not and is overridden later
+	    compiler_flags_filtered='`func_echo_all "$compiler_flags " | $SED -e "s%-brtl\\([, ]\\)%-berok\\1%g"`'
+	    if test svr4 != "$with_aix_soname"; then
+	      # This is similar to how AIX traditionally builds its shared
+	      # libraries. Need -bnortl late, we may have -brtl in LDFLAGS.
+	      archive_expsym_cmds_CXX="$archive_expsym_cmds_CXX"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'
+	    fi
+	    if test aix != "$with_aix_soname"; then
+	      archive_expsym_cmds_CXX="$archive_expsym_cmds_CXX"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all "#! $soname($shared_archive_member_spec.o)"; if test shr_64 = "$shared_archive_member_spec"; then func_echo_all "# 64"; else func_echo_all "# 32"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'
+	    else
+	      # used by -dlpreopen to get the symbols
+	      archive_expsym_cmds_CXX="$archive_expsym_cmds_CXX"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'
+	    fi
+	    archive_expsym_cmds_CXX="$archive_expsym_cmds_CXX"'~$RM -r $output_objdir/$realname.d'
           fi
         fi
         ;;
@@ -14028,7 +15286,7 @@ fi
 	  allow_undefined_flag_CXX=unsupported
 	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
 	  # support --undefined.  This deserves some investigation.  FIXME
-	  archive_cmds_CXX='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	  archive_cmds_CXX='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
 	else
 	  ld_shlibs_CXX=no
 	fi
@@ -14056,57 +15314,58 @@ fi
 	  # Tell ltmain to make .lib files, not .a files.
 	  libext=lib
 	  # Tell ltmain to make .dll files, not .so files.
-	  shrext_cmds=".dll"
+	  shrext_cmds=.dll
 	  # FIXME: Setting linknames here is a bad hack.
-	  archive_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
-	  archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	      $SED -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
-	    else
-	      $SED -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
-	    fi~
-	    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
-	    linknames='
+	  archive_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~linknames='
+	  archive_expsym_cmds_CXX='if   test DEF = "`$SED -n     -e '\''s/^[	 ]*//'\''     -e '\''/^\(;.*\)*$/d'\''     -e '\''s/^\(EXPORTS\|LIBRARY\)\([	 ].*\)*$/DEF/p'\''     -e q     $export_symbols`" ; then
+              cp "$export_symbols" "$output_objdir/$soname.def";
+              echo "$tool_output_objdir$soname.def" > "$output_objdir/$soname.exp";
+            else
+              $SED -e '\''s/^/-link -EXPORT:/'\'' < $export_symbols > $output_objdir/$soname.exp;
+            fi~
+            $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+            linknames='
 	  # The linker will not automatically build a static lib if we build a DLL.
 	  # _LT_TAGVAR(old_archive_from_new_cmds, CXX)='true'
 	  enable_shared_with_static_runtimes_CXX=yes
 	  # Don't use ranlib
 	  old_postinstall_cmds_CXX='chmod 644 $oldlib'
 	  postlink_cmds_CXX='lt_outputfile="@OUTPUT@"~
-	    lt_tool_outputfile="@TOOL_OUTPUT@"~
-	    case $lt_outputfile in
-	      *.exe|*.EXE) ;;
-	      *)
-		lt_outputfile="$lt_outputfile.exe"
-		lt_tool_outputfile="$lt_tool_outputfile.exe"
-		;;
-	    esac~
-	    func_to_tool_file "$lt_outputfile"~
-	    if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
-	      $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
-	      $RM "$lt_outputfile.manifest";
-	    fi'
+            lt_tool_outputfile="@TOOL_OUTPUT@"~
+            case $lt_outputfile in
+              *.exe|*.EXE) ;;
+              *)
+                lt_outputfile=$lt_outputfile.exe
+                lt_tool_outputfile=$lt_tool_outputfile.exe
+                ;;
+            esac~
+            func_to_tool_file "$lt_outputfile"~
+            if test : != "$MANIFEST_TOOL" && test -f "$lt_outputfile.manifest"; then
+              $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+              $RM "$lt_outputfile.manifest";
+            fi'
 	  ;;
 	*)
 	  # g++
 	  # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
 	  # as there is no search path for DLLs.
 	  hardcode_libdir_flag_spec_CXX='-L$libdir'
-	  export_dynamic_flag_spec_CXX='${wl}--export-all-symbols'
+	  export_dynamic_flag_spec_CXX='$wl--export-all-symbols'
 	  allow_undefined_flag_CXX=unsupported
 	  always_export_symbols_CXX=no
 	  enable_shared_with_static_runtimes_CXX=yes
 
 	  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-	    archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	    # If the export-symbols file already is a .def file (1st line
-	    # is EXPORTS), use it as is; otherwise, prepend...
-	    archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	      cp $export_symbols $output_objdir/$soname.def;
-	    else
-	      echo EXPORTS > $output_objdir/$soname.def;
-	      cat $export_symbols >> $output_objdir/$soname.def;
-	    fi~
-	    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	    archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	    # If the export-symbols file already is a .def file, use it as
+	    # is; otherwise, prepend EXPORTS...
+	    archive_expsym_cmds_CXX='if   test DEF = "`$SED -n     -e '\''s/^[	 ]*//'\''     -e '\''/^\(;.*\)*$/d'\''     -e '\''s/^\(EXPORTS\|LIBRARY\)\([	 ].*\)*$/DEF/p'\''     -e q     $export_symbols`" ; then
+              cp $export_symbols $output_objdir/$soname.def;
+            else
+              echo EXPORTS > $output_objdir/$soname.def;
+              cat $export_symbols >> $output_objdir/$soname.def;
+            fi~
+            $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
 	  else
 	    ld_shlibs_CXX=no
 	  fi
@@ -14120,27 +15379,27 @@ fi
   hardcode_direct_CXX=no
   hardcode_automatic_CXX=yes
   hardcode_shlibpath_var_CXX=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    whole_archive_flag_spec_CXX='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  if test yes = "$lt_cv_ld_force_load"; then
+    whole_archive_flag_spec_CXX='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience $wl-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
 
   else
     whole_archive_flag_spec_CXX=''
   fi
   link_all_deplibs_CXX=yes
-  allow_undefined_flag_CXX="$_lt_dar_allow_undefined"
+  allow_undefined_flag_CXX=$_lt_dar_allow_undefined
   case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
+     ifort*|nagfor*) _lt_dar_can_shared=yes ;;
      *) _lt_dar_can_shared=$GCC ;;
   esac
-  if test "$_lt_dar_can_shared" = "yes"; then
+  if test yes = "$_lt_dar_can_shared"; then
     output_verbose_link_cmd=func_echo_all
-    archive_cmds_CXX="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds_CXX="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds_CXX="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-       if test "$lt_cv_apple_cc_single_mod" != "yes"; then
-      archive_cmds_CXX="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
-      archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    archive_cmds_CXX="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod$_lt_dsymutil"
+    module_cmds_CXX="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags$_lt_dsymutil"
+    archive_expsym_cmds_CXX="sed 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod$_lt_dar_export_syms$_lt_dsymutil"
+    module_expsym_cmds_CXX="sed -e 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags$_lt_dar_export_syms$_lt_dsymutil"
+       if test yes != "$lt_cv_apple_cc_single_mod"; then
+      archive_cmds_CXX="\$CC -r -keep_private_externs -nostdlib -o \$lib-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$lib-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring$_lt_dsymutil"
+      archive_expsym_cmds_CXX="sed 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \$lib-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$lib-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring$_lt_dar_export_syms$_lt_dsymutil"
     fi
 
   else
@@ -14149,6 +15408,34 @@ fi
 
 	;;
 
+      os2*)
+	hardcode_libdir_flag_spec_CXX='-L$libdir'
+	hardcode_minus_L_CXX=yes
+	allow_undefined_flag_CXX=unsupported
+	shrext_cmds=.dll
+	archive_cmds_CXX='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	  $ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	  $ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	  $ECHO EXPORTS >> $output_objdir/$libname.def~
+	  emxexp $libobjs | $SED /"_DLL_InitTerm"/d >> $output_objdir/$libname.def~
+	  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	  emximp -o $lib $output_objdir/$libname.def'
+	archive_expsym_cmds_CXX='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	  $ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	  $ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	  $ECHO EXPORTS >> $output_objdir/$libname.def~
+	  prefix_cmds="$SED"~
+	  if test EXPORTS = "`$SED 1q $export_symbols`"; then
+	    prefix_cmds="$prefix_cmds -e 1d";
+	  fi~
+	  prefix_cmds="$prefix_cmds -e \"s/^\(.*\)$/_\1/g\""~
+	  cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~
+	  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	  emximp -o $lib $output_objdir/$libname.def'
+	old_archive_From_new_cmds_CXX='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'
+	enable_shared_with_static_runtimes_CXX=yes
+	;;
+
       dgux*)
         case $cc_basename in
           ec++*)
@@ -14184,14 +15471,14 @@ fi
         ;;
 
       haiku*)
-        archive_cmds_CXX='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        archive_cmds_CXX='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
         link_all_deplibs_CXX=yes
         ;;
 
       hpux9*)
-        hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+        hardcode_libdir_flag_spec_CXX='$wl+b $wl$libdir'
         hardcode_libdir_separator_CXX=:
-        export_dynamic_flag_spec_CXX='${wl}-E'
+        export_dynamic_flag_spec_CXX='$wl-E'
         hardcode_direct_CXX=yes
         hardcode_minus_L_CXX=yes # Not in the search PATH,
 				             # but as the default
@@ -14203,7 +15490,7 @@ fi
             ld_shlibs_CXX=no
             ;;
           aCC*)
-            archive_cmds_CXX='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            archive_cmds_CXX='$RM $output_objdir/$soname~$CC -b $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
             # Commands to make compiler produce verbose output that lists
             # what "hidden" libraries, object files and flags are used when
             # linking a shared library.
@@ -14212,11 +15499,11 @@ fi
             # explicitly linking system object files so we need to strip them
             # from the output so that they don't get included in the library
             # dependencies.
-            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
             ;;
           *)
-            if test "$GXX" = yes; then
-              archive_cmds_CXX='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            if test yes = "$GXX"; then
+              archive_cmds_CXX='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
             else
               # FIXME: insert proper C++ library support
               ld_shlibs_CXX=no
@@ -14226,15 +15513,15 @@ fi
         ;;
 
       hpux10*|hpux11*)
-        if test $with_gnu_ld = no; then
-	  hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+        if test no = "$with_gnu_ld"; then
+	  hardcode_libdir_flag_spec_CXX='$wl+b $wl$libdir'
 	  hardcode_libdir_separator_CXX=:
 
           case $host_cpu in
             hppa*64*|ia64*)
               ;;
             *)
-	      export_dynamic_flag_spec_CXX='${wl}-E'
+	      export_dynamic_flag_spec_CXX='$wl-E'
               ;;
           esac
         fi
@@ -14260,13 +15547,13 @@ fi
           aCC*)
 	    case $host_cpu in
 	      hppa*64*)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        archive_cmds_CXX='$CC -b $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	        ;;
 	      ia64*)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        archive_cmds_CXX='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	        ;;
 	      *)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        archive_cmds_CXX='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	        ;;
 	    esac
 	    # Commands to make compiler produce verbose output that lists
@@ -14277,20 +15564,20 @@ fi
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
 	    ;;
           *)
-	    if test "$GXX" = yes; then
-	      if test $with_gnu_ld = no; then
+	    if test yes = "$GXX"; then
+	      if test no = "$with_gnu_ld"; then
 	        case $host_cpu in
 	          hppa*64*)
-	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	            ;;
 	          ia64*)
-	            archive_cmds_CXX='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            archive_cmds_CXX='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	            ;;
 	          *)
-	            archive_cmds_CXX='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            archive_cmds_CXX='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	            ;;
 	        esac
 	      fi
@@ -14305,22 +15592,22 @@ fi
       interix[3-9]*)
 	hardcode_direct_CXX=no
 	hardcode_shlibpath_var_CXX=no
-	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	export_dynamic_flag_spec_CXX='${wl}-E'
+	hardcode_libdir_flag_spec_CXX='$wl-rpath,$libdir'
+	export_dynamic_flag_spec_CXX='$wl-E'
 	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
 	# Instead, shared libraries are loaded at an image base (0x10000000 by
 	# default) and relocated if they conflict, which is a slow very memory
 	# consuming and fragmenting process.  To avoid this, we pick a random,
 	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
 	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-	archive_cmds_CXX='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-	archive_expsym_cmds_CXX='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	archive_cmds_CXX='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	archive_expsym_cmds_CXX='sed "s|^|_|" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
 	;;
       irix5* | irix6*)
         case $cc_basename in
           CC*)
 	    # SGI C++
-	    archive_cmds_CXX='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	    archive_cmds_CXX='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
 
 	    # Archives containing C++ object files must be created using
 	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
@@ -14329,17 +15616,17 @@ fi
 	    old_archive_cmds_CXX='$CC -ar -WR,-u -o $oldlib $oldobjs'
 	    ;;
           *)
-	    if test "$GXX" = yes; then
-	      if test "$with_gnu_ld" = no; then
-	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	    if test yes = "$GXX"; then
+	      if test no = "$with_gnu_ld"; then
+	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 	      else
-	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` -o $lib'
+	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` -o $lib'
 	      fi
 	    fi
 	    link_all_deplibs_CXX=yes
 	    ;;
         esac
-        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+        hardcode_libdir_flag_spec_CXX='$wl-rpath $wl$libdir'
         hardcode_libdir_separator_CXX=:
         inherit_rpath_CXX=yes
         ;;
@@ -14352,8 +15639,8 @@ fi
 	    # KCC will only create a shared library if the output file
 	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
 	    # to its proper name (with version) after linking.
-	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
-	    archive_expsym_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\$tempext\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    archive_expsym_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\$tempext\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib $wl-retain-symbols-file,$export_symbols; mv \$templib $lib'
 	    # Commands to make compiler produce verbose output that lists
 	    # what "hidden" libraries, object files and flags are used when
 	    # linking a shared library.
@@ -14362,10 +15649,10 @@ fi
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
 
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	    hardcode_libdir_flag_spec_CXX='$wl-rpath,$libdir'
+	    export_dynamic_flag_spec_CXX='$wl--export-dynamic'
 
 	    # Archives containing C++ object files must be created using
 	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
@@ -14379,59 +15666,59 @@ fi
 	    # earlier do not add the objects themselves.
 	    case `$CC -V 2>&1` in
 	      *"Version 7."*)
-	        archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	        archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+		archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 		;;
 	      *)  # Version 8.0 or newer
 	        tmp_idyn=
 	        case $host_cpu in
 		  ia64*) tmp_idyn=' -i_dynamic';;
 		esac
-	        archive_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		archive_expsym_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	        archive_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+		archive_expsym_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 		;;
 	    esac
 	    archive_cmds_need_lc_CXX=no
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    hardcode_libdir_flag_spec_CXX='$wl-rpath,$libdir'
+	    export_dynamic_flag_spec_CXX='$wl--export-dynamic'
+	    whole_archive_flag_spec_CXX='$wl--whole-archive$convenience $wl--no-whole-archive'
 	    ;;
           pgCC* | pgcpp*)
             # Portland Group C++ compiler
 	    case `$CC -V` in
 	    *pgCC\ [1-5].* | *pgcpp\ [1-5].*)
 	      prelink_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
-		compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
+               rm -rf $tpldir~
+               $CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+               compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
 	      old_archive_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
-		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
-		$RANLIB $oldlib'
+                rm -rf $tpldir~
+                $CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+                $AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
+                $RANLIB $oldlib'
 	      archive_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+                rm -rf $tpldir~
+                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
 	      archive_expsym_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+                rm -rf $tpldir~
+                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 	      ;;
 	    *) # Version 6 and above use weak symbols
-	      archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
-	      archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+	      archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 	      ;;
 	    esac
 
-	    hardcode_libdir_flag_spec_CXX='${wl}--rpath ${wl}$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    whole_archive_flag_spec_CXX='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	    hardcode_libdir_flag_spec_CXX='$wl--rpath $wl$libdir'
+	    export_dynamic_flag_spec_CXX='$wl--export-dynamic'
+	    whole_archive_flag_spec_CXX='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
             ;;
 	  cxx*)
 	    # Compaq C++
-	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+	    archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname  -o $lib $wl-retain-symbols-file $wl$export_symbols'
 
 	    runpath_var=LD_RUN_PATH
 	    hardcode_libdir_flag_spec_CXX='-rpath $libdir'
@@ -14445,18 +15732,18 @@ fi
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
 	    ;;
 	  xl* | mpixl* | bgxl*)
 	    # IBM XL 8.0 on PPC, with GNU ld
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    archive_cmds_CXX='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    if test "x$supports_anon_versioning" = xyes; then
+	    hardcode_libdir_flag_spec_CXX='$wl-rpath $wl$libdir'
+	    export_dynamic_flag_spec_CXX='$wl--export-dynamic'
+	    archive_cmds_CXX='$CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	    if test yes = "$supports_anon_versioning"; then
 	      archive_expsym_cmds_CXX='echo "{ global:" > $output_objdir/$libname.ver~
-		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-		echo "local: *; };" >> $output_objdir/$libname.ver~
-		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+                cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+                echo "local: *; };" >> $output_objdir/$libname.ver~
+                $CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'
 	    fi
 	    ;;
 	  *)
@@ -14464,10 +15751,10 @@ fi
 	    *Sun\ C*)
 	      # Sun C++ 5.9
 	      no_undefined_flag_CXX=' -zdefs'
-	      archive_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	      archive_expsym_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      archive_cmds_CXX='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      archive_expsym_cmds_CXX='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file $wl$export_symbols'
 	      hardcode_libdir_flag_spec_CXX='-R$libdir'
-	      whole_archive_flag_spec_CXX='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	      whole_archive_flag_spec_CXX='$wl--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	      compiler_needs_object_CXX=yes
 
 	      # Not sure whether something based on
@@ -14525,22 +15812,17 @@ fi
         ld_shlibs_CXX=yes
 	;;
 
-      openbsd2*)
-        # C++ shared libraries are fairly broken
-	ld_shlibs_CXX=no
-	;;
-
-      openbsd*)
+      openbsd* | bitrig*)
 	if test -f /usr/libexec/ld.so; then
 	  hardcode_direct_CXX=yes
 	  hardcode_shlibpath_var_CXX=no
 	  hardcode_direct_absolute_CXX=yes
 	  archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
-	  hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	    archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
-	    export_dynamic_flag_spec_CXX='${wl}-E'
-	    whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  hardcode_libdir_flag_spec_CXX='$wl-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`"; then
+	    archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file,$export_symbols -o $lib'
+	    export_dynamic_flag_spec_CXX='$wl-E'
+	    whole_archive_flag_spec_CXX=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'
 	  fi
 	  output_verbose_link_cmd=func_echo_all
 	else
@@ -14556,9 +15838,9 @@ fi
 	    # KCC will only create a shared library if the output file
 	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
 	    # to its proper name (with version) after linking.
-	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\$tempext\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
 
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	    hardcode_libdir_flag_spec_CXX='$wl-rpath,$libdir'
 	    hardcode_libdir_separator_CXX=:
 
 	    # Archives containing C++ object files must be created using
@@ -14576,17 +15858,17 @@ fi
           cxx*)
 	    case $host in
 	      osf3*)
-	        allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
-	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && func_echo_all "${wl}-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	        allow_undefined_flag_CXX=' $wl-expect_unresolved $wl\*'
+	        archive_cmds_CXX='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $soname `test -n "$verstring" && func_echo_all "$wl-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
+	        hardcode_libdir_flag_spec_CXX='$wl-rpath $wl$libdir'
 		;;
 	      *)
 	        allow_undefined_flag_CXX=' -expect_unresolved \*'
-	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        archive_cmds_CXX='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
 	        archive_expsym_cmds_CXX='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
-	          echo "-hidden">> $lib.exp~
-	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
-	          $RM $lib.exp'
+                  echo "-hidden">> $lib.exp~
+                  $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname $wl-input $wl$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib~
+                  $RM $lib.exp'
 	        hardcode_libdir_flag_spec_CXX='-rpath $libdir'
 		;;
 	    esac
@@ -14601,21 +15883,21 @@ fi
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
 	    ;;
 	  *)
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	    if test yes,no = "$GXX,$with_gnu_ld"; then
+	      allow_undefined_flag_CXX=' $wl-expect_unresolved $wl\*'
 	      case $host in
 	        osf3*)
-	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	          archive_cmds_CXX='$CC -shared -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 		  ;;
 	        *)
-	          archive_cmds_CXX='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	          archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-msym $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 		  ;;
 	      esac
 
-	      hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	      hardcode_libdir_flag_spec_CXX='$wl-rpath $wl$libdir'
 	      hardcode_libdir_separator_CXX=:
 
 	      # Commands to make compiler produce verbose output that lists
@@ -14661,9 +15943,9 @@ fi
 	    # Sun C++ 4.2, 5.x and Centerline C++
             archive_cmds_need_lc_CXX=yes
 	    no_undefined_flag_CXX=' -zdefs'
-	    archive_cmds_CXX='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    archive_cmds_CXX='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	    archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+              $CC -G$allow_undefined_flag $wl-M $wl$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
 
 	    hardcode_libdir_flag_spec_CXX='-R$libdir'
 	    hardcode_shlibpath_var_CXX=no
@@ -14671,7 +15953,7 @@ fi
 	      solaris2.[0-5] | solaris2.[0-5].*) ;;
 	      *)
 		# The compiler driver will combine and reorder linker options,
-		# but understands `-z linker_flag'.
+		# but understands '-z linker_flag'.
 	        # Supported since Solaris 2.6 (maybe 2.5.1?)
 		whole_archive_flag_spec_CXX='-z allextract$convenience -z defaultextract'
 	        ;;
@@ -14688,30 +15970,30 @@ fi
 	    ;;
           gcx*)
 	    # Green Hills C++ Compiler
-	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'
 
 	    # The C++ compiler must be used to create the archive.
 	    old_archive_cmds_CXX='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
 	    ;;
           *)
 	    # GNU C++ compiler with Solaris linker
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      no_undefined_flag_CXX=' ${wl}-z ${wl}defs'
+	    if test yes,no = "$GXX,$with_gnu_ld"; then
+	      no_undefined_flag_CXX=' $wl-z ${wl}defs'
 	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
-	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'
 	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+                  $CC -shared $pic_flag -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
 
 	        # Commands to make compiler produce verbose output that lists
 	        # what "hidden" libraries, object files and flags are used when
 	        # linking a shared library.
 	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
 	      else
-	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # g++ 2.7 appears to require '-G' NOT '-shared' on this
 	        # platform.
-	        archive_cmds_CXX='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        archive_cmds_CXX='$CC -G -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'
 	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+                  $CC -G -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
 
 	        # Commands to make compiler produce verbose output that lists
 	        # what "hidden" libraries, object files and flags are used when
@@ -14719,11 +16001,11 @@ fi
 	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
 	      fi
 
-	      hardcode_libdir_flag_spec_CXX='${wl}-R $wl$libdir'
+	      hardcode_libdir_flag_spec_CXX='$wl-R $wl$libdir'
 	      case $host_os in
 		solaris2.[0-5] | solaris2.[0-5].*) ;;
 		*)
-		  whole_archive_flag_spec_CXX='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  whole_archive_flag_spec_CXX='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'
 		  ;;
 	      esac
 	    fi
@@ -14732,52 +16014,52 @@ fi
         ;;
 
     sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag_CXX='${wl}-z,text'
+      no_undefined_flag_CXX='$wl-z,text'
       archive_cmds_need_lc_CXX=no
       hardcode_shlibpath_var_CXX=no
       runpath_var='LD_RUN_PATH'
 
       case $cc_basename in
         CC*)
-	  archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_cmds_CXX='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds_CXX='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	*)
-	  archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_cmds_CXX='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds_CXX='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
       esac
       ;;
 
       sysv5* | sco3.2v5* | sco5v6*)
-	# Note: We can NOT use -z defs as we might desire, because we do not
+	# Note: We CANNOT use -z defs as we might desire, because we do not
 	# link with -lc, and that would cause any symbols used from libc to
 	# always be unresolved, which means just about no library would
 	# ever link correctly.  If we're not using GNU ld we use -z text
 	# though, which does catch some bad symbols but isn't as heavy-handed
 	# as -z defs.
-	no_undefined_flag_CXX='${wl}-z,text'
-	allow_undefined_flag_CXX='${wl}-z,nodefs'
+	no_undefined_flag_CXX='$wl-z,text'
+	allow_undefined_flag_CXX='$wl-z,nodefs'
 	archive_cmds_need_lc_CXX=no
 	hardcode_shlibpath_var_CXX=no
-	hardcode_libdir_flag_spec_CXX='${wl}-R,$libdir'
+	hardcode_libdir_flag_spec_CXX='$wl-R,$libdir'
 	hardcode_libdir_separator_CXX=':'
 	link_all_deplibs_CXX=yes
-	export_dynamic_flag_spec_CXX='${wl}-Bexport'
+	export_dynamic_flag_spec_CXX='$wl-Bexport'
 	runpath_var='LD_RUN_PATH'
 
 	case $cc_basename in
           CC*)
-	    archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_cmds_CXX='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_expsym_cmds_CXX='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	    old_archive_cmds_CXX='$CC -Tprelink_objects $oldobjs~
-	      '"$old_archive_cmds_CXX"
+              '"$old_archive_cmds_CXX"
 	    reload_cmds_CXX='$CC -Tprelink_objects $reload_objs~
-	      '"$reload_cmds_CXX"
+              '"$reload_cmds_CXX"
 	    ;;
 	  *)
-	    archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_cmds_CXX='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_expsym_cmds_CXX='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	    ;;
 	esac
       ;;
@@ -14809,10 +16091,10 @@ fi
 
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
 $as_echo "$ld_shlibs_CXX" >&6; }
-    test "$ld_shlibs_CXX" = no && can_build_shared=no
+    test no = "$ld_shlibs_CXX" && can_build_shared=no
 
-    GCC_CXX="$GXX"
-    LD_CXX="$LD"
+    GCC_CXX=$GXX
+    LD_CXX=$LD
 
     ## CAVEAT EMPTOR:
     ## There is no encapsulation within the following macros, do not change
@@ -14856,13 +16138,13 @@ if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   pre_test_object_deps_done=no
 
   for p in `eval "$output_verbose_link_cmd"`; do
-    case ${prev}${p} in
+    case $prev$p in
 
     -L* | -R* | -l*)
        # Some compilers place space between "-{L,R}" and the path.
        # Remove the space.
-       if test $p = "-L" ||
-          test $p = "-R"; then
+       if test x-L = "$p" ||
+          test x-R = "$p"; then
 	 prev=$p
 	 continue
        fi
@@ -14878,16 +16160,16 @@ if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
        case $p in
        =*) func_stripname_cnf '=' '' "$p"; p=$lt_sysroot$func_stripname_result ;;
        esac
-       if test "$pre_test_object_deps_done" = no; then
-	 case ${prev} in
+       if test no = "$pre_test_object_deps_done"; then
+	 case $prev in
 	 -L | -R)
 	   # Internal compiler library paths should come after those
 	   # provided the user.  The postdeps already come after the
 	   # user supplied libs so there is no need to process them.
 	   if test -z "$compiler_lib_search_path_CXX"; then
-	     compiler_lib_search_path_CXX="${prev}${p}"
+	     compiler_lib_search_path_CXX=$prev$p
 	   else
-	     compiler_lib_search_path_CXX="${compiler_lib_search_path_CXX} ${prev}${p}"
+	     compiler_lib_search_path_CXX="${compiler_lib_search_path_CXX} $prev$p"
 	   fi
 	   ;;
 	 # The "-l" case would never come before the object being
@@ -14895,9 +16177,9 @@ if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
 	 esac
        else
 	 if test -z "$postdeps_CXX"; then
-	   postdeps_CXX="${prev}${p}"
+	   postdeps_CXX=$prev$p
 	 else
-	   postdeps_CXX="${postdeps_CXX} ${prev}${p}"
+	   postdeps_CXX="${postdeps_CXX} $prev$p"
 	 fi
        fi
        prev=
@@ -14912,15 +16194,15 @@ if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
 	 continue
        fi
 
-       if test "$pre_test_object_deps_done" = no; then
+       if test no = "$pre_test_object_deps_done"; then
 	 if test -z "$predep_objects_CXX"; then
-	   predep_objects_CXX="$p"
+	   predep_objects_CXX=$p
 	 else
 	   predep_objects_CXX="$predep_objects_CXX $p"
 	 fi
        else
 	 if test -z "$postdep_objects_CXX"; then
-	   postdep_objects_CXX="$p"
+	   postdep_objects_CXX=$p
 	 else
 	   postdep_objects_CXX="$postdep_objects_CXX $p"
 	 fi
@@ -14950,51 +16232,6 @@ interix[3-9]*)
   postdep_objects_CXX=
   postdeps_CXX=
   ;;
-
-linux*)
-  case `$CC -V 2>&1 | sed 5q` in
-  *Sun\ C*)
-    # Sun C++ 5.9
-
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
-      ;;
-    esac
-
-    if test "$solaris_use_stlport4" != yes; then
-      postdeps_CXX='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
-
-solaris*)
-  case $cc_basename in
-  CC* | sunCC*)
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
-      ;;
-    esac
-
-    # Adding this requires a known-good setup of shared libraries for
-    # Sun compiler versions before 5.6, else PIC objects from an old
-    # archive will be linked into the output, leading to subtle bugs.
-    if test "$solaris_use_stlport4" != yes; then
-      postdeps_CXX='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
 esac
 
 
@@ -15003,7 +16240,7 @@ case " $postdeps_CXX " in
 esac
  compiler_lib_search_dirs_CXX=
 if test -n "${compiler_lib_search_path_CXX}"; then
- compiler_lib_search_dirs_CXX=`echo " ${compiler_lib_search_path_CXX}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+ compiler_lib_search_dirs_CXX=`echo " ${compiler_lib_search_path_CXX}" | $SED -e 's! -L! !g' -e 's!^ !!'`
 fi
 
 
@@ -15042,17 +16279,18 @@ lt_prog_compiler_static_CXX=
 
 
   # C++ specific cases for pic, static, wl, etc.
-  if test "$GXX" = yes; then
+  if test yes = "$GXX"; then
     lt_prog_compiler_wl_CXX='-Wl,'
     lt_prog_compiler_static_CXX='-static'
 
     case $host_os in
     aix*)
       # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# AIX 5 now supports IA64 processor
 	lt_prog_compiler_static_CXX='-Bstatic'
       fi
+      lt_prog_compiler_pic_CXX='-fPIC'
       ;;
 
     amigaos*)
@@ -15063,8 +16301,8 @@ lt_prog_compiler_static_CXX=
         ;;
       m68k)
             # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
+            # adding the '-m68020' flag to GCC prevents building anything better,
+            # like '-m68040'.
             lt_prog_compiler_pic_CXX='-m68020 -resident32 -malways-restore-a4'
         ;;
       esac
@@ -15079,6 +16317,11 @@ lt_prog_compiler_static_CXX=
       # Although the cygwin gcc ignores -fPIC, still need this for old-style
       # (--disable-auto-import) libraries
       lt_prog_compiler_pic_CXX='-DDLL_EXPORT'
+      case $host_os in
+      os2*)
+	lt_prog_compiler_static_CXX='$wl-static'
+	;;
+      esac
       ;;
     darwin* | rhapsody*)
       # PIC is the default on this platform
@@ -15128,7 +16371,7 @@ lt_prog_compiler_static_CXX=
     case $host_os in
       aix[4-9]*)
 	# All AIX code is PIC.
-	if test "$host_cpu" = ia64; then
+	if test ia64 = "$host_cpu"; then
 	  # AIX 5 now supports IA64 processor
 	  lt_prog_compiler_static_CXX='-Bstatic'
 	else
@@ -15168,14 +16411,14 @@ lt_prog_compiler_static_CXX=
 	case $cc_basename in
 	  CC*)
 	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
-	    if test "$host_cpu" != ia64; then
+	    lt_prog_compiler_static_CXX='$wl-a ${wl}archive'
+	    if test ia64 != "$host_cpu"; then
 	      lt_prog_compiler_pic_CXX='+Z'
 	    fi
 	    ;;
 	  aCC*)
 	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
+	    lt_prog_compiler_static_CXX='$wl-a ${wl}archive'
 	    case $host_cpu in
 	    hppa*64*|ia64*)
 	      # +Z the default
@@ -15212,7 +16455,7 @@ lt_prog_compiler_static_CXX=
 	    lt_prog_compiler_pic_CXX='-fPIC'
 	    ;;
 	  ecpc* )
-	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    # old Intel C++ for x86_64, which still supported -KPIC.
 	    lt_prog_compiler_wl_CXX='-Wl,'
 	    lt_prog_compiler_pic_CXX='-KPIC'
 	    lt_prog_compiler_static_CXX='-static'
@@ -15357,7 +16600,7 @@ lt_prog_compiler_static_CXX=
   fi
 
 case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
+  # For platforms that do not support PIC, -DPIC is meaningless:
   *djgpp*)
     lt_prog_compiler_pic_CXX=
     ;;
@@ -15389,7 +16632,7 @@ else
   lt_cv_prog_compiler_pic_works_CXX=no
    ac_outfile=conftest.$ac_objext
    echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic_CXX -DPIC"
+   lt_compiler_flag="$lt_prog_compiler_pic_CXX -DPIC"  ## exclude from sc_useless_quotes_in_assignment
    # Insert the option either (1) after the last *FLAGS variable, or
    # (2) before a word containing "conftest.", or (3) at the end.
    # Note that $ac_compile itself does not contain backslashes and begins
@@ -15419,7 +16662,7 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works_CXX" >&5
 $as_echo "$lt_cv_prog_compiler_pic_works_CXX" >&6; }
 
-if test x"$lt_cv_prog_compiler_pic_works_CXX" = xyes; then
+if test yes = "$lt_cv_prog_compiler_pic_works_CXX"; then
     case $lt_prog_compiler_pic_CXX in
      "" | " "*) ;;
      *) lt_prog_compiler_pic_CXX=" $lt_prog_compiler_pic_CXX" ;;
@@ -15445,7 +16688,7 @@ if ${lt_cv_prog_compiler_static_works_CXX+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler_static_works_CXX=no
-   save_LDFLAGS="$LDFLAGS"
+   save_LDFLAGS=$LDFLAGS
    LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
    echo "$lt_simple_link_test_code" > conftest.$ac_ext
    if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
@@ -15464,13 +16707,13 @@ else
      fi
    fi
    $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+   LDFLAGS=$save_LDFLAGS
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works_CXX" >&5
 $as_echo "$lt_cv_prog_compiler_static_works_CXX" >&6; }
 
-if test x"$lt_cv_prog_compiler_static_works_CXX" = xyes; then
+if test yes = "$lt_cv_prog_compiler_static_works_CXX"; then
     :
 else
     lt_prog_compiler_static_CXX=
@@ -15584,8 +16827,8 @@ $as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
 
 
 
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o_CXX" = no && test "$need_locks" != no; then
+hard_links=nottested
+if test no = "$lt_cv_prog_compiler_c_o_CXX" && test no != "$need_locks"; then
   # do not overwrite the value of need_locks provided by the user
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
 $as_echo_n "checking if we can lock with hard links... " >&6; }
@@ -15597,9 +16840,9 @@ $as_echo_n "checking if we can lock with hard links... " >&6; }
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
 $as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+  if test no = "$hard_links"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: '$CC' does not support '-c -o', so 'make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: '$CC' does not support '-c -o', so 'make -j' may be unsafe" >&2;}
     need_locks=warn
   fi
 else
@@ -15616,17 +16859,21 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
   case $host_os in
   aix[4-9]*)
     # If we're using GNU nm, then we don't want the "-C" option.
-    # -C means demangle to AIX nm, but means don't demangle with GNU nm
-    # Also, AIX nm treats weak defined symbols like other global defined
-    # symbols, whereas GNU nm marks them as "W".
+    # -C means demangle to GNU nm, but means don't demangle to AIX nm.
+    # Without the "-l" option, or with the "-B" option, AIX nm treats
+    # weak defined symbols like other global defined symbols, whereas
+    # GNU nm marks them as "W".
+    # While the 'weak' keyword is ignored in the Export File, we need
+    # it in the Import File for the 'aix-soname' feature, so we have
+    # to replace the "-B" option with "-P" for AIX nm.
     if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-      export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+      export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { if (\$ 2 == "W") { print \$ 3 " weak" } else { print \$ 3 } } }'\'' | sort -u > $export_symbols'
     else
-      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+      export_symbols_cmds_CXX='`func_echo_all $NM | $SED -e '\''s/B\([^B]*\)$/P\1/'\''` -PCpgl $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) && (substr(\$ 1,1,1) != ".")) { if ((\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) { print \$ 1 " weak" } else { print \$ 1 } } }'\'' | sort -u > $export_symbols'
     fi
     ;;
   pw32*)
-    export_symbols_cmds_CXX="$ltdll_cmds"
+    export_symbols_cmds_CXX=$ltdll_cmds
     ;;
   cygwin* | mingw* | cegcc*)
     case $cc_basename in
@@ -15649,7 +16896,7 @@ $as_echo_n "checking whether the $compiler linker ($LD) supports shared librarie
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
 $as_echo "$ld_shlibs_CXX" >&6; }
-test "$ld_shlibs_CXX" = no && can_build_shared=no
+test no = "$ld_shlibs_CXX" && can_build_shared=no
 
 with_gnu_ld_CXX=$with_gnu_ld
 
@@ -15666,7 +16913,7 @@ x|xyes)
   # Assume -lc should be added
   archive_cmds_need_lc_CXX=yes
 
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
+  if test yes,yes = "$GCC,$enable_shared"; then
     case $archive_cmds_CXX in
     *'~'*)
       # FIXME: we may have to deal with multi-command sequences.
@@ -15794,7 +17041,7 @@ $as_echo_n "checking dynamic linker characteristics... " >&6; }
 library_names_spec=
 libname_spec='lib$name'
 soname_spec=
-shrext_cmds=".so"
+shrext_cmds=.so
 postinstall_cmds=
 postuninstall_cmds=
 finish_cmds=
@@ -15811,14 +17058,16 @@ hardcode_into_libs=no
 # flags to be left without arguments
 need_version=unknown
 
+
+
 case $host_os in
 aix3*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname.a'
   shlibpath_var=LIBPATH
 
   # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
+  soname_spec='$libname$release$shared_ext$major'
   ;;
 
 aix[4-9]*)
@@ -15826,41 +17075,91 @@ aix[4-9]*)
   need_lib_prefix=no
   need_version=no
   hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
+  if test ia64 = "$host_cpu"; then
     # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    library_names_spec='$libname$release$shared_ext$major $libname$release$shared_ext$versuffix $libname$shared_ext'
     shlibpath_var=LD_LIBRARY_PATH
   else
     # With GCC up to 2.95.x, collect2 would create an import file
     # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
+    # the line '#! .'.  This would cause the generated library to
+    # depend on '.', always an invalid library.  This was fixed in
     # development snapshots of GCC prior to 3.0.
     case $host_os in
       aix4 | aix4.[01] | aix4.[01].*)
       if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
 	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	   echo '#endif'; } | $CC -E - | $GREP yes > /dev/null; then
 	:
       else
 	can_build_shared=no
       fi
       ;;
     esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # Using Import Files as archive members, it is possible to support
+    # filename-based versioning of shared library archives on AIX. While
+    # this would work for both with and without runtime linking, it will
+    # prevent static linking of such archives. So we do filename-based
+    # shared library versioning with .so extension only, which is used
+    # when both runtime linking and shared linking is enabled.
+    # Unfortunately, runtime linking may impact performance, so we do
+    # not want this to be the default eventually. Also, we use the
+    # versioned .so libs for executables only if there is the -brtl
+    # linker flag in LDFLAGS as well, or --with-aix-soname=svr4 only.
+    # To allow for filename-based versioning support, we need to create
+    # libNAME.so.V as an archive file, containing:
+    # *) an Import File, referring to the versioned filename of the
+    #    archive as well as the shared archive member, telling the
+    #    bitwidth (32 or 64) of that shared object, and providing the
+    #    list of exported symbols of that shared object, eventually
+    #    decorated with the 'weak' keyword
+    # *) the shared object with the F_LOADONLY flag set, to really avoid
+    #    it being seen by the linker.
+    # At run time we better use the real file rather than another symlink,
+    # but for link time we create the symlink libNAME.so -> libNAME.so.V
+
+    case $with_aix_soname,$aix_use_runtimelinking in
+    # AIX (on Power*) has no versioning support, so currently we cannot hardcode correct
     # soname into executable. Probably we can add versioning support to
     # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
+    aix,yes) # traditional libtool
+      dynamic_linker='AIX unversionable lib.so'
       # If using run time linking (on AIX 4.2 or later) use lib<name>.so
       # instead of lib<name>.a to let people know that these are not
       # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+      ;;
+    aix,no) # traditional AIX only
+      dynamic_linker='AIX lib.a(lib.so.V)'
       # We preserve .a as extension for shared libraries through AIX4.2
       # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
+      library_names_spec='$libname$release.a $libname.a'
+      soname_spec='$libname$release$shared_ext$major'
+      ;;
+    svr4,*) # full svr4 only
+      dynamic_linker="AIX lib.so.V($shared_archive_member_spec.o)"
+      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'
+      # We do not specify a path in Import Files, so LIBPATH fires.
+      shlibpath_overrides_runpath=yes
+      ;;
+    *,yes) # both, prefer svr4
+      dynamic_linker="AIX lib.so.V($shared_archive_member_spec.o), lib.a(lib.so.V)"
+      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'
+      # unpreferred sharedlib libNAME.a needs extra handling
+      postinstall_cmds='test -n "$linkname" || linkname="$realname"~func_stripname "" ".so" "$linkname"~$install_shared_prog "$dir/$func_stripname_result.$libext" "$destdir/$func_stripname_result.$libext"~test -z "$tstripme" || test -z "$striplib" || $striplib "$destdir/$func_stripname_result.$libext"'
+      postuninstall_cmds='for n in $library_names $old_library; do :; done~func_stripname "" ".so" "$n"~test "$func_stripname_result" = "$n" || func_append rmfiles " $odir/$func_stripname_result.$libext"'
+      # We do not specify a path in Import Files, so LIBPATH fires.
+      shlibpath_overrides_runpath=yes
+      ;;
+    *,no) # both, prefer aix
+      dynamic_linker="AIX lib.a(lib.so.V), lib.so.V($shared_archive_member_spec.o)"
+      library_names_spec='$libname$release.a $libname.a'
+      soname_spec='$libname$release$shared_ext$major'
+      # unpreferred sharedlib libNAME.so.V and symlink libNAME.so need extra handling
+      postinstall_cmds='test -z "$dlname" || $install_shared_prog $dir/$dlname $destdir/$dlname~test -z "$tstripme" || test -z "$striplib" || $striplib $destdir/$dlname~test -n "$linkname" || linkname=$realname~func_stripname "" ".a" "$linkname"~(cd "$destdir" && $LN_S -f $dlname $func_stripname_result.so)'
+      postuninstall_cmds='test -z "$dlname" || func_append rmfiles " $odir/$dlname"~for n in $old_library $library_names; do :; done~func_stripname "" ".a" "$n"~func_append rmfiles " $odir/$func_stripname_result.so"'
+      ;;
+    esac
     shlibpath_var=LIBPATH
   fi
   ;;
@@ -15870,18 +17169,18 @@ amigaos*)
   powerpc)
     # Since July 2007 AmigaOS4 officially supports .so libraries.
     # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
     ;;
   m68k)
     library_names_spec='$libname.ixlibrary $libname.a'
     # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
     ;;
   esac
   ;;
 
 beos*)
-  library_names_spec='${libname}${shared_ext}'
+  library_names_spec='$libname$shared_ext'
   dynamic_linker="$host_os ld.so"
   shlibpath_var=LIBRARY_PATH
   ;;
@@ -15889,8 +17188,8 @@ beos*)
 bsdi[45]*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
@@ -15902,7 +17201,7 @@ bsdi[45]*)
 
 cygwin* | mingw* | pw32* | cegcc*)
   version_type=windows
-  shrext_cmds=".dll"
+  shrext_cmds=.dll
   need_version=no
   need_lib_prefix=no
 
@@ -15911,8 +17210,8 @@ cygwin* | mingw* | pw32* | cegcc*)
     # gcc
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+    postinstall_cmds='base_file=`basename \$file`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; echo \$dlname'\''`~
       dldir=$destdir/`dirname \$dlpath`~
       test -d \$dldir || mkdir -p \$dldir~
       $install_prog $dir/$dlname \$dldir/$dlname~
@@ -15928,16 +17227,16 @@ cygwin* | mingw* | pw32* | cegcc*)
     case $host_os in
     cygwin*)
       # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      soname_spec='`echo $libname | sed -e 's/^lib/cyg/'``echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
 
       ;;
     mingw* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      soname_spec='$libname`echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
       ;;
     pw32*)
       # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      library_names_spec='`echo $libname | sed -e 's/^lib/pw/'``echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
       ;;
     esac
     dynamic_linker='Win32 ld.exe'
@@ -15946,8 +17245,8 @@ cygwin* | mingw* | pw32* | cegcc*)
   *,cl*)
     # Native MSVC
     libname_spec='$name'
-    soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-    library_names_spec='${libname}.dll.lib'
+    soname_spec='$libname`echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext'
+    library_names_spec='$libname.dll.lib'
 
     case $build_os in
     mingw*)
@@ -15974,7 +17273,7 @@ cygwin* | mingw* | pw32* | cegcc*)
       sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
       ;;
     *)
-      sys_lib_search_path_spec="$LIB"
+      sys_lib_search_path_spec=$LIB
       if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
         # It is most probably a Windows format PATH.
         sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
@@ -15987,8 +17286,8 @@ cygwin* | mingw* | pw32* | cegcc*)
     esac
 
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+    postinstall_cmds='base_file=`basename \$file`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; echo \$dlname'\''`~
       dldir=$destdir/`dirname \$dlpath`~
       test -d \$dldir || mkdir -p \$dldir~
       $install_prog $dir/$dlname \$dldir/$dlname'
@@ -16001,7 +17300,7 @@ cygwin* | mingw* | pw32* | cegcc*)
 
   *)
     # Assume MSVC wrapper
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    library_names_spec='$libname`echo $release | $SED -e 's/[.]/-/g'`$versuffix$shared_ext $libname.lib'
     dynamic_linker='Win32 ld.exe'
     ;;
   esac
@@ -16014,8 +17313,8 @@ darwin* | rhapsody*)
   version_type=darwin
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
+  library_names_spec='$libname$release$major$shared_ext $libname$shared_ext'
+  soname_spec='$libname$release$major$shared_ext'
   shlibpath_overrides_runpath=yes
   shlibpath_var=DYLD_LIBRARY_PATH
   shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
@@ -16027,8 +17326,8 @@ dgux*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
@@ -16046,12 +17345,13 @@ freebsd* | dragonfly*)
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+      soname_spec='$libname$release$shared_ext$major'
       need_version=no
       need_lib_prefix=no
       ;;
     freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
       need_version=yes
       ;;
   esac
@@ -16081,10 +17381,10 @@ haiku*)
   need_lib_prefix=no
   need_version=no
   dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
+  shlibpath_overrides_runpath=no
   sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
   hardcode_into_libs=yes
   ;;
@@ -16102,14 +17402,15 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.so"
     shlibpath_var=LD_LIBRARY_PATH
     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
+    if test 32 = "$HPUX_IA64_MODE"; then
       sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+      sys_lib_dlsearch_path_spec=/usr/lib/hpux32
     else
       sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+      sys_lib_dlsearch_path_spec=/usr/lib/hpux64
     fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
     ;;
   hppa*64*)
     shrext_cmds='.sl'
@@ -16117,8 +17418,8 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.sl"
     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
     ;;
@@ -16127,8 +17428,8 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.sl"
     shlibpath_var=SHLIB_PATH
     shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     ;;
   esac
   # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
@@ -16141,8 +17442,8 @@ interix[3-9]*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
@@ -16153,7 +17454,7 @@ irix5* | irix6* | nonstopux*)
   case $host_os in
     nonstopux*) version_type=nonstopux ;;
     *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
+	if test yes = "$lt_cv_prog_gnu_ld"; then
 		version_type=linux # correct to gnu/linux during the next big refactor
 	else
 		version_type=irix
@@ -16161,8 +17462,8 @@ irix5* | irix6* | nonstopux*)
   esac
   need_lib_prefix=no
   need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='$libname$release$shared_ext$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$release$shared_ext $libname$shared_ext'
   case $host_os in
   irix5* | nonstopux*)
     libsuff= shlibsuff=
@@ -16181,8 +17482,8 @@ irix5* | irix6* | nonstopux*)
   esac
   shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
   shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  sys_lib_search_path_spec="/usr/lib$libsuff /lib$libsuff /usr/local/lib$libsuff"
+  sys_lib_dlsearch_path_spec="/usr/lib$libsuff /lib$libsuff"
   hardcode_into_libs=yes
   ;;
 
@@ -16191,13 +17492,33 @@ linux*oldld* | linux*aout* | linux*coff*)
   dynamic_linker=no
   ;;
 
+linux*android*)
+  version_type=none # Android doesn't support versioned libraries.
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='$libname$release$shared_ext'
+  soname_spec='$libname$release$shared_ext'
+  finish_cmds=
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  dynamic_linker='Android linker'
+  # Don't embed -rpath directories since the linker doesn't support them.
+  hardcode_libdir_flag_spec_CXX='-L$libdir'
+  ;;
+
 # This must be glibc/ELF.
 linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
@@ -16241,7 +17562,12 @@ fi
   # before this can be enabled.
   hardcode_into_libs=yes
 
-  # Append ld.so.conf contents to the search path
+  # Ideally, we could use ldconfig to report *all* directores which are
+  # searched for libraries, however this is still not possible.  Aside from not
+  # being certain /sbin/ldconfig is available, command
+  # 'ldconfig -N -X -v | grep ^/' on 64bit Fedora does not report /usr/lib64,
+  # even though it is searched at run-time.  Try to do the best guess by
+  # appending ld.so.conf contents (and includes) to the search path.
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
@@ -16273,12 +17599,12 @@ netbsd*)
   need_lib_prefix=no
   need_version=no
   if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
     finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
     dynamic_linker='NetBSD (a.out) ld.so'
   else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     dynamic_linker='NetBSD ld.elf_so'
   fi
   shlibpath_var=LD_LIBRARY_PATH
@@ -16288,7 +17614,7 @@ netbsd*)
 
 newsos6)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   ;;
@@ -16297,58 +17623,68 @@ newsos6)
   version_type=qnx
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
   hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
-  ;;
-
-openbsd*)
-  version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
-  need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd* | bitrig*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec=/usr/lib
+  need_lib_prefix=no
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`"; then
+    need_version=no
   else
-    shlibpath_overrides_runpath=yes
+    need_version=yes
   fi
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
   ;;
 
 os2*)
   libname_spec='$name'
-  shrext_cmds=".dll"
+  version_type=windows
+  shrext_cmds=.dll
+  need_version=no
   need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
+  # OS/2 can only load a DLL with a base name of 8 characters or less.
+  soname_spec='`test -n "$os2dllname" && libname="$os2dllname";
+    v=$($ECHO $release$versuffix | tr -d .-);
+    n=$($ECHO $libname | cut -b -$((8 - ${#v})) | tr . _);
+    $ECHO $n$v`$shared_ext'
+  library_names_spec='${libname}_dll.$libext'
   dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
+  shlibpath_var=BEGINLIBPATH
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+  postinstall_cmds='base_file=`basename \$file`~
+    dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; $ECHO \$dlname'\''`~
+    dldir=$destdir/`dirname \$dlpath`~
+    test -d \$dldir || mkdir -p \$dldir~
+    $install_prog $dir/$dlname \$dldir/$dlname~
+    chmod a+x \$dldir/$dlname~
+    if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+      eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+    fi'
+  postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; $ECHO \$dlname'\''`~
+    dlpath=$dir/\$dldll~
+    $RM \$dlpath'
   ;;
 
 osf3* | osf4* | osf5*)
   version_type=osf
   need_lib_prefix=no
   need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='$libname$release$shared_ext$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
   ;;
 
 rdos*)
@@ -16359,8 +17695,8 @@ solaris*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   hardcode_into_libs=yes
@@ -16370,11 +17706,11 @@ solaris*)
 
 sunos4*)
   version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
   finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     need_lib_prefix=no
   fi
   need_version=yes
@@ -16382,8 +17718,8 @@ sunos4*)
 
 sysv4 | sysv4.3*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   case $host_vendor in
     sni)
@@ -16404,24 +17740,24 @@ sysv4 | sysv4.3*)
   ;;
 
 sysv4*MP*)
-  if test -d /usr/nec ;then
+  if test -d /usr/nec; then
     version_type=linux # correct to gnu/linux during the next big refactor
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
+    library_names_spec='$libname$shared_ext.$versuffix $libname$shared_ext.$major $libname$shared_ext'
+    soname_spec='$libname$shared_ext.$major'
     shlibpath_var=LD_LIBRARY_PATH
   fi
   ;;
 
 sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
+  version_type=sco
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
   else
     sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
@@ -16439,7 +17775,7 @@ tpf*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
   hardcode_into_libs=yes
@@ -16447,8 +17783,8 @@ tpf*)
 
 uts4*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
@@ -16458,20 +17794,32 @@ uts4*)
 esac
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
 $as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
+test no = "$dynamic_linker" && can_build_shared=no
 
 variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
 fi
 
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+if test set = "${lt_cv_sys_lib_search_path_spec+set}"; then
+  sys_lib_search_path_spec=$lt_cv_sys_lib_search_path_spec
 fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+
+if test set = "${lt_cv_sys_lib_dlsearch_path_spec+set}"; then
+  sys_lib_dlsearch_path_spec=$lt_cv_sys_lib_dlsearch_path_spec
 fi
 
+# remember unaugmented sys_lib_dlsearch_path content for libtool script decls...
+configure_time_dlsearch_path=$sys_lib_dlsearch_path_spec
+
+# ... but it needs LT_SYS_LIBRARY_PATH munging for other configure-time code
+func_munge_path_list sys_lib_dlsearch_path_spec "$LT_SYS_LIBRARY_PATH"
+
+# to be used as default LT_SYS_LIBRARY_PATH value in generated libtool
+configure_time_lt_sys_library_path=$LT_SYS_LIBRARY_PATH
+
+
+
 
 
 
@@ -16514,15 +17862,15 @@ $as_echo_n "checking how to hardcode library paths into programs... " >&6; }
 hardcode_action_CXX=
 if test -n "$hardcode_libdir_flag_spec_CXX" ||
    test -n "$runpath_var_CXX" ||
-   test "X$hardcode_automatic_CXX" = "Xyes" ; then
+   test yes = "$hardcode_automatic_CXX"; then
 
   # We can hardcode non-existent directories.
-  if test "$hardcode_direct_CXX" != no &&
+  if test no != "$hardcode_direct_CXX" &&
      # If the only mechanism to avoid hardcoding is shlibpath_var, we
      # have to relink, otherwise we might link with an installed library
      # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, CXX)" != no &&
-     test "$hardcode_minus_L_CXX" != no; then
+     ## test no != "$_LT_TAGVAR(hardcode_shlibpath_var, CXX)" &&
+     test no != "$hardcode_minus_L_CXX"; then
     # Linking always hardcodes the temporary library directory.
     hardcode_action_CXX=relink
   else
@@ -16537,12 +17885,12 @@ fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action_CXX" >&5
 $as_echo "$hardcode_action_CXX" >&6; }
 
-if test "$hardcode_action_CXX" = relink ||
-   test "$inherit_rpath_CXX" = yes; then
+if test relink = "$hardcode_action_CXX" ||
+   test yes = "$inherit_rpath_CXX"; then
   # Fast installation is not supported
   enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
+elif test yes = "$shlibpath_overrides_runpath" ||
+     test no = "$enable_shared"; then
   # Fast installation is not necessary
   enable_fast_install=needless
 fi
@@ -16565,7 +17913,7 @@ fi
   lt_cv_path_LD=$lt_save_path_LD
   lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
   lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
-fi # test "$_lt_caught_CXX_error" != yes
+fi # test yes != "$_lt_caught_CXX_error"
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -16595,6 +17943,75 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 # Only expand once:
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if ${ac_cv_path_SED+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_SED" || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error $? "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
+else
+  ac_cv_path_SED=$SED
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
 
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
@@ -17487,6 +18904,14 @@ else
 fi
 
 
+ if test "x$HAVE_CXX11" = "x1"; then
+  HAVE_CXX11_TRUE=
+  HAVE_CXX11_FALSE='#'
+else
+  HAVE_CXX11_TRUE='#'
+  HAVE_CXX11_FALSE=
+fi
+
  if test "x$with_int" == "ximath-32"; then
   SMALL_INT_OPT_TRUE=
   SMALL_INT_OPT_FALSE='#'
@@ -17628,9 +19053,6 @@ fi
 
 
 
-
-
-
 # Check whether --with-clang was given.
 if test "${with_clang+set}" = set; then :
   withval=$with_clang;
@@ -17713,7 +19135,12 @@ $as_echo "$with_clang" >&6; }
 
 case "$with_clang" in
 system)
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
 $as_echo_n "checking for grep that handles long lines and -e... " >&6; }
 if ${ac_cv_path_GREP+:} false; then :
   $as_echo_n "(cached) " >&6
@@ -17776,7 +19203,7 @@ $as_echo "$ac_cv_path_GREP" >&6; }
  GREP="$ac_cv_path_GREP"
 
 
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
 $as_echo_n "checking for a sed that does not truncate output... " >&6; }
 if ${ac_cv_path_SED+:} false; then :
   $as_echo_n "(cached) " >&6
@@ -17845,8 +19272,8 @@ $as_echo "$ac_cv_path_SED" >&6; }
  SED="$ac_cv_path_SED"
   rm -f conftest.sed
 
-	llvm_config="llvm-config"
-	# Extract the first word of ""$llvm_config"", so it can be a program name with args.
+llvm_config="llvm-config"
+# Extract the first word of ""$llvm_config"", so it can be a program name with args.
 set dummy "$llvm_config"; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
@@ -17883,45 +19310,44 @@ $as_echo "no" >&6; }
 fi
 
 
-	if test "x$with_clang_prefix" != "x"; then
-		llvm_config="$with_clang_prefix/bin/llvm-config"
-		if test -x "$llvm_config"; then
-			llvm_config_found=yes
-		fi
+if test "x$with_clang_prefix" != "x"; then
+	llvm_config="$with_clang_prefix/bin/llvm-config"
+	if test -x "$llvm_config"; then
+		llvm_config_found=yes
 	fi
-	if test "$llvm_config_found" != yes; then
-		as_fn_error $? "llvm-config not found" "$LINENO" 5
-	fi
-	CLANG_CXXFLAGS=`$llvm_config --cxxflags | \
-		$SED -e 's/-Wcovered-switch-default//'`
-	CLANG_LDFLAGS=`$llvm_config --ldflags`
-	targets=`$llvm_config --targets-built`
-	components="$targets asmparser bitreader support mc"
-	$llvm_config --components | $GREP option > /dev/null 2> /dev/null
-	if test $? -eq 0; then
-		components="$components option"
-	fi
-	CLANG_LIBS=`$llvm_config --libs $components`
-	systemlibs=`$llvm_config --system-libs 2> /dev/null | tail -1`
-	if test $? -eq 0; then
-		CLANG_LIBS="$CLANG_LIBS $systemlibs"
-	fi
-	CLANG_PREFIX=`$llvm_config --prefix`
+fi
+if test "$llvm_config_found" != yes; then
+	as_fn_error $? "llvm-config not found" "$LINENO" 5
+fi
+CLANG_CXXFLAGS=`$llvm_config --cxxflags | \
+	$SED -e 's/-Wcovered-switch-default//;s/-gsplit-dwarf//'`
+CLANG_LDFLAGS=`$llvm_config --ldflags`
+targets=`$llvm_config --targets-built`
+components="$targets asmparser bitreader support mc"
+$llvm_config --components | $GREP option > /dev/null 2> /dev/null
+if test $? -eq 0; then
+	components="$components option"
+fi
+CLANG_LIBS=`$llvm_config --libs $components`
+systemlibs=`$llvm_config --system-libs 2> /dev/null | tail -1`
+if test $? -eq 0; then
+	CLANG_LIBS="$CLANG_LIBS $systemlibs"
+fi
+CLANG_PREFIX=`$llvm_config --prefix`
 
 cat >>confdefs.h <<_ACEOF
 #define CLANG_PREFIX "$CLANG_PREFIX"
 _ACEOF
 
 
-	SAVE_CPPFLAGS="$CPPFLAGS"
-	CPPFLAGS="$CLANG_CXXFLAGS $CPPFLAGS"
-	ac_ext=cpp
+SAVE_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CLANG_CXXFLAGS $CPPFLAGS"
+ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
-
 ac_fn_cxx_check_header_mongrel "$LINENO" "clang/Basic/SourceLocation.h" "ac_cv_header_clang_Basic_SourceLocation_h" "$ac_includes_default"
 if test "x$ac_cv_header_clang_Basic_SourceLocation_h" = xyes; then :
 
@@ -17930,7 +19356,7 @@ else
 fi
 
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <llvm/Support/Host.h>
 
@@ -17945,7 +19371,7 @@ $as_echo "#define getDefaultTargetTriple getHostTriple" >>confdefs.h
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Basic/SourceLocation.h>
 
@@ -17960,7 +19386,7 @@ $as_echo "#define getExpansionLineNumber getInstantiationLineNumber" >>confdefs.
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Basic/Diagnostic.h>
 
@@ -17975,7 +19401,7 @@ $as_echo "#define DiagnosticsEngine Diagnostic" >>confdefs.h
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Driver/Driver.h>
 
@@ -17988,7 +19414,7 @@ $as_echo "#define USE_ARRAYREF /**/" >>confdefs.h
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Driver/Driver.h>
 
@@ -18001,7 +19427,7 @@ $as_echo "#define HAVE_CXXISPRODUCTION /**/" >>confdefs.h
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Driver/Driver.h>
 
@@ -18014,16 +19440,16 @@ $as_echo "#define HAVE_ISPRODUCTION /**/" >>confdefs.h
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Driver/Driver.h>
 int
 main ()
 {
 
-		using namespace clang;
-		DiagnosticsEngine *Diags;
-		new driver::Driver("", "", "", *Diags);
+	using namespace clang;
+	DiagnosticsEngine *Diags;
+	new driver::Driver("", "", "", *Diags);
 
   ;
   return 0;
@@ -18035,7 +19461,7 @@ $as_echo "#define DRIVER_CTOR_TAKES_DEFAULTIMAGENAME /**/" >>confdefs.h
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/AST/ASTConsumer.h>
 
@@ -18058,7 +19484,7 @@ $as_echo "#define HandleTopLevelDeclContinue true" >>confdefs.h
 fi
 rm -f conftest*
 
-	ac_fn_cxx_check_header_mongrel "$LINENO" "clang/Basic/DiagnosticOptions.h" "ac_cv_header_clang_Basic_DiagnosticOptions_h" "$ac_includes_default"
+ac_fn_cxx_check_header_mongrel "$LINENO" "clang/Basic/DiagnosticOptions.h" "ac_cv_header_clang_Basic_DiagnosticOptions_h" "$ac_includes_default"
 if test "x$ac_cv_header_clang_Basic_DiagnosticOptions_h" = xyes; then :
 
 $as_echo "#define HAVE_BASIC_DIAGNOSTICOPTIONS_H /**/" >>confdefs.h
@@ -18066,17 +19492,26 @@ $as_echo "#define HAVE_BASIC_DIAGNOSTICOPTIONS_H /**/" >>confdefs.h
 fi
 
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+ac_fn_cxx_check_header_compile "$LINENO" "clang/Lex/PreprocessorOptions.h" "ac_cv_header_clang_Lex_PreprocessorOptions_h" "#include <clang/Basic/LLVM.h>
+"
+if test "x$ac_cv_header_clang_Lex_PreprocessorOptions_h" = xyes; then :
+
+$as_echo "#define HAVE_LEX_PREPROCESSOROPTIONS_H /**/" >>confdefs.h
+
+fi
+
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Basic/TargetInfo.h>
 int
 main ()
 {
 
-		using namespace clang;
-		std::shared_ptr<TargetOptions> TO;
-		DiagnosticsEngine *Diags;
-		TargetInfo::CreateTargetInfo(*Diags, TO);
+	using namespace clang;
+	std::shared_ptr<TargetOptions> TO;
+	DiagnosticsEngine *Diags;
+	TargetInfo::CreateTargetInfo(*Diags, TO);
 
   ;
   return 0;
@@ -18088,17 +19523,17 @@ $as_echo "#define CREATETARGETINFO_TAKES_SHARED_PTR /**/" >>confdefs.h
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Basic/TargetInfo.h>
 int
 main ()
 {
 
-		using namespace clang;
-		TargetOptions *TO;
-		DiagnosticsEngine *Diags;
-		TargetInfo::CreateTargetInfo(*Diags, TO);
+	using namespace clang;
+	TargetOptions *TO;
+	DiagnosticsEngine *Diags;
+	TargetInfo::CreateTargetInfo(*Diags, TO);
 
   ;
   return 0;
@@ -18110,17 +19545,17 @@ $as_echo "#define CREATETARGETINFO_TAKES_POINTER /**/" >>confdefs.h
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Frontend/CompilerInstance.h>
 int
 main ()
 {
 
-		using namespace clang;
-		DiagnosticConsumer *client;
-		CompilerInstance *Clang;
-		Clang->createDiagnostics(client);
+	using namespace clang;
+	DiagnosticConsumer *client;
+	CompilerInstance *Clang;
+	Clang->createDiagnostics(client);
 
   ;
   return 0;
@@ -18134,16 +19569,16 @@ $as_echo "#define CREATEDIAGNOSTICS_TAKES_ARG /**/" >>confdefs.h
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Lex/HeaderSearchOptions.h>
 int
 main ()
 {
 
-		using namespace clang;
-		HeaderSearchOptions HSO;
-		HSO.AddPath("", frontend::Angled, false, false);
+	using namespace clang;
+	HeaderSearchOptions HSO;
+	HSO.AddPath("", frontend::Angled, false, false);
 
   ;
   return 0;
@@ -18155,7 +19590,7 @@ $as_echo "#define ADDPATH_TAKES_4_ARGUMENTS /**/" >>confdefs.h
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/AST/CanonicalType.h>
 
@@ -18171,7 +19606,7 @@ $as_echo "#define getArgType getParamType" >>confdefs.h
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/AST/CanonicalType.h>
 
@@ -18186,16 +19621,16 @@ $as_echo "#define getReturnType getResultType" >>confdefs.h
 fi
 rm -f conftest*
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Frontend/CompilerInstance.h>
 int
 main ()
 {
 
-		using namespace clang;
-		CompilerInstance *Clang;
-		Clang->createPreprocessor(TU_Complete);
+	using namespace clang;
+	CompilerInstance *Clang;
+	Clang->createPreprocessor(TU_Complete);
 
   ;
   return 0;
@@ -18207,7 +19642,7 @@ $as_echo "#define CREATEPREPROCESSOR_TAKES_TUKIND /**/" >>confdefs.h
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Basic/SourceManager.h>
 
@@ -18220,7 +19655,7 @@ $as_echo "#define HAVE_SETMAINFILEID /**/" >>confdefs.h
 fi
 rm -f conftest*
 
-	ac_fn_cxx_check_header_mongrel "$LINENO" "llvm/ADT/OwningPtr.h" "ac_cv_header_llvm_ADT_OwningPtr_h" "$ac_includes_default"
+ac_fn_cxx_check_header_mongrel "$LINENO" "llvm/ADT/OwningPtr.h" "ac_cv_header_llvm_ADT_OwningPtr_h" "$ac_includes_default"
 if test "x$ac_cv_header_llvm_ADT_OwningPtr_h" = xyes; then :
 
 $as_echo "#define HAVE_ADT_OWNINGPTR_H /**/" >>confdefs.h
@@ -18228,7 +19663,7 @@ $as_echo "#define HAVE_ADT_OWNINGPTR_H /**/" >>confdefs.h
 fi
 
 
-	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <clang/Basic/Builtins.h>
 
@@ -18243,18 +19678,87 @@ $as_echo "#define initializeBuiltins InitializeBuiltins" >>confdefs.h
 fi
 rm -f conftest*
 
-	ac_ext=c
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <clang/Frontend/FrontendOptions.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "IK_C" >/dev/null 2>&1; then :
+
+else
+
+$as_echo "#define IK_C InputKind::C" >>confdefs.h
+
+fi
+rm -f conftest*
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+	#include <clang/Basic/TargetOptions.h>
+	#include <clang/Lex/PreprocessorOptions.h>
+	#include <clang/Frontend/CompilerInstance.h>
+
+int
+main ()
+{
+
+	using namespace clang;
+	CompilerInstance *Clang;
+	TargetOptions TO;
+	llvm::Triple T(TO.Triple);
+	PreprocessorOptions PO;
+	CompilerInvocation::setLangDefaults(Clang->getLangOpts(), IK_C,
+			T, PO, LangStandard::lang_unspecified);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+$as_echo "#define SETLANGDEFAULTS_TAKES_5_ARGUMENTS /**/" >>confdefs.h
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+	#include <clang/Frontend/CompilerInstance.h>
+	#include <clang/Frontend/CompilerInvocation.h>
+
+int
+main ()
+{
+
+	using namespace clang;
+	CompilerInvocation *invocation;
+	CompilerInstance *Clang;
+	Clang->setInvocation(std::make_shared<CompilerInvocation>(*invocation));
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+$as_echo "#define SETINVOCATION_TAKES_SHARED_PTR /**/" >>confdefs.h
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-	CPPFLAGS="$SAVE_CPPFLAGS"
+CPPFLAGS="$SAVE_CPPFLAGS"
 
-	SAVE_LDFLAGS="$LDFLAGS"
-	LDFLAGS="$CLANG_LDFLAGS $LDFLAGS"
+SAVE_LDFLAGS="$LDFLAGS"
+LDFLAGS="$CLANG_LDFLAGS $LDFLAGS"
 
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lclangEdit" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lclangEdit" >&5
 $as_echo_n "checking for main in -lclangEdit... " >&6; }
 if ${ac_cv_lib_clangEdit_main+:} false; then :
   $as_echo_n "(cached) " >&6
@@ -18288,7 +19792,8 @@ if test "x$ac_cv_lib_clangEdit_main" = xyes; then :
   LIB_CLANG_EDIT=-lclangEdit
 fi
 
-	LDFLAGS="$SAVE_LDFLAGS"
+LDFLAGS="$SAVE_LDFLAGS"
+
 	;;
 esac
  if test $with_clang = system; then
@@ -18569,6 +20074,8 @@ ac_config_commands="$ac_config_commands $ax_create_pkgconfig_generate"
 
 ac_config_headers="$ac_config_headers isl_config.h"
 
+ac_config_files="$ac_config_files isl_srcdir.c"
+
 ac_config_files="$ac_config_files Makefile"
 
 ac_config_files="$ac_config_files doc/Makefile"
@@ -18583,6 +20090,10 @@ ac_config_files="$ac_config_files codegen_test.sh"
 
 ac_config_files="$ac_config_files pip_test.sh"
 
+ac_config_files="$ac_config_files flow_test.sh"
+
+ac_config_files="$ac_config_files schedule_test.sh"
+
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -18741,6 +20252,10 @@ if test -z "${GMP_FOR_MP_TRUE}" && test -z "${GMP_FOR_MP_FALSE}"; then
   as_fn_error $? "conditional \"GMP_FOR_MP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${HAVE_CXX11_TRUE}" && test -z "${HAVE_CXX11_FALSE}"; then
+  as_fn_error $? "conditional \"HAVE_CXX11\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${SMALL_INT_OPT_TRUE}" && test -z "${SMALL_INT_OPT_FALSE}"; then
   as_fn_error $? "conditional \"SMALL_INT_OPT\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -19146,7 +20661,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by isl $as_me 0.17.1, which was
+This file was extended by isl $as_me 0.18, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -19212,7 +20727,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-isl config.status 0.17.1
+isl config.status 0.18
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
@@ -19347,6 +20862,7 @@ enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
 enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
 pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
 enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
+shared_archive_member_spec='`$ECHO "$shared_archive_member_spec" | $SED "$delay_single_quote_subst"`'
 SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
 ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
 PATH_SEPARATOR='`$ECHO "$PATH_SEPARATOR" | $SED "$delay_single_quote_subst"`'
@@ -19396,10 +20912,13 @@ compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
 GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
 lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
 lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_import='`$ECHO "$lt_cv_sys_global_symbol_to_import" | $SED "$delay_single_quote_subst"`'
 lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
 lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
+lt_cv_nm_interface='`$ECHO "$lt_cv_nm_interface" | $SED "$delay_single_quote_subst"`'
 nm_file_list_spec='`$ECHO "$nm_file_list_spec" | $SED "$delay_single_quote_subst"`'
 lt_sysroot='`$ECHO "$lt_sysroot" | $SED "$delay_single_quote_subst"`'
+lt_cv_truncate_bin='`$ECHO "$lt_cv_truncate_bin" | $SED "$delay_single_quote_subst"`'
 objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
 MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
 lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
@@ -19464,7 +20983,8 @@ finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
 finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
 hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
 sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
-sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
+configure_time_dlsearch_path='`$ECHO "$configure_time_dlsearch_path" | $SED "$delay_single_quote_subst"`'
+configure_time_lt_sys_library_path='`$ECHO "$configure_time_lt_sys_library_path" | $SED "$delay_single_quote_subst"`'
 hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
 enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
 enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
@@ -19569,9 +21089,12 @@ CFLAGS \
 compiler \
 lt_cv_sys_global_symbol_pipe \
 lt_cv_sys_global_symbol_to_cdecl \
+lt_cv_sys_global_symbol_to_import \
 lt_cv_sys_global_symbol_to_c_name_address \
 lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
+lt_cv_nm_interface \
 nm_file_list_spec \
+lt_cv_truncate_bin \
 lt_prog_compiler_no_builtin_flag \
 lt_prog_compiler_pic \
 lt_prog_compiler_wl \
@@ -19637,7 +21160,7 @@ postdeps_CXX \
 compiler_lib_search_path_CXX; do
     case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
     *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\"" ## exclude from sc_prohibit_nested_quotes
       ;;
     *)
       eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
@@ -19664,7 +21187,8 @@ postinstall_cmds \
 postuninstall_cmds \
 finish_cmds \
 sys_lib_search_path_spec \
-sys_lib_dlsearch_path_spec \
+configure_time_dlsearch_path \
+configure_time_lt_sys_library_path \
 reload_cmds_CXX \
 old_archive_cmds_CXX \
 old_archive_from_new_cmds_CXX \
@@ -19678,7 +21202,7 @@ prelink_cmds_CXX \
 postlink_cmds_CXX; do
     case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
     *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\"" ## exclude from sc_prohibit_nested_quotes
       ;;
     *)
       eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
@@ -19687,19 +21211,16 @@ postlink_cmds_CXX; do
 done
 
 ac_aux_dir='$ac_aux_dir'
-xsi_shell='$xsi_shell'
-lt_shell_append='$lt_shell_append'
 
-# See if we are running on zsh, and set the options which allow our
+# See if we are running on zsh, and set the options that allow our
 # commands through without removal of \ escapes INIT.
-if test -n "\${ZSH_VERSION+set}" ; then
+if test -n "\${ZSH_VERSION+set}"; then
    setopt NO_GLOB_SUBST
 fi
 
 
     PACKAGE='$PACKAGE'
     VERSION='$VERSION'
-    TIMESTAMP='$TIMESTAMP'
     RM='$RM'
     ofile='$ofile'
 
@@ -19761,12 +21282,15 @@ do
     "$ac_stdint_h") CONFIG_COMMANDS="$CONFIG_COMMANDS $ac_stdint_h" ;;
     "$ax_create_pkgconfig_generate") CONFIG_COMMANDS="$CONFIG_COMMANDS $ax_create_pkgconfig_generate" ;;
     "isl_config.h") CONFIG_HEADERS="$CONFIG_HEADERS isl_config.h" ;;
+    "isl_srcdir.c") CONFIG_FILES="$CONFIG_FILES isl_srcdir.c" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
     "interface/Makefile") CONFIG_FILES="$CONFIG_FILES interface/Makefile" ;;
     "bound_test.sh") CONFIG_FILES="$CONFIG_FILES bound_test.sh" ;;
     "codegen_test.sh") CONFIG_FILES="$CONFIG_FILES codegen_test.sh" ;;
     "pip_test.sh") CONFIG_FILES="$CONFIG_FILES pip_test.sh" ;;
+    "flow_test.sh") CONFIG_FILES="$CONFIG_FILES flow_test.sh" ;;
+    "schedule_test.sh") CONFIG_FILES="$CONFIG_FILES schedule_test.sh" ;;
 
   *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
@@ -20457,55 +21981,52 @@ $as_echo X"$file" |
  ;;
     "libtool":C)
 
-    # See if we are running on zsh, and set the options which allow our
+    # See if we are running on zsh, and set the options that allow our
     # commands through without removal of \ escapes.
-    if test -n "${ZSH_VERSION+set}" ; then
+    if test -n "${ZSH_VERSION+set}"; then
       setopt NO_GLOB_SUBST
     fi
 
-    cfgfile="${ofile}T"
+    cfgfile=${ofile}T
     trap "$RM \"$cfgfile\"; exit 1" 1 2 15
     $RM "$cfgfile"
 
     cat <<_LT_EOF >> "$cfgfile"
 #! $SHELL
-
-# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
-# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
-# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# Generated automatically by $as_me ($PACKAGE) $VERSION
 # NOTE: Changes made to this file will be lost: look at ltmain.sh.
+
+# Provide generalized library-building support services.
+# Written by Gordon Matzigkeit, 1996
+
+# Copyright (C) 2014 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of of the License, or
+# (at your option) any later version.
 #
-#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
-#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-#                 Foundation, Inc.
-#   Written by Gordon Matzigkeit, 1996
-#
-#   This file is part of GNU Libtool.
-#
-# GNU Libtool is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# As a special exception to the GNU General Public License,
-# if you distribute this file as part of a program or library that
-# is built using GNU Libtool, you may include this file under the
-# same distribution terms that you use for the rest of that program.
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program or library that is built
+# using GNU Libtool, you may include this file under the  same
+# distribution terms that you use for the rest of that program.
 #
-# GNU Libtool is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with GNU Libtool; see the file COPYING.  If not, a copy
-# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
-# obtained by writing to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 
 # The names of the tagged configurations supported by this script.
-available_tags="CXX "
+available_tags='CXX '
+
+# Configured defaults for sys_lib_dlsearch_path munging.
+: \${LT_SYS_LIBRARY_PATH="$configure_time_lt_sys_library_path"}
 
 # ### BEGIN LIBTOOL CONFIG
 
@@ -20525,6 +22046,9 @@ pic_mode=$pic_mode
 # Whether or not to optimize for fast installation.
 fast_install=$enable_fast_install
 
+# Shared archive member basename,for filename based shared library versioning on AIX.
+shared_archive_member_spec=$shared_archive_member_spec
+
 # Shell to use when invoking shell scripts.
 SHELL=$lt_SHELL
 
@@ -20642,18 +22166,27 @@ global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
 # Transform the output of nm in a proper C declaration.
 global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
 
+# Transform the output of nm into a list of symbols to manually relocate.
+global_symbol_to_import=$lt_lt_cv_sys_global_symbol_to_import
+
 # Transform the output of nm in a C name address pair.
 global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
 
 # Transform the output of nm in a C name address pair when lib prefix is needed.
 global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
 
+# The name lister interface.
+nm_interface=$lt_lt_cv_nm_interface
+
 # Specify filename containing input files for \$NM.
 nm_file_list_spec=$lt_nm_file_list_spec
 
-# The root where to search for dependent libraries,and in which our libraries should be installed.
+# The root where to search for dependent libraries,and where our libraries should be installed.
 lt_sysroot=$lt_sysroot
 
+# Command to truncate a binary pipe.
+lt_truncate_bin=$lt_lt_cv_truncate_bin
+
 # The name of the directory that contains temporary libtool files.
 objdir=$objdir
 
@@ -20744,8 +22277,11 @@ hardcode_into_libs=$hardcode_into_libs
 # Compile-time system search path for libraries.
 sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
 
-# Run-time system search path for libraries.
-sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+# Detected run-time system search path for libraries.
+sys_lib_dlsearch_path_spec=$lt_configure_time_dlsearch_path
+
+# Explicit LT_SYS_LIBRARY_PATH set during ./configure time.
+configure_time_lt_sys_library_path=$lt_configure_time_lt_sys_library_path
 
 # Whether dlopen is supported.
 dlopen_support=$enable_dlopen
@@ -20838,13 +22374,13 @@ hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
 # Whether we need a single "-rpath" flag with a separated argument.
 hardcode_libdir_separator=$lt_hardcode_libdir_separator
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
 # DIR into the resulting binary.
 hardcode_direct=$hardcode_direct
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
 # DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# "absolute",i.e impossible to change by setting \$shlibpath_var if the
 # library is relocated.
 hardcode_direct_absolute=$hardcode_direct_absolute
 
@@ -20910,13 +22446,72 @@ compiler_lib_search_path=$lt_compiler_lib_search_path
 
 _LT_EOF
 
+    cat <<'_LT_EOF' >> "$cfgfile"
+
+# ### BEGIN FUNCTIONS SHARED WITH CONFIGURE
+
+# func_munge_path_list VARIABLE PATH
+# -----------------------------------
+# VARIABLE is name of variable containing _space_ separated list of
+# directories to be munged by the contents of PATH, which is string
+# having a format:
+# "DIR[:DIR]:"
+#       string "DIR[ DIR]" will be prepended to VARIABLE
+# ":DIR[:DIR]"
+#       string "DIR[ DIR]" will be appended to VARIABLE
+# "DIRP[:DIRP]::[DIRA:]DIRA"
+#       string "DIRP[ DIRP]" will be prepended to VARIABLE and string
+#       "DIRA[ DIRA]" will be appended to VARIABLE
+# "DIR[:DIR]"
+#       VARIABLE will be replaced by "DIR[ DIR]"
+func_munge_path_list ()
+{
+    case x$2 in
+    x)
+        ;;
+    *:)
+        eval $1=\"`$ECHO $2 | $SED 's/:/ /g'` \$$1\"
+        ;;
+    x:*)
+        eval $1=\"\$$1 `$ECHO $2 | $SED 's/:/ /g'`\"
+        ;;
+    *::*)
+        eval $1=\"\$$1\ `$ECHO $2 | $SED -e 's/.*:://' -e 's/:/ /g'`\"
+        eval $1=\"`$ECHO $2 | $SED -e 's/::.*//' -e 's/:/ /g'`\ \$$1\"
+        ;;
+    *)
+        eval $1=\"`$ECHO $2 | $SED 's/:/ /g'`\"
+        ;;
+    esac
+}
+
+
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+func_cc_basename ()
+{
+    for cc_temp in $*""; do
+      case $cc_temp in
+        compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+        distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+        \-*) ;;
+        *) break;;
+      esac
+    done
+    func_cc_basename_result=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+}
+
+
+# ### END FUNCTIONS SHARED WITH CONFIGURE
+
+_LT_EOF
+
   case $host_os in
   aix3*)
     cat <<\_LT_EOF >> "$cfgfile"
 # AIX sometimes has problems with the GCC collect2 program.  For some
 # reason, if we set the COLLECT_NAMES environment variable, the problems
 # vanish in a puff of smoke.
-if test "X${COLLECT_NAMES+set}" != Xset; then
+if test set != "${COLLECT_NAMES+set}"; then
   COLLECT_NAMES=
   export COLLECT_NAMES
 fi
@@ -20925,7 +22520,7 @@ _LT_EOF
   esac
 
 
-ltmain="$ac_aux_dir/ltmain.sh"
+ltmain=$ac_aux_dir/ltmain.sh
 
 
   # We use sed instead of cat because bash on DJGPP gets confused if
@@ -20935,165 +22530,6 @@ ltmain="$ac_aux_dir/ltmain.sh"
   sed '$q' "$ltmain" >> "$cfgfile" \
      || (rm -f "$cfgfile"; exit 1)
 
-  if test x"$xsi_shell" = xyes; then
-  sed -e '/^func_dirname ()$/,/^} # func_dirname /c\
-func_dirname ()\
-{\
-\    case ${1} in\
-\      */*) func_dirname_result="${1%/*}${2}" ;;\
-\      *  ) func_dirname_result="${3}" ;;\
-\    esac\
-} # Extended-shell func_dirname implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_basename ()$/,/^} # func_basename /c\
-func_basename ()\
-{\
-\    func_basename_result="${1##*/}"\
-} # Extended-shell func_basename implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_dirname_and_basename ()$/,/^} # func_dirname_and_basename /c\
-func_dirname_and_basename ()\
-{\
-\    case ${1} in\
-\      */*) func_dirname_result="${1%/*}${2}" ;;\
-\      *  ) func_dirname_result="${3}" ;;\
-\    esac\
-\    func_basename_result="${1##*/}"\
-} # Extended-shell func_dirname_and_basename implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_stripname ()$/,/^} # func_stripname /c\
-func_stripname ()\
-{\
-\    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\
-\    # positional parameters, so assign one to ordinary parameter first.\
-\    func_stripname_result=${3}\
-\    func_stripname_result=${func_stripname_result#"${1}"}\
-\    func_stripname_result=${func_stripname_result%"${2}"}\
-} # Extended-shell func_stripname implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_split_long_opt ()$/,/^} # func_split_long_opt /c\
-func_split_long_opt ()\
-{\
-\    func_split_long_opt_name=${1%%=*}\
-\    func_split_long_opt_arg=${1#*=}\
-} # Extended-shell func_split_long_opt implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_split_short_opt ()$/,/^} # func_split_short_opt /c\
-func_split_short_opt ()\
-{\
-\    func_split_short_opt_arg=${1#??}\
-\    func_split_short_opt_name=${1%"$func_split_short_opt_arg"}\
-} # Extended-shell func_split_short_opt implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_lo2o ()$/,/^} # func_lo2o /c\
-func_lo2o ()\
-{\
-\    case ${1} in\
-\      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\
-\      *)    func_lo2o_result=${1} ;;\
-\    esac\
-} # Extended-shell func_lo2o implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_xform ()$/,/^} # func_xform /c\
-func_xform ()\
-{\
-    func_xform_result=${1%.*}.lo\
-} # Extended-shell func_xform implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_arith ()$/,/^} # func_arith /c\
-func_arith ()\
-{\
-    func_arith_result=$(( $* ))\
-} # Extended-shell func_arith implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_len ()$/,/^} # func_len /c\
-func_len ()\
-{\
-    func_len_result=${#1}\
-} # Extended-shell func_len implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-fi
-
-if test x"$lt_shell_append" = xyes; then
-  sed -e '/^func_append ()$/,/^} # func_append /c\
-func_append ()\
-{\
-    eval "${1}+=\\${2}"\
-} # Extended-shell func_append implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_append_quoted ()$/,/^} # func_append_quoted /c\
-func_append_quoted ()\
-{\
-\    func_quote_for_eval "${2}"\
-\    eval "${1}+=\\\\ \\$func_quote_for_eval_result"\
-} # Extended-shell func_append_quoted implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  # Save a `func_append' function call where possible by direct use of '+='
-  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1+="%g' $cfgfile > $cfgfile.tmp \
-    && mv -f "$cfgfile.tmp" "$cfgfile" \
-      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-  test 0 -eq $? || _lt_function_replace_fail=:
-else
-  # Save a `func_append' function call even when '+=' is not available
-  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1="$\1%g' $cfgfile > $cfgfile.tmp \
-    && mv -f "$cfgfile.tmp" "$cfgfile" \
-      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-  test 0 -eq $? || _lt_function_replace_fail=:
-fi
-
-if test x"$_lt_function_replace_fail" = x":"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Unable to substitute extended shell functions in $ofile" >&5
-$as_echo "$as_me: WARNING: Unable to substitute extended shell functions in $ofile" >&2;}
-fi
-
-
    mv -f "$cfgfile" "$ofile" ||
     (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
   chmod +x "$ofile"
@@ -21180,13 +22616,13 @@ hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_CXX
 # Whether we need a single "-rpath" flag with a separated argument.
 hardcode_libdir_separator=$lt_hardcode_libdir_separator_CXX
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
 # DIR into the resulting binary.
 hardcode_direct=$hardcode_direct_CXX
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# Set to "yes" if using DIR/libNAME\$shared_ext during linking hardcodes
 # DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# "absolute",i.e impossible to change by setting \$shlibpath_var if the
 # library is relocated.
 hardcode_direct_absolute=$hardcode_direct_absolute_CXX
 
@@ -21856,6 +23292,8 @@ fi ; rm conftest.sed # DONE generate $pkgconfig_uninstalled
     "bound_test.sh":F) chmod +x bound_test.sh ;;
     "codegen_test.sh":F) chmod +x codegen_test.sh ;;
     "pip_test.sh":F) chmod +x pip_test.sh ;;
+    "flow_test.sh":F) chmod +x flow_test.sh ;;
+    "schedule_test.sh":F) chmod +x schedule_test.sh ;;
 
   esac
 done # for ac_tag
diff --git a/lib/Analysis/isl/configure.ac b/lib/Analysis/isl/configure.ac
index df0bb29..5de7b5a 100644
--- a/lib/Analysis/isl/configure.ac
+++ b/lib/Analysis/isl/configure.ac
@@ -1,10 +1,10 @@
-AC_INIT([isl], [0.17.1], [isl-development@googlegroups.com])
+AC_INIT([isl], [0.18], [isl-development@googlegroups.com])
 AC_CONFIG_AUX_DIR([.])
 AC_CONFIG_MACRO_DIR([m4])
 AM_INIT_AUTOMAKE([foreign])
 m4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])])
 AC_SUBST(versioninfo)
-versioninfo=17:1:2
+versioninfo=18:0:3
 
 if test "x$prefix" != "xNONE"; then
 	prefix_wd=`cd $prefix && pwd`
@@ -25,7 +25,20 @@ AX_CC_MAXOPT
 AX_GCC_WARN_UNUSED_RESULT
 AX_C___ATTRIBUTE__
 
+# CXX11FLAGS contains the flags (if any) added by AX_CXX_COMPILE_STDCXX_11
+# Original state of CXX and CXXCPP is preserved because CXX11FLAGS
+# is only needed for compiling interface/isl_test_cpp
+AC_SUBST(CXX11FLAGS)
+ac_save_CXX="$CXX"
+ac_save_CXXCPP="$CXXCPP"
+AX_CXX_COMPILE_STDCXX_11([noext], [optional])
+CXX11FLAGS=${CXX#$ac_save_CXX}
+CXX="$ac_save_CXX"
+CXXCPP="$ac_save_CXXCPP"
+
+AC_PROG_GREP
 AC_PROG_LIBTOOL
+AC_PROG_SED
 
 AC_CHECK_PROG(PERL, perl, perl, [])
 AC_CHECK_PROG(PDFLATEX, pdflatex, pdflatex, [])
@@ -66,6 +79,7 @@ fi
 AM_CONDITIONAL(IMATH_FOR_MP, test x$with_int = ximath -o x$with_int = ximath-32)
 AM_CONDITIONAL(GMP_FOR_MP, test x$with_int = xgmp)
 
+AM_CONDITIONAL(HAVE_CXX11, test "x$HAVE_CXX11" = "x1")
 AM_CONDITIONAL(SMALL_INT_OPT, test "x$with_int" == "ximath-32")
 AS_IF([test "x$with_int" == "ximath-32"], [
 	AC_DEFINE([USE_SMALL_INT_OPT], [], [Use small integer optimization])
@@ -95,150 +109,10 @@ if test "x$ac_cv_have_decl_snprintf" = xno -a \
 	AC_MSG_ERROR([No snprintf implementation found])
 fi
 
-AC_SUBST(CLANG_CXXFLAGS)
-AC_SUBST(CLANG_LDFLAGS)
-AC_SUBST(CLANG_LIBS)
 AX_SUBMODULE(clang,system|no,no)
 case "$with_clang" in
 system)
-	AC_PROG_GREP
-	AC_PROG_SED
-	llvm_config="llvm-config"
-	AC_CHECK_PROG([llvm_config_found], ["$llvm_config"], [yes])
-	if test "x$with_clang_prefix" != "x"; then
-		llvm_config="$with_clang_prefix/bin/llvm-config"
-		if test -x "$llvm_config"; then
-			llvm_config_found=yes
-		fi
-	fi
-	if test "$llvm_config_found" != yes; then
-		AC_MSG_ERROR([llvm-config not found])
-	fi
-	CLANG_CXXFLAGS=`$llvm_config --cxxflags | \
-		$SED -e 's/-Wcovered-switch-default//'`
-	CLANG_LDFLAGS=`$llvm_config --ldflags`
-	targets=`$llvm_config --targets-built`
-	components="$targets asmparser bitreader support mc"
-	$llvm_config --components | $GREP option > /dev/null 2> /dev/null
-	if test $? -eq 0; then
-		components="$components option"
-	fi
-	CLANG_LIBS=`$llvm_config --libs $components`
-	systemlibs=`$llvm_config --system-libs 2> /dev/null | tail -1`
-	if test $? -eq 0; then
-		CLANG_LIBS="$CLANG_LIBS $systemlibs"
-	fi
-	CLANG_PREFIX=`$llvm_config --prefix`
-	AC_DEFINE_UNQUOTED(CLANG_PREFIX, ["$CLANG_PREFIX"],
-				[Clang installation prefix])
-
-	SAVE_CPPFLAGS="$CPPFLAGS"
-	CPPFLAGS="$CLANG_CXXFLAGS $CPPFLAGS"
-	AC_LANG_PUSH(C++)
-	AC_CHECK_HEADER([clang/Basic/SourceLocation.h], [],
-		[AC_ERROR([clang header file not found])])
-	AC_EGREP_HEADER([getDefaultTargetTriple], [llvm/Support/Host.h], [],
-		[AC_DEFINE([getDefaultTargetTriple], [getHostTriple],
-		[Define to getHostTriple for older versions of clang])])
-	AC_EGREP_HEADER([getExpansionLineNumber],
-		[clang/Basic/SourceLocation.h], [],
-		[AC_DEFINE([getExpansionLineNumber],
-			[getInstantiationLineNumber],
-	    [Define to getInstantiationLineNumber for older versions of clang])])
-	AC_EGREP_HEADER([DiagnosticsEngine],
-		[clang/Basic/Diagnostic.h], [],
-		[AC_DEFINE([DiagnosticsEngine],
-			[Diagnostic],
-	    [Define to Diagnostic for older versions of clang])])
-	AC_EGREP_HEADER([ArrayRef], [clang/Driver/Driver.h],
-		[AC_DEFINE([USE_ARRAYREF], [],
-			[Define if Driver::BuildCompilation takes ArrayRef])])
-	AC_EGREP_HEADER([CXXIsProduction], [clang/Driver/Driver.h],
-		[AC_DEFINE([HAVE_CXXISPRODUCTION], [],
-		[Define if Driver constructor takes CXXIsProduction argument])])
-	AC_EGREP_HEADER([ IsProduction], [clang/Driver/Driver.h],
-		[AC_DEFINE([HAVE_ISPRODUCTION], [],
-		[Define if Driver constructor takes IsProduction argument])])
-	AC_TRY_COMPILE([#include <clang/Driver/Driver.h>], [
-		using namespace clang;
-		DiagnosticsEngine *Diags;
-		new driver::Driver("", "", "", *Diags);
-	], [AC_DEFINE([DRIVER_CTOR_TAKES_DEFAULTIMAGENAME], [],
-		      [Define if Driver constructor takes default image name])])
-	AC_EGREP_HEADER([void HandleTopLevelDecl\(], [clang/AST/ASTConsumer.h],
-		[AC_DEFINE([HandleTopLevelDeclReturn], [void],
-			   [Return type of HandleTopLevelDeclReturn])
-		 AC_DEFINE([HandleTopLevelDeclContinue], [],
-			   [Return type of HandleTopLevelDeclReturn])],
-		[AC_DEFINE([HandleTopLevelDeclReturn], [bool],
-			   [Return type of HandleTopLevelDeclReturn])
-		 AC_DEFINE([HandleTopLevelDeclContinue], [true],
-			   [Return type of HandleTopLevelDeclReturn])])
-	AC_CHECK_HEADER([clang/Basic/DiagnosticOptions.h],
-		[AC_DEFINE([HAVE_BASIC_DIAGNOSTICOPTIONS_H], [],
-			   [Define if clang/Basic/DiagnosticOptions.h exists])])
-	AC_TRY_COMPILE([#include <clang/Basic/TargetInfo.h>], [
-		using namespace clang;
-		std::shared_ptr<TargetOptions> TO;
-		DiagnosticsEngine *Diags;
-		TargetInfo::CreateTargetInfo(*Diags, TO);
-	], [AC_DEFINE([CREATETARGETINFO_TAKES_SHARED_PTR], [],
-		    [Define if TargetInfo::CreateTargetInfo takes shared_ptr])])
-	AC_TRY_COMPILE([#include <clang/Basic/TargetInfo.h>], [
-		using namespace clang;
-		TargetOptions *TO;
-		DiagnosticsEngine *Diags;
-		TargetInfo::CreateTargetInfo(*Diags, TO);
-	], [AC_DEFINE([CREATETARGETINFO_TAKES_POINTER], [],
-		      [Define if TargetInfo::CreateTargetInfo takes pointer])])
-	AC_TRY_COMPILE([#include <clang/Frontend/CompilerInstance.h>], [
-		using namespace clang;
-		DiagnosticConsumer *client;
-		CompilerInstance *Clang;
-		Clang->createDiagnostics(client);
-	], [], [AC_DEFINE([CREATEDIAGNOSTICS_TAKES_ARG], [],
-	[Define if CompilerInstance::createDiagnostics takes argc and argv])])
-	AC_TRY_COMPILE([#include <clang/Lex/HeaderSearchOptions.h>], [
-		using namespace clang;
-		HeaderSearchOptions HSO;
-		HSO.AddPath("", frontend::Angled, false, false);
-	], [AC_DEFINE([ADDPATH_TAKES_4_ARGUMENTS], [],
-		[Define if HeaderSearchOptions::AddPath takes 4 arguments])])
-	AC_EGREP_HEADER([getNumParams],
-		[clang/AST/CanonicalType.h],
-		[AC_DEFINE([getNumArgs], [getNumParams],
-		    [Define to getNumParams for newer versions of clang])
-		 AC_DEFINE([getArgType], [getParamType],
-		    [Define to getParamType for newer versions of clang])])
-	AC_EGREP_HEADER([getReturnType],
-		[clang/AST/CanonicalType.h], [],
-		[AC_DEFINE([getReturnType], [getResultType],
-		    [Define to getResultType for older versions of clang])])
-	AC_TRY_COMPILE([#include <clang/Frontend/CompilerInstance.h>], [
-		using namespace clang;
-		CompilerInstance *Clang;
-		Clang->createPreprocessor(TU_Complete);
-	], [AC_DEFINE([CREATEPREPROCESSOR_TAKES_TUKIND], [],
-	[Define if CompilerInstance::createPreprocessor takes
-	 TranslationUnitKind])])
-	AC_EGREP_HEADER([setMainFileID], [clang/Basic/SourceManager.h],
-		[AC_DEFINE([HAVE_SETMAINFILEID], [],
-		[Define if SourceManager has a setMainFileID method])])
-	AC_CHECK_HEADER([llvm/ADT/OwningPtr.h],
-		[AC_DEFINE([HAVE_ADT_OWNINGPTR_H], [],
-			   [Define if llvm/ADT/OwningPtr.h exists])])
-	AC_EGREP_HEADER([initializeBuiltins],
-		[clang/Basic/Builtins.h], [],
-		[AC_DEFINE([initializeBuiltins], [InitializeBuiltins],
-		[Define to InitializeBuiltins for older versions of clang])])
-	AC_LANG_POP
-	CPPFLAGS="$SAVE_CPPFLAGS"
-
-	SAVE_LDFLAGS="$LDFLAGS"
-	LDFLAGS="$CLANG_LDFLAGS $LDFLAGS"
-	AC_SUBST(LIB_CLANG_EDIT)
-	AC_CHECK_LIB([clangEdit], [main], [LIB_CLANG_EDIT=-lclangEdit], [])
-	LDFLAGS="$SAVE_LDFLAGS"
+	AX_DETECT_CLANG
 	;;
 esac
 AM_CONDITIONAL(HAVE_CLANG, test $with_clang = system)
@@ -256,6 +130,7 @@ AX_DETECT_GIT_HEAD
 
 AH_BOTTOM([#include <isl_config_post.h>])
 AC_CONFIG_HEADERS(isl_config.h)
+AC_CONFIG_FILES(isl_srcdir.c)
 AC_CONFIG_FILES(Makefile)
 AC_CONFIG_FILES(doc/Makefile)
 if test $with_clang = system; then
@@ -264,6 +139,8 @@ fi
 AC_CONFIG_FILES([bound_test.sh], [chmod +x bound_test.sh])
 AC_CONFIG_FILES([codegen_test.sh], [chmod +x codegen_test.sh])
 AC_CONFIG_FILES([pip_test.sh], [chmod +x pip_test.sh])
+AC_CONFIG_FILES([flow_test.sh], [chmod +x flow_test.sh])
+AC_CONFIG_FILES([schedule_test.sh], [chmod +x schedule_test.sh])
 AC_CONFIG_COMMANDS_POST([
 	dnl pass on arguments to subdir configures, but don't
 	dnl add them to config.status
diff --git a/lib/Analysis/isl/doc/Makefile.in b/lib/Analysis/isl/doc/Makefile.in
index 3fb0104..b5d1905 100644
--- a/lib/Analysis/isl/doc/Makefile.in
+++ b/lib/Analysis/isl/doc/Makefile.in
@@ -95,6 +95,9 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/ax_c___attribute__.m4 \
 	$(top_srcdir)/m4/ax_compiler_vendor.m4 \
 	$(top_srcdir)/m4/ax_create_pkgconfig_info.m4 \
 	$(top_srcdir)/m4/ax_create_stdint_h.m4 \
+	$(top_srcdir)/m4/ax_cxx_compile_stdcxx.m4 \
+	$(top_srcdir)/m4/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/m4/ax_detect_clang.m4 \
 	$(top_srcdir)/m4/ax_detect_git_head.m4 \
 	$(top_srcdir)/m4/ax_detect_gmp.m4 \
 	$(top_srcdir)/m4/ax_detect_imath.m4 \
@@ -152,6 +155,7 @@ CLANG_LIBS = @CLANG_LIBS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXX11FLAGS = @CXX11FLAGS@
 CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
@@ -171,6 +175,7 @@ GIT_HEAD = @GIT_HEAD@
 GIT_HEAD_ID = @GIT_HEAD_ID@
 GIT_HEAD_VERSION = @GIT_HEAD_VERSION@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -185,6 +190,7 @@ LIB_CLANG_EDIT = @LIB_CLANG_EDIT@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MKDIR_P = @MKDIR_P@
@@ -264,6 +270,7 @@ pkgconfig_libfile = @pkgconfig_libfile@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
+runstatedir = @runstatedir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
diff --git a/lib/Analysis/isl/doc/implementation.tex b/lib/Analysis/isl/doc/implementation.tex
index 096e125..698adb9 100644
--- a/lib/Analysis/isl/doc/implementation.tex
+++ b/lib/Analysis/isl/doc/implementation.tex
@@ -473,6 +473,18 @@ See \autoref{s:online} for the detection
 and exploitation of symmetries that appear during the course of
 the dual simplex method.
 
+Note that the replacement of the $b_i(\vec p)$ by $u$ may lose
+information if the parameters that occur in $b_i(\vec p)$ also
+occur in other constraints.  The replacement is therefore currently
+only applied when all the parameters in all of the $b_i(\vec p)$
+only occur in a single constraint, i.e., the one in which
+the parameter is removed.
+This is the case for the examples from \textcite{Bygde2010licentiate}
+in \autoref{t:comparison}.
+The version of {\tt isl} that was used during the experiments
+of \autoref{s:pip:experiments} did not take into account
+this single-occurrence constraint.
+
 \subsubsection{Parameter Compression}\label{s:compression}
 
 It may in some cases be apparent from the equalities in the problem
@@ -678,7 +690,7 @@ as an \emph{integer} affine combination of other variables is
 propagated to the main tableau, where it is used to eliminate that
 integer division.
 
-\subsection{Experiments}
+\subsection{Experiments}\label{s:pip:experiments}
 
 \autoref{t:comparison} compares the execution times of {\tt isl}
 (with both types of context tableau)
diff --git a/lib/Analysis/isl/doc/manual.pdf b/lib/Analysis/isl/doc/manual.pdf
deleted file mode 100644
index fd8bb1e72c054d0ef30968a43244f36f836765d3..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 473515
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

diff --git a/lib/Analysis/isl/doc/user.pod b/lib/Analysis/isl/doc/user.pod
index 97d2e2e..1bb0da4 100644
--- a/lib/Analysis/isl/doc/user.pod
+++ b/lib/Analysis/isl/doc/user.pod
@@ -253,6 +253,23 @@ is now obtained by turning on the C<schedule_serialize_sccs> option.
 
 =back
 
+=head3 Changes since isl-0.17
+
+=over
+
+=item * The function C<isl_printer_print_ast_expr> no longer prints
+in C format by default.  To print in C format, the output format
+of the printer needs to have been explicitly set to C<ISL_FORMAT_C>.
+As a result, the function C<isl_ast_expr_to_str> no longer prints
+the expression in C format.  Use C<isl_ast_expr_to_C_str> instead.
+
+=item * The functions C<isl_set_align_divs> and C<isl_map_align_divs>
+have been deprecated.  The function C<isl_set_lift> has an effect
+that is similar to C<isl_set_align_divs> and could in some cases
+be used as an alternative.
+
+=back
+
 =head1 License
 
 C<isl> is released under the MIT license.
@@ -704,6 +721,11 @@ The following binary properties are defined on pairs of C<isl_val>s.
 	isl_bool isl_val_abs_eq(__isl_keep isl_val *v1,
 		__isl_keep isl_val *v2);
 
+Comparisons to NaN always return false.
+That is, a NaN is not considered to hold any relative position
+with respect to any value.  In particular, a NaN
+is neither considered to be equal to nor to be different from
+any value (including another NaN).
 The function C<isl_val_abs_eq> checks whether its two arguments
 are equal in absolute value.
 
@@ -751,6 +773,8 @@ The following binary operations are available on C<isl_val>s.
 		unsigned long v2);
 	__isl_give isl_val *isl_val_div(__isl_take isl_val *v1,
 		__isl_take isl_val *v2);
+	__isl_give isl_val *isl_val_div_ui(__isl_take isl_val *v1,
+		unsigned long v2);
 
 On integer values, we additionally have the following operations.
 
@@ -940,6 +964,12 @@ Spaces can be compared using the following functions:
 	#include <isl/space.h>
 	isl_bool isl_space_is_equal(__isl_keep isl_space *space1,
 		__isl_keep isl_space *space2);
+	isl_bool isl_space_has_equal_params(
+		__isl_keep isl_space *space1,
+		__isl_keep isl_space *space2);
+	isl_bool isl_space_has_equal_tuples(
+		__isl_keep isl_space *space1,
+		__isl_keep isl_space *space2);
 	isl_bool isl_space_is_domain(__isl_keep isl_space *space1,
 		__isl_keep isl_space *space2);
 	isl_bool isl_space_is_range(__isl_keep isl_space *space1,
@@ -958,6 +988,19 @@ tuples (C<isl_dim_in>, C<isl_dim_out> or C<isl_dim_set>) of the given
 spaces are the same.  That is, it checks if they have the same
 identifier (if any), the same dimension and the same internal structure
 (if any).
+The function
+C<isl_space_has_equal_params> checks whether two spaces
+have the same parameters in the same order.
+C<isl_space_has_equal_tuples> check whether two spaces have
+the same tuples.  In contrast to C<isl_space_is_equal> below,
+it does not check the
+parameters.  This is useful because many C<isl> functions align the
+parameters before they perform their operations, such that equivalence
+is not necessary.
+C<isl_space_is_equal> checks whether two spaces are identical,
+meaning that they have the same parameters and the same tuples.
+That is, it checks whether both C<isl_space_has_equal_params> and
+C<isl_space_has_equal_tuples> hold.
 
 It is often useful to create objects that live in the
 same space as some other object.  This can be accomplished
@@ -1456,7 +1499,8 @@ using the following functions.
 	isl_bool isl_space_has_tuple_name(
 		__isl_keep isl_space *space,
 		enum isl_dim_type type);
-	const char *isl_space_get_tuple_name(__isl_keep isl_space *space,
+	__isl_keep const char *isl_space_get_tuple_name(
+		__isl_keep isl_space *space,
 		enum isl_dim_type type);
 
 	#include <isl/local_space.h>
@@ -2075,28 +2119,30 @@ variables as integer divisions of the other variables, possibly
 including earlier existentially quantified variables.
 An explicitly represented existentially quantified variable therefore
 has a unique value when the values of the other variables are known.
-If, furthermore, the same existentials, i.e., existentials
-with the same explicit representations, should appear in the
-same order in each of the disjuncts of a set or map, then the user should call
-either of the following functions.
-
-	__isl_give isl_set *isl_set_align_divs(
-		__isl_take isl_set *set);
-	__isl_give isl_map *isl_map_align_divs(
-		__isl_take isl_map *map);
 
 Alternatively, the existentially quantified variables can be removed
 using the following functions, which compute an overapproximation.
 
+	#include <isl/set.h>
 	__isl_give isl_basic_set *isl_basic_set_remove_divs(
 		__isl_take isl_basic_set *bset);
-	__isl_give isl_basic_map *isl_basic_map_remove_divs(
-		__isl_take isl_basic_map *bmap);
 	__isl_give isl_set *isl_set_remove_divs(
 		__isl_take isl_set *set);
+
+	#include <isl/map.h>
+	__isl_give isl_basic_map *isl_basic_map_remove_divs(
+		__isl_take isl_basic_map *bmap);
 	__isl_give isl_map *isl_map_remove_divs(
 		__isl_take isl_map *map);
 
+	#include <isl/union_set.h>
+	__isl_give isl_union_set *isl_union_set_remove_divs(
+		__isl_take isl_union_set *bset);
+
+	#include <isl/union_map.h>
+	__isl_give isl_union_map *isl_union_map_remove_divs(
+		__isl_take isl_union_map *bmap);
+
 It is also possible to only remove those divs that are defined
 in terms of a given range of dimensions or only those for which
 no explicit representation is known.
@@ -2193,11 +2239,17 @@ from
 	int isl_map_n_basic_map(__isl_keep isl_map *map);
 
 It is also possible to obtain a list of basic sets from a set
+or union set
 
 	#include <isl/set.h>
 	__isl_give isl_basic_set_list *isl_set_get_basic_set_list(
 		__isl_keep isl_set *set);
 
+	#include <isl/union_set.h>
+	__isl_give isl_basic_set_list *
+	isl_union_set_get_basic_set_list(
+		__isl_keep isl_union_set *uset);
+
 The returned list can be manipulated using the functions in L<"Lists">.
 
 To iterate over the constraints of a basic set or map, use
@@ -2335,7 +2387,8 @@ Points can be copied or freed using
 
 	__isl_give isl_point *isl_point_copy(
 		__isl_keep isl_point *pnt);
-	void isl_point_free(__isl_take isl_point *pnt);
+	__isl_null isl_point *isl_point_free(
+		__isl_take isl_point *pnt);
 
 A singleton set can be created from a point using
 
@@ -3060,6 +3113,8 @@ use the following functions.
 		isl_stat (*fn)(__isl_take isl_set *set,
 			  __isl_take isl_aff *aff,
 			  void *user), void *user);
+	int isl_pw_multi_aff_n_piece(
+		__isl_keep isl_pw_multi_aff *pma);
 	isl_stat isl_pw_multi_aff_foreach_piece(
 		__isl_keep isl_pw_multi_aff *pma,
 		isl_stat (*fn)(__isl_take isl_set *set,
@@ -3067,6 +3122,8 @@ use the following functions.
 			    void *user), void *user);
 
 	#include <isl/polynomial.h>
+	int isl_pw_qpolynomial_n_piece(
+		__isl_keep isl_pw_qpolynomial *pwqp);
 	isl_stat isl_pw_qpolynomial_foreach_piece(
 		__isl_keep isl_pw_qpolynomial *pwqp,
 		isl_stat (*fn)(__isl_take isl_set *set,
@@ -3077,6 +3134,8 @@ use the following functions.
 		isl_stat (*fn)(__isl_take isl_set *set,
 			  __isl_take isl_qpolynomial *qp,
 			  void *user), void *user);
+	int isl_pw_qpolynomial_fold_n_piece(
+		__isl_keep isl_pw_qpolynomial_fold *pwf);
 	isl_stat isl_pw_qpolynomial_fold_foreach_piece(
 		__isl_keep isl_pw_qpolynomial_fold *pwf,
 		isl_stat (*fn)(__isl_take isl_set *set,
@@ -3662,6 +3721,10 @@ Alternatively, a string representation can be obtained
 directly using the following functions, which always print
 in isl format.
 
+	#include <isl/id.h>
+	__isl_give char *isl_id_to_str(
+		__isl_keep isl_id *id);
+
 	#include <isl/space.h>
 	__isl_give char *isl_space_to_str(
 		__isl_keep isl_space *space);
@@ -3672,6 +3735,8 @@ in isl format.
 		__isl_keep isl_multi_val *mv);
 
 	#include <isl/set.h>
+	__isl_give char *isl_basic_set_to_str(
+		__isl_keep isl_basic_set *bset);
 	__isl_give char *isl_set_to_str(
 		__isl_keep isl_set *set);
 
@@ -3680,6 +3745,8 @@ in isl format.
 		__isl_keep isl_union_set *uset);
 
 	#include <isl/map.h>
+	__isl_give char *isl_basic_map_to_str(
+		__isl_keep isl_basic_map *bmap);
 	__isl_give char *isl_map_to_str(
 		__isl_keep isl_map *map);
 
@@ -3704,6 +3771,16 @@ in isl format.
 	__isl_give char *isl_multi_union_pw_aff_to_str(
 		__isl_keep isl_multi_union_pw_aff *mupa);
 
+	#include <isl/point.h>
+	__isl_give char *isl_point_to_str(
+		__isl_keep isl_point *pnt);
+
+	#include <isl/polynomial.h>
+	__isl_give char *isl_pw_qpolynomial_to_str(
+		__isl_keep isl_pw_qpolynomial *pwqp);
+	__isl_give char *isl_union_pw_qpolynomial_to_str(
+		__isl_keep isl_union_pw_qpolynomial *upwqp);
+
 =head2 Properties
 
 =head3 Unary Properties
@@ -3913,7 +3990,7 @@ To check whether a set is a parameter domain, use this function:
 =item * Wrapping
 
 The following functions check whether the space of the given
-(basic) set or relation range is a wrapped relation.
+(basic) set or relation domain and/or range is a wrapped relation.
 
 	#include <isl/space.h>
 	isl_bool isl_space_is_wrapping(
@@ -3922,6 +3999,8 @@ The following functions check whether the space of the given
 		__isl_keep isl_space *space);
 	isl_bool isl_space_range_is_wrapping(
 		__isl_keep isl_space *space);
+	isl_bool isl_space_is_product(
+		__isl_keep isl_space *space);
 
 	#include <isl/set.h>
 	isl_bool isl_basic_set_is_wrapping(
@@ -3933,6 +4012,7 @@ The following functions check whether the space of the given
 		__isl_keep isl_map *map);
 	isl_bool isl_map_range_is_wrapping(
 		__isl_keep isl_map *map);
+	isl_bool isl_map_is_product(__isl_keep isl_map *map);
 
 	#include <isl/val.h>
 	isl_bool isl_multi_val_range_is_wrapping(
@@ -3950,6 +4030,10 @@ The input to C<isl_space_is_wrapping> should
 be the space of a set, while that of
 C<isl_space_domain_is_wrapping> and
 C<isl_space_range_is_wrapping> should be the space of a relation.
+The input to C<isl_space_is_product> can be either the space
+of a set or that of a binary relation.
+In case the input is the space of a binary relation, it checks
+whether both domain and range are wrapping.
 
 =item * Internal Product
 
@@ -4006,14 +4090,40 @@ the input is itself a wrapped relation.
 
 Check whether the given expression is a constant.
 
+	#include <isl/val.h>
+	isl_bool isl_multi_val_involves_nan(
+		__isl_keep isl_multi_val *mv);
+
 	#include <isl/aff.h>
 	isl_bool isl_aff_is_nan(__isl_keep isl_aff *aff);
+	isl_bool isl_multi_aff_involves_nan(
+		__isl_keep isl_multi_aff *ma);
 	isl_bool isl_pw_aff_involves_nan(
 		__isl_keep isl_pw_aff *pa);
+	isl_bool isl_pw_multi_aff_involves_nan(
+		__isl_keep isl_pw_multi_aff *pma);
+	isl_bool isl_multi_pw_aff_involves_nan(
+		__isl_keep isl_multi_pw_aff *mpa);
+	isl_bool isl_union_pw_aff_involves_nan(
+		__isl_keep isl_union_pw_aff *upa);
+	isl_bool isl_union_pw_multi_aff_involves_nan(
+		__isl_keep isl_union_pw_multi_aff *upma);
+	isl_bool isl_multi_union_pw_aff_involves_nan(
+		__isl_keep isl_multi_union_pw_aff *mupa);
 
 	#include <isl/polynomial.h>
+	isl_bool isl_qpolynomial_is_nan(
+		__isl_keep isl_qpolynomial *qp);
 	isl_bool isl_qpolynomial_fold_is_nan(
 		__isl_keep isl_qpolynomial_fold *fold);
+	isl_bool isl_pw_qpolynomial_involves_nan(
+		__isl_keep isl_pw_qpolynomial *pwqp);
+	isl_bool isl_pw_qpolynomial_fold_involves_nan(
+		__isl_keep isl_pw_qpolynomial_fold *pwf);
+	isl_bool isl_union_pw_qpolynomial_involves_nan(
+		__isl_keep isl_union_pw_qpolynomial *upwqp);
+	isl_bool isl_union_pw_qpolynomial_fold_involves_nan(
+		__isl_keep isl_union_pw_qpolynomial_fold *upwf);
 
 Check whether the given expression is equal to or involves NaN.
 
@@ -4081,9 +4191,15 @@ return true if the objects are not the same.
 	isl_bool isl_pw_aff_plain_is_equal(
 		__isl_keep isl_pw_aff *pwaff1,
 		__isl_keep isl_pw_aff *pwaff2);
+	isl_bool isl_pw_aff_is_equal(
+		__isl_keep isl_pw_aff *pa1,
+		__isl_keep isl_pw_aff *pa2);
 	isl_bool isl_pw_multi_aff_plain_is_equal(
 		__isl_keep isl_pw_multi_aff *pma1,
 		__isl_keep isl_pw_multi_aff *pma2);
+	isl_bool isl_pw_multi_aff_is_equal(
+		__isl_keep isl_pw_multi_aff *pma1,
+		__isl_keep isl_pw_multi_aff *pma2);
 	isl_bool isl_multi_pw_aff_plain_is_equal(
 		__isl_keep isl_multi_pw_aff *mpa1,
 		__isl_keep isl_multi_pw_aff *mpa2);
@@ -4215,10 +4331,14 @@ the internal representation of the inputs has not changed), but may
 change over different versions of C<isl>.
 
 	#include <isl/aff.h>
+	int isl_multi_aff_plain_cmp(
+		__isl_keep isl_multi_aff *ma1,
+		__isl_keep isl_multi_aff *ma2);
 	int isl_pw_aff_plain_cmp(__isl_keep isl_pw_aff *pa1,
 		__isl_keep isl_pw_aff *pa2);
 
-The function C<isl_pw_aff_plain_cmp> can be used to sort
+The functions C<isl_multi_aff_plain_cmp> and
+C<isl_pw_aff_plain_cmp> can be used to sort C<isl_multi_aff>s and
 C<isl_pw_aff>s.  The order is not strictly defined.
 The current order sorts expressions that only involve
 earlier dimensions before those that involve later dimensions.
@@ -4329,6 +4449,9 @@ parameters.
 	#include <isl/aff.h>
 	__isl_give isl_aff *isl_aff_project_domain_on_params(
 		__isl_take isl_aff *aff);
+	__isl_give isl_pw_aff *
+	isl_pw_aff_project_domain_on_params(
+		__isl_take isl_pw_aff *pa);
 	__isl_give isl_pw_multi_aff *
 	isl_pw_multi_aff_project_domain_on_params(
 		__isl_take isl_pw_multi_aff *pma);
@@ -4490,6 +4613,14 @@ flat anonymous space.
 	isl_union_pw_multi_aff_from_domain(
 		__isl_take isl_union_set *uset);
 
+	#include <isl/polynomial.h>
+	__isl_give isl_pw_qpolynomial *
+	isl_pw_qpolynomial_from_range(
+		__isl_take isl_pw_qpolynomial *pwqp);
+	__isl_give isl_pw_qpolynomial_fold *
+	isl_pw_qpolynomial_fold_from_range(
+		__isl_take isl_pw_qpolynomial_fold *pwf);
+
 =item * Slicing
 
 	#include <isl/set.h>
@@ -4537,12 +4668,17 @@ Intersect the set, relation or function domain
 with the hyperplane where the given
 dimension has the fixed given value.
 
-	__isl_give isl_basic_map *isl_basic_map_lower_bound_si(
-		__isl_take isl_basic_map *bmap,
-		enum isl_dim_type type, unsigned pos, int value);
-	__isl_give isl_basic_map *isl_basic_map_upper_bound_si(
-		__isl_take isl_basic_map *bmap,
-		enum isl_dim_type type, unsigned pos, int value);
+	#include <isl/set.h>
+	__isl_give isl_basic_set *
+	isl_basic_set_lower_bound_val(
+		__isl_take isl_basic_set *bset,
+		enum isl_dim_type type, unsigned pos,
+		__isl_take isl_val *value);
+	__isl_give isl_basic_set *
+	isl_basic_set_upper_bound_val(
+		__isl_take isl_basic_set *bset,
+		enum isl_dim_type type, unsigned pos,
+		__isl_take isl_val *value);
 	__isl_give isl_set *isl_set_lower_bound_si(
 		__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, int value);
@@ -4550,9 +4686,6 @@ dimension has the fixed given value.
 		__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos,
 		__isl_take isl_val *value);
-	__isl_give isl_map *isl_map_lower_bound_si(
-		__isl_take isl_map *map,
-		enum isl_dim_type type, unsigned pos, int value);
 	__isl_give isl_set *isl_set_upper_bound_si(
 		__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, int value);
@@ -4560,6 +4693,17 @@ dimension has the fixed given value.
 		__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos,
 		__isl_take isl_val *value);
+
+	#include <isl/map.h>
+	__isl_give isl_basic_map *isl_basic_map_lower_bound_si(
+		__isl_take isl_basic_map *bmap,
+		enum isl_dim_type type, unsigned pos, int value);
+	__isl_give isl_basic_map *isl_basic_map_upper_bound_si(
+		__isl_take isl_basic_map *bmap,
+		enum isl_dim_type type, unsigned pos, int value);
+	__isl_give isl_map *isl_map_lower_bound_si(
+		__isl_take isl_map *map,
+		enum isl_dim_type type, unsigned pos, int value);
 	__isl_give isl_map *isl_map_upper_bound_si(
 		__isl_take isl_map *map,
 		enum isl_dim_type type, unsigned pos, int value);
@@ -5018,6 +5162,8 @@ NaN if the problem is empty.
 		__isl_take isl_set *set, int pos);
 	__isl_give isl_pw_aff *isl_set_dim_max(
 		__isl_take isl_set *set, int pos);
+	__isl_give isl_pw_aff *isl_map_dim_min(
+		__isl_take isl_map *map, int pos);
 	__isl_give isl_pw_aff *isl_map_dim_max(
 		__isl_take isl_map *map, int pos);
 
@@ -5039,8 +5185,12 @@ Fourier-Motzkin elimination, but this may change or be made optional
 in future.  In particular, future implementations may use different
 dualization algorithms or skip the elimination step.
 
+	#include <isl/set.h>
 	__isl_give isl_basic_set *isl_basic_set_coefficients(
 		__isl_take isl_basic_set *bset);
+	__isl_give isl_basic_set_list *
+	isl_basic_set_list_coefficients(
+		__isl_take isl_basic_set_list *list);
 	__isl_give isl_basic_set *isl_set_coefficients(
 		__isl_take isl_set *set);
 	__isl_give isl_union_set *isl_union_set_coefficients(
@@ -5701,6 +5851,14 @@ the same (number of) parameters.
 	__isl_give isl_map *isl_map_intersect(
 		__isl_take isl_map *map1,
 		__isl_take isl_map *map2);
+	__isl_give isl_map *
+	isl_map_intersect_domain_factor_range(
+		__isl_take isl_map *map,
+		__isl_take isl_map *factor);
+	__isl_give isl_map *
+	isl_map_intersect_range_factor_range(
+		__isl_take isl_map *map,
+		__isl_take isl_map *factor);
 
 	#include <isl/union_set.h>
 	__isl_give isl_union_set *isl_union_set_intersect_params(
@@ -5723,6 +5881,10 @@ the same (number of) parameters.
 	__isl_give isl_union_map *isl_union_map_intersect(
 		__isl_take isl_union_map *umap1,
 		__isl_take isl_union_map *umap2);
+	__isl_give isl_union_map *
+	isl_union_map_intersect_range_factor_range(
+		__isl_take isl_union_map *umap,
+		__isl_take isl_union_map *factor);
 
 	#include <isl/aff.h>
 	__isl_give isl_pw_aff *isl_pw_aff_intersect_domain(
@@ -6168,18 +6330,33 @@ into the first expression.
 	__isl_give isl_set *isl_aff_eq_set(
 		__isl_take isl_aff *aff1,
 		__isl_take isl_aff *aff2);
+	__isl_give isl_set *isl_aff_ne_set(
+		__isl_take isl_aff *aff1,
+		__isl_take isl_aff *aff2);
 	__isl_give isl_basic_set *isl_aff_le_basic_set(
 		__isl_take isl_aff *aff1,
 		__isl_take isl_aff *aff2);
 	__isl_give isl_set *isl_aff_le_set(
 		__isl_take isl_aff *aff1,
 		__isl_take isl_aff *aff2);
+	__isl_give isl_basic_set *isl_aff_lt_basic_set(
+		__isl_take isl_aff *aff1,
+		__isl_take isl_aff *aff2);
+	__isl_give isl_set *isl_aff_lt_set(
+		__isl_take isl_aff *aff1,
+		__isl_take isl_aff *aff2);
 	__isl_give isl_basic_set *isl_aff_ge_basic_set(
 		__isl_take isl_aff *aff1,
 		__isl_take isl_aff *aff2);
 	__isl_give isl_set *isl_aff_ge_set(
 		__isl_take isl_aff *aff1,
 		__isl_take isl_aff *aff2);
+	__isl_give isl_basic_set *isl_aff_gt_basic_set(
+		__isl_take isl_aff *aff1,
+		__isl_take isl_aff *aff2);
+	__isl_give isl_set *isl_aff_gt_set(
+		__isl_take isl_aff *aff1,
+		__isl_take isl_aff *aff2);
 	__isl_give isl_set *isl_pw_aff_eq_set(
 		__isl_take isl_pw_aff *pwaff1,
 		__isl_take isl_pw_aff *pwaff2);
@@ -7342,6 +7519,11 @@ Lists can be created, copied, modified and freed using the following functions.
 	__isl_give isl_set_list *isl_set_list_concat(
 		__isl_take isl_set_list *list1,
 		__isl_take isl_set_list *list2);
+	__isl_give isl_set_list *isl_set_list_map(
+		__isl_take isl_set_list *list,
+		__isl_give isl_set *(*fn)(__isl_take isl_set *el,
+			void *user),
+		void *user);
 	__isl_give isl_set_list *isl_set_list_sort(
 		__isl_take isl_set_list *list,
 		int (*cmp)(__isl_keep isl_set *a,
@@ -7572,7 +7754,7 @@ library.
 
 The function C<isl_basic_set_compute_vertices> performs the
 actual computation of the parametric vertices and the chamber
-decomposition and store the result in an C<isl_vertices> object.
+decomposition and stores the result in an C<isl_vertices> object.
 This information can be queried by either iterating over all
 the vertices or iterating over all the chambers or cells
 and then iterating over all vertices that are active on the chamber.
@@ -7595,7 +7777,8 @@ the following.
 
 	int isl_vertices_get_n_vertices(
 		__isl_keep isl_vertices *vertices);
-	void isl_vertices_free(__isl_take isl_vertices *vertices);
+	__isl_null isl_vertices *isl_vertices_free(
+		__isl_take isl_vertices *vertices);
 
 Vertices can be inspected and destroyed using the following functions.
 
@@ -7664,7 +7847,7 @@ A filter node does not impose any ordering, but rather intersects
 the set of domain elements that the current subtree refers to
 with a given union set.  The subtree of the filter node only
 refers to domain elements in the intersection.
-A filter node is typically only used a child of a sequence or
+A filter node is typically only used as a child of a sequence or
 set node.
 
 =item C<isl_schedule_node_leaf>
@@ -8123,7 +8306,8 @@ a band node with an anchored subtree.
 		__isl_take isl_schedule_node *node);
 
 Most nodes in a schedule tree only contain local information.
-In some cases, however, a node may also refer to outer band nodes.
+In some cases, however, a node may also refer to the schedule dimensions
+of its outer band nodes.
 This means that the position of the node within the tree should
 not be changed, or at least that no changes are performed to the
 outer band nodes.  The following function can be used to test
@@ -8601,26 +8785,31 @@ C<isl_schedule_node_to_str> prints the schedule node in block format.
 =head2 Dependence Analysis
 
 C<isl> contains specialized functionality for performing
-array dataflow analysis.  That is, given a I<sink> access relation
-and a collection of possible I<source> access relations,
+array dataflow analysis.  That is, given a I<sink> access relation,
+a collection of possible I<source> accesses and
+a collection of I<kill> accesses,
 C<isl> can compute relations that describe
-for each iteration of the sink access, which iteration
-of which of the source access relations was the last
-to access the same data element before the given iteration
-of the sink access.
+for each iteration of the sink access, which iterations
+of which of the source access relations may have
+accessed the same data element before the given iteration
+of the sink access without any intermediate kill of that data element.
 The resulting dependence relations map source iterations
 to either the corresponding sink iterations or
 pairs of corresponding sink iterations and accessed data elements.
 To compute standard flow dependences, the sink should be
 a read, while the sources should be writes.
-If any of the source accesses are marked as being I<may>
-accesses, then there will be a dependence from the last
-I<must> access B<and> from any I<may> access that follows
-this last I<must> access.
-In particular, if I<all> sources are I<may> accesses,
+If no kills are specified,
 then memory based dependence analysis is performed.
-If, on the other hand, all sources are I<must> accesses,
+If, on the other hand, all sources are also kills,
 then value based dependence analysis is performed.
+If any of the source accesses are marked as being I<must>
+accesses, then they are also treated as kills.
+Furthermore, the specification of must-sources results
+in the computation of must-dependences.
+Only dependences originating in a must access not coscheduled
+with any other access to the same element and without
+any may accesses between the must access and the sink access
+are considered to be must dependences.
 
 =head3 High-level Interface
 
@@ -8646,14 +8835,18 @@ the following functions.
 	isl_union_access_info_from_sink(
 		__isl_take isl_union_map *sink);
 	__isl_give isl_union_access_info *
-	isl_union_access_info_set_must_source(
+	isl_union_access_info_set_kill(
 		__isl_take isl_union_access_info *access,
-		__isl_take isl_union_map *must_source);
+		__isl_take isl_union_map *kill);
 	__isl_give isl_union_access_info *
 	isl_union_access_info_set_may_source(
 		__isl_take isl_union_access_info *access,
 		__isl_take isl_union_map *may_source);
 	__isl_give isl_union_access_info *
+	isl_union_access_info_set_must_source(
+		__isl_take isl_union_access_info *access,
+		__isl_take isl_union_map *must_source);
+	__isl_give isl_union_access_info *
 	isl_union_access_info_set_schedule(
 		__isl_take isl_union_access_info *access,
 		__isl_take isl_schedule *schedule);
@@ -8671,7 +8864,9 @@ the following functions.
 The may sources set by C<isl_union_access_info_set_may_source>
 do not need to include the must sources set by
 C<isl_union_access_info_set_must_source> as a subset.
-The user is free not to call one (or both) of these functions,
+The kills set by C<isl_union_access_info_set_kill> may overlap
+with the may-sources and/or must-sources.
+The user is free not to call one (or more) of these functions,
 in which case the corresponding set is kept to its empty default.
 Similarly, the default schedule initialized by
 C<isl_union_access_info_from_sink> is empty.
@@ -8683,6 +8878,14 @@ the access relations.  In particular, the domains of the access
 relations are effectively intersected with the domain of the schedule
 and only the resulting accesses are considered by the dependence analysis.
 
+An C<isl_union_access_info> object can be read from input
+using the following function.
+
+	#include <isl/flow.h>
+	__isl_give isl_union_access_info *
+	isl_union_access_info_read_from_file(isl_ctx *ctx,
+		FILE *input);
+
 A representation of the information contained in an object
 of type C<isl_union_access_info> can be obtained using
 
@@ -8696,8 +8899,8 @@ of type C<isl_union_access_info> can be obtained using
 
 C<isl_union_access_info_to_str> prints the information in flow format.
 
-The output of C<isl_union_access_info_compute_flow> can be examined
-and freed using the following functions.
+The output of C<isl_union_access_info_compute_flow> can be examined,
+copied, and freed using the following functions.
 
 	#include <isl/flow.h>
 	__isl_give isl_union_map *isl_union_flow_get_must_dependence(
@@ -8714,6 +8917,8 @@ and freed using the following functions.
 		__isl_keep isl_union_flow *flow);
 	__isl_give isl_union_map *isl_union_flow_get_may_no_source(
 		__isl_keep isl_union_flow *flow);
+	__isl_give isl_union_flow *isl_union_flow_copy(
+		__isl_keep isl_union_flow *flow);
 	__isl_null isl_union_flow *isl_union_flow_free(
 		__isl_take isl_union_flow *flow);
 
@@ -8790,6 +8995,7 @@ C<sink>, a token C<sink_user> used to identify the sink
 access to the user, a callback function for specifying the
 relative order of source and sink accesses, and the number
 of source access relations that will be added.
+
 The callback function has type C<int (*)(void *first, void *second)>.
 The function is called with two user supplied tokens identifying
 either a source or the sink and it should return the shared nesting
@@ -8798,7 +9004,12 @@ In particular, let I<n> be the number of loops shared by
 the two accesses.  If C<first> precedes C<second> textually,
 then the function should return I<2 * n + 1>; otherwise,
 it should return I<2 * n>.
-The sources can be added to the C<isl_access_info> by performing
+The low-level interface assumes that no sources are coscheduled.
+If the information returned by the callback does not allow
+the relative order to be determined, then one of the sources
+is arbitrarily taken to be executed after the other(s).
+
+The sources can be added to the C<isl_access_info> object by performing
 (at most) C<max_source> calls to C<isl_access_info_add_source>.
 C<must> indicates whether the source is a I<must> access
 or a I<may> access.  Note that a multi-valued access relation
@@ -8809,7 +9020,7 @@ the source access.  The range of the source access relation
 C<source> should have the same dimension as the range
 of the sink access relation.
 The C<isl_access_info_free> function should usually not be
-called explicitly, because it is called implicitly by
+called explicitly, because it is already called implicitly by
 C<isl_access_info_compute_flow>.
 
 The result of the dependence analysis is collected in an
@@ -9049,6 +9260,8 @@ using the following functions.
 	__isl_give isl_union_set *
 	isl_schedule_constraints_get_domain(
 		__isl_keep isl_schedule_constraints *sc);
+	__isl_give isl_set *isl_schedule_constraints_get_context(
+		__isl_keep isl_schedule_constraints *sc);
 	__isl_give isl_union_map *
 	isl_schedule_constraints_get_validity(
 		__isl_keep isl_schedule_constraints *sc);
@@ -9065,6 +9278,28 @@ using the following functions.
 	isl_schedule_constraints_get_conditional_validity_condition(
 		__isl_keep isl_schedule_constraints *sc);
 
+An C<isl_schedule_constraints> object can be read from input
+using the following functions.
+
+	#include <isl/schedule.h>
+	__isl_give isl_schedule_constraints *
+	isl_schedule_constraints_read_from_str(isl_ctx *ctx,
+		const char *str);
+	__isl_give isl_schedule_constraints *
+	isl_schedule_constraints_read_from_file(isl_ctx *ctx,
+		FILE *input);
+
+The contents of an C<isl_schedule_constraints> object can be printed
+using the following functions.
+
+	#include <isl/schedule.h>
+	__isl_give isl_printer *
+	isl_printer_print_schedule_constraints(
+		__isl_take isl_printer *p,
+		__isl_keep isl_schedule_constraints *sc);
+	__isl_give char *isl_schedule_constraints_to_str(
+		__isl_keep isl_schedule_constraints *sc);
+
 The following function computes a schedule directly from
 an iteration domain and validity and proximity dependences
 and is implemented in terms of the functions described above.
@@ -9122,6 +9357,10 @@ L</"Schedule Trees">.
 		isl_ctx *ctx, int val);
 	int isl_options_get_schedule_algorithm(
 		isl_ctx *ctx);
+	isl_stat isl_options_set_schedule_carry_self_first(
+		isl_ctx *ctx, int val);
+	int isl_options_get_schedule_carry_self_first(
+		isl_ctx *ctx);
 	isl_stat isl_options_set_schedule_separate_components(
 		isl_ctx *ctx, int val);
 	int isl_options_get_schedule_separate_components(
@@ -9201,9 +9440,9 @@ and C<ISL_SCHEDULE_ALGORITHM_FEAUTRIER>.
 
 If this option is set, then we try to construct schedules in which the
 constant term is split off from the linear part if the linear parts of
-the scheduling rows for all nodes in the graphs have a common non-trivial
+the scheduling rows for all nodes in the graph have a common non-trivial
 divisor.
-The constant term is then placed in a separate band and the linear
+The constant term is then dropped and the linear
 part is reduced.
 This option is only effective when the Feautrier style scheduler is
 being used, either as the main scheduler or as a fallback for the
@@ -9219,6 +9458,12 @@ For the Feautrier style scheduler, this option detects potentially
 coalescing schedules and then tries to adjust the schedule to avoid
 the coalescing.
 
+=item * schedule_carry_self_first
+
+If this option is set, then the Feautrier style scheduler
+(when used as a fallback for the Pluto-like scheduler) will
+first try to only carry self-dependences.
+
 =item * schedule_separate_components
 
 If this option is set then the function C<isl_schedule_get_map>
@@ -9714,6 +9959,16 @@ Basic printing can be performed using the following functions.
 		__isl_keep isl_ast_node *node);
 	__isl_give char *isl_ast_expr_to_str(
 		__isl_keep isl_ast_expr *expr);
+	__isl_give char *isl_ast_node_to_str(
+		__isl_keep isl_ast_node *node);
+	__isl_give char *isl_ast_expr_to_C_str(
+		__isl_keep isl_ast_expr *expr);
+	__isl_give char *isl_ast_node_to_C_str(
+		__isl_keep isl_ast_node *node);
+
+The functions C<isl_ast_expr_to_C_str> and
+C<isl_ast_node_to_C_str> are convenience functions
+that return a string representation of the input in C format.
 
 More advanced printing can be performed using the following functions.
 
@@ -10080,7 +10335,8 @@ This option may also be set directly using
 C<isl_schedule_node_band_member_set_isolate_ast_loop_type>.
 The atomic/separate/unroll choice for the remaining part is determined
 by the regular C<atomic>, C<separate> or C<unroll> option.
-The use of the C<isolate> option causes any tree containing the node
+Since the C<isolate> option references outer schedule dimensions,
+its use in a band node causes any tree containing the node
 to be considered anchored.
 
 As an example, consider the isolation of full tiles from partial tiles
@@ -10541,7 +10797,8 @@ C<isl_ast_build_get_schedule> having any particular value.
 Although C<isl> is mainly meant to be used as a library,
 it also contains some basic applications that use some
 of the functionality of C<isl>.
-The input may be specified in either the L<isl format>
+For applications that take one or more polytopes or polyhedra
+as input, this input may be specified in either the L<isl format>
 or the L<PolyLib format>.
 
 =head2 C<isl_polyhedron_sample>
@@ -10576,9 +10833,22 @@ is given, then the constant should appear in the last column.
 Given a polytope, C<isl_polytope_scan> prints
 all integer points in the polytope.
 
+=head2 C<isl_flow>
+
+Given an C<isl_union_access_info> object as input,
+C<isl_flow> prints out the corresponding dependences,
+as computed by C<isl_union_access_info_compute_flow>.
+
 =head2 C<isl_codegen>
 
-Given a schedule, a context set and an options relation,
+Given either a schedule tree or a sequence consisting of
+a schedule map, a context set and an options relation,
 C<isl_codegen> prints out an AST that scans the domain elements
 of the schedule in the order of their image(s) taking into account
 the constraints in the context set.
+
+=head2 C<isl_schedule>
+
+Given an C<isl_schedule_constraints> object as input,
+C<isl_schedule> prints out a schedule that satisfies the given
+constraints.
diff --git a/lib/Analysis/isl/extract_key.c b/lib/Analysis/isl/extract_key.c
new file mode 100644
index 0000000..070c1f6
--- /dev/null
+++ b/lib/Analysis/isl/extract_key.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2013      Ecole Normale Superieure
+ *
+ * Use of this software is governed by the MIT license
+ *
+ * Written by Sven Verdoolaege,
+ * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
+ */
+
+#include <string.h>
+
+/* Extract a mapping key from the token "tok".
+ * Return KEY_ERROR on error, i.e., if "tok" does not
+ * correspond to any known key.
+ */
+static KEY extract_key(__isl_keep isl_stream *s, struct isl_token *tok)
+{
+	int type;
+	char *name;
+	KEY key;
+	isl_ctx *ctx;
+
+	if (!tok)
+		return KEY_ERROR;
+	type = isl_token_get_type(tok);
+	if (type != ISL_TOKEN_IDENT && type != ISL_TOKEN_STRING) {
+		isl_stream_error(s, tok, "expecting key");
+		return KEY_ERROR;
+	}
+
+	ctx = isl_stream_get_ctx(s);
+	name = isl_token_get_str(ctx, tok);
+	if (!name)
+		return KEY_ERROR;
+
+	for (key = 0; key < KEY_END; ++key) {
+		if (!strcmp(name, key_str[key]))
+			break;
+	}
+	free(name);
+
+	if (key >= KEY_END)
+		isl_die(ctx, isl_error_invalid, "unknown key",
+			return KEY_ERROR);
+	return key;
+}
+
+/* Read a key from "s" and return the corresponding enum.
+ * Return KEY_ERROR on error, i.e., if the first token
+ * on the stream does not correspond to any known key.
+ */
+static KEY get_key(__isl_keep isl_stream *s)
+{
+	struct isl_token *tok;
+	KEY key;
+
+	tok = isl_stream_next_token(s);
+	key = extract_key(s, tok);
+	isl_token_free(tok);
+
+	return key;
+}
diff --git a/lib/Analysis/isl/flow.c b/lib/Analysis/isl/flow.c
new file mode 100644
index 0000000..9472c5b
--- /dev/null
+++ b/lib/Analysis/isl/flow.c
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2017      Sven Verdoolaege
+ *
+ * Use of this software is governed by the MIT license
+ *
+ * Written by Sven Verdoolaege.
+ */
+
+/* This program takes an isl_union_access_info object as input and
+ * prints the corresponding dependences.
+ */
+
+#include <isl/options.h>
+#include <isl/printer.h>
+#include <isl/union_map.h>
+#include <isl/flow.h>
+#include <isl/schedule.h>
+
+int main(int argc, char **argv)
+{
+	isl_ctx *ctx;
+	isl_printer *p;
+	isl_union_access_info *access;
+	isl_union_flow *flow;
+	struct isl_options *options;
+
+	options = isl_options_new_with_defaults();
+	argc = isl_options_parse(options, argc, argv, ISL_ARG_ALL);
+	ctx = isl_ctx_alloc_with_options(&isl_options_args, options);
+
+	access = isl_union_access_info_read_from_file(ctx, stdin);
+	flow = isl_union_access_info_compute_flow(access);
+
+	p = isl_printer_to_file(ctx, stdout);
+	p = isl_printer_set_yaml_style(p, ISL_YAML_STYLE_BLOCK);
+	p = isl_printer_print_union_flow(p, flow);
+	isl_printer_free(p);
+
+	isl_union_flow_free(flow);
+
+	isl_ctx_free(ctx);
+
+	return 0;
+}
diff --git a/lib/Analysis/isl/flow_cmp.c b/lib/Analysis/isl/flow_cmp.c
new file mode 100644
index 0000000..ca7e377
--- /dev/null
+++ b/lib/Analysis/isl/flow_cmp.c
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2017      Sven Verdoolaege
+ *
+ * Use of this software is governed by the MIT license
+ *
+ * Written by Sven Verdoolaege.
+ */
+
+#include <stdlib.h>
+
+#include <isl/arg.h>
+#include <isl/options.h>
+#include <isl/union_map.h>
+#include <isl/stream.h>
+
+struct options {
+	struct isl_options *isl;
+	char *flow1;
+	char *flow2;
+};
+
+ISL_ARGS_START(struct options, options_args)
+ISL_ARG_CHILD(struct options, isl, "isl", &isl_options_args, "isl options")
+ISL_ARG_ARG(struct options, flow1, "flow1", NULL)
+ISL_ARG_ARG(struct options, flow2, "flow2", NULL)
+ISL_ARGS_END
+
+ISL_ARG_DEF(options, struct options, options_args)
+
+static void die(const char *msg)
+{
+	fprintf(stderr, "%s\n", msg);
+	exit(EXIT_FAILURE);
+}
+
+static FILE *open_or_die(const char *filename)
+{
+	FILE *file;
+
+	file = fopen(filename, "r");
+	if (!file) {
+		fprintf(stderr, "Unable to open %s\n", filename);
+		exit(EXIT_FAILURE);
+	}
+	return file;
+}
+
+#undef BASE
+#define BASE union_map
+#include "read_in_string_templ.c"
+
+/* Given two YAML descriptions of isl_union_flow objects, check whether
+ * they are equivalent.
+ * Return EXIT_SUCCESS if they are and EXIT_FAILURE if they are not
+ * or if anything else went wrong.
+ *
+ * The descriptions are checked field by field, meaning that the fields
+ * are expected to appear in the same order in both inputs.
+ */
+int main(int argc, char **argv)
+{
+	int more;
+	isl_ctx *ctx;
+	struct options *options;
+	FILE *input1, *input2;
+	isl_stream *s1, *s2;
+
+	options = options_new_with_defaults();
+	if (!options)
+		return EXIT_FAILURE;
+
+	ctx = isl_ctx_alloc_with_options(&options_args, options);
+	argc = options_parse(options, argc, argv, ISL_ARG_ALL);
+
+	input1 = open_or_die(options->flow1);
+	input2 = open_or_die(options->flow2);
+	s1 = isl_stream_new_file(ctx, input1);
+	s2 = isl_stream_new_file(ctx, input2);
+
+	if (isl_stream_yaml_read_start_mapping(s1))
+		isl_die(ctx, isl_error_unknown, "arg1 not a YAML mapping",
+			return EXIT_FAILURE);
+	if (isl_stream_yaml_read_start_mapping(s2))
+		isl_die(ctx, isl_error_unknown, "arg2 not a YAML mapping",
+			return EXIT_FAILURE);
+
+	while ((more = isl_stream_yaml_next(s1)) > 0) {
+		int more2;
+		isl_bool equal;
+		isl_union_map *umap1, *umap2;
+
+		more2 = isl_stream_yaml_next(s2);
+		if (more2 < 0)
+			return EXIT_FAILURE;
+		if (!more2)
+			isl_die(ctx, isl_error_unknown, "arg2 shorter",
+				return EXIT_FAILURE);
+		if (isl_stream_eat(s1, ISL_TOKEN_IDENT) < 0)
+			return EXIT_FAILURE;
+		if (isl_stream_eat(s2, ISL_TOKEN_IDENT) < 0)
+			return EXIT_FAILURE;
+		more = isl_stream_yaml_next(s1);
+		more2 = isl_stream_yaml_next(s2);
+		if (more < 0 || more2 < 0)
+			return EXIT_FAILURE;
+		if (!more || !more2)
+			isl_die(ctx, isl_error_unknown, "missing value",
+				return EXIT_FAILURE);
+
+		umap1 = read_union_map(s1);
+		umap2 = read_union_map(s2);
+		equal = isl_union_map_is_equal(umap1, umap2);
+		isl_union_map_free(umap1);
+		isl_union_map_free(umap2);
+		if (equal < 0)
+			return EXIT_FAILURE;
+		if (!equal)
+			die("field not equal");
+	}
+	if (more < 0)
+		return EXIT_FAILURE;
+
+
+	if (isl_stream_yaml_read_end_mapping(s1) < 0) {
+		isl_stream_error(s1, NULL, "unexpected extra elements");
+		return EXIT_FAILURE;
+	}
+	if (isl_stream_yaml_read_end_mapping(s2) < 0) {
+		isl_stream_error(s2, NULL, "unexpected extra elements");
+		return EXIT_FAILURE;
+	}
+
+	isl_stream_free(s1);
+	isl_stream_free(s2);
+	fclose(input1);
+	fclose(input2);
+	isl_ctx_free(ctx);
+
+	return EXIT_SUCCESS;
+}
diff --git a/lib/Analysis/isl/flow_test.sh.in b/lib/Analysis/isl/flow_test.sh.in
new file mode 100644
index 0000000..fa9177c
--- /dev/null
+++ b/lib/Analysis/isl/flow_test.sh.in
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+EXEEXT=@EXEEXT@
+srcdir=@srcdir@
+
+failed=0
+
+for i in $srcdir/test_inputs/flow/*.ai; do
+	echo $i;
+	base=`basename $i .ai`
+	test=test-$base.flow
+	dir=`dirname $i`
+	ref=$dir/$base.flow
+	(./isl_flow$EXEEXT < $i > $test &&
+	./isl_flow_cmp$EXEEXT $ref $test && rm $test) || failed=1
+done
+
+test $failed -eq 0 || exit
diff --git a/lib/Analysis/isl/imath/gmp_compat.c b/lib/Analysis/isl/imath/gmp_compat.c
index 30b63e6..fb45547 100644
--- a/lib/Analysis/isl/imath/gmp_compat.c
+++ b/lib/Analysis/isl/imath/gmp_compat.c
@@ -28,6 +28,12 @@
 #include <assert.h>
 #include <ctype.h>
 #include <string.h>
+#include <stdio.h>
+
+#if defined(_MSC_VER)
+#include <BaseTsd.h>
+typedef SSIZE_T ssize_t;
+#endif
 
 #ifdef  NDEBUG
 #define CHECK(res) (res)
@@ -35,6 +41,12 @@
 #define CHECK(res) assert(((res) == MP_OK) && "expected MP_OK")
 #endif
 
+/* *(signed char *)&endian_test will thus either be:
+ *     0b00000001 =  1 on big-endian
+ *     0b11111111 = -1 on little-endian */
+static const uint16_t endian_test = 0x1FF;
+#define HOST_ENDIAN (*(signed char *)&endian_test)
+
 /*************************************************************************
  *
  * Functions with direct translations
@@ -190,18 +202,18 @@ void GMPZAPI(divexact)(mp_int q, mp_int n, mp_int d) {
 
 /* gmp: mpz_divisible_p */
 /* gmp: return 1 if d divides n, 0 otherwise */
-/* gmp: 0 is considered to divide 0*/
+/* gmp: 0 is considered to divide only 0 */
 int GMPZAPI(divisible_p)(mp_int n, mp_int d) {
   /* variables to hold remainder */
   mpz_t rz;
   mp_int r = &rz;
   int r_is_zero;
 
-  /* check for n = 0, d = 0 */
+  /* check for d = 0 */
   int n_is_zero = mp_int_compare_zero(n) == 0;
   int d_is_zero = mp_int_compare_zero(d) == 0;
-  if (n_is_zero && d_is_zero)
-    return 1;
+  if (d_is_zero)
+    return n_is_zero;
 
   /* return true if remainder is 0 */
   CHECK(mp_int_init(r));
@@ -673,22 +685,19 @@ unsigned long GMPZAPI(fdiv_q_ui)(mp_int q, mp_int n, unsigned long d) {
 
 /* gmp: mpz_export */
 void* GMPZAPI(export)(void *rop, size_t *countp, int order, size_t size, int endian, size_t nails, mp_int op) {
-  int i;
+  int i, j;
   int num_used_bytes;
   size_t num_words, num_missing_bytes;
+  ssize_t word_offset;
   unsigned char* dst;
-  unsigned char* src;
+  mp_digit* src;
+  int src_bits;
 
   /* We do not have a complete implementation. Assert to ensure our
-   * restrictions are in place, We do not support big endian output, but do not
-   * check that native endian is little endian. */
+   * restrictions are in place. */
   assert(nails  == 0 && "Do not support non-full words");
-  assert((endian == 0 || endian == -1) && "Do not support big endian");
-
-  /* The gmp API requires that order must be -1 or 1.
-     Not sure how gmp behaves when order is not 1 or -1, so force all non-one
-     values to -1 for now. */
-  if (order != 1) order = -1;
+  assert(endian == 1 || endian == 0 || endian == -1);
+  assert(order == 1 || order == -1);
 
   /* Test for zero */
   if (mp_int_compare_zero(op) == 0) {
@@ -719,47 +728,32 @@ void* GMPZAPI(export)(void *rop, size_t *countp, int order, size_t size, int end
     rop = malloc(num_words * size);
   }
 
-  /* Initialize dst and src pointers */
-  dst = (unsigned char *)rop;
-  src = (unsigned char *)MP_DIGITS(op);
-
-  /* Most significant word first */
-  if (order == 1) {
-    size_t words_written = 0;
-    src += (num_words-1) * size;
-
-    /* Handle write of first word specially */
-    for (i = 0; i < size - num_missing_bytes; i++)
-      dst[i] = src[i];
-    for (; i < size; i++)
-      dst[i] = 0;
-    dst += size;
-    src -= size;
-    words_written++;
-
-    for (; words_written < num_words; words_written++) {
-      for (i = 0; i < size; i++)
-        dst[i] = src[i];
-      dst += size;
-      src -= size;
-    }
+  if (endian == 0) {
+    endian = HOST_ENDIAN;
   }
-  /* Least significant word first */
-  else {
-    size_t words_written = 0;
-    for (; words_written < num_words - 1; words_written++) {
-      for (i = 0; i < size; i++)
-        dst[i] = src[i];
-      dst += size;
-      src += size;
-    }
 
-    /* Handle write of last word specially */
-    for (i = 0; i < size - num_missing_bytes; i++)
-      dst[i] = src[i];
+  /* Initialize dst and src pointers */
+  dst = (unsigned char *) rop + (order >= 0 ? (num_words-1) * size : 0) + (endian >= 0 ? size-1 : 0);
+  src = MP_DIGITS(op);
+  src_bits = MP_DIGIT_BIT;
+
+  word_offset = (endian >= 0 ? size : -size) + (order < 0 ? size : -size);
 
-    for (; i < size; i++)
-      dst[i] = 0;
+  for (i = 0; i < num_words; i++) {
+    for (j = 0; j < size && i * size + j < num_used_bytes; j++) {
+      if (src_bits == 0) {
+        ++src;
+        src_bits = MP_DIGIT_BIT;
+      }
+      *dst = (*src >> (MP_DIGIT_BIT - src_bits)) & 0xFF;
+      src_bits -= 8;
+      dst -= endian;
+    }
+    for (; j < size; j++) {
+      *dst = 0;
+      dst -= endian;
+    }
+    dst += word_offset;
   }
 
   if (countp)
@@ -773,17 +767,23 @@ void GMPZAPI(import)(mp_int rop, size_t count, int order, size_t size, int endia
   mp_int tmp = &tmpz;
   size_t total_size;
   size_t num_digits;
-  const char *src;
-  char *dst;
-  int i;
+  ssize_t word_offset;
+  const unsigned char *src;
+  mp_digit *dst;
+  int dst_bits;
+  int i, j;
   if (count == 0 || op == NULL)
     return;
 
   /* We do not have a complete implementation. Assert to ensure our
-   * restrictions are in place, We do not support big endian output, but do not
-   * check that native endian is little endian. */
+   * restrictions are in place. */
   assert(nails  == 0 && "Do not support non-full words");
-  assert((endian == 0 || endian == -1) && "Do not support big endian");
+  assert(endian == 1 || endian == 0 || endian == -1);
+  assert(order == 1 || order == -1);
+
+  if (endian == 0) {
+    endian = HOST_ENDIAN;
+  }
 
   /* Compute number of needed digits by ceil division */
   total_size = count * size;
@@ -795,30 +795,25 @@ void GMPZAPI(import)(mp_int rop, size_t count, int order, size_t size, int endia
     tmp->digits[i] = 0;
 
   /* Copy bytes */
-  src = (const char *) op;
-  dst = (char *)MP_DIGITS(tmp);
-
-  /* Most significant word is first */
-  if (order == 1) {
-    size_t word;
-    dst += (count - 1) * size;
-    for (word = 0; word < count; word++) {
-      for (i = 0; i < size; i++)
-        dst[i] = src[i];
-      dst -= size;
-      src += size;
-    }
-  }
-  /* Least significant word is first */
-  else {
-    size_t word;
-    for (word = 0; word < count; word++) {
-      for (i = 0; i < size; i++)
-        dst[i] = src[i];
-      dst += size;
-      src += size;
+  src = (const unsigned char *) op + (order >= 0 ? (count-1) * size : 0) + (endian >= 0 ? size-1 : 0);
+  dst = MP_DIGITS(tmp);
+  dst_bits = 0;
+
+  word_offset = (endian >= 0 ? size : -size) + (order < 0 ? size : -size);
+
+  for (i = 0; i < count; i++) {
+    for (j = 0; j < size; j++) {
+      if (dst_bits == MP_DIGIT_BIT) {
+        ++dst;
+        dst_bits = 0;
+      }
+      *dst |= ((mp_digit)*src) << dst_bits;
+      dst_bits += 8;
+      src -= endian;
     }
+    src += word_offset;
   }
+
   MP_USED(tmp) = num_digits;
 
   /* Remove leading zeros from number */
diff --git a/lib/Analysis/isl/imath/imath.c b/lib/Analysis/isl/imath/imath.c
index 7a767dc..be99305 100644
--- a/lib/Analysis/isl/imath/imath.c
+++ b/lib/Analysis/isl/imath/imath.c
@@ -993,7 +993,7 @@ mp_result mp_int_expt(mp_int a, mp_small b, mp_int c)
 {
   mpz_t t;
   mp_result res;
-  unsigned int v = abs(b);
+  unsigned int v = labs(b);
 
   CHECK(c != NULL);
   if (b < 0)
@@ -1025,7 +1025,7 @@ mp_result mp_int_expt_value(mp_small a, mp_small b, mp_int c)
 {
   mpz_t     t;
   mp_result res;
-  unsigned int v = abs(b);
+  unsigned int v = labs(b);
 
   CHECK(c != NULL);
   if (b < 0)
@@ -1635,7 +1635,7 @@ mp_result mp_int_to_int(mp_int z, mp_small *out)
   }
 
   if (out)
-    *out = (sz == MP_NEG) ? -(mp_small)uv : (mp_small)uv;
+    *out = (mp_small)((sz == MP_NEG) ? -uv : uv);
 
   return MP_OK;
 }
@@ -2092,7 +2092,7 @@ STATIC int      s_ucmp(mp_int a, mp_int b)
 
 STATIC int      s_vcmp(mp_int a, mp_small v)
 {
-  mp_usmall uv = (mp_usmall) (v < 0) ? -v : v;
+  mp_usmall uv = (v < 0) ? -(mp_usmall) v : (mp_usmall) v;
   return s_uvcmp(a, uv);
 }
 
@@ -2511,7 +2511,7 @@ STATIC void     s_qmod(mp_int z, mp_size p2)
 {
   mp_size start = p2 / MP_DIGIT_BIT + 1, rest = p2 % MP_DIGIT_BIT;
   mp_size uz = MP_USED(z);
-  mp_digit mask = (1 << rest) - 1;
+  mp_digit mask = (1u << rest) - 1;
 
   if (start <= uz) {
     MP_USED(z) = start;
@@ -2679,7 +2679,7 @@ STATIC int      s_norm(mp_int a, mp_int b)
   mp_digit d = b->digits[MP_USED(b) - 1];
   int k = 0;
 
-  while (d < (mp_digit) (1 << (MP_DIGIT_BIT - 1))) { /* d < (MP_RADIX / 2) */
+  while (d < (1u << (mp_digit)(MP_DIGIT_BIT - 1))) { /* d < (MP_RADIX / 2) */
     d <<= 1;
     ++k;
   }
@@ -2816,106 +2816,6 @@ STATIC mp_result s_embar(mp_int a, mp_int b, mp_int m, mp_int mu, mp_int c)
   return res;
 }
 
-#if 0
-/*
-  The s_udiv function produces incorrect results. For example, with test
-     div:11141460315522012760862883825:48318382095:0,230584300062375935
-   commenting out the function for now and using s_udiv_knuth instead.
-   STATIC mp_result s_udiv(mp_int a, mp_int b);
-*/
-/* Precondition:  a >= b and b > 0
-   Postcondition: a' = a / b, b' = a % b
- */
-STATIC mp_result s_udiv(mp_int a, mp_int b)
-{
-  mpz_t q, r, t;
-  mp_size ua, ub, qpos = 0;
-  mp_digit *da, btop;
-  mp_result res = MP_OK;
-  int k, skip = 0;
-
-  /* Force signs to positive */
-  MP_SIGN(a) = MP_ZPOS;
-  MP_SIGN(b) = MP_ZPOS;
-
-  /* Normalize, per Knuth */
-  k = s_norm(a, b);
-
-  ua = MP_USED(a); ub = MP_USED(b); btop = b->digits[ub - 1];
-  if ((res = mp_int_init_size(&q, ua)) != MP_OK) return res;
-  if ((res = mp_int_init_size(&t, ua + 1)) != MP_OK) goto CLEANUP;
-
-  da = MP_DIGITS(a);
-  r.digits = da + ua - 1;  /* The contents of r are shared with a */
-  r.used   = 1;
-  r.sign   = MP_ZPOS;
-  r.alloc  = MP_ALLOC(a);
-  ZERO(t.digits, t.alloc);
-
-  /* Solve for quotient digits, store in q.digits in reverse order */
-  while (r.digits >= da) {
-    assert(qpos <= q.alloc);
-
-    if (s_ucmp(b, &r) > 0) {
-      r.digits -= 1;
-      r.used += 1;
-
-      if (++skip > 1 && qpos > 0)
-	q.digits[qpos++] = 0;
-
-      CLAMP(&r);
-    }
-    else {
-      mp_word  pfx = r.digits[r.used - 1];
-      mp_word  qdigit;
-
-      if (r.used > 1 && pfx < btop) {
-	pfx <<= MP_DIGIT_BIT / 2;
-	pfx <<= MP_DIGIT_BIT / 2;
-	pfx |= r.digits[r.used - 2];
-      }
-
-      qdigit = pfx / btop;
-      if (qdigit > MP_DIGIT_MAX) {
-	qdigit = MP_DIGIT_MAX;
-      }
-
-      s_dbmul(MP_DIGITS(b), (mp_digit) qdigit, t.digits, ub);
-      t.used = ub + 1; CLAMP(&t);
-      while (s_ucmp(&t, &r) > 0) {
-	--qdigit;
-	(void) mp_int_sub(&t, b, &t); /* cannot fail */
-      }
-
-      s_usub(r.digits, t.digits, r.digits, r.used, t.used);
-      CLAMP(&r);
-
-      q.digits[qpos++] = (mp_digit) qdigit;
-      ZERO(t.digits, t.used);
-      skip = 0;
-    }
-  }
-
-  /* Put quotient digits in the correct order, and discard extra zeroes */
-  q.used = qpos;
-  REV(mp_digit, q.digits, qpos);
-  CLAMP(&q);
-
-  /* Denormalize the remainder */
-  CLAMP(a);
-  if (k != 0)
-    s_qdiv(a, k);
-
-  mp_int_copy(a, b);  /* ok:  0 <= r < b */
-  mp_int_copy(&q, a); /* ok:  q <= a     */
-
-  mp_int_clear(&t);
- CLEANUP:
-  mp_int_clear(&q);
-  return res;
-}
-#endif
-
 /* Division of nonnegative integers
 
    This function implements division algorithm for unsigned multi-precision
@@ -2956,19 +2856,18 @@ STATIC mp_result s_udiv_knuth(mp_int u, mp_int v) {
     return MP_OK;
   }
 
-  /************************************************************/
-  /* Algorithm D */
-  /************************************************************/
-  /* The n and m variables are defined as used by Knuth.
+  /* Algorithm D
+
+     The n and m variables are defined as used by Knuth.
      u is an n digit number with digits u_{n-1}..u_0.
      v is an n+m digit number with digits from v_{m+n-1}..v_0.
-     We require that n > 1 and m >= 0 */
+     We require that n > 1 and m >= 0
+   */
   n = MP_USED(v);
   m = MP_USED(u) - n;
-  assert(n >  1);
+  assert(n > 1);
   assert(m >= 0);
 
-  /************************************************************/
   /* D1: Normalize.
      The normalization step provides the necessary condition for Theorem B,
      which states that the quotient estimate for q_j, call it qhat
@@ -2980,7 +2879,8 @@ STATIC mp_result s_udiv_knuth(mp_int u, mp_int v) {
       qhat - 2 <= q_j <= qhat.
 
      That is, qhat is always greater than the actual quotient digit q,
-     and it is never more than two larger than the actual quotient digit.  */
+     and it is never more than two larger than the actual quotient digit.
+   */
   k = s_norm(u, v);
 
   /* Extend size of u by one if needed.
@@ -3001,16 +2901,17 @@ STATIC mp_result s_udiv_knuth(mp_int u, mp_int v) {
 
      The multiplication in step D4 multiplies qhat * 0v_{n-1}..v_0.  We need to
      add the leading zero to v here to ensure that the multiplication will
-     produce the full n+1 digit result.  */
+     produce the full n+1 digit result.
+   */
   if (!s_pad(v, n+1)) return MP_MEMORY; v->digits[n] = 0;
 
   /* Initialize temporary variables q and t.
      q allocates space for m+1 digits to store the quotient digits
-     t allocates space for n+1 digits to hold the result of q_j*v */
+     t allocates space for n+1 digits to hold the result of q_j*v
+   */
   if ((res = mp_int_init_size(&q, m + 1)) != MP_OK) return res;
   if ((res = mp_int_init_size(&t, n + 1)) != MP_OK) goto CLEANUP;
 
-  /************************************************************/
   /* D2: Initialize j */
   j = m;
   r.digits = MP_DIGITS(u) + j;  /* The contents of r are shared with u */
@@ -3021,7 +2922,6 @@ STATIC mp_result s_udiv_knuth(mp_int u, mp_int v) {
 
   /* Calculate the m+1 digits of the quotient result */
   for (; j >= 0; j--) {
-    /************************************************************/
     /* D3: Calculate q' */
     /* r->digits is aligned to position j of the number u */
     mp_word pfx, qhat;
@@ -3038,7 +2938,6 @@ STATIC mp_result s_udiv_knuth(mp_int u, mp_int v) {
     if (qhat > MP_DIGIT_MAX)
       qhat = MP_DIGIT_MAX;
 
-    /************************************************************/
     /* D4,D5,D6: Multiply qhat * v and test for a correct value of q
 
        We proceed a bit different than the way described by Knuth. This way is
@@ -3049,7 +2948,8 @@ STATIC mp_result s_udiv_knuth(mp_int u, mp_int v) {
        more time before we get a value that is smaller than r.
 
        This way is less efficent than Knuth becuase we do more multiplies, but
-       we do not need to worry about underflow this way.  */
+       we do not need to worry about underflow this way.
+     */
     /* t = qhat * v */
     s_dbmul(MP_DIGITS(v), (mp_digit) qhat, t.digits, n+1); t.used = n + 1;
     CLAMP(&t);
@@ -3072,25 +2972,25 @@ STATIC mp_result s_udiv_knuth(mp_int u, mp_int v) {
        digits long. */
     r.used = n + 1;
 
-    /************************************************************/
-    /* D4: Multiply and subtract */
-    /* note: The multiply was completed above so we only need to subtract here.
-     **/
+    /* D4: Multiply and subtract
+
+       Note: The multiply was completed above so we only need to subtract here.
+     */
     s_usub(r.digits, t.digits, r.digits, r.used, t.used);
 
-    /************************************************************/
-    /* D5: Test remainder */
-    /* note: Not needed because we always check that qhat is the correct value
-     *       before performing the subtract.
-     *       Value cast to mp_digit to prevent warning, qhat has been clamped to MP_DIGIT_MAX */
+    /* D5: Test remainder
+
+       Note: Not needed because we always check that qhat is the correct value
+             before performing the subtract.  Value cast to mp_digit to prevent
+             warning, qhat has been clamped to MP_DIGIT_MAX
+     */
     q.digits[j] = (mp_digit)qhat;
 
-    /************************************************************/
-    /* D6: Add back */
-    /* note: Not needed because we always check that qhat is the correct value
-     *       before performing the subtract. */
+    /* D6: Add back
+       Note: Not needed because we always check that qhat is the correct value
+             before performing the subtract.
+     */
 
-    /************************************************************/
     /* D7: Loop on j */
     r.digits--;
     ZERO(t.digits, t.alloc);
diff --git a/lib/Analysis/isl/imath_wrap/wrap.h b/lib/Analysis/isl/imath_wrap/wrap.h
index f68e50d..a2ea88f 100644
--- a/lib/Analysis/isl/imath_wrap/wrap.h
+++ b/lib/Analysis/isl/imath_wrap/wrap.h
@@ -39,7 +39,6 @@
 #define impz_divisible_p	isl_impz_divisible_p
 #define impz_export	isl_impz_export
 #define impz_fdiv_q	isl_impz_fdiv_q
-#define impz_fdiv_q_ui	isl_impz_fdiv_q_ui
 #define impz_fdiv_r	isl_impz_fdiv_r
 #define impz_gcd	isl_impz_gcd
 #define impz_get_si	isl_impz_get_si
diff --git a/lib/Analysis/isl/include/isl/aff.h b/lib/Analysis/isl/include/isl/aff.h
index 29f8a5d..b032ab1 100644
--- a/lib/Analysis/isl/include/isl/aff.h
+++ b/lib/Analysis/isl/include/isl/aff.h
@@ -80,25 +80,34 @@ isl_bool isl_aff_is_nan(__isl_keep isl_aff *aff);
 
 __isl_give isl_aff *isl_aff_get_div(__isl_keep isl_aff *aff, int pos);
 
+__isl_export
 __isl_give isl_aff *isl_aff_neg(__isl_take isl_aff *aff);
+__isl_export
 __isl_give isl_aff *isl_aff_ceil(__isl_take isl_aff *aff);
+__isl_export
 __isl_give isl_aff *isl_aff_floor(__isl_take isl_aff *aff);
+__isl_overload
 __isl_give isl_aff *isl_aff_mod_val(__isl_take isl_aff *aff,
 	__isl_take isl_val *mod);
 
+__isl_export
 __isl_give isl_aff *isl_aff_mul(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_export
 __isl_give isl_aff *isl_aff_div(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
 __isl_export
 __isl_give isl_aff *isl_aff_add(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_export
 __isl_give isl_aff *isl_aff_sub(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
 
+__isl_overload
 __isl_give isl_aff *isl_aff_scale_val(__isl_take isl_aff *aff,
 	__isl_take isl_val *v);
 __isl_give isl_aff *isl_aff_scale_down_ui(__isl_take isl_aff *aff, unsigned f);
+__isl_overload
 __isl_give isl_aff *isl_aff_scale_down_val(__isl_take isl_aff *aff,
 	__isl_take isl_val *v);
 
@@ -132,16 +141,32 @@ __isl_give isl_basic_set *isl_aff_neg_basic_set(__isl_take isl_aff *aff);
 
 __isl_give isl_basic_set *isl_aff_eq_basic_set(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_export
 __isl_give isl_set *isl_aff_eq_set(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_export
+__isl_give isl_set *isl_aff_ne_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2);
 __isl_give isl_basic_set *isl_aff_le_basic_set(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_export
 __isl_give isl_set *isl_aff_le_set(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_give isl_basic_set *isl_aff_lt_basic_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2);
+__isl_export
+__isl_give isl_set *isl_aff_lt_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2);
 __isl_give isl_basic_set *isl_aff_ge_basic_set(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_export
 __isl_give isl_set *isl_aff_ge_set(__isl_take isl_aff *aff1,
 	__isl_take isl_aff *aff2);
+__isl_give isl_basic_set *isl_aff_gt_basic_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2);
+__isl_export
+__isl_give isl_set *isl_aff_gt_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2);
 
 __isl_constructor
 __isl_give isl_aff *isl_aff_read_from_str(isl_ctx *ctx, const char *str);
@@ -188,7 +213,8 @@ int isl_pw_aff_plain_cmp(__isl_keep isl_pw_aff *pa1,
 	__isl_keep isl_pw_aff *pa2);
 isl_bool isl_pw_aff_plain_is_equal(__isl_keep isl_pw_aff *pwaff1,
 	__isl_keep isl_pw_aff *pwaff2);
-int isl_pw_aff_is_equal(__isl_keep isl_pw_aff *pa1, __isl_keep isl_pw_aff *pa2);
+isl_bool isl_pw_aff_is_equal(__isl_keep isl_pw_aff *pa1,
+	__isl_keep isl_pw_aff *pa2);
 
 __isl_give isl_pw_aff *isl_pw_aff_union_min(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
@@ -207,6 +233,9 @@ isl_bool isl_pw_aff_involves_dims(__isl_keep isl_pw_aff *pwaff,
 
 isl_bool isl_pw_aff_is_cst(__isl_keep isl_pw_aff *pwaff);
 
+__isl_give isl_pw_aff *isl_pw_aff_project_domain_on_params(
+	__isl_take isl_pw_aff *pa);
+
 __isl_give isl_pw_aff *isl_pw_aff_align_params(__isl_take isl_pw_aff *pwaff,
 	__isl_take isl_space *model);
 
@@ -224,26 +253,37 @@ __isl_give isl_set *isl_pw_aff_params(__isl_take isl_pw_aff *pwa);
 __isl_give isl_set *isl_pw_aff_domain(__isl_take isl_pw_aff *pwaff);
 __isl_give isl_pw_aff *isl_pw_aff_from_range(__isl_take isl_pw_aff *pwa);
 
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_min(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_max(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_mul(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_div(__isl_take isl_pw_aff *pa1,
 	__isl_take isl_pw_aff *pa2);
 __isl_export
 __isl_give isl_pw_aff *isl_pw_aff_add(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_sub(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_neg(__isl_take isl_pw_aff *pwaff);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_ceil(__isl_take isl_pw_aff *pwaff);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_floor(__isl_take isl_pw_aff *pwaff);
+__isl_overload
 __isl_give isl_pw_aff *isl_pw_aff_mod_val(__isl_take isl_pw_aff *pa,
 	__isl_take isl_val *mod);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_tdiv_q(__isl_take isl_pw_aff *pa1,
 	__isl_take isl_pw_aff *pa2);
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_tdiv_r(__isl_take isl_pw_aff *pa1,
 	__isl_take isl_pw_aff *pa2);
 
@@ -254,11 +294,14 @@ __isl_give isl_pw_aff *isl_pw_aff_intersect_domain(__isl_take isl_pw_aff *pa,
 __isl_give isl_pw_aff *isl_pw_aff_subtract_domain(__isl_take isl_pw_aff *pa,
 	__isl_take isl_set *set);
 
+__isl_export
 __isl_give isl_pw_aff *isl_pw_aff_cond(__isl_take isl_pw_aff *cond,
 	__isl_take isl_pw_aff *pwaff_true, __isl_take isl_pw_aff *pwaff_false);
 
+__isl_overload
 __isl_give isl_pw_aff *isl_pw_aff_scale_val(__isl_take isl_pw_aff *pa,
 	__isl_take isl_val *v);
+__isl_overload
 __isl_give isl_pw_aff *isl_pw_aff_scale_down_val(__isl_take isl_pw_aff *pa,
 	__isl_take isl_val *f);
 
@@ -301,16 +344,22 @@ __isl_give isl_set *isl_pw_aff_nonneg_set(__isl_take isl_pw_aff *pwaff);
 __isl_give isl_set *isl_pw_aff_zero_set(__isl_take isl_pw_aff *pwaff);
 __isl_give isl_set *isl_pw_aff_non_zero_set(__isl_take isl_pw_aff *pwaff);
 
+__isl_export
 __isl_give isl_set *isl_pw_aff_eq_set(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_set *isl_pw_aff_ne_set(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_set *isl_pw_aff_le_set(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_set *isl_pw_aff_lt_set(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_set *isl_pw_aff_ge_set(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
+__isl_export
 __isl_give isl_set *isl_pw_aff_gt_set(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2);
 
@@ -345,6 +394,7 @@ __isl_give isl_set *isl_pw_aff_list_gt_set(__isl_take isl_pw_aff_list *list1,
 	__isl_take isl_pw_aff_list *list2);
 
 ISL_DECLARE_MULTI(aff)
+ISL_DECLARE_MULTI_CMP(aff)
 ISL_DECLARE_MULTI_NEG(aff)
 ISL_DECLARE_MULTI_DIMS(aff)
 ISL_DECLARE_MULTI_WITH_DOMAIN(aff)
@@ -477,8 +527,11 @@ __isl_give isl_pw_multi_aff *isl_pw_multi_aff_set_dim_id(
 	__isl_take isl_pw_multi_aff *pma,
 	enum isl_dim_type type, unsigned pos, __isl_take isl_id *id);
 
+isl_bool isl_pw_multi_aff_involves_nan(__isl_keep isl_pw_multi_aff *pma);
 isl_bool isl_pw_multi_aff_plain_is_equal(__isl_keep isl_pw_multi_aff *pma1,
 	__isl_keep isl_pw_multi_aff *pma2);
+isl_bool isl_pw_multi_aff_is_equal(__isl_keep isl_pw_multi_aff *pma1,
+	__isl_keep isl_pw_multi_aff *pma2);
 
 __isl_give isl_pw_multi_aff *isl_pw_multi_aff_fix_si(
 	__isl_take isl_pw_multi_aff *pma, enum isl_dim_type type,
@@ -551,6 +604,7 @@ __isl_overload
 __isl_give isl_pw_multi_aff *isl_pw_multi_aff_pullback_pw_multi_aff(
 	__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2);
 
+int isl_pw_multi_aff_n_piece(__isl_keep isl_pw_multi_aff *pma);
 isl_stat isl_pw_multi_aff_foreach_piece(__isl_keep isl_pw_multi_aff *pma,
 	isl_stat (*fn)(__isl_take isl_set *set, __isl_take isl_multi_aff *maff,
 		    void *user), void *user);
@@ -645,6 +699,8 @@ isl_stat isl_union_pw_multi_aff_foreach_pw_multi_aff(
 __isl_give isl_pw_multi_aff *isl_union_pw_multi_aff_extract_pw_multi_aff(
 	__isl_keep isl_union_pw_multi_aff *upma, __isl_take isl_space *space);
 
+isl_bool isl_union_pw_multi_aff_involves_nan(
+	__isl_keep isl_union_pw_multi_aff *upma);
 isl_bool isl_union_pw_multi_aff_plain_is_equal(
 	__isl_keep isl_union_pw_multi_aff *upma1,
 	__isl_keep isl_union_pw_multi_aff *upma2);
@@ -819,6 +875,7 @@ isl_stat isl_union_pw_aff_foreach_pw_aff(__isl_keep isl_union_pw_aff *upa,
 __isl_give isl_pw_aff *isl_union_pw_aff_extract_pw_aff(
 	__isl_keep isl_union_pw_aff *upa, __isl_take isl_space *space);
 
+isl_bool isl_union_pw_aff_involves_nan(__isl_keep isl_union_pw_aff *upa);
 isl_bool isl_union_pw_aff_plain_is_equal(__isl_keep isl_union_pw_aff *upa1,
 	__isl_keep isl_union_pw_aff *upa2);
 
@@ -885,6 +942,7 @@ __isl_give isl_union_pw_aff *isl_union_pw_aff_read_from_str(isl_ctx *ctx,
 __isl_give char *isl_union_pw_aff_to_str(__isl_keep isl_union_pw_aff *upa);
 __isl_give isl_printer *isl_printer_print_union_pw_aff(
 	__isl_take isl_printer *p, __isl_keep isl_union_pw_aff *upa);
+void isl_union_pw_aff_dump(__isl_keep isl_union_pw_aff *upa);
 
 ISL_DECLARE_MULTI(union_pw_aff)
 ISL_DECLARE_MULTI_NEG(union_pw_aff)
@@ -928,8 +986,8 @@ __isl_give isl_union_pw_aff *isl_multi_union_pw_aff_apply_aff(
 	__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_aff *aff);
 __isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_apply_multi_aff(
 	__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_multi_aff *ma);
-__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_apply_multi_aff(
-	__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_multi_aff *ma);
+__isl_give isl_union_pw_aff *isl_multi_union_pw_aff_apply_pw_aff(
+	__isl_take isl_multi_union_pw_aff *mupa, __isl_take isl_pw_aff *pa);
 __isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_apply_pw_multi_aff(
 	__isl_take isl_multi_union_pw_aff *mupa,
 	__isl_take isl_pw_multi_aff *pma);
diff --git a/lib/Analysis/isl/include/isl/aff_type.h b/lib/Analysis/isl/include/isl/aff_type.h
index 9a618d6..6cffa18 100644
--- a/lib/Analysis/isl/include/isl/aff_type.h
+++ b/lib/Analysis/isl/include/isl/aff_type.h
@@ -12,7 +12,7 @@ typedef struct isl_aff isl_aff;
 
 ISL_DECLARE_LIST(aff)
 
-struct __isl_subclass(isl_pw_multi_aff) __isl_subclass(isl_multi_pw_aff)
+struct __isl_subclass(isl_multi_pw_aff) __isl_subclass(isl_pw_multi_aff)
 	__isl_subclass(isl_union_pw_aff) isl_pw_aff;
 typedef struct isl_pw_aff isl_pw_aff;
 
@@ -24,11 +24,11 @@ typedef struct isl_union_pw_aff isl_union_pw_aff;
 
 ISL_DECLARE_LIST_TYPE(union_pw_aff)
 
-struct __isl_subclass(isl_pw_multi_aff) __isl_subclass(isl_multi_pw_aff)
+struct __isl_subclass(isl_multi_pw_aff) __isl_subclass(isl_pw_multi_aff)
 	isl_multi_aff;
 typedef struct isl_multi_aff isl_multi_aff;
 
-struct __isl_subclass(isl_union_pw_multi_aff) __isl_subclass(isl_multi_pw_aff)
+struct __isl_subclass(isl_multi_pw_aff) __isl_subclass(isl_union_pw_multi_aff)
 	isl_pw_multi_aff;
 typedef struct isl_pw_multi_aff isl_pw_multi_aff;
 
diff --git a/lib/Analysis/isl/include/isl/ast.h b/lib/Analysis/isl/include/isl/ast.h
index 8eca398..2793e16 100644
--- a/lib/Analysis/isl/include/isl/ast.h
+++ b/lib/Analysis/isl/include/isl/ast.h
@@ -83,6 +83,8 @@ __isl_give isl_printer *isl_printer_print_ast_expr(__isl_take isl_printer *p,
 	__isl_keep isl_ast_expr *expr);
 void isl_ast_expr_dump(__isl_keep isl_ast_expr *expr);
 __isl_give char *isl_ast_expr_to_str(__isl_keep isl_ast_expr *expr);
+__isl_export
+__isl_give char *isl_ast_expr_to_C_str(__isl_keep isl_ast_expr *expr);
 
 __isl_give isl_ast_node *isl_ast_node_alloc_user(__isl_take isl_ast_expr *expr);
 __isl_give isl_ast_node *isl_ast_node_copy(__isl_keep isl_ast_node *node);
@@ -132,6 +134,7 @@ isl_stat isl_ast_node_foreach_descendant_top_down(
 __isl_give isl_printer *isl_printer_print_ast_node(__isl_take isl_printer *p,
 	__isl_keep isl_ast_node *node);
 void isl_ast_node_dump(__isl_keep isl_ast_node *node);
+__isl_give char *isl_ast_node_to_str(__isl_keep isl_ast_node *node);
 
 __isl_give isl_ast_print_options *isl_ast_print_options_alloc(isl_ctx *ctx);
 __isl_give isl_ast_print_options *isl_ast_print_options_copy(
@@ -180,6 +183,9 @@ __isl_give isl_printer *isl_ast_node_if_print(__isl_keep isl_ast_node *node,
 	__isl_take isl_printer *p,
 	__isl_take isl_ast_print_options *options);
 
+__isl_export
+__isl_give char *isl_ast_node_to_C_str(__isl_keep isl_ast_node *node);
+
 #if defined(__cplusplus)
 }
 #endif
diff --git a/lib/Analysis/isl/include/isl/ast_build.h b/lib/Analysis/isl/include/isl/ast_build.h
index fa51873..bf08e03 100644
--- a/lib/Analysis/isl/include/isl/ast_build.h
+++ b/lib/Analysis/isl/include/isl/ast_build.h
@@ -10,7 +10,7 @@
 extern "C" {
 #endif
 
-struct isl_ast_build;
+struct __isl_export isl_ast_build;
 typedef struct isl_ast_build isl_ast_build;
 
 
@@ -45,7 +45,9 @@ int isl_options_get_ast_build_allow_or(isl_ctx *ctx);
 
 isl_ctx *isl_ast_build_get_ctx(__isl_keep isl_ast_build *build);
 
+__isl_constructor
 __isl_give isl_ast_build *isl_ast_build_alloc(isl_ctx *ctx);
+__isl_export
 __isl_give isl_ast_build *isl_ast_build_from_context(__isl_take isl_set *set);
 
 __isl_give isl_space *isl_ast_build_get_schedule_space(
@@ -92,21 +94,28 @@ __isl_give isl_ast_build *isl_ast_build_set_create_leaf(
 	__isl_give isl_ast_node *(*fn)(__isl_take isl_ast_build *build,
 		void *user), void *user);
 
+__isl_overload
 __isl_give isl_ast_expr *isl_ast_build_expr_from_set(
 	__isl_keep isl_ast_build *build, __isl_take isl_set *set);
+__isl_overload
 __isl_give isl_ast_expr *isl_ast_build_expr_from_pw_aff(
 	__isl_keep isl_ast_build *build, __isl_take isl_pw_aff *pa);
+__isl_overload
 __isl_give isl_ast_expr *isl_ast_build_access_from_pw_multi_aff(
 	__isl_keep isl_ast_build *build, __isl_take isl_pw_multi_aff *pma);
+__isl_overload
 __isl_give isl_ast_expr *isl_ast_build_access_from_multi_pw_aff(
 	__isl_keep isl_ast_build *build, __isl_take isl_multi_pw_aff *mpa);
+__isl_overload
 __isl_give isl_ast_expr *isl_ast_build_call_from_pw_multi_aff(
 	__isl_keep isl_ast_build *build, __isl_take isl_pw_multi_aff *pma);
+__isl_overload
 __isl_give isl_ast_expr *isl_ast_build_call_from_multi_pw_aff(
 	__isl_keep isl_ast_build *build, __isl_take isl_multi_pw_aff *mpa);
 
 __isl_give isl_ast_node *isl_ast_build_node_from_schedule(
 	__isl_keep isl_ast_build *build, __isl_take isl_schedule *schedule);
+__isl_export
 __isl_give isl_ast_node *isl_ast_build_node_from_schedule_map(
 	__isl_keep isl_ast_build *build, __isl_take isl_union_map *schedule);
 __isl_give isl_ast_node *isl_ast_build_ast_from_schedule(
diff --git a/lib/Analysis/isl/include/isl/ast_type.h b/lib/Analysis/isl/include/isl/ast_type.h
index f18149e..1e09b3b 100644
--- a/lib/Analysis/isl/include/isl/ast_type.h
+++ b/lib/Analysis/isl/include/isl/ast_type.h
@@ -7,10 +7,10 @@
 extern "C" {
 #endif
 
-struct isl_ast_expr;
+struct __isl_export isl_ast_expr;
 typedef struct isl_ast_expr isl_ast_expr;
 
-struct isl_ast_node;
+struct __isl_export isl_ast_node;
 typedef struct isl_ast_node isl_ast_node;
 
 enum isl_ast_op_type {
diff --git a/lib/Analysis/isl/include/isl/constraint.h b/lib/Analysis/isl/include/isl/constraint.h
index d3b563a..92fa029 100644
--- a/lib/Analysis/isl/include/isl/constraint.h
+++ b/lib/Analysis/isl/include/isl/constraint.h
@@ -68,13 +68,13 @@ __isl_give isl_map *isl_map_add_constraint(__isl_take isl_map *map,
 __isl_give isl_set *isl_set_add_constraint(__isl_take isl_set *set,
 	__isl_take isl_constraint *constraint);
 
-int isl_basic_map_has_defining_equality(
+isl_bool isl_basic_map_has_defining_equality(
 	__isl_keep isl_basic_map *bmap, enum isl_dim_type type, int pos,
 	__isl_give isl_constraint **c);
-int isl_basic_set_has_defining_equality(
+isl_bool isl_basic_set_has_defining_equality(
 	struct isl_basic_set *bset, enum isl_dim_type type, int pos,
 	struct isl_constraint **constraint);
-int isl_basic_set_has_defining_inequalities(
+isl_bool isl_basic_set_has_defining_inequalities(
 	struct isl_basic_set *bset, enum isl_dim_type type, int pos,
 	struct isl_constraint **lower,
 	struct isl_constraint **upper);
@@ -121,8 +121,8 @@ isl_bool isl_constraint_is_upper_bound(__isl_keep isl_constraint *constraint,
 
 __isl_give isl_basic_map *isl_basic_map_from_constraint(
 	__isl_take isl_constraint *constraint);
-struct isl_basic_set *isl_basic_set_from_constraint(
-	struct isl_constraint *constraint);
+__isl_give isl_basic_set *isl_basic_set_from_constraint(
+	__isl_take isl_constraint *constraint);
 
 __isl_give isl_aff *isl_constraint_get_bound(
 	__isl_keep isl_constraint *constraint, enum isl_dim_type type, int pos);
@@ -131,9 +131,6 @@ __isl_give isl_aff *isl_constraint_get_aff(
 __isl_give isl_constraint *isl_equality_from_aff(__isl_take isl_aff *aff);
 __isl_give isl_constraint *isl_inequality_from_aff(__isl_take isl_aff *aff);
 
-__isl_give isl_basic_set *isl_basic_set_drop_constraint(
-	__isl_take isl_basic_set *bset, __isl_take isl_constraint *constraint);
-
 int isl_constraint_plain_cmp(__isl_keep isl_constraint *c1,
 	__isl_keep isl_constraint *c2);
 int isl_constraint_cmp_last_non_zero(__isl_keep isl_constraint *c1,
diff --git a/lib/Analysis/isl/include/isl/deprecated/aff_int.h b/lib/Analysis/isl/include/isl/deprecated/aff_int.h
index cbab1f9..a067374 100644
--- a/lib/Analysis/isl/include/isl/deprecated/aff_int.h
+++ b/lib/Analysis/isl/include/isl/deprecated/aff_int.h
@@ -11,7 +11,7 @@ extern "C" {
 int isl_aff_get_constant(__isl_keep isl_aff *aff, isl_int *v);
 int isl_aff_get_coefficient(__isl_keep isl_aff *aff,
 	enum isl_dim_type type, int pos, isl_int *v);
-int isl_aff_get_denominator(__isl_keep isl_aff *aff, isl_int *v);
+isl_stat isl_aff_get_denominator(__isl_keep isl_aff *aff, isl_int *v);
 __isl_give isl_aff *isl_aff_set_constant(__isl_take isl_aff *aff, isl_int v);
 __isl_give isl_aff *isl_aff_set_coefficient(__isl_take isl_aff *aff,
 	enum isl_dim_type type, int pos, isl_int v);
diff --git a/lib/Analysis/isl/include/isl/deprecated/map_int.h b/lib/Analysis/isl/include/isl/deprecated/map_int.h
index e9f7701..c120c40 100644
--- a/lib/Analysis/isl/include/isl/deprecated/map_int.h
+++ b/lib/Analysis/isl/include/isl/deprecated/map_int.h
@@ -8,12 +8,12 @@
 extern "C" {
 #endif
 
-int isl_basic_map_plain_is_fixed(__isl_keep isl_basic_map *bmap,
+isl_bool isl_basic_map_plain_is_fixed(__isl_keep isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned pos, isl_int *val);
 
 __isl_give isl_map *isl_map_fix(__isl_take isl_map *map,
 	enum isl_dim_type type, unsigned pos, isl_int value);
-int isl_map_plain_is_fixed(__isl_keep isl_map *map,
+isl_bool isl_map_plain_is_fixed(__isl_keep isl_map *map,
 	enum isl_dim_type type, unsigned pos, isl_int *val);
 
 __isl_give isl_map *isl_map_fixed_power(__isl_take isl_map *map, isl_int exp);
diff --git a/lib/Analysis/isl/include/isl/deprecated/set_int.h b/lib/Analysis/isl/include/isl/deprecated/set_int.h
index 84bb88a..6f9ed06 100644
--- a/lib/Analysis/isl/include/isl/deprecated/set_int.h
+++ b/lib/Analysis/isl/include/isl/deprecated/set_int.h
@@ -17,7 +17,7 @@ __isl_give isl_set *isl_set_upper_bound(__isl_take isl_set *set,
 __isl_give isl_set *isl_set_fix(__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, isl_int value);
 
-int isl_set_plain_is_fixed(__isl_keep isl_set *set,
+isl_bool isl_set_plain_is_fixed(__isl_keep isl_set *set,
 	enum isl_dim_type type, unsigned pos, isl_int *val);
 
 #if defined(__cplusplus)
diff --git a/lib/Analysis/isl/include/isl/flow.h b/lib/Analysis/isl/include/isl/flow.h
index 388d791..f606549 100644
--- a/lib/Analysis/isl/include/isl/flow.h
+++ b/lib/Analysis/isl/include/isl/flow.h
@@ -1,6 +1,8 @@
 #ifndef ISL_FLOW_H
 #define ISL_FLOW_H
 
+#include <stdio.h>
+
 #include <isl/set_type.h>
 #include <isl/map_type.h>
 #include <isl/union_set_type.h>
@@ -82,6 +84,10 @@ __isl_give isl_union_access_info *isl_union_access_info_set_may_source(
 	__isl_take isl_union_access_info *access,
 	__isl_take isl_union_map *may_source);
 __isl_export
+__isl_give isl_union_access_info *isl_union_access_info_set_kill(
+	__isl_take isl_union_access_info *access,
+	__isl_take isl_union_map *kill);
+__isl_export
 __isl_give isl_union_access_info *isl_union_access_info_set_schedule(
 	__isl_take isl_union_access_info *access,
 	__isl_take isl_schedule *schedule);
@@ -97,6 +103,8 @@ __isl_null isl_union_access_info *isl_union_access_info_free(
 isl_ctx *isl_union_access_info_get_ctx(
 	__isl_keep isl_union_access_info *access);
 
+__isl_give isl_union_access_info *isl_union_access_info_read_from_file(
+	isl_ctx *ctx, FILE *input);
 __isl_give isl_printer *isl_printer_print_union_access_info(
 	__isl_take isl_printer *p, __isl_keep isl_union_access_info *access);
 __isl_give char *isl_union_access_info_to_str(
@@ -107,6 +115,8 @@ __isl_give isl_union_flow *isl_union_access_info_compute_flow(
 	__isl_take isl_union_access_info *access);
 
 isl_ctx *isl_union_flow_get_ctx(__isl_keep isl_union_flow *flow);
+__isl_give isl_union_flow *isl_union_flow_copy(
+	__isl_keep isl_union_flow *flow);
 __isl_export
 __isl_give isl_union_map *isl_union_flow_get_must_dependence(
 	__isl_keep isl_union_flow *flow);
diff --git a/lib/Analysis/isl/include/isl/id.h b/lib/Analysis/isl/include/isl/id.h
index fa01846..c025d51 100644
--- a/lib/Analysis/isl/include/isl/id.h
+++ b/lib/Analysis/isl/include/isl/id.h
@@ -29,6 +29,7 @@ __isl_keep const char *isl_id_get_name(__isl_keep isl_id *id);
 __isl_give isl_id *isl_id_set_free_user(__isl_take isl_id *id,
 	void (*free_user)(void *user));
 
+__isl_give char *isl_id_to_str(__isl_keep isl_id *id);
 __isl_give isl_printer *isl_printer_print_id(__isl_take isl_printer *p,
 	__isl_keep isl_id *id);
 void isl_id_dump(__isl_keep isl_id *id);
diff --git a/lib/Analysis/isl/include/isl/isl-noexceptions.h b/lib/Analysis/isl/include/isl/isl-noexceptions.h
new file mode 100644
index 0000000..b1d5c6d
--- /dev/null
+++ b/lib/Analysis/isl/include/isl/isl-noexceptions.h
@@ -0,0 +1,15252 @@
+/// These are automatically generated C++ bindings for isl.
+///
+/// isl is a library for computing with integer sets and maps described by
+/// Presburger formulas. On top of this, isl provides various tools for
+/// polyhedral compilation, ranging from dependence analysis over scheduling
+/// to AST generation.
+
+#ifndef ISL_CPP_NOEXCEPTIONS
+#define ISL_CPP_NOEXCEPTIONS
+
+#include <isl/aff.h>
+#include <isl/ast_build.h>
+#include <isl/constraint.h>
+#include <isl/flow.h>
+#include <isl/id.h>
+#include <isl/ilp.h>
+#include <isl/map.h>
+#include <isl/schedule.h>
+#include <isl/schedule_node.h>
+#include <isl/set.h>
+#include <isl/union_map.h>
+#include <isl/union_set.h>
+#include <isl/val.h>
+#include <isl/polynomial.h>
+
+#include <functional>
+#include <string>
+
+namespace isl {
+inline namespace noexceptions {
+
+#define ISLPP_STRINGIZE_(X) #X
+#define ISLPP_STRINGIZE(X) ISLPP_STRINGIZE_(X)
+
+#define ISLPP_ASSERT(test, message)                          \
+  do {                                                       \
+    if (test)                                                \
+      break;                                                 \
+    fputs("Assertion \"" #test "\" failed at " __FILE__      \
+      ":" ISLPP_STRINGIZE(__LINE__) "\n  " message "\n",     \
+      stderr);                                               \
+  } while (0)
+
+class boolean {
+private:
+  isl_bool val;
+
+  friend isl::boolean manage(isl_bool val);
+  boolean(isl_bool val): val(val) {}
+public:
+  boolean()
+      : val(isl_bool_error) {}
+
+  /* implicit */ boolean(bool val)
+      : val(val ? isl_bool_true : isl_bool_false) {}
+
+  bool is_error() const { return val == isl_bool_error; }
+  bool is_false() const { return val == isl_bool_false; }
+  bool is_true() const { return val == isl_bool_true; }
+
+  operator bool() const {
+    ISLPP_ASSERT(!is_error(), "IMPLEMENTATION ERROR: Unhandled error state");
+    return is_true();
+  }
+
+  boolean operator!() const {
+    if (is_error())
+      return *this;
+    return !is_true();
+  }
+};
+
+inline isl::boolean manage(isl_bool val) {
+  return isl::boolean(val);
+}
+
+class ctx {
+  isl_ctx *ptr;
+public:
+  /* implicit */ ctx(isl_ctx *ctx)
+      : ptr(ctx) {}
+  isl_ctx *release() {
+    auto tmp = ptr;
+    ptr = nullptr;
+    return tmp;
+  }
+  isl_ctx *get() {
+    return ptr;
+  }
+};
+
+enum class stat {
+  ok = isl_stat_ok,
+  error = isl_stat_error
+};
+
+enum class dim {
+  cst = isl_dim_cst,
+  param = isl_dim_param,
+  in = isl_dim_in,
+  out = isl_dim_out,
+  set = isl_dim_set,
+  div = isl_dim_div,
+  all = isl_dim_all
+};
+
+}
+} // namespace isl
+
+namespace isl {
+
+inline namespace noexceptions {
+
+// forward declarations
+class aff;
+class aff_list;
+class ast_build;
+class ast_expr;
+class ast_expr_list;
+class ast_node;
+class ast_node_list;
+class band_list;
+class basic_map;
+class basic_map_list;
+class basic_set;
+class basic_set_list;
+class constraint;
+class constraint_list;
+class id;
+class id_list;
+class id_to_ast_expr;
+class local_space;
+class map;
+class map_list;
+class multi_aff;
+class multi_pw_aff;
+class multi_union_pw_aff;
+class multi_val;
+class point;
+class pw_aff;
+class pw_aff_list;
+class pw_multi_aff;
+class pw_qpolynomial;
+class qpolynomial;
+class schedule;
+class schedule_constraints;
+class schedule_node;
+class set;
+class set_list;
+class space;
+class term;
+class union_access_info;
+class union_flow;
+class union_map;
+class union_map_list;
+class union_pw_aff;
+class union_pw_aff_list;
+class union_pw_multi_aff;
+class union_pw_multi_aff_list;
+class union_pw_qpolynomial;
+class union_set;
+class union_set_list;
+class val;
+class val_list;
+
+// declarations for isl::aff
+inline isl::aff manage(__isl_take isl_aff *ptr);
+inline isl::aff give(__isl_take isl_aff *ptr);
+
+
+class aff {
+  friend inline isl::aff manage(__isl_take isl_aff *ptr);
+
+  isl_aff *ptr = nullptr;
+
+  inline explicit aff(__isl_take isl_aff *ptr);
+
+public:
+  inline /* implicit */ aff();
+  inline /* implicit */ aff(const isl::aff &obj);
+  inline /* implicit */ aff(std::nullptr_t);
+  inline explicit aff(isl::local_space ls);
+  inline explicit aff(isl::local_space ls, isl::val val);
+  inline explicit aff(isl::ctx ctx, const std::string &str);
+  inline isl::aff &operator=(isl::aff obj);
+  inline ~aff();
+  inline __isl_give isl_aff *copy() const &;
+  inline __isl_give isl_aff *copy() && = delete;
+  inline __isl_keep isl_aff *get() const;
+  inline __isl_give isl_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_aff *keep() const;
+  inline __isl_give isl_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::aff add(isl::aff aff2) const;
+  inline isl::aff add_coefficient_si(isl::dim type, int pos, int v) const;
+  inline isl::aff add_coefficient_val(isl::dim type, int pos, isl::val v) const;
+  inline isl::aff add_constant_num_si(int v) const;
+  inline isl::aff add_constant_si(int v) const;
+  inline isl::aff add_constant_val(isl::val v) const;
+  inline isl::aff add_dims(isl::dim type, unsigned int n) const;
+  inline isl::aff align_params(isl::space model) const;
+  inline isl::aff ceil() const;
+  inline int coefficient_sgn(isl::dim type, int pos) const;
+  inline int dim(isl::dim type) const;
+  inline isl::aff div(isl::aff aff2) const;
+  inline isl::aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_set eq_basic_set(isl::aff aff2) const;
+  inline isl::set eq_set(isl::aff aff2) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::aff floor() const;
+  inline isl::basic_set ge_basic_set(isl::aff aff2) const;
+  inline isl::set ge_set(isl::aff aff2) const;
+  inline isl::val get_coefficient_val(isl::dim type, int pos) const;
+  inline isl::val get_constant_val() const;
+  inline isl::val get_denominator_val() const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::aff get_div(int pos) const;
+  inline isl::local_space get_domain_local_space() const;
+  inline isl::space get_domain_space() const;
+  inline uint32_t get_hash() const;
+  inline isl::local_space get_local_space() const;
+  inline isl::space get_space() const;
+  inline isl::aff gist(isl::set context) const;
+  inline isl::aff gist_params(isl::set context) const;
+  inline isl::basic_set gt_basic_set(isl::aff aff2) const;
+  inline isl::set gt_set(isl::aff aff2) const;
+  inline isl::aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean is_cst() const;
+  inline isl::boolean is_nan() const;
+  inline isl::basic_set le_basic_set(isl::aff aff2) const;
+  inline isl::set le_set(isl::aff aff2) const;
+  inline isl::basic_set lt_basic_set(isl::aff aff2) const;
+  inline isl::set lt_set(isl::aff aff2) const;
+  inline isl::aff mod(isl::val mod) const;
+  inline isl::aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  inline isl::aff mul(isl::aff aff2) const;
+  static inline isl::aff nan_on_domain(isl::local_space ls);
+  inline isl::set ne_set(isl::aff aff2) const;
+  inline isl::aff neg() const;
+  inline isl::basic_set neg_basic_set() const;
+  inline isl::boolean plain_is_equal(const isl::aff &aff2) const;
+  inline isl::boolean plain_is_zero() const;
+  inline isl::aff project_domain_on_params() const;
+  inline isl::aff pullback(isl::multi_aff ma) const;
+  inline isl::aff pullback_aff(isl::aff aff2) const;
+  inline isl::aff scale(isl::val v) const;
+  inline isl::aff scale_down(isl::val v) const;
+  inline isl::aff scale_down_ui(unsigned int f) const;
+  inline isl::aff set_coefficient_si(isl::dim type, int pos, int v) const;
+  inline isl::aff set_coefficient_val(isl::dim type, int pos, isl::val v) const;
+  inline isl::aff set_constant_si(int v) const;
+  inline isl::aff set_constant_val(isl::val v) const;
+  inline isl::aff set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::aff set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::aff sub(isl::aff aff2) const;
+  static inline isl::aff var_on_domain(isl::local_space ls, isl::dim type, unsigned int pos);
+  inline isl::basic_set zero_basic_set() const;
+};
+
+// declarations for isl::aff_list
+inline isl::aff_list manage(__isl_take isl_aff_list *ptr);
+inline isl::aff_list give(__isl_take isl_aff_list *ptr);
+
+
+class aff_list {
+  friend inline isl::aff_list manage(__isl_take isl_aff_list *ptr);
+
+  isl_aff_list *ptr = nullptr;
+
+  inline explicit aff_list(__isl_take isl_aff_list *ptr);
+
+public:
+  inline /* implicit */ aff_list();
+  inline /* implicit */ aff_list(const isl::aff_list &obj);
+  inline /* implicit */ aff_list(std::nullptr_t);
+  inline isl::aff_list &operator=(isl::aff_list obj);
+  inline ~aff_list();
+  inline __isl_give isl_aff_list *copy() const &;
+  inline __isl_give isl_aff_list *copy() && = delete;
+  inline __isl_keep isl_aff_list *get() const;
+  inline __isl_give isl_aff_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_aff_list *keep() const;
+  inline __isl_give isl_aff_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::ast_build
+inline isl::ast_build manage(__isl_take isl_ast_build *ptr);
+inline isl::ast_build give(__isl_take isl_ast_build *ptr);
+
+
+class ast_build {
+  friend inline isl::ast_build manage(__isl_take isl_ast_build *ptr);
+
+  isl_ast_build *ptr = nullptr;
+
+  inline explicit ast_build(__isl_take isl_ast_build *ptr);
+
+public:
+  inline /* implicit */ ast_build();
+  inline /* implicit */ ast_build(const isl::ast_build &obj);
+  inline /* implicit */ ast_build(std::nullptr_t);
+  inline explicit ast_build(isl::ctx ctx);
+  inline isl::ast_build &operator=(isl::ast_build obj);
+  inline ~ast_build();
+  inline __isl_give isl_ast_build *copy() const &;
+  inline __isl_give isl_ast_build *copy() && = delete;
+  inline __isl_keep isl_ast_build *get() const;
+  inline __isl_give isl_ast_build *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_ast_build *keep() const;
+  inline __isl_give isl_ast_build *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+
+  inline isl::ast_expr access_from(isl::pw_multi_aff pma) const;
+  inline isl::ast_expr access_from(isl::multi_pw_aff mpa) const;
+  inline isl::ast_node ast_from_schedule(isl::union_map schedule) const;
+  inline isl::ast_expr call_from(isl::pw_multi_aff pma) const;
+  inline isl::ast_expr call_from(isl::multi_pw_aff mpa) const;
+  inline isl::ast_expr expr_from(isl::set set) const;
+  inline isl::ast_expr expr_from(isl::pw_aff pa) const;
+  static inline isl::ast_build from_context(isl::set set);
+  inline isl::union_map get_schedule() const;
+  inline isl::space get_schedule_space() const;
+  inline isl::ast_node node_from_schedule(isl::schedule schedule) const;
+  inline isl::ast_node node_from_schedule_map(isl::union_map schedule) const;
+  inline isl::ast_build restrict(isl::set set) const;
+};
+
+// declarations for isl::ast_expr
+inline isl::ast_expr manage(__isl_take isl_ast_expr *ptr);
+inline isl::ast_expr give(__isl_take isl_ast_expr *ptr);
+
+
+class ast_expr {
+  friend inline isl::ast_expr manage(__isl_take isl_ast_expr *ptr);
+
+  isl_ast_expr *ptr = nullptr;
+
+  inline explicit ast_expr(__isl_take isl_ast_expr *ptr);
+
+public:
+  inline /* implicit */ ast_expr();
+  inline /* implicit */ ast_expr(const isl::ast_expr &obj);
+  inline /* implicit */ ast_expr(std::nullptr_t);
+  inline isl::ast_expr &operator=(isl::ast_expr obj);
+  inline ~ast_expr();
+  inline __isl_give isl_ast_expr *copy() const &;
+  inline __isl_give isl_ast_expr *copy() && = delete;
+  inline __isl_keep isl_ast_expr *get() const;
+  inline __isl_give isl_ast_expr *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_ast_expr *keep() const;
+  inline __isl_give isl_ast_expr *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::ast_expr access(isl::ast_expr_list indices) const;
+  inline isl::ast_expr add(isl::ast_expr expr2) const;
+  inline isl::ast_expr address_of() const;
+  inline isl::ast_expr call(isl::ast_expr_list arguments) const;
+  inline isl::ast_expr div(isl::ast_expr expr2) const;
+  inline isl::ast_expr eq(isl::ast_expr expr2) const;
+  static inline isl::ast_expr from_id(isl::id id);
+  static inline isl::ast_expr from_val(isl::val v);
+  inline isl::ast_expr ge(isl::ast_expr expr2) const;
+  inline isl::id get_id() const;
+  inline isl::ast_expr get_op_arg(int pos) const;
+  inline isl::val get_val() const;
+  inline isl::ast_expr gt(isl::ast_expr expr2) const;
+  inline isl::boolean is_equal(const isl::ast_expr &expr2) const;
+  inline isl::ast_expr le(isl::ast_expr expr2) const;
+  inline isl::ast_expr lt(isl::ast_expr expr2) const;
+  inline isl::ast_expr mul(isl::ast_expr expr2) const;
+  inline isl::ast_expr neg() const;
+  inline isl::ast_expr pdiv_q(isl::ast_expr expr2) const;
+  inline isl::ast_expr pdiv_r(isl::ast_expr expr2) const;
+  inline isl::ast_expr set_op_arg(int pos, isl::ast_expr arg) const;
+  inline isl::ast_expr sub(isl::ast_expr expr2) const;
+  inline isl::ast_expr substitute_ids(isl::id_to_ast_expr id2expr) const;
+  inline std::string to_C_str() const;
+};
+
+// declarations for isl::ast_expr_list
+inline isl::ast_expr_list manage(__isl_take isl_ast_expr_list *ptr);
+inline isl::ast_expr_list give(__isl_take isl_ast_expr_list *ptr);
+
+
+class ast_expr_list {
+  friend inline isl::ast_expr_list manage(__isl_take isl_ast_expr_list *ptr);
+
+  isl_ast_expr_list *ptr = nullptr;
+
+  inline explicit ast_expr_list(__isl_take isl_ast_expr_list *ptr);
+
+public:
+  inline /* implicit */ ast_expr_list();
+  inline /* implicit */ ast_expr_list(const isl::ast_expr_list &obj);
+  inline /* implicit */ ast_expr_list(std::nullptr_t);
+  inline isl::ast_expr_list &operator=(isl::ast_expr_list obj);
+  inline ~ast_expr_list();
+  inline __isl_give isl_ast_expr_list *copy() const &;
+  inline __isl_give isl_ast_expr_list *copy() && = delete;
+  inline __isl_keep isl_ast_expr_list *get() const;
+  inline __isl_give isl_ast_expr_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_ast_expr_list *keep() const;
+  inline __isl_give isl_ast_expr_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::ast_node
+inline isl::ast_node manage(__isl_take isl_ast_node *ptr);
+inline isl::ast_node give(__isl_take isl_ast_node *ptr);
+
+
+class ast_node {
+  friend inline isl::ast_node manage(__isl_take isl_ast_node *ptr);
+
+  isl_ast_node *ptr = nullptr;
+
+  inline explicit ast_node(__isl_take isl_ast_node *ptr);
+
+public:
+  inline /* implicit */ ast_node();
+  inline /* implicit */ ast_node(const isl::ast_node &obj);
+  inline /* implicit */ ast_node(std::nullptr_t);
+  inline isl::ast_node &operator=(isl::ast_node obj);
+  inline ~ast_node();
+  inline __isl_give isl_ast_node *copy() const &;
+  inline __isl_give isl_ast_node *copy() && = delete;
+  inline __isl_keep isl_ast_node *get() const;
+  inline __isl_give isl_ast_node *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_ast_node *keep() const;
+  inline __isl_give isl_ast_node *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  static inline isl::ast_node alloc_user(isl::ast_expr expr);
+  inline isl::ast_node_list block_get_children() const;
+  inline isl::ast_node for_get_body() const;
+  inline isl::ast_expr for_get_cond() const;
+  inline isl::ast_expr for_get_inc() const;
+  inline isl::ast_expr for_get_init() const;
+  inline isl::ast_expr for_get_iterator() const;
+  inline isl::boolean for_is_degenerate() const;
+  inline isl::id get_annotation() const;
+  inline isl::ast_expr if_get_cond() const;
+  inline isl::ast_node if_get_else() const;
+  inline isl::ast_node if_get_then() const;
+  inline isl::boolean if_has_else() const;
+  inline isl::id mark_get_id() const;
+  inline isl::ast_node mark_get_node() const;
+  inline isl::ast_node set_annotation(isl::id annotation) const;
+  inline std::string to_C_str() const;
+  inline isl::ast_expr user_get_expr() const;
+};
+
+// declarations for isl::ast_node_list
+inline isl::ast_node_list manage(__isl_take isl_ast_node_list *ptr);
+inline isl::ast_node_list give(__isl_take isl_ast_node_list *ptr);
+
+
+class ast_node_list {
+  friend inline isl::ast_node_list manage(__isl_take isl_ast_node_list *ptr);
+
+  isl_ast_node_list *ptr = nullptr;
+
+  inline explicit ast_node_list(__isl_take isl_ast_node_list *ptr);
+
+public:
+  inline /* implicit */ ast_node_list();
+  inline /* implicit */ ast_node_list(const isl::ast_node_list &obj);
+  inline /* implicit */ ast_node_list(std::nullptr_t);
+  inline isl::ast_node_list &operator=(isl::ast_node_list obj);
+  inline ~ast_node_list();
+  inline __isl_give isl_ast_node_list *copy() const &;
+  inline __isl_give isl_ast_node_list *copy() && = delete;
+  inline __isl_keep isl_ast_node_list *get() const;
+  inline __isl_give isl_ast_node_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_ast_node_list *keep() const;
+  inline __isl_give isl_ast_node_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::band_list
+inline isl::band_list manage(__isl_take isl_band_list *ptr);
+inline isl::band_list give(__isl_take isl_band_list *ptr);
+
+
+class band_list {
+  friend inline isl::band_list manage(__isl_take isl_band_list *ptr);
+
+  isl_band_list *ptr = nullptr;
+
+  inline explicit band_list(__isl_take isl_band_list *ptr);
+
+public:
+  inline /* implicit */ band_list();
+  inline /* implicit */ band_list(const isl::band_list &obj);
+  inline /* implicit */ band_list(std::nullptr_t);
+  inline isl::band_list &operator=(isl::band_list obj);
+  inline ~band_list();
+  inline __isl_give isl_band_list *copy() const &;
+  inline __isl_give isl_band_list *copy() && = delete;
+  inline __isl_keep isl_band_list *get() const;
+  inline __isl_give isl_band_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_band_list *keep() const;
+  inline __isl_give isl_band_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::basic_map
+inline isl::basic_map manage(__isl_take isl_basic_map *ptr);
+inline isl::basic_map give(__isl_take isl_basic_map *ptr);
+
+
+class basic_map {
+  friend inline isl::basic_map manage(__isl_take isl_basic_map *ptr);
+
+  isl_basic_map *ptr = nullptr;
+
+  inline explicit basic_map(__isl_take isl_basic_map *ptr);
+
+public:
+  inline /* implicit */ basic_map();
+  inline /* implicit */ basic_map(const isl::basic_map &obj);
+  inline /* implicit */ basic_map(std::nullptr_t);
+  inline explicit basic_map(isl::ctx ctx, const std::string &str);
+  inline isl::basic_map &operator=(isl::basic_map obj);
+  inline ~basic_map();
+  inline __isl_give isl_basic_map *copy() const &;
+  inline __isl_give isl_basic_map *copy() && = delete;
+  inline __isl_keep isl_basic_map *get() const;
+  inline __isl_give isl_basic_map *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_basic_map *keep() const;
+  inline __isl_give isl_basic_map *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::basic_map add_constraint(isl::constraint constraint) const;
+  inline isl::basic_map add_dims(isl::dim type, unsigned int n) const;
+  inline isl::basic_map affine_hull() const;
+  inline isl::basic_map align_params(isl::space model) const;
+  inline isl::basic_map apply_domain(isl::basic_map bmap2) const;
+  inline isl::basic_map apply_range(isl::basic_map bmap2) const;
+  inline isl::boolean can_curry() const;
+  inline isl::boolean can_uncurry() const;
+  inline isl::boolean can_zip() const;
+  inline isl::basic_map curry() const;
+  inline isl::basic_set deltas() const;
+  inline isl::basic_map deltas_map() const;
+  inline isl::basic_map detect_equalities() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::basic_set domain() const;
+  inline isl::basic_map domain_map() const;
+  inline isl::basic_map domain_product(isl::basic_map bmap2) const;
+  inline isl::basic_map drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_map drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_map eliminate(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::basic_map empty(isl::space dim);
+  static inline isl::basic_map equal(isl::space dim, unsigned int n_equal);
+  inline isl::basic_map equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::basic_map fix_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::basic_map fix_val(isl::dim type, unsigned int pos, isl::val v) const;
+  inline isl::basic_map flat_product(isl::basic_map bmap2) const;
+  inline isl::basic_map flat_range_product(isl::basic_map bmap2) const;
+  inline isl::basic_map flatten() const;
+  inline isl::basic_map flatten_domain() const;
+  inline isl::basic_map flatten_range() const;
+  inline isl::stat foreach_constraint(const std::function<isl::stat(isl::constraint)> &fn) const;
+  static inline isl::basic_map from_aff(isl::aff aff);
+  static inline isl::basic_map from_aff_list(isl::space domain_dim, isl::aff_list list);
+  static inline isl::basic_map from_constraint(isl::constraint constraint);
+  static inline isl::basic_map from_domain(isl::basic_set bset);
+  static inline isl::basic_map from_domain_and_range(isl::basic_set domain, isl::basic_set range);
+  static inline isl::basic_map from_multi_aff(isl::multi_aff maff);
+  static inline isl::basic_map from_qpolynomial(isl::qpolynomial qp);
+  static inline isl::basic_map from_range(isl::basic_set bset);
+  inline isl::constraint_list get_constraint_list() const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::aff get_div(int pos) const;
+  inline isl::local_space get_local_space() const;
+  inline isl::space get_space() const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::basic_map gist(isl::basic_map context) const;
+  inline isl::basic_map gist_domain(isl::basic_set context) const;
+  inline isl::boolean has_dim_id(isl::dim type, unsigned int pos) const;
+  static inline isl::basic_map identity(isl::space dim);
+  inline isl::boolean image_is_bounded() const;
+  inline isl::basic_map insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;
+  inline isl::basic_map intersect(isl::basic_map bmap2) const;
+  inline isl::basic_map intersect_domain(isl::basic_set bset) const;
+  inline isl::basic_map intersect_range(isl::basic_set bset) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean is_disjoint(const isl::basic_map &bmap2) const;
+  inline isl::boolean is_empty() const;
+  inline isl::boolean is_equal(const isl::basic_map &bmap2) const;
+  inline isl::boolean is_rational() const;
+  inline isl::boolean is_single_valued() const;
+  inline isl::boolean is_strict_subset(const isl::basic_map &bmap2) const;
+  inline isl::boolean is_subset(const isl::basic_map &bmap2) const;
+  inline isl::boolean is_universe() const;
+  static inline isl::basic_map less_at(isl::space dim, unsigned int pos);
+  inline isl::map lexmax() const;
+  inline isl::map lexmin() const;
+  inline isl::pw_multi_aff lexmin_pw_multi_aff() const;
+  inline isl::basic_map lower_bound_si(isl::dim type, unsigned int pos, int value) const;
+  static inline isl::basic_map more_at(isl::space dim, unsigned int pos);
+  inline isl::basic_map move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  static inline isl::basic_map nat_universe(isl::space dim);
+  inline isl::basic_map neg() const;
+  inline isl::basic_map order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::basic_map order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;
+  inline isl::boolean plain_is_empty() const;
+  inline isl::boolean plain_is_universe() const;
+  inline isl::basic_map preimage_domain_multi_aff(isl::multi_aff ma) const;
+  inline isl::basic_map preimage_range_multi_aff(isl::multi_aff ma) const;
+  inline isl::basic_map product(isl::basic_map bmap2) const;
+  inline isl::basic_map project_out(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_set range() const;
+  inline isl::basic_map range_map() const;
+  inline isl::basic_map range_product(isl::basic_map bmap2) const;
+  inline isl::basic_map remove_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_map remove_divs() const;
+  inline isl::basic_map remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_map remove_redundancies() const;
+  inline isl::basic_map reverse() const;
+  inline isl::basic_map sample() const;
+  inline isl::basic_map set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::basic_map set_tuple_name(isl::dim type, const std::string &s) const;
+  inline isl::basic_map sum(isl::basic_map bmap2) const;
+  inline isl::basic_map uncurry() const;
+  inline isl::map unite(isl::basic_map bmap2) const;
+  static inline isl::basic_map universe(isl::space dim);
+  inline isl::basic_map upper_bound_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::basic_set wrap() const;
+  inline isl::basic_map zip() const;
+};
+
+// declarations for isl::basic_map_list
+inline isl::basic_map_list manage(__isl_take isl_basic_map_list *ptr);
+inline isl::basic_map_list give(__isl_take isl_basic_map_list *ptr);
+
+
+class basic_map_list {
+  friend inline isl::basic_map_list manage(__isl_take isl_basic_map_list *ptr);
+
+  isl_basic_map_list *ptr = nullptr;
+
+  inline explicit basic_map_list(__isl_take isl_basic_map_list *ptr);
+
+public:
+  inline /* implicit */ basic_map_list();
+  inline /* implicit */ basic_map_list(const isl::basic_map_list &obj);
+  inline /* implicit */ basic_map_list(std::nullptr_t);
+  inline isl::basic_map_list &operator=(isl::basic_map_list obj);
+  inline ~basic_map_list();
+  inline __isl_give isl_basic_map_list *copy() const &;
+  inline __isl_give isl_basic_map_list *copy() && = delete;
+  inline __isl_keep isl_basic_map_list *get() const;
+  inline __isl_give isl_basic_map_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_basic_map_list *keep() const;
+  inline __isl_give isl_basic_map_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::basic_set
+inline isl::basic_set manage(__isl_take isl_basic_set *ptr);
+inline isl::basic_set give(__isl_take isl_basic_set *ptr);
+
+
+class basic_set {
+  friend inline isl::basic_set manage(__isl_take isl_basic_set *ptr);
+
+  isl_basic_set *ptr = nullptr;
+
+  inline explicit basic_set(__isl_take isl_basic_set *ptr);
+
+public:
+  inline /* implicit */ basic_set();
+  inline /* implicit */ basic_set(const isl::basic_set &obj);
+  inline /* implicit */ basic_set(std::nullptr_t);
+  inline explicit basic_set(isl::ctx ctx, const std::string &str);
+  inline /* implicit */ basic_set(isl::point pnt);
+  inline isl::basic_set &operator=(isl::basic_set obj);
+  inline ~basic_set();
+  inline __isl_give isl_basic_set *copy() const &;
+  inline __isl_give isl_basic_set *copy() && = delete;
+  inline __isl_keep isl_basic_set *get() const;
+  inline __isl_give isl_basic_set *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_basic_set *keep() const;
+  inline __isl_give isl_basic_set *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::basic_set affine_hull() const;
+  inline isl::basic_set align_params(isl::space model) const;
+  inline isl::basic_set apply(isl::basic_map bmap) const;
+  static inline isl::basic_set box_from_points(isl::point pnt1, isl::point pnt2);
+  inline isl::basic_set coefficients() const;
+  inline isl::basic_set detect_equalities() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::basic_set drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_set drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_set eliminate(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::basic_set empty(isl::space dim);
+  inline isl::basic_set fix_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::basic_set fix_val(isl::dim type, unsigned int pos, isl::val v) const;
+  inline isl::basic_set flat_product(isl::basic_set bset2) const;
+  inline isl::basic_set flatten() const;
+  inline isl::stat foreach_bound_pair(isl::dim type, unsigned int pos, const std::function<isl::stat(isl::constraint, isl::constraint, isl::basic_set)> &fn) const;
+  inline isl::stat foreach_constraint(const std::function<isl::stat(isl::constraint)> &fn) const;
+  static inline isl::basic_set from_constraint(isl::constraint constraint);
+  inline isl::basic_set from_params() const;
+  inline isl::constraint_list get_constraint_list() const;
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::aff get_div(int pos) const;
+  inline isl::local_space get_local_space() const;
+  inline isl::space get_space() const;
+  inline std::string get_tuple_name() const;
+  inline isl::basic_set gist(isl::basic_set context) const;
+  inline isl::basic_set insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;
+  inline isl::basic_set intersect(isl::basic_set bset2) const;
+  inline isl::basic_set intersect_params(isl::basic_set bset2) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean is_bounded() const;
+  inline isl::boolean is_disjoint(const isl::basic_set &bset2) const;
+  inline isl::boolean is_empty() const;
+  inline isl::boolean is_equal(const isl::basic_set &bset2) const;
+  inline int is_rational() const;
+  inline isl::boolean is_subset(const isl::basic_set &bset2) const;
+  inline isl::boolean is_universe() const;
+  inline isl::boolean is_wrapping() const;
+  inline isl::set lexmax() const;
+  inline isl::set lexmin() const;
+  inline isl::basic_set lower_bound_val(isl::dim type, unsigned int pos, isl::val value) const;
+  inline isl::val max_val(const isl::aff &obj) const;
+  inline isl::basic_set move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  static inline isl::basic_set nat_universe(isl::space dim);
+  inline isl::basic_set neg() const;
+  inline isl::basic_set params() const;
+  inline isl::boolean plain_is_empty() const;
+  inline isl::boolean plain_is_equal(const isl::basic_set &bset2) const;
+  inline isl::boolean plain_is_universe() const;
+  static inline isl::basic_set positive_orthant(isl::space space);
+  inline isl::basic_set preimage_multi_aff(isl::multi_aff ma) const;
+  inline isl::basic_set project_out(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_set remove_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_set remove_divs() const;
+  inline isl::basic_set remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::basic_set remove_redundancies() const;
+  inline isl::basic_set remove_unknown_divs() const;
+  inline isl::basic_set sample() const;
+  inline isl::point sample_point() const;
+  inline isl::basic_set set_tuple_id(isl::id id) const;
+  inline isl::basic_set set_tuple_name(const std::string &s) const;
+  inline isl::basic_set solutions() const;
+  inline isl::set unite(isl::basic_set bset2) const;
+  static inline isl::basic_set universe(isl::space dim);
+  inline isl::basic_map unwrap() const;
+  inline isl::basic_set upper_bound_val(isl::dim type, unsigned int pos, isl::val value) const;
+};
+
+// declarations for isl::basic_set_list
+inline isl::basic_set_list manage(__isl_take isl_basic_set_list *ptr);
+inline isl::basic_set_list give(__isl_take isl_basic_set_list *ptr);
+
+
+class basic_set_list {
+  friend inline isl::basic_set_list manage(__isl_take isl_basic_set_list *ptr);
+
+  isl_basic_set_list *ptr = nullptr;
+
+  inline explicit basic_set_list(__isl_take isl_basic_set_list *ptr);
+
+public:
+  inline /* implicit */ basic_set_list();
+  inline /* implicit */ basic_set_list(const isl::basic_set_list &obj);
+  inline /* implicit */ basic_set_list(std::nullptr_t);
+  inline isl::basic_set_list &operator=(isl::basic_set_list obj);
+  inline ~basic_set_list();
+  inline __isl_give isl_basic_set_list *copy() const &;
+  inline __isl_give isl_basic_set_list *copy() && = delete;
+  inline __isl_keep isl_basic_set_list *get() const;
+  inline __isl_give isl_basic_set_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_basic_set_list *keep() const;
+  inline __isl_give isl_basic_set_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::constraint
+inline isl::constraint manage(__isl_take isl_constraint *ptr);
+inline isl::constraint give(__isl_take isl_constraint *ptr);
+
+
+class constraint {
+  friend inline isl::constraint manage(__isl_take isl_constraint *ptr);
+
+  isl_constraint *ptr = nullptr;
+
+  inline explicit constraint(__isl_take isl_constraint *ptr);
+
+public:
+  inline /* implicit */ constraint();
+  inline /* implicit */ constraint(const isl::constraint &obj);
+  inline /* implicit */ constraint(std::nullptr_t);
+  inline isl::constraint &operator=(isl::constraint obj);
+  inline ~constraint();
+  inline __isl_give isl_constraint *copy() const &;
+  inline __isl_give isl_constraint *copy() && = delete;
+  inline __isl_keep isl_constraint *get() const;
+  inline __isl_give isl_constraint *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_constraint *keep() const;
+  inline __isl_give isl_constraint *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+  static inline isl::constraint alloc_equality(isl::local_space ls);
+  static inline isl::constraint alloc_inequality(isl::local_space ls);
+  inline int cmp_last_non_zero(const isl::constraint &c2) const;
+  inline isl::aff get_aff() const;
+  inline isl::aff get_bound(isl::dim type, int pos) const;
+  inline isl::val get_coefficient_val(isl::dim type, int pos) const;
+  inline isl::val get_constant_val() const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::aff get_div(int pos) const;
+  inline isl::local_space get_local_space() const;
+  inline isl::space get_space() const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline int is_div_constraint() const;
+  inline isl::boolean is_lower_bound(isl::dim type, unsigned int pos) const;
+  inline isl::boolean is_upper_bound(isl::dim type, unsigned int pos) const;
+  inline int plain_cmp(const isl::constraint &c2) const;
+  inline isl::constraint set_coefficient_si(isl::dim type, int pos, int v) const;
+  inline isl::constraint set_coefficient_val(isl::dim type, int pos, isl::val v) const;
+  inline isl::constraint set_constant_si(int v) const;
+  inline isl::constraint set_constant_val(isl::val v) const;
+};
+
+// declarations for isl::constraint_list
+inline isl::constraint_list manage(__isl_take isl_constraint_list *ptr);
+inline isl::constraint_list give(__isl_take isl_constraint_list *ptr);
+
+
+class constraint_list {
+  friend inline isl::constraint_list manage(__isl_take isl_constraint_list *ptr);
+
+  isl_constraint_list *ptr = nullptr;
+
+  inline explicit constraint_list(__isl_take isl_constraint_list *ptr);
+
+public:
+  inline /* implicit */ constraint_list();
+  inline /* implicit */ constraint_list(const isl::constraint_list &obj);
+  inline /* implicit */ constraint_list(std::nullptr_t);
+  inline isl::constraint_list &operator=(isl::constraint_list obj);
+  inline ~constraint_list();
+  inline __isl_give isl_constraint_list *copy() const &;
+  inline __isl_give isl_constraint_list *copy() && = delete;
+  inline __isl_keep isl_constraint_list *get() const;
+  inline __isl_give isl_constraint_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_constraint_list *keep() const;
+  inline __isl_give isl_constraint_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::id
+inline isl::id manage(__isl_take isl_id *ptr);
+inline isl::id give(__isl_take isl_id *ptr);
+
+
+class id {
+  friend inline isl::id manage(__isl_take isl_id *ptr);
+
+  isl_id *ptr = nullptr;
+
+  inline explicit id(__isl_take isl_id *ptr);
+
+public:
+  inline /* implicit */ id();
+  inline /* implicit */ id(const isl::id &obj);
+  inline /* implicit */ id(std::nullptr_t);
+  inline isl::id &operator=(isl::id obj);
+  inline ~id();
+  inline __isl_give isl_id *copy() const &;
+  inline __isl_give isl_id *copy() && = delete;
+  inline __isl_keep isl_id *get() const;
+  inline __isl_give isl_id *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_id *keep() const;
+  inline __isl_give isl_id *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  static inline isl::id alloc(isl::ctx ctx, const std::string &name, void * user);
+  inline uint32_t get_hash() const;
+  inline std::string get_name() const;
+  inline void * get_user() const;
+};
+
+// declarations for isl::id_list
+inline isl::id_list manage(__isl_take isl_id_list *ptr);
+inline isl::id_list give(__isl_take isl_id_list *ptr);
+
+
+class id_list {
+  friend inline isl::id_list manage(__isl_take isl_id_list *ptr);
+
+  isl_id_list *ptr = nullptr;
+
+  inline explicit id_list(__isl_take isl_id_list *ptr);
+
+public:
+  inline /* implicit */ id_list();
+  inline /* implicit */ id_list(const isl::id_list &obj);
+  inline /* implicit */ id_list(std::nullptr_t);
+  inline isl::id_list &operator=(isl::id_list obj);
+  inline ~id_list();
+  inline __isl_give isl_id_list *copy() const &;
+  inline __isl_give isl_id_list *copy() && = delete;
+  inline __isl_keep isl_id_list *get() const;
+  inline __isl_give isl_id_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_id_list *keep() const;
+  inline __isl_give isl_id_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::id_to_ast_expr
+inline isl::id_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr);
+inline isl::id_to_ast_expr give(__isl_take isl_id_to_ast_expr *ptr);
+
+
+class id_to_ast_expr {
+  friend inline isl::id_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr);
+
+  isl_id_to_ast_expr *ptr = nullptr;
+
+  inline explicit id_to_ast_expr(__isl_take isl_id_to_ast_expr *ptr);
+
+public:
+  inline /* implicit */ id_to_ast_expr();
+  inline /* implicit */ id_to_ast_expr(const isl::id_to_ast_expr &obj);
+  inline /* implicit */ id_to_ast_expr(std::nullptr_t);
+  inline isl::id_to_ast_expr &operator=(isl::id_to_ast_expr obj);
+  inline ~id_to_ast_expr();
+  inline __isl_give isl_id_to_ast_expr *copy() const &;
+  inline __isl_give isl_id_to_ast_expr *copy() && = delete;
+  inline __isl_keep isl_id_to_ast_expr *get() const;
+  inline __isl_give isl_id_to_ast_expr *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_id_to_ast_expr *keep() const;
+  inline __isl_give isl_id_to_ast_expr *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+  static inline isl::id_to_ast_expr alloc(isl::ctx ctx, int min_size);
+  inline isl::id_to_ast_expr drop(isl::id key) const;
+  inline isl::stat foreach(const std::function<isl::stat(isl::id, isl::ast_expr)> &fn) const;
+  inline isl::ast_expr get(isl::id key) const;
+  inline isl::boolean has(const isl::id &key) const;
+  inline isl::id_to_ast_expr set(isl::id key, isl::ast_expr val) const;
+};
+
+// declarations for isl::local_space
+inline isl::local_space manage(__isl_take isl_local_space *ptr);
+inline isl::local_space give(__isl_take isl_local_space *ptr);
+
+
+class local_space {
+  friend inline isl::local_space manage(__isl_take isl_local_space *ptr);
+
+  isl_local_space *ptr = nullptr;
+
+  inline explicit local_space(__isl_take isl_local_space *ptr);
+
+public:
+  inline /* implicit */ local_space();
+  inline /* implicit */ local_space(const isl::local_space &obj);
+  inline /* implicit */ local_space(std::nullptr_t);
+  inline explicit local_space(isl::space dim);
+  inline isl::local_space &operator=(isl::local_space obj);
+  inline ~local_space();
+  inline __isl_give isl_local_space *copy() const &;
+  inline __isl_give isl_local_space *copy() && = delete;
+  inline __isl_keep isl_local_space *get() const;
+  inline __isl_give isl_local_space *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_local_space *keep() const;
+  inline __isl_give isl_local_space *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+  inline isl::local_space add_dims(isl::dim type, unsigned int n) const;
+  inline int dim(isl::dim type) const;
+  inline isl::local_space domain() const;
+  inline isl::local_space drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::local_space flatten_domain() const;
+  inline isl::local_space flatten_range() const;
+  inline isl::local_space from_domain() const;
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::aff get_div(int pos) const;
+  inline isl::space get_space() const;
+  inline isl::boolean has_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::local_space insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::local_space intersect(isl::local_space ls2) const;
+  inline isl::boolean is_equal(const isl::local_space &ls2) const;
+  inline isl::boolean is_params() const;
+  inline isl::boolean is_set() const;
+  inline isl::local_space range() const;
+  inline isl::local_space set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::local_space set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::local_space wrap() const;
+};
+
+// declarations for isl::map
+inline isl::map manage(__isl_take isl_map *ptr);
+inline isl::map give(__isl_take isl_map *ptr);
+
+
+class map {
+  friend inline isl::map manage(__isl_take isl_map *ptr);
+
+  isl_map *ptr = nullptr;
+
+  inline explicit map(__isl_take isl_map *ptr);
+
+public:
+  inline /* implicit */ map();
+  inline /* implicit */ map(const isl::map &obj);
+  inline /* implicit */ map(std::nullptr_t);
+  inline explicit map(isl::ctx ctx, const std::string &str);
+  inline /* implicit */ map(isl::basic_map bmap);
+  inline isl::map &operator=(isl::map obj);
+  inline ~map();
+  inline __isl_give isl_map *copy() const &;
+  inline __isl_give isl_map *copy() && = delete;
+  inline __isl_keep isl_map *get() const;
+  inline __isl_give isl_map *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_map *keep() const;
+  inline __isl_give isl_map *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::map add_constraint(isl::constraint constraint) const;
+  inline isl::map add_dims(isl::dim type, unsigned int n) const;
+  inline isl::basic_map affine_hull() const;
+  inline isl::map align_params(isl::space model) const;
+  inline isl::map apply_domain(isl::map map2) const;
+  inline isl::map apply_range(isl::map map2) const;
+  inline isl::boolean can_curry() const;
+  inline isl::boolean can_range_curry() const;
+  inline isl::boolean can_uncurry() const;
+  inline isl::boolean can_zip() const;
+  inline isl::map coalesce() const;
+  inline isl::map complement() const;
+  inline isl::basic_map convex_hull() const;
+  inline isl::map curry() const;
+  inline isl::set deltas() const;
+  inline isl::map deltas_map() const;
+  inline isl::map detect_equalities() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::pw_aff dim_max(int pos) const;
+  inline isl::pw_aff dim_min(int pos) const;
+  inline isl::set domain() const;
+  inline isl::map domain_factor_domain() const;
+  inline isl::map domain_factor_range() const;
+  inline isl::boolean domain_is_wrapping() const;
+  inline isl::map domain_map() const;
+  inline isl::map domain_product(isl::map map2) const;
+  inline isl::map drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::map drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::map eliminate(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::map empty(isl::space dim);
+  inline isl::map equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::map factor_domain() const;
+  inline isl::map factor_range() const;
+  inline int find_dim_by_id(isl::dim type, const isl::id &id) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::map fix_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::map fix_val(isl::dim type, unsigned int pos, isl::val v) const;
+  inline isl::map fixed_power_val(isl::val exp) const;
+  inline isl::map flat_domain_product(isl::map map2) const;
+  inline isl::map flat_product(isl::map map2) const;
+  inline isl::map flat_range_product(isl::map map2) const;
+  inline isl::map flatten() const;
+  inline isl::map flatten_domain() const;
+  inline isl::map flatten_range() const;
+  inline isl::map floordiv_val(isl::val d) const;
+  inline isl::stat foreach_basic_map(const std::function<isl::stat(isl::basic_map)> &fn) const;
+  static inline isl::map from_aff(isl::aff aff);
+  static inline isl::map from_domain(isl::set set);
+  static inline isl::map from_domain_and_range(isl::set domain, isl::set range);
+  static inline isl::map from_multi_aff(isl::multi_aff maff);
+  static inline isl::map from_multi_pw_aff(isl::multi_pw_aff mpa);
+  static inline isl::map from_pw_aff(isl::pw_aff pwaff);
+  static inline isl::map from_pw_multi_aff(isl::pw_multi_aff pma);
+  static inline isl::map from_range(isl::set set);
+  static inline isl::map from_union_map(isl::union_map umap);
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline uint32_t get_hash() const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::map gist(isl::map context) const;
+  inline isl::map gist_basic_map(isl::basic_map context) const;
+  inline isl::map gist_domain(isl::set context) const;
+  inline isl::map gist_params(isl::set context) const;
+  inline isl::map gist_range(isl::set context) const;
+  inline isl::boolean has_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_equal_space(const isl::map &map2) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  inline isl::boolean has_tuple_name(isl::dim type) const;
+  static inline isl::map identity(isl::space dim);
+  inline isl::map insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;
+  inline isl::map intersect(isl::map map2) const;
+  inline isl::map intersect_domain(isl::set set) const;
+  inline isl::map intersect_domain_factor_range(isl::map factor) const;
+  inline isl::map intersect_params(isl::set params) const;
+  inline isl::map intersect_range(isl::set set) const;
+  inline isl::map intersect_range_factor_range(isl::map factor) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean is_bijective() const;
+  inline isl::boolean is_disjoint(const isl::map &map2) const;
+  inline isl::boolean is_empty() const;
+  inline isl::boolean is_equal(const isl::map &map2) const;
+  inline isl::boolean is_identity() const;
+  inline isl::boolean is_injective() const;
+  inline isl::boolean is_product() const;
+  inline isl::boolean is_single_valued() const;
+  inline isl::boolean is_strict_subset(const isl::map &map2) const;
+  inline isl::boolean is_subset(const isl::map &map2) const;
+  inline int is_translation() const;
+  static inline isl::map lex_ge(isl::space set_dim);
+  static inline isl::map lex_ge_first(isl::space dim, unsigned int n);
+  inline isl::map lex_ge_map(isl::map map2) const;
+  static inline isl::map lex_gt(isl::space set_dim);
+  static inline isl::map lex_gt_first(isl::space dim, unsigned int n);
+  inline isl::map lex_gt_map(isl::map map2) const;
+  static inline isl::map lex_le(isl::space set_dim);
+  static inline isl::map lex_le_first(isl::space dim, unsigned int n);
+  inline isl::map lex_le_map(isl::map map2) const;
+  static inline isl::map lex_lt(isl::space set_dim);
+  static inline isl::map lex_lt_first(isl::space dim, unsigned int n);
+  inline isl::map lex_lt_map(isl::map map2) const;
+  inline isl::map lexmax() const;
+  inline isl::pw_multi_aff lexmax_pw_multi_aff() const;
+  inline isl::map lexmin() const;
+  inline isl::pw_multi_aff lexmin_pw_multi_aff() const;
+  inline isl::map lower_bound_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::map move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  static inline isl::map nat_universe(isl::space dim);
+  inline isl::map neg() const;
+  inline isl::map oppose(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::map order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::map order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::map order_le(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::map order_lt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline isl::set params() const;
+  inline isl::val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;
+  inline isl::boolean plain_is_empty() const;
+  inline isl::boolean plain_is_equal(const isl::map &map2) const;
+  inline isl::boolean plain_is_injective() const;
+  inline isl::boolean plain_is_single_valued() const;
+  inline isl::boolean plain_is_universe() const;
+  inline isl::basic_map plain_unshifted_simple_hull() const;
+  inline isl::basic_map polyhedral_hull() const;
+  inline isl::map preimage_domain_multi_aff(isl::multi_aff ma) const;
+  inline isl::map preimage_domain_multi_pw_aff(isl::multi_pw_aff mpa) const;
+  inline isl::map preimage_domain_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::map preimage_range_multi_aff(isl::multi_aff ma) const;
+  inline isl::map preimage_range_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::map product(isl::map map2) const;
+  inline isl::map project_out(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set range() const;
+  inline isl::map range_curry() const;
+  inline isl::map range_factor_domain() const;
+  inline isl::map range_factor_range() const;
+  inline isl::boolean range_is_wrapping() const;
+  inline isl::map range_map() const;
+  inline isl::map range_product(isl::map map2) const;
+  inline isl::map remove_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::map remove_divs() const;
+  inline isl::map remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::map remove_redundancies() const;
+  inline isl::map remove_unknown_divs() const;
+  inline isl::map reset_tuple_id(isl::dim type) const;
+  inline isl::map reset_user() const;
+  inline isl::map reverse() const;
+  inline isl::basic_map sample() const;
+  inline isl::map set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::map set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::map set_tuple_name(isl::dim type, const std::string &s) const;
+  inline isl::basic_map simple_hull() const;
+  inline isl::map subtract(isl::map map2) const;
+  inline isl::map subtract_domain(isl::set dom) const;
+  inline isl::map subtract_range(isl::set dom) const;
+  inline isl::map sum(isl::map map2) const;
+  inline isl::map uncurry() const;
+  inline isl::map unite(isl::map map2) const;
+  static inline isl::map universe(isl::space dim);
+  inline isl::basic_map unshifted_simple_hull() const;
+  inline isl::basic_map unshifted_simple_hull_from_map_list(isl::map_list list) const;
+  inline isl::map upper_bound_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::set wrap() const;
+  inline isl::map zip() const;
+};
+
+// declarations for isl::map_list
+inline isl::map_list manage(__isl_take isl_map_list *ptr);
+inline isl::map_list give(__isl_take isl_map_list *ptr);
+
+
+class map_list {
+  friend inline isl::map_list manage(__isl_take isl_map_list *ptr);
+
+  isl_map_list *ptr = nullptr;
+
+  inline explicit map_list(__isl_take isl_map_list *ptr);
+
+public:
+  inline /* implicit */ map_list();
+  inline /* implicit */ map_list(const isl::map_list &obj);
+  inline /* implicit */ map_list(std::nullptr_t);
+  inline isl::map_list &operator=(isl::map_list obj);
+  inline ~map_list();
+  inline __isl_give isl_map_list *copy() const &;
+  inline __isl_give isl_map_list *copy() && = delete;
+  inline __isl_keep isl_map_list *get() const;
+  inline __isl_give isl_map_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_map_list *keep() const;
+  inline __isl_give isl_map_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::multi_aff
+inline isl::multi_aff manage(__isl_take isl_multi_aff *ptr);
+inline isl::multi_aff give(__isl_take isl_multi_aff *ptr);
+
+
+class multi_aff {
+  friend inline isl::multi_aff manage(__isl_take isl_multi_aff *ptr);
+
+  isl_multi_aff *ptr = nullptr;
+
+  inline explicit multi_aff(__isl_take isl_multi_aff *ptr);
+
+public:
+  inline /* implicit */ multi_aff();
+  inline /* implicit */ multi_aff(const isl::multi_aff &obj);
+  inline /* implicit */ multi_aff(std::nullptr_t);
+  inline explicit multi_aff(isl::ctx ctx, const std::string &str);
+  inline /* implicit */ multi_aff(isl::aff aff);
+  inline isl::multi_aff &operator=(isl::multi_aff obj);
+  inline ~multi_aff();
+  inline __isl_give isl_multi_aff *copy() const &;
+  inline __isl_give isl_multi_aff *copy() && = delete;
+  inline __isl_keep isl_multi_aff *get() const;
+  inline __isl_give isl_multi_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_multi_aff *keep() const;
+  inline __isl_give isl_multi_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::multi_aff add(isl::multi_aff multi2) const;
+  inline isl::multi_aff add_dims(isl::dim type, unsigned int n) const;
+  inline isl::multi_aff align_params(isl::space model) const;
+  inline unsigned int dim(isl::dim type) const;
+  static inline isl::multi_aff domain_map(isl::space space);
+  inline isl::multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::multi_aff factor_range() const;
+  inline int find_dim_by_id(isl::dim type, const isl::id &id) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::multi_aff flat_range_product(isl::multi_aff multi2) const;
+  inline isl::multi_aff flatten_domain() const;
+  inline isl::multi_aff flatten_range() const;
+  inline isl::multi_aff floor() const;
+  static inline isl::multi_aff from_aff_list(isl::space space, isl::aff_list list);
+  inline isl::multi_aff from_range() const;
+  inline isl::aff get_aff(int pos) const;
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::space get_domain_space() const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::multi_aff gist(isl::set context) const;
+  inline isl::multi_aff gist_params(isl::set context) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  static inline isl::multi_aff identity(isl::space space);
+  inline isl::multi_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::set lex_ge_set(isl::multi_aff ma2) const;
+  inline isl::set lex_gt_set(isl::multi_aff ma2) const;
+  inline isl::set lex_le_set(isl::multi_aff ma2) const;
+  inline isl::set lex_lt_set(isl::multi_aff ma2) const;
+  inline isl::multi_aff mod_multi_val(isl::multi_val mv) const;
+  inline isl::multi_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  static inline isl::multi_aff multi_val_on_space(isl::space space, isl::multi_val mv);
+  inline isl::multi_aff neg() const;
+  inline int plain_cmp(const isl::multi_aff &multi2) const;
+  inline isl::boolean plain_is_equal(const isl::multi_aff &multi2) const;
+  inline isl::multi_aff product(isl::multi_aff multi2) const;
+  static inline isl::multi_aff project_out_map(isl::space space, isl::dim type, unsigned int first, unsigned int n);
+  inline isl::multi_aff pullback(isl::multi_aff ma2) const;
+  inline isl::multi_aff range_factor_domain() const;
+  inline isl::multi_aff range_factor_range() const;
+  inline isl::boolean range_is_wrapping() const;
+  static inline isl::multi_aff range_map(isl::space space);
+  inline isl::multi_aff range_product(isl::multi_aff multi2) const;
+  inline isl::multi_aff range_splice(unsigned int pos, isl::multi_aff multi2) const;
+  inline isl::multi_aff reset_tuple_id(isl::dim type) const;
+  inline isl::multi_aff reset_user() const;
+  inline isl::multi_aff scale_down_multi_val(isl::multi_val mv) const;
+  inline isl::multi_aff scale_down_val(isl::val v) const;
+  inline isl::multi_aff scale_multi_val(isl::multi_val mv) const;
+  inline isl::multi_aff scale_val(isl::val v) const;
+  inline isl::multi_aff set_aff(int pos, isl::aff el) const;
+  inline isl::multi_aff set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::multi_aff set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::multi_aff set_tuple_name(isl::dim type, const std::string &s) const;
+  inline isl::multi_aff splice(unsigned int in_pos, unsigned int out_pos, isl::multi_aff multi2) const;
+  inline isl::multi_aff sub(isl::multi_aff multi2) const;
+  static inline isl::multi_aff zero(isl::space space);
+};
+
+// declarations for isl::multi_pw_aff
+inline isl::multi_pw_aff manage(__isl_take isl_multi_pw_aff *ptr);
+inline isl::multi_pw_aff give(__isl_take isl_multi_pw_aff *ptr);
+
+
+class multi_pw_aff {
+  friend inline isl::multi_pw_aff manage(__isl_take isl_multi_pw_aff *ptr);
+
+  isl_multi_pw_aff *ptr = nullptr;
+
+  inline explicit multi_pw_aff(__isl_take isl_multi_pw_aff *ptr);
+
+public:
+  inline /* implicit */ multi_pw_aff();
+  inline /* implicit */ multi_pw_aff(const isl::multi_pw_aff &obj);
+  inline /* implicit */ multi_pw_aff(std::nullptr_t);
+  inline /* implicit */ multi_pw_aff(isl::multi_aff ma);
+  inline /* implicit */ multi_pw_aff(isl::pw_aff pa);
+  inline /* implicit */ multi_pw_aff(isl::pw_multi_aff pma);
+  inline explicit multi_pw_aff(isl::ctx ctx, const std::string &str);
+  inline isl::multi_pw_aff &operator=(isl::multi_pw_aff obj);
+  inline ~multi_pw_aff();
+  inline __isl_give isl_multi_pw_aff *copy() const &;
+  inline __isl_give isl_multi_pw_aff *copy() && = delete;
+  inline __isl_keep isl_multi_pw_aff *get() const;
+  inline __isl_give isl_multi_pw_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_multi_pw_aff *keep() const;
+  inline __isl_give isl_multi_pw_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::multi_pw_aff add(isl::multi_pw_aff multi2) const;
+  inline isl::multi_pw_aff add_dims(isl::dim type, unsigned int n) const;
+  inline isl::multi_pw_aff align_params(isl::space model) const;
+  inline isl::multi_pw_aff coalesce() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::set domain() const;
+  inline isl::multi_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::map eq_map(isl::multi_pw_aff mpa2) const;
+  inline isl::multi_pw_aff factor_range() const;
+  inline int find_dim_by_id(isl::dim type, const isl::id &id) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::multi_pw_aff flat_range_product(isl::multi_pw_aff multi2) const;
+  inline isl::multi_pw_aff flatten_range() const;
+  static inline isl::multi_pw_aff from_pw_aff_list(isl::space space, isl::pw_aff_list list);
+  inline isl::multi_pw_aff from_range() const;
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::space get_domain_space() const;
+  inline uint32_t get_hash() const;
+  inline isl::pw_aff get_pw_aff(int pos) const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::multi_pw_aff gist(isl::set set) const;
+  inline isl::multi_pw_aff gist_params(isl::set set) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  static inline isl::multi_pw_aff identity(isl::space space);
+  inline isl::multi_pw_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::multi_pw_aff intersect_domain(isl::set domain) const;
+  inline isl::multi_pw_aff intersect_params(isl::set set) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::boolean is_cst() const;
+  inline isl::boolean is_equal(const isl::multi_pw_aff &mpa2) const;
+  inline isl::map lex_gt_map(isl::multi_pw_aff mpa2) const;
+  inline isl::map lex_lt_map(isl::multi_pw_aff mpa2) const;
+  inline isl::multi_pw_aff mod_multi_val(isl::multi_val mv) const;
+  inline isl::multi_pw_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  inline isl::multi_pw_aff neg() const;
+  inline isl::boolean plain_is_equal(const isl::multi_pw_aff &multi2) const;
+  inline isl::multi_pw_aff product(isl::multi_pw_aff multi2) const;
+  inline isl::multi_pw_aff pullback(isl::multi_aff ma) const;
+  inline isl::multi_pw_aff pullback(isl::pw_multi_aff pma) const;
+  inline isl::multi_pw_aff pullback(isl::multi_pw_aff mpa2) const;
+  inline isl::multi_pw_aff range_factor_domain() const;
+  inline isl::multi_pw_aff range_factor_range() const;
+  inline isl::boolean range_is_wrapping() const;
+  inline isl::multi_pw_aff range_product(isl::multi_pw_aff multi2) const;
+  inline isl::multi_pw_aff range_splice(unsigned int pos, isl::multi_pw_aff multi2) const;
+  inline isl::multi_pw_aff reset_tuple_id(isl::dim type) const;
+  inline isl::multi_pw_aff reset_user() const;
+  inline isl::multi_pw_aff scale_down_multi_val(isl::multi_val mv) const;
+  inline isl::multi_pw_aff scale_down_val(isl::val v) const;
+  inline isl::multi_pw_aff scale_multi_val(isl::multi_val mv) const;
+  inline isl::multi_pw_aff scale_val(isl::val v) const;
+  inline isl::multi_pw_aff set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::multi_pw_aff set_pw_aff(int pos, isl::pw_aff el) const;
+  inline isl::multi_pw_aff set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::multi_pw_aff set_tuple_name(isl::dim type, const std::string &s) const;
+  inline isl::multi_pw_aff splice(unsigned int in_pos, unsigned int out_pos, isl::multi_pw_aff multi2) const;
+  inline isl::multi_pw_aff sub(isl::multi_pw_aff multi2) const;
+  static inline isl::multi_pw_aff zero(isl::space space);
+};
+
+// declarations for isl::multi_union_pw_aff
+inline isl::multi_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr);
+inline isl::multi_union_pw_aff give(__isl_take isl_multi_union_pw_aff *ptr);
+
+
+class multi_union_pw_aff {
+  friend inline isl::multi_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr);
+
+  isl_multi_union_pw_aff *ptr = nullptr;
+
+  inline explicit multi_union_pw_aff(__isl_take isl_multi_union_pw_aff *ptr);
+
+public:
+  inline /* implicit */ multi_union_pw_aff();
+  inline /* implicit */ multi_union_pw_aff(const isl::multi_union_pw_aff &obj);
+  inline /* implicit */ multi_union_pw_aff(std::nullptr_t);
+  inline /* implicit */ multi_union_pw_aff(isl::union_pw_aff upa);
+  inline /* implicit */ multi_union_pw_aff(isl::multi_pw_aff mpa);
+  inline explicit multi_union_pw_aff(isl::union_pw_multi_aff upma);
+  inline explicit multi_union_pw_aff(isl::ctx ctx, const std::string &str);
+  inline isl::multi_union_pw_aff &operator=(isl::multi_union_pw_aff obj);
+  inline ~multi_union_pw_aff();
+  inline __isl_give isl_multi_union_pw_aff *copy() const &;
+  inline __isl_give isl_multi_union_pw_aff *copy() && = delete;
+  inline __isl_keep isl_multi_union_pw_aff *get() const;
+  inline __isl_give isl_multi_union_pw_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_multi_union_pw_aff *keep() const;
+  inline __isl_give isl_multi_union_pw_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::multi_union_pw_aff add(isl::multi_union_pw_aff multi2) const;
+  inline isl::multi_union_pw_aff align_params(isl::space model) const;
+  inline isl::union_pw_aff apply_aff(isl::aff aff) const;
+  inline isl::union_pw_aff apply_pw_aff(isl::pw_aff pa) const;
+  inline isl::multi_union_pw_aff apply_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::multi_union_pw_aff coalesce() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::union_set domain() const;
+  inline isl::multi_union_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::multi_pw_aff extract_multi_pw_aff(isl::space space) const;
+  inline isl::multi_union_pw_aff factor_range() const;
+  inline int find_dim_by_id(isl::dim type, const isl::id &id) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::multi_union_pw_aff flat_range_product(isl::multi_union_pw_aff multi2) const;
+  inline isl::multi_union_pw_aff flatten_range() const;
+  inline isl::multi_union_pw_aff floor() const;
+  static inline isl::multi_union_pw_aff from_multi_aff(isl::multi_aff ma);
+  inline isl::multi_union_pw_aff from_range() const;
+  static inline isl::multi_union_pw_aff from_union_map(isl::union_map umap);
+  static inline isl::multi_union_pw_aff from_union_pw_aff_list(isl::space space, isl::union_pw_aff_list list);
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::space get_domain_space() const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::union_pw_aff get_union_pw_aff(int pos) const;
+  inline isl::multi_union_pw_aff gist(isl::union_set context) const;
+  inline isl::multi_union_pw_aff gist_params(isl::set context) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  inline isl::multi_union_pw_aff intersect_domain(isl::union_set uset) const;
+  inline isl::multi_union_pw_aff intersect_params(isl::set params) const;
+  inline isl::multi_union_pw_aff intersect_range(isl::set set) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::multi_union_pw_aff mod_multi_val(isl::multi_val mv) const;
+  static inline isl::multi_union_pw_aff multi_aff_on_domain(isl::union_set domain, isl::multi_aff ma);
+  static inline isl::multi_union_pw_aff multi_val_on_domain(isl::union_set domain, isl::multi_val mv);
+  inline isl::multi_union_pw_aff neg() const;
+  inline isl::boolean plain_is_equal(const isl::multi_union_pw_aff &multi2) const;
+  inline isl::multi_union_pw_aff pullback(isl::union_pw_multi_aff upma) const;
+  inline isl::multi_union_pw_aff range_factor_domain() const;
+  inline isl::multi_union_pw_aff range_factor_range() const;
+  inline isl::boolean range_is_wrapping() const;
+  inline isl::multi_union_pw_aff range_product(isl::multi_union_pw_aff multi2) const;
+  inline isl::multi_union_pw_aff range_splice(unsigned int pos, isl::multi_union_pw_aff multi2) const;
+  inline isl::multi_union_pw_aff reset_tuple_id(isl::dim type) const;
+  inline isl::multi_union_pw_aff reset_user() const;
+  inline isl::multi_union_pw_aff scale_down_multi_val(isl::multi_val mv) const;
+  inline isl::multi_union_pw_aff scale_down_val(isl::val v) const;
+  inline isl::multi_union_pw_aff scale_multi_val(isl::multi_val mv) const;
+  inline isl::multi_union_pw_aff scale_val(isl::val v) const;
+  inline isl::multi_union_pw_aff set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::multi_union_pw_aff set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::multi_union_pw_aff set_tuple_name(isl::dim type, const std::string &s) const;
+  inline isl::multi_union_pw_aff set_union_pw_aff(int pos, isl::union_pw_aff el) const;
+  inline isl::multi_union_pw_aff sub(isl::multi_union_pw_aff multi2) const;
+  inline isl::multi_union_pw_aff union_add(isl::multi_union_pw_aff mupa2) const;
+  static inline isl::multi_union_pw_aff zero(isl::space space);
+  inline isl::union_set zero_union_set() const;
+};
+
+// declarations for isl::multi_val
+inline isl::multi_val manage(__isl_take isl_multi_val *ptr);
+inline isl::multi_val give(__isl_take isl_multi_val *ptr);
+
+
+class multi_val {
+  friend inline isl::multi_val manage(__isl_take isl_multi_val *ptr);
+
+  isl_multi_val *ptr = nullptr;
+
+  inline explicit multi_val(__isl_take isl_multi_val *ptr);
+
+public:
+  inline /* implicit */ multi_val();
+  inline /* implicit */ multi_val(const isl::multi_val &obj);
+  inline /* implicit */ multi_val(std::nullptr_t);
+  inline explicit multi_val(isl::ctx ctx, const std::string &str);
+  inline isl::multi_val &operator=(isl::multi_val obj);
+  inline ~multi_val();
+  inline __isl_give isl_multi_val *copy() const &;
+  inline __isl_give isl_multi_val *copy() && = delete;
+  inline __isl_keep isl_multi_val *get() const;
+  inline __isl_give isl_multi_val *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_multi_val *keep() const;
+  inline __isl_give isl_multi_val *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::multi_val add(isl::multi_val multi2) const;
+  inline isl::multi_val add_dims(isl::dim type, unsigned int n) const;
+  inline isl::multi_val add_val(isl::val v) const;
+  inline isl::multi_val align_params(isl::space model) const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::multi_val drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::multi_val factor_range() const;
+  inline int find_dim_by_id(isl::dim type, const isl::id &id) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::multi_val flat_range_product(isl::multi_val multi2) const;
+  inline isl::multi_val flatten_range() const;
+  inline isl::multi_val from_range() const;
+  static inline isl::multi_val from_val_list(isl::space space, isl::val_list list);
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::space get_domain_space() const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::val get_val(int pos) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  inline isl::multi_val insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::multi_val mod_multi_val(isl::multi_val mv) const;
+  inline isl::multi_val mod_val(isl::val v) const;
+  inline isl::multi_val neg() const;
+  inline isl::boolean plain_is_equal(const isl::multi_val &multi2) const;
+  inline isl::multi_val product(isl::multi_val multi2) const;
+  inline isl::multi_val range_factor_domain() const;
+  inline isl::multi_val range_factor_range() const;
+  inline isl::boolean range_is_wrapping() const;
+  inline isl::multi_val range_product(isl::multi_val multi2) const;
+  inline isl::multi_val range_splice(unsigned int pos, isl::multi_val multi2) const;
+  inline isl::multi_val reset_tuple_id(isl::dim type) const;
+  inline isl::multi_val reset_user() const;
+  inline isl::multi_val scale_down_multi_val(isl::multi_val mv) const;
+  inline isl::multi_val scale_down_val(isl::val v) const;
+  inline isl::multi_val scale_multi_val(isl::multi_val mv) const;
+  inline isl::multi_val scale_val(isl::val v) const;
+  inline isl::multi_val set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::multi_val set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::multi_val set_tuple_name(isl::dim type, const std::string &s) const;
+  inline isl::multi_val set_val(int pos, isl::val el) const;
+  inline isl::multi_val splice(unsigned int in_pos, unsigned int out_pos, isl::multi_val multi2) const;
+  inline isl::multi_val sub(isl::multi_val multi2) const;
+  static inline isl::multi_val zero(isl::space space);
+};
+
+// declarations for isl::point
+inline isl::point manage(__isl_take isl_point *ptr);
+inline isl::point give(__isl_take isl_point *ptr);
+
+
+class point {
+  friend inline isl::point manage(__isl_take isl_point *ptr);
+
+  isl_point *ptr = nullptr;
+
+  inline explicit point(__isl_take isl_point *ptr);
+
+public:
+  inline /* implicit */ point();
+  inline /* implicit */ point(const isl::point &obj);
+  inline /* implicit */ point(std::nullptr_t);
+  inline explicit point(isl::space dim);
+  inline isl::point &operator=(isl::point obj);
+  inline ~point();
+  inline __isl_give isl_point *copy() const &;
+  inline __isl_give isl_point *copy() && = delete;
+  inline __isl_keep isl_point *get() const;
+  inline __isl_give isl_point *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_point *keep() const;
+  inline __isl_give isl_point *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::point add_ui(isl::dim type, int pos, unsigned int val) const;
+  inline isl::val get_coordinate_val(isl::dim type, int pos) const;
+  inline isl::space get_space() const;
+  inline isl::point set_coordinate_val(isl::dim type, int pos, isl::val v) const;
+  inline isl::point sub_ui(isl::dim type, int pos, unsigned int val) const;
+};
+
+// declarations for isl::pw_aff
+inline isl::pw_aff manage(__isl_take isl_pw_aff *ptr);
+inline isl::pw_aff give(__isl_take isl_pw_aff *ptr);
+
+
+class pw_aff {
+  friend inline isl::pw_aff manage(__isl_take isl_pw_aff *ptr);
+
+  isl_pw_aff *ptr = nullptr;
+
+  inline explicit pw_aff(__isl_take isl_pw_aff *ptr);
+
+public:
+  inline /* implicit */ pw_aff();
+  inline /* implicit */ pw_aff(const isl::pw_aff &obj);
+  inline /* implicit */ pw_aff(std::nullptr_t);
+  inline /* implicit */ pw_aff(isl::aff aff);
+  inline explicit pw_aff(isl::local_space ls);
+  inline explicit pw_aff(isl::set domain, isl::val v);
+  inline explicit pw_aff(isl::ctx ctx, const std::string &str);
+  inline isl::pw_aff &operator=(isl::pw_aff obj);
+  inline ~pw_aff();
+  inline __isl_give isl_pw_aff *copy() const &;
+  inline __isl_give isl_pw_aff *copy() && = delete;
+  inline __isl_keep isl_pw_aff *get() const;
+  inline __isl_give isl_pw_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_pw_aff *keep() const;
+  inline __isl_give isl_pw_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::pw_aff add(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff add_dims(isl::dim type, unsigned int n) const;
+  inline isl::pw_aff align_params(isl::space model) const;
+  static inline isl::pw_aff alloc(isl::set set, isl::aff aff);
+  inline isl::pw_aff ceil() const;
+  inline isl::pw_aff coalesce() const;
+  inline isl::pw_aff cond(isl::pw_aff pwaff_true, isl::pw_aff pwaff_false) const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::pw_aff div(isl::pw_aff pa2) const;
+  inline isl::set domain() const;
+  inline isl::pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::pw_aff empty(isl::space dim);
+  inline isl::map eq_map(isl::pw_aff pa2) const;
+  inline isl::set eq_set(isl::pw_aff pwaff2) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::pw_aff floor() const;
+  inline isl::stat foreach_piece(const std::function<isl::stat(isl::set, isl::aff)> &fn) const;
+  inline isl::pw_aff from_range() const;
+  inline isl::set ge_set(isl::pw_aff pwaff2) const;
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::space get_domain_space() const;
+  inline uint32_t get_hash() const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline isl::pw_aff gist(isl::set context) const;
+  inline isl::pw_aff gist_params(isl::set context) const;
+  inline isl::map gt_map(isl::pw_aff pa2) const;
+  inline isl::set gt_set(isl::pw_aff pwaff2) const;
+  inline isl::boolean has_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  inline isl::pw_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::pw_aff intersect_domain(isl::set set) const;
+  inline isl::pw_aff intersect_params(isl::set set) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::boolean is_cst() const;
+  inline isl::boolean is_empty() const;
+  inline isl::boolean is_equal(const isl::pw_aff &pa2) const;
+  inline isl::set le_set(isl::pw_aff pwaff2) const;
+  inline isl::map lt_map(isl::pw_aff pa2) const;
+  inline isl::set lt_set(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff max(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff min(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff mod(isl::val mod) const;
+  inline isl::pw_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  inline isl::pw_aff mul(isl::pw_aff pwaff2) const;
+  static inline isl::pw_aff nan_on_domain(isl::local_space ls);
+  inline isl::set ne_set(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff neg() const;
+  inline isl::set non_zero_set() const;
+  inline isl::set nonneg_set() const;
+  inline isl::set params() const;
+  inline int plain_cmp(const isl::pw_aff &pa2) const;
+  inline isl::boolean plain_is_equal(const isl::pw_aff &pwaff2) const;
+  inline isl::set pos_set() const;
+  inline isl::pw_aff project_domain_on_params() const;
+  inline isl::pw_aff pullback(isl::multi_aff ma) const;
+  inline isl::pw_aff pullback(isl::pw_multi_aff pma) const;
+  inline isl::pw_aff pullback(isl::multi_pw_aff mpa) const;
+  inline isl::pw_aff reset_tuple_id(isl::dim type) const;
+  inline isl::pw_aff reset_user() const;
+  inline isl::pw_aff scale(isl::val v) const;
+  inline isl::pw_aff scale_down(isl::val f) const;
+  inline isl::pw_aff set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::pw_aff set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::pw_aff sub(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff subtract_domain(isl::set set) const;
+  inline isl::pw_aff tdiv_q(isl::pw_aff pa2) const;
+  inline isl::pw_aff tdiv_r(isl::pw_aff pa2) const;
+  inline isl::pw_aff union_add(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff union_max(isl::pw_aff pwaff2) const;
+  inline isl::pw_aff union_min(isl::pw_aff pwaff2) const;
+  static inline isl::pw_aff var_on_domain(isl::local_space ls, isl::dim type, unsigned int pos);
+  inline isl::set zero_set() const;
+};
+
+// declarations for isl::pw_aff_list
+inline isl::pw_aff_list manage(__isl_take isl_pw_aff_list *ptr);
+inline isl::pw_aff_list give(__isl_take isl_pw_aff_list *ptr);
+
+
+class pw_aff_list {
+  friend inline isl::pw_aff_list manage(__isl_take isl_pw_aff_list *ptr);
+
+  isl_pw_aff_list *ptr = nullptr;
+
+  inline explicit pw_aff_list(__isl_take isl_pw_aff_list *ptr);
+
+public:
+  inline /* implicit */ pw_aff_list();
+  inline /* implicit */ pw_aff_list(const isl::pw_aff_list &obj);
+  inline /* implicit */ pw_aff_list(std::nullptr_t);
+  inline isl::pw_aff_list &operator=(isl::pw_aff_list obj);
+  inline ~pw_aff_list();
+  inline __isl_give isl_pw_aff_list *copy() const &;
+  inline __isl_give isl_pw_aff_list *copy() && = delete;
+  inline __isl_keep isl_pw_aff_list *get() const;
+  inline __isl_give isl_pw_aff_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_pw_aff_list *keep() const;
+  inline __isl_give isl_pw_aff_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::pw_multi_aff
+inline isl::pw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr);
+inline isl::pw_multi_aff give(__isl_take isl_pw_multi_aff *ptr);
+
+
+class pw_multi_aff {
+  friend inline isl::pw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr);
+
+  isl_pw_multi_aff *ptr = nullptr;
+
+  inline explicit pw_multi_aff(__isl_take isl_pw_multi_aff *ptr);
+
+public:
+  inline /* implicit */ pw_multi_aff();
+  inline /* implicit */ pw_multi_aff(const isl::pw_multi_aff &obj);
+  inline /* implicit */ pw_multi_aff(std::nullptr_t);
+  inline /* implicit */ pw_multi_aff(isl::multi_aff ma);
+  inline /* implicit */ pw_multi_aff(isl::pw_aff pa);
+  inline explicit pw_multi_aff(isl::ctx ctx, const std::string &str);
+  inline isl::pw_multi_aff &operator=(isl::pw_multi_aff obj);
+  inline ~pw_multi_aff();
+  inline __isl_give isl_pw_multi_aff *copy() const &;
+  inline __isl_give isl_pw_multi_aff *copy() && = delete;
+  inline __isl_keep isl_pw_multi_aff *get() const;
+  inline __isl_give isl_pw_multi_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_pw_multi_aff *keep() const;
+  inline __isl_give isl_pw_multi_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::pw_multi_aff add(isl::pw_multi_aff pma2) const;
+  inline isl::pw_multi_aff align_params(isl::space model) const;
+  static inline isl::pw_multi_aff alloc(isl::set set, isl::multi_aff maff);
+  inline isl::pw_multi_aff coalesce() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::set domain() const;
+  inline isl::pw_multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::pw_multi_aff empty(isl::space space);
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::pw_multi_aff fix_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::pw_multi_aff flat_range_product(isl::pw_multi_aff pma2) const;
+  inline isl::stat foreach_piece(const std::function<isl::stat(isl::set, isl::multi_aff)> &fn) const;
+  static inline isl::pw_multi_aff from_domain(isl::set set);
+  static inline isl::pw_multi_aff from_map(isl::map map);
+  static inline isl::pw_multi_aff from_multi_pw_aff(isl::multi_pw_aff mpa);
+  static inline isl::pw_multi_aff from_set(isl::set set);
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::space get_domain_space() const;
+  inline isl::pw_aff get_pw_aff(int pos) const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::pw_multi_aff gist(isl::set set) const;
+  inline isl::pw_multi_aff gist_params(isl::set set) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  inline isl::boolean has_tuple_name(isl::dim type) const;
+  static inline isl::pw_multi_aff identity(isl::space space);
+  inline isl::pw_multi_aff intersect_domain(isl::set set) const;
+  inline isl::pw_multi_aff intersect_params(isl::set set) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::boolean is_equal(const isl::pw_multi_aff &pma2) const;
+  static inline isl::pw_multi_aff multi_val_on_domain(isl::set domain, isl::multi_val mv);
+  inline isl::pw_multi_aff neg() const;
+  inline isl::boolean plain_is_equal(const isl::pw_multi_aff &pma2) const;
+  inline isl::pw_multi_aff product(isl::pw_multi_aff pma2) const;
+  inline isl::pw_multi_aff project_domain_on_params() const;
+  static inline isl::pw_multi_aff project_out_map(isl::space space, isl::dim type, unsigned int first, unsigned int n);
+  inline isl::pw_multi_aff pullback(isl::multi_aff ma) const;
+  inline isl::pw_multi_aff pullback(isl::pw_multi_aff pma2) const;
+  static inline isl::pw_multi_aff range_map(isl::space space);
+  inline isl::pw_multi_aff range_product(isl::pw_multi_aff pma2) const;
+  inline isl::pw_multi_aff reset_tuple_id(isl::dim type) const;
+  inline isl::pw_multi_aff reset_user() const;
+  inline isl::pw_multi_aff scale_down_val(isl::val v) const;
+  inline isl::pw_multi_aff scale_multi_val(isl::multi_val mv) const;
+  inline isl::pw_multi_aff scale_val(isl::val v) const;
+  inline isl::pw_multi_aff set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::pw_multi_aff set_pw_aff(unsigned int pos, isl::pw_aff pa) const;
+  inline isl::pw_multi_aff set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::pw_multi_aff sub(isl::pw_multi_aff pma2) const;
+  inline isl::pw_multi_aff subtract_domain(isl::set set) const;
+  inline isl::pw_multi_aff union_add(isl::pw_multi_aff pma2) const;
+  inline isl::pw_multi_aff union_lexmax(isl::pw_multi_aff pma2) const;
+  inline isl::pw_multi_aff union_lexmin(isl::pw_multi_aff pma2) const;
+  static inline isl::pw_multi_aff zero(isl::space space);
+};
+
+// declarations for isl::pw_qpolynomial
+inline isl::pw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr);
+inline isl::pw_qpolynomial give(__isl_take isl_pw_qpolynomial *ptr);
+
+
+class pw_qpolynomial {
+  friend inline isl::pw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr);
+
+  isl_pw_qpolynomial *ptr = nullptr;
+
+  inline explicit pw_qpolynomial(__isl_take isl_pw_qpolynomial *ptr);
+
+public:
+  inline /* implicit */ pw_qpolynomial();
+  inline /* implicit */ pw_qpolynomial(const isl::pw_qpolynomial &obj);
+  inline /* implicit */ pw_qpolynomial(std::nullptr_t);
+  inline explicit pw_qpolynomial(isl::ctx ctx, const std::string &str);
+  inline isl::pw_qpolynomial &operator=(isl::pw_qpolynomial obj);
+  inline ~pw_qpolynomial();
+  inline __isl_give isl_pw_qpolynomial *copy() const &;
+  inline __isl_give isl_pw_qpolynomial *copy() && = delete;
+  inline __isl_keep isl_pw_qpolynomial *get() const;
+  inline __isl_give isl_pw_qpolynomial *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_pw_qpolynomial *keep() const;
+  inline __isl_give isl_pw_qpolynomial *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::pw_qpolynomial add(isl::pw_qpolynomial pwqp2) const;
+  inline isl::pw_qpolynomial add_dims(isl::dim type, unsigned int n) const;
+  static inline isl::pw_qpolynomial alloc(isl::set set, isl::qpolynomial qp);
+  inline isl::pw_qpolynomial coalesce() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::set domain() const;
+  inline isl::pw_qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::val eval(isl::point pnt) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::pw_qpolynomial fix_val(isl::dim type, unsigned int n, isl::val v) const;
+  inline isl::stat foreach_piece(const std::function<isl::stat(isl::set, isl::qpolynomial)> &fn) const;
+  static inline isl::pw_qpolynomial from_pw_aff(isl::pw_aff pwaff);
+  static inline isl::pw_qpolynomial from_qpolynomial(isl::qpolynomial qp);
+  inline isl::pw_qpolynomial from_range() const;
+  inline isl::space get_domain_space() const;
+  inline isl::space get_space() const;
+  inline isl::pw_qpolynomial gist(isl::set context) const;
+  inline isl::pw_qpolynomial gist_params(isl::set context) const;
+  inline isl::boolean has_equal_space(const isl::pw_qpolynomial &pwqp2) const;
+  inline isl::pw_qpolynomial insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::pw_qpolynomial intersect_domain(isl::set set) const;
+  inline isl::pw_qpolynomial intersect_params(isl::set set) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::boolean is_zero() const;
+  inline isl::val max() const;
+  inline isl::val min() const;
+  inline isl::pw_qpolynomial move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  inline isl::pw_qpolynomial mul(isl::pw_qpolynomial pwqp2) const;
+  inline isl::pw_qpolynomial neg() const;
+  inline isl::boolean plain_is_equal(const isl::pw_qpolynomial &pwqp2) const;
+  inline isl::pw_qpolynomial pow(unsigned int exponent) const;
+  inline isl::pw_qpolynomial project_domain_on_params() const;
+  inline isl::pw_qpolynomial reset_domain_space(isl::space dim) const;
+  inline isl::pw_qpolynomial reset_user() const;
+  inline isl::pw_qpolynomial scale_down_val(isl::val v) const;
+  inline isl::pw_qpolynomial scale_val(isl::val v) const;
+  inline isl::pw_qpolynomial split_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::pw_qpolynomial split_periods(int max_periods) const;
+  inline isl::pw_qpolynomial sub(isl::pw_qpolynomial pwqp2) const;
+  inline isl::pw_qpolynomial subtract_domain(isl::set set) const;
+  inline isl::pw_qpolynomial to_polynomial(int sign) const;
+  static inline isl::pw_qpolynomial zero(isl::space dim);
+};
+
+// declarations for isl::qpolynomial
+inline isl::qpolynomial manage(__isl_take isl_qpolynomial *ptr);
+inline isl::qpolynomial give(__isl_take isl_qpolynomial *ptr);
+
+
+class qpolynomial {
+  friend inline isl::qpolynomial manage(__isl_take isl_qpolynomial *ptr);
+
+  isl_qpolynomial *ptr = nullptr;
+
+  inline explicit qpolynomial(__isl_take isl_qpolynomial *ptr);
+
+public:
+  inline /* implicit */ qpolynomial();
+  inline /* implicit */ qpolynomial(const isl::qpolynomial &obj);
+  inline /* implicit */ qpolynomial(std::nullptr_t);
+  inline isl::qpolynomial &operator=(isl::qpolynomial obj);
+  inline ~qpolynomial();
+  inline __isl_give isl_qpolynomial *copy() const &;
+  inline __isl_give isl_qpolynomial *copy() && = delete;
+  inline __isl_keep isl_qpolynomial *get() const;
+  inline __isl_give isl_qpolynomial *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_qpolynomial *keep() const;
+  inline __isl_give isl_qpolynomial *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+  inline isl::qpolynomial add(isl::qpolynomial qp2) const;
+  inline isl::qpolynomial add_dims(isl::dim type, unsigned int n) const;
+  inline isl::qpolynomial align_params(isl::space model) const;
+  inline isl::stat as_polynomial_on_domain(const isl::basic_set &bset, const std::function<isl::stat(isl::basic_set, isl::qpolynomial)> &fn) const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::val eval(isl::point pnt) const;
+  inline isl::stat foreach_term(const std::function<isl::stat(isl::term)> &fn) const;
+  static inline isl::qpolynomial from_aff(isl::aff aff);
+  static inline isl::qpolynomial from_constraint(isl::constraint c, isl::dim type, unsigned int pos);
+  static inline isl::qpolynomial from_term(isl::term term);
+  inline isl::val get_constant_val() const;
+  inline isl::space get_domain_space() const;
+  inline isl::space get_space() const;
+  inline isl::qpolynomial gist(isl::set context) const;
+  inline isl::qpolynomial gist_params(isl::set context) const;
+  inline isl::qpolynomial homogenize() const;
+  static inline isl::qpolynomial infty_on_domain(isl::space dim);
+  inline isl::qpolynomial insert_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean is_infty() const;
+  inline isl::boolean is_nan() const;
+  inline isl::boolean is_neginfty() const;
+  inline isl::boolean is_zero() const;
+  inline isl::qpolynomial move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  inline isl::qpolynomial mul(isl::qpolynomial qp2) const;
+  static inline isl::qpolynomial nan_on_domain(isl::space dim);
+  inline isl::qpolynomial neg() const;
+  static inline isl::qpolynomial neginfty_on_domain(isl::space dim);
+  static inline isl::qpolynomial one_on_domain(isl::space dim);
+  inline isl::boolean plain_is_equal(const isl::qpolynomial &qp2) const;
+  inline isl::qpolynomial pow(unsigned int power) const;
+  inline isl::qpolynomial project_domain_on_params() const;
+  inline isl::qpolynomial scale_down_val(isl::val v) const;
+  inline isl::qpolynomial scale_val(isl::val v) const;
+  inline int sgn() const;
+  inline isl::qpolynomial sub(isl::qpolynomial qp2) const;
+  static inline isl::qpolynomial val_on_domain(isl::space space, isl::val val);
+  static inline isl::qpolynomial var_on_domain(isl::space dim, isl::dim type, unsigned int pos);
+  static inline isl::qpolynomial zero_on_domain(isl::space dim);
+};
+
+// declarations for isl::schedule
+inline isl::schedule manage(__isl_take isl_schedule *ptr);
+inline isl::schedule give(__isl_take isl_schedule *ptr);
+
+
+class schedule {
+  friend inline isl::schedule manage(__isl_take isl_schedule *ptr);
+
+  isl_schedule *ptr = nullptr;
+
+  inline explicit schedule(__isl_take isl_schedule *ptr);
+
+public:
+  inline /* implicit */ schedule();
+  inline /* implicit */ schedule(const isl::schedule &obj);
+  inline /* implicit */ schedule(std::nullptr_t);
+  inline explicit schedule(isl::ctx ctx, const std::string &str);
+  inline isl::schedule &operator=(isl::schedule obj);
+  inline ~schedule();
+  inline __isl_give isl_schedule *copy() const &;
+  inline __isl_give isl_schedule *copy() && = delete;
+  inline __isl_keep isl_schedule *get() const;
+  inline __isl_give isl_schedule *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_schedule *keep() const;
+  inline __isl_give isl_schedule *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::schedule align_params(isl::space space) const;
+  static inline isl::schedule empty(isl::space space);
+  static inline isl::schedule from_domain(isl::union_set domain);
+  inline isl::union_set get_domain() const;
+  inline isl::union_map get_map() const;
+  inline isl::schedule_node get_root() const;
+  inline isl::schedule gist_domain_params(isl::set context) const;
+  inline isl::schedule insert_context(isl::set context) const;
+  inline isl::schedule insert_guard(isl::set guard) const;
+  inline isl::schedule insert_partial_schedule(isl::multi_union_pw_aff partial) const;
+  inline isl::schedule intersect_domain(isl::union_set domain) const;
+  inline isl::boolean plain_is_equal(const isl::schedule &schedule2) const;
+  inline isl::schedule pullback(isl::union_pw_multi_aff upma) const;
+  inline isl::schedule reset_user() const;
+  inline isl::schedule sequence(isl::schedule schedule2) const;
+  inline isl::schedule set(isl::schedule schedule2) const;
+};
+
+// declarations for isl::schedule_constraints
+inline isl::schedule_constraints manage(__isl_take isl_schedule_constraints *ptr);
+inline isl::schedule_constraints give(__isl_take isl_schedule_constraints *ptr);
+
+
+class schedule_constraints {
+  friend inline isl::schedule_constraints manage(__isl_take isl_schedule_constraints *ptr);
+
+  isl_schedule_constraints *ptr = nullptr;
+
+  inline explicit schedule_constraints(__isl_take isl_schedule_constraints *ptr);
+
+public:
+  inline /* implicit */ schedule_constraints();
+  inline /* implicit */ schedule_constraints(const isl::schedule_constraints &obj);
+  inline /* implicit */ schedule_constraints(std::nullptr_t);
+  inline explicit schedule_constraints(isl::ctx ctx, const std::string &str);
+  inline isl::schedule_constraints &operator=(isl::schedule_constraints obj);
+  inline ~schedule_constraints();
+  inline __isl_give isl_schedule_constraints *copy() const &;
+  inline __isl_give isl_schedule_constraints *copy() && = delete;
+  inline __isl_keep isl_schedule_constraints *get() const;
+  inline __isl_give isl_schedule_constraints *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_schedule_constraints *keep() const;
+  inline __isl_give isl_schedule_constraints *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::schedule_constraints apply(isl::union_map umap) const;
+  inline isl::schedule compute_schedule() const;
+  inline isl::union_map get_coincidence() const;
+  inline isl::union_map get_conditional_validity() const;
+  inline isl::union_map get_conditional_validity_condition() const;
+  inline isl::set get_context() const;
+  inline isl::union_set get_domain() const;
+  inline isl::union_map get_proximity() const;
+  inline isl::union_map get_validity() const;
+  static inline isl::schedule_constraints on_domain(isl::union_set domain);
+  inline isl::schedule_constraints set_coincidence(isl::union_map coincidence) const;
+  inline isl::schedule_constraints set_conditional_validity(isl::union_map condition, isl::union_map validity) const;
+  inline isl::schedule_constraints set_context(isl::set context) const;
+  inline isl::schedule_constraints set_proximity(isl::union_map proximity) const;
+  inline isl::schedule_constraints set_validity(isl::union_map validity) const;
+};
+
+// declarations for isl::schedule_node
+inline isl::schedule_node manage(__isl_take isl_schedule_node *ptr);
+inline isl::schedule_node give(__isl_take isl_schedule_node *ptr);
+
+
+class schedule_node {
+  friend inline isl::schedule_node manage(__isl_take isl_schedule_node *ptr);
+
+  isl_schedule_node *ptr = nullptr;
+
+  inline explicit schedule_node(__isl_take isl_schedule_node *ptr);
+
+public:
+  inline /* implicit */ schedule_node();
+  inline /* implicit */ schedule_node(const isl::schedule_node &obj);
+  inline /* implicit */ schedule_node(std::nullptr_t);
+  inline isl::schedule_node &operator=(isl::schedule_node obj);
+  inline ~schedule_node();
+  inline __isl_give isl_schedule_node *copy() const &;
+  inline __isl_give isl_schedule_node *copy() && = delete;
+  inline __isl_keep isl_schedule_node *get() const;
+  inline __isl_give isl_schedule_node *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_schedule_node *keep() const;
+  inline __isl_give isl_schedule_node *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::schedule_node align_params(isl::space space) const;
+  inline isl::schedule_node ancestor(int generation) const;
+  inline isl::boolean band_member_get_coincident(int pos) const;
+  inline isl::schedule_node band_member_set_coincident(int pos, int coincident) const;
+  inline isl::schedule_node band_set_ast_build_options(isl::union_set options) const;
+  inline isl::schedule_node child(int pos) const;
+  inline isl::set context_get_context() const;
+  inline isl::schedule_node cut() const;
+  inline isl::union_set domain_get_domain() const;
+  inline isl::union_pw_multi_aff expansion_get_contraction() const;
+  inline isl::union_map expansion_get_expansion() const;
+  inline isl::union_map extension_get_extension() const;
+  inline isl::union_set filter_get_filter() const;
+  inline isl::schedule_node first_child() const;
+  inline isl::stat foreach_ancestor_top_down(const std::function<isl::stat(isl::schedule_node)> &fn) const;
+  static inline isl::schedule_node from_domain(isl::union_set domain);
+  static inline isl::schedule_node from_extension(isl::union_map extension);
+  inline int get_ancestor_child_position(const isl::schedule_node &ancestor) const;
+  inline isl::schedule_node get_child(int pos) const;
+  inline int get_child_position() const;
+  inline isl::union_set get_domain() const;
+  inline isl::multi_union_pw_aff get_prefix_schedule_multi_union_pw_aff() const;
+  inline isl::union_map get_prefix_schedule_relation() const;
+  inline isl::union_map get_prefix_schedule_union_map() const;
+  inline isl::union_pw_multi_aff get_prefix_schedule_union_pw_multi_aff() const;
+  inline isl::schedule get_schedule() const;
+  inline int get_schedule_depth() const;
+  inline isl::schedule_node get_shared_ancestor(const isl::schedule_node &node2) const;
+  inline isl::union_pw_multi_aff get_subtree_contraction() const;
+  inline isl::union_map get_subtree_expansion() const;
+  inline isl::union_map get_subtree_schedule_union_map() const;
+  inline int get_tree_depth() const;
+  inline isl::union_set get_universe_domain() const;
+  inline isl::schedule_node graft_after(isl::schedule_node graft) const;
+  inline isl::schedule_node graft_before(isl::schedule_node graft) const;
+  inline isl::schedule_node group(isl::id group_id) const;
+  inline isl::set guard_get_guard() const;
+  inline isl::boolean has_children() const;
+  inline isl::boolean has_next_sibling() const;
+  inline isl::boolean has_parent() const;
+  inline isl::boolean has_previous_sibling() const;
+  inline isl::schedule_node insert_context(isl::set context) const;
+  inline isl::schedule_node insert_filter(isl::union_set filter) const;
+  inline isl::schedule_node insert_guard(isl::set context) const;
+  inline isl::schedule_node insert_mark(isl::id mark) const;
+  inline isl::schedule_node insert_partial_schedule(isl::multi_union_pw_aff schedule) const;
+  inline isl::schedule_node insert_sequence(isl::union_set_list filters) const;
+  inline isl::schedule_node insert_set(isl::union_set_list filters) const;
+  inline isl::boolean is_equal(const isl::schedule_node &node2) const;
+  inline isl::boolean is_subtree_anchored() const;
+  inline isl::id mark_get_id() const;
+  inline isl::schedule_node next_sibling() const;
+  inline isl::schedule_node order_after(isl::union_set filter) const;
+  inline isl::schedule_node order_before(isl::union_set filter) const;
+  inline isl::schedule_node parent() const;
+  inline isl::schedule_node previous_sibling() const;
+  inline isl::schedule_node reset_user() const;
+  inline isl::schedule_node root() const;
+  inline isl::schedule_node sequence_splice_child(int pos) const;
+};
+
+// declarations for isl::set
+inline isl::set manage(__isl_take isl_set *ptr);
+inline isl::set give(__isl_take isl_set *ptr);
+
+
+class set {
+  friend inline isl::set manage(__isl_take isl_set *ptr);
+
+  isl_set *ptr = nullptr;
+
+  inline explicit set(__isl_take isl_set *ptr);
+
+public:
+  inline /* implicit */ set();
+  inline /* implicit */ set(const isl::set &obj);
+  inline /* implicit */ set(std::nullptr_t);
+  inline explicit set(isl::union_set uset);
+  inline explicit set(isl::ctx ctx, const std::string &str);
+  inline /* implicit */ set(isl::basic_set bset);
+  inline /* implicit */ set(isl::point pnt);
+  inline isl::set &operator=(isl::set obj);
+  inline ~set();
+  inline __isl_give isl_set *copy() const &;
+  inline __isl_give isl_set *copy() && = delete;
+  inline __isl_keep isl_set *get() const;
+  inline __isl_give isl_set *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_set *keep() const;
+  inline __isl_give isl_set *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::set add_constraint(isl::constraint constraint) const;
+  inline isl::set add_dims(isl::dim type, unsigned int n) const;
+  inline isl::basic_set affine_hull() const;
+  inline isl::set align_params(isl::space model) const;
+  inline isl::set apply(isl::map map) const;
+  inline isl::basic_set bounded_simple_hull() const;
+  static inline isl::set box_from_points(isl::point pnt1, isl::point pnt2);
+  inline isl::set coalesce() const;
+  inline isl::basic_set coefficients() const;
+  inline isl::set complement() const;
+  inline isl::basic_set convex_hull() const;
+  inline isl::val count_val() const;
+  inline isl::set detect_equalities() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::boolean dim_has_any_lower_bound(isl::dim type, unsigned int pos) const;
+  inline isl::boolean dim_has_any_upper_bound(isl::dim type, unsigned int pos) const;
+  inline isl::boolean dim_has_lower_bound(isl::dim type, unsigned int pos) const;
+  inline isl::boolean dim_has_upper_bound(isl::dim type, unsigned int pos) const;
+  inline isl::boolean dim_is_bounded(isl::dim type, unsigned int pos) const;
+  inline isl::pw_aff dim_max(int pos) const;
+  inline isl::pw_aff dim_min(int pos) const;
+  inline isl::set drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set eliminate(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::set empty(isl::space dim);
+  inline isl::set equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;
+  inline int find_dim_by_id(isl::dim type, const isl::id &id) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::set fix_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::set fix_val(isl::dim type, unsigned int pos, isl::val v) const;
+  inline isl::set flat_product(isl::set set2) const;
+  inline isl::set flatten() const;
+  inline isl::map flatten_map() const;
+  inline int follows_at(const isl::set &set2, int pos) const;
+  inline isl::stat foreach_basic_set(const std::function<isl::stat(isl::basic_set)> &fn) const;
+  inline isl::stat foreach_point(const std::function<isl::stat(isl::point)> &fn) const;
+  static inline isl::set from_multi_pw_aff(isl::multi_pw_aff mpa);
+  inline isl::set from_params() const;
+  static inline isl::set from_pw_aff(isl::pw_aff pwaff);
+  static inline isl::set from_pw_multi_aff(isl::pw_multi_aff pma);
+  inline isl::basic_set_list get_basic_set_list() const;
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::space get_space() const;
+  inline isl::id get_tuple_id() const;
+  inline std::string get_tuple_name() const;
+  inline isl::set gist(isl::set context) const;
+  inline isl::set gist_basic_set(isl::basic_set context) const;
+  inline isl::set gist_params(isl::set context) const;
+  inline isl::boolean has_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_equal_space(const isl::set &set2) const;
+  inline isl::boolean has_tuple_id() const;
+  inline isl::boolean has_tuple_name() const;
+  inline isl::map identity() const;
+  inline isl::pw_aff indicator_function() const;
+  inline isl::set insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;
+  inline isl::set intersect(isl::set set2) const;
+  inline isl::set intersect_params(isl::set params) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean is_bounded() const;
+  inline isl::boolean is_box() const;
+  inline isl::boolean is_disjoint(const isl::set &set2) const;
+  inline isl::boolean is_empty() const;
+  inline isl::boolean is_equal(const isl::set &set2) const;
+  inline isl::boolean is_params() const;
+  inline isl::boolean is_singleton() const;
+  inline isl::boolean is_strict_subset(const isl::set &set2) const;
+  inline isl::boolean is_subset(const isl::set &set2) const;
+  inline isl::boolean is_wrapping() const;
+  inline isl::map lex_ge_set(isl::set set2) const;
+  inline isl::map lex_gt_set(isl::set set2) const;
+  inline isl::map lex_le_set(isl::set set2) const;
+  inline isl::map lex_lt_set(isl::set set2) const;
+  inline isl::set lexmax() const;
+  inline isl::pw_multi_aff lexmax_pw_multi_aff() const;
+  inline isl::set lexmin() const;
+  inline isl::pw_multi_aff lexmin_pw_multi_aff() const;
+  inline isl::set lower_bound_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::set lower_bound_val(isl::dim type, unsigned int pos, isl::val value) const;
+  inline isl::val max_val(const isl::aff &obj) const;
+  inline isl::val min_val(const isl::aff &obj) const;
+  inline isl::set move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  static inline isl::set nat_universe(isl::space dim);
+  inline isl::set neg() const;
+  inline isl::set params() const;
+  inline int plain_cmp(const isl::set &set2) const;
+  inline isl::val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;
+  inline isl::boolean plain_is_disjoint(const isl::set &set2) const;
+  inline isl::boolean plain_is_empty() const;
+  inline isl::boolean plain_is_equal(const isl::set &set2) const;
+  inline isl::boolean plain_is_universe() const;
+  inline isl::basic_set plain_unshifted_simple_hull() const;
+  inline isl::basic_set polyhedral_hull() const;
+  inline isl::set preimage_multi_aff(isl::multi_aff ma) const;
+  inline isl::set preimage_multi_pw_aff(isl::multi_pw_aff mpa) const;
+  inline isl::set preimage_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::set product(isl::set set2) const;
+  inline isl::map project_onto_map(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set project_out(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set remove_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set remove_divs() const;
+  inline isl::set remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set remove_redundancies() const;
+  inline isl::set remove_unknown_divs() const;
+  inline isl::set reset_space(isl::space dim) const;
+  inline isl::set reset_tuple_id() const;
+  inline isl::set reset_user() const;
+  inline isl::basic_set sample() const;
+  inline isl::point sample_point() const;
+  inline isl::set set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::set set_tuple_id(isl::id id) const;
+  inline isl::set set_tuple_name(const std::string &s) const;
+  inline isl::basic_set simple_hull() const;
+  inline int size() const;
+  inline isl::basic_set solutions() const;
+  inline isl::set split_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::set subtract(isl::set set2) const;
+  inline isl::set sum(isl::set set2) const;
+  inline isl::set unite(isl::set set2) const;
+  static inline isl::set universe(isl::space dim);
+  inline isl::basic_set unshifted_simple_hull() const;
+  inline isl::basic_set unshifted_simple_hull_from_set_list(isl::set_list list) const;
+  inline isl::map unwrap() const;
+  inline isl::set upper_bound_si(isl::dim type, unsigned int pos, int value) const;
+  inline isl::set upper_bound_val(isl::dim type, unsigned int pos, isl::val value) const;
+  inline isl::map wrapped_domain_map() const;
+};
+
+// declarations for isl::set_list
+inline isl::set_list manage(__isl_take isl_set_list *ptr);
+inline isl::set_list give(__isl_take isl_set_list *ptr);
+
+
+class set_list {
+  friend inline isl::set_list manage(__isl_take isl_set_list *ptr);
+
+  isl_set_list *ptr = nullptr;
+
+  inline explicit set_list(__isl_take isl_set_list *ptr);
+
+public:
+  inline /* implicit */ set_list();
+  inline /* implicit */ set_list(const isl::set_list &obj);
+  inline /* implicit */ set_list(std::nullptr_t);
+  inline isl::set_list &operator=(isl::set_list obj);
+  inline ~set_list();
+  inline __isl_give isl_set_list *copy() const &;
+  inline __isl_give isl_set_list *copy() && = delete;
+  inline __isl_keep isl_set_list *get() const;
+  inline __isl_give isl_set_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_set_list *keep() const;
+  inline __isl_give isl_set_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::space
+inline isl::space manage(__isl_take isl_space *ptr);
+inline isl::space give(__isl_take isl_space *ptr);
+
+
+class space {
+  friend inline isl::space manage(__isl_take isl_space *ptr);
+
+  isl_space *ptr = nullptr;
+
+  inline explicit space(__isl_take isl_space *ptr);
+
+public:
+  inline /* implicit */ space();
+  inline /* implicit */ space(const isl::space &obj);
+  inline /* implicit */ space(std::nullptr_t);
+  inline explicit space(isl::ctx ctx, unsigned int nparam, unsigned int n_in, unsigned int n_out);
+  inline explicit space(isl::ctx ctx, unsigned int nparam, unsigned int dim);
+  inline isl::space &operator=(isl::space obj);
+  inline ~space();
+  inline __isl_give isl_space *copy() const &;
+  inline __isl_give isl_space *copy() && = delete;
+  inline __isl_keep isl_space *get() const;
+  inline __isl_give isl_space *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_space *keep() const;
+  inline __isl_give isl_space *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::space add_dims(isl::dim type, unsigned int n) const;
+  inline isl::space align_params(isl::space dim2) const;
+  inline isl::boolean can_curry() const;
+  inline isl::boolean can_range_curry() const;
+  inline isl::boolean can_uncurry() const;
+  inline isl::boolean can_zip() const;
+  inline isl::space curry() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::space domain() const;
+  inline isl::space domain_factor_domain() const;
+  inline isl::space domain_factor_range() const;
+  inline isl::boolean domain_is_wrapping() const;
+  inline isl::space domain_map() const;
+  inline isl::space domain_product(isl::space right) const;
+  inline isl::space drop_dims(isl::dim type, unsigned int first, unsigned int num) const;
+  inline isl::space factor_domain() const;
+  inline isl::space factor_range() const;
+  inline int find_dim_by_id(isl::dim type, const isl::id &id) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::space from_domain() const;
+  inline isl::space from_range() const;
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::id get_tuple_id(isl::dim type) const;
+  inline std::string get_tuple_name(isl::dim type) const;
+  inline isl::boolean has_dim_id(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_dim_name(isl::dim type, unsigned int pos) const;
+  inline isl::boolean has_equal_params(const isl::space &space2) const;
+  inline isl::boolean has_equal_tuples(const isl::space &space2) const;
+  inline isl::boolean has_tuple_id(isl::dim type) const;
+  inline isl::boolean has_tuple_name(isl::dim type) const;
+  inline isl::space insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;
+  inline isl::boolean is_domain(const isl::space &space2) const;
+  inline isl::boolean is_equal(const isl::space &space2) const;
+  inline isl::boolean is_map() const;
+  inline isl::boolean is_params() const;
+  inline isl::boolean is_product() const;
+  inline isl::boolean is_range(const isl::space &space2) const;
+  inline isl::boolean is_set() const;
+  inline isl::boolean is_wrapping() const;
+  inline isl::space join(isl::space right) const;
+  inline isl::space map_from_domain_and_range(isl::space range) const;
+  inline isl::space map_from_set() const;
+  inline isl::space move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;
+  inline isl::space params() const;
+  static inline isl::space params_alloc(isl::ctx ctx, unsigned int nparam);
+  inline isl::space product(isl::space right) const;
+  inline isl::space range() const;
+  inline isl::space range_curry() const;
+  inline isl::space range_factor_domain() const;
+  inline isl::space range_factor_range() const;
+  inline isl::boolean range_is_wrapping() const;
+  inline isl::space range_map() const;
+  inline isl::space range_product(isl::space right) const;
+  inline isl::space reset_tuple_id(isl::dim type) const;
+  inline isl::space reset_user() const;
+  inline isl::space reverse() const;
+  inline isl::space set_dim_id(isl::dim type, unsigned int pos, isl::id id) const;
+  inline isl::space set_from_params() const;
+  inline isl::space set_tuple_id(isl::dim type, isl::id id) const;
+  inline isl::space set_tuple_name(isl::dim type, const std::string &s) const;
+  inline isl::boolean tuple_is_equal(isl::dim type1, const isl::space &space2, isl::dim type2) const;
+  inline isl::space uncurry() const;
+  inline isl::space unwrap() const;
+  inline isl::space wrap() const;
+  inline isl::space zip() const;
+};
+
+// declarations for isl::term
+inline isl::term manage(__isl_take isl_term *ptr);
+inline isl::term give(__isl_take isl_term *ptr);
+
+
+class term {
+  friend inline isl::term manage(__isl_take isl_term *ptr);
+
+  isl_term *ptr = nullptr;
+
+  inline explicit term(__isl_take isl_term *ptr);
+
+public:
+  inline /* implicit */ term();
+  inline /* implicit */ term(const isl::term &obj);
+  inline /* implicit */ term(std::nullptr_t);
+  inline isl::term &operator=(isl::term obj);
+  inline ~term();
+  inline __isl_give isl_term *copy() const &;
+  inline __isl_give isl_term *copy() && = delete;
+  inline __isl_keep isl_term *get() const;
+  inline __isl_give isl_term *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_term *keep() const;
+  inline __isl_give isl_term *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::val get_coefficient_val() const;
+  inline isl::aff get_div(unsigned int pos) const;
+  inline int get_exp(isl::dim type, unsigned int pos) const;
+};
+
+// declarations for isl::union_access_info
+inline isl::union_access_info manage(__isl_take isl_union_access_info *ptr);
+inline isl::union_access_info give(__isl_take isl_union_access_info *ptr);
+
+
+class union_access_info {
+  friend inline isl::union_access_info manage(__isl_take isl_union_access_info *ptr);
+
+  isl_union_access_info *ptr = nullptr;
+
+  inline explicit union_access_info(__isl_take isl_union_access_info *ptr);
+
+public:
+  inline /* implicit */ union_access_info();
+  inline /* implicit */ union_access_info(const isl::union_access_info &obj);
+  inline /* implicit */ union_access_info(std::nullptr_t);
+  inline explicit union_access_info(isl::union_map sink);
+  inline isl::union_access_info &operator=(isl::union_access_info obj);
+  inline ~union_access_info();
+  inline __isl_give isl_union_access_info *copy() const &;
+  inline __isl_give isl_union_access_info *copy() && = delete;
+  inline __isl_keep isl_union_access_info *get() const;
+  inline __isl_give isl_union_access_info *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_access_info *keep() const;
+  inline __isl_give isl_union_access_info *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+
+  inline isl::union_flow compute_flow() const;
+  inline isl::union_access_info set_kill(isl::union_map kill) const;
+  inline isl::union_access_info set_may_source(isl::union_map may_source) const;
+  inline isl::union_access_info set_must_source(isl::union_map must_source) const;
+  inline isl::union_access_info set_schedule(isl::schedule schedule) const;
+  inline isl::union_access_info set_schedule_map(isl::union_map schedule_map) const;
+};
+
+// declarations for isl::union_flow
+inline isl::union_flow manage(__isl_take isl_union_flow *ptr);
+inline isl::union_flow give(__isl_take isl_union_flow *ptr);
+
+
+class union_flow {
+  friend inline isl::union_flow manage(__isl_take isl_union_flow *ptr);
+
+  isl_union_flow *ptr = nullptr;
+
+  inline explicit union_flow(__isl_take isl_union_flow *ptr);
+
+public:
+  inline /* implicit */ union_flow();
+  inline /* implicit */ union_flow(const isl::union_flow &obj);
+  inline /* implicit */ union_flow(std::nullptr_t);
+  inline isl::union_flow &operator=(isl::union_flow obj);
+  inline ~union_flow();
+  inline __isl_give isl_union_flow *copy() const &;
+  inline __isl_give isl_union_flow *copy() && = delete;
+  inline __isl_keep isl_union_flow *get() const;
+  inline __isl_give isl_union_flow *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_flow *keep() const;
+  inline __isl_give isl_union_flow *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+
+  inline isl::union_map get_full_may_dependence() const;
+  inline isl::union_map get_full_must_dependence() const;
+  inline isl::union_map get_may_dependence() const;
+  inline isl::union_map get_may_no_source() const;
+  inline isl::union_map get_must_dependence() const;
+  inline isl::union_map get_must_no_source() const;
+};
+
+// declarations for isl::union_map
+inline isl::union_map manage(__isl_take isl_union_map *ptr);
+inline isl::union_map give(__isl_take isl_union_map *ptr);
+
+
+class union_map {
+  friend inline isl::union_map manage(__isl_take isl_union_map *ptr);
+
+  isl_union_map *ptr = nullptr;
+
+  inline explicit union_map(__isl_take isl_union_map *ptr);
+
+public:
+  inline /* implicit */ union_map();
+  inline /* implicit */ union_map(const isl::union_map &obj);
+  inline /* implicit */ union_map(std::nullptr_t);
+  inline explicit union_map(isl::union_pw_aff upa);
+  inline /* implicit */ union_map(isl::basic_map bmap);
+  inline /* implicit */ union_map(isl::map map);
+  inline explicit union_map(isl::ctx ctx, const std::string &str);
+  inline isl::union_map &operator=(isl::union_map obj);
+  inline ~union_map();
+  inline __isl_give isl_union_map *copy() const &;
+  inline __isl_give isl_union_map *copy() && = delete;
+  inline __isl_keep isl_union_map *get() const;
+  inline __isl_give isl_union_map *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_map *keep() const;
+  inline __isl_give isl_union_map *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::union_map add_map(isl::map map) const;
+  inline isl::union_map affine_hull() const;
+  inline isl::union_map align_params(isl::space model) const;
+  inline isl::union_map apply_domain(isl::union_map umap2) const;
+  inline isl::union_map apply_range(isl::union_map umap2) const;
+  inline isl::union_map coalesce() const;
+  inline isl::boolean contains(const isl::space &space) const;
+  inline isl::union_map curry() const;
+  inline isl::union_set deltas() const;
+  inline isl::union_map deltas_map() const;
+  inline isl::union_map detect_equalities() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::union_set domain() const;
+  inline isl::union_map domain_factor_domain() const;
+  inline isl::union_map domain_factor_range() const;
+  inline isl::union_map domain_map() const;
+  inline isl::union_pw_multi_aff domain_map_union_pw_multi_aff() const;
+  inline isl::union_map domain_product(isl::union_map umap2) const;
+  static inline isl::union_map empty(isl::space dim);
+  inline isl::union_map eq_at_multi_union_pw_aff(isl::multi_union_pw_aff mupa) const;
+  inline isl::map extract_map(isl::space dim) const;
+  inline isl::union_map factor_domain() const;
+  inline isl::union_map factor_range() const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::union_map fixed_power(isl::val exp) const;
+  inline isl::union_map flat_domain_product(isl::union_map umap2) const;
+  inline isl::union_map flat_range_product(isl::union_map umap2) const;
+  inline isl::stat foreach_map(const std::function<isl::stat(isl::map)> &fn) const;
+  static inline isl::union_map from(isl::union_pw_multi_aff upma);
+  static inline isl::union_map from(isl::multi_union_pw_aff mupa);
+  static inline isl::union_map from_domain(isl::union_set uset);
+  static inline isl::union_map from_domain_and_range(isl::union_set domain, isl::union_set range);
+  static inline isl::union_map from_range(isl::union_set uset);
+  inline isl::id get_dim_id(isl::dim type, unsigned int pos) const;
+  inline uint32_t get_hash() const;
+  inline isl::space get_space() const;
+  inline isl::union_map gist(isl::union_map context) const;
+  inline isl::union_map gist_domain(isl::union_set uset) const;
+  inline isl::union_map gist_params(isl::set set) const;
+  inline isl::union_map gist_range(isl::union_set uset) const;
+  inline isl::union_map intersect(isl::union_map umap2) const;
+  inline isl::union_map intersect_domain(isl::union_set uset) const;
+  inline isl::union_map intersect_params(isl::set set) const;
+  inline isl::union_map intersect_range(isl::union_set uset) const;
+  inline isl::union_map intersect_range_factor_range(isl::union_map factor) const;
+  inline isl::boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::boolean is_bijective() const;
+  inline isl::boolean is_disjoint(const isl::union_map &umap2) const;
+  inline isl::boolean is_empty() const;
+  inline isl::boolean is_equal(const isl::union_map &umap2) const;
+  inline isl::boolean is_identity() const;
+  inline isl::boolean is_injective() const;
+  inline isl::boolean is_single_valued() const;
+  inline isl::boolean is_strict_subset(const isl::union_map &umap2) const;
+  inline isl::boolean is_subset(const isl::union_map &umap2) const;
+  inline isl::union_map lex_ge_union_map(isl::union_map umap2) const;
+  inline isl::union_map lex_gt_at_multi_union_pw_aff(isl::multi_union_pw_aff mupa) const;
+  inline isl::union_map lex_gt_union_map(isl::union_map umap2) const;
+  inline isl::union_map lex_le_union_map(isl::union_map umap2) const;
+  inline isl::union_map lex_lt_at_multi_union_pw_aff(isl::multi_union_pw_aff mupa) const;
+  inline isl::union_map lex_lt_union_map(isl::union_map umap2) const;
+  inline isl::union_map lexmax() const;
+  inline isl::union_map lexmin() const;
+  inline isl::set params() const;
+  inline isl::boolean plain_is_injective() const;
+  inline isl::union_map polyhedral_hull() const;
+  inline isl::union_map preimage_domain_multi_aff(isl::multi_aff ma) const;
+  inline isl::union_map preimage_domain_multi_pw_aff(isl::multi_pw_aff mpa) const;
+  inline isl::union_map preimage_domain_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::union_map preimage_domain_union_pw_multi_aff(isl::union_pw_multi_aff upma) const;
+  inline isl::union_map preimage_range_multi_aff(isl::multi_aff ma) const;
+  inline isl::union_map preimage_range_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::union_map preimage_range_union_pw_multi_aff(isl::union_pw_multi_aff upma) const;
+  inline isl::union_map product(isl::union_map umap2) const;
+  inline isl::union_map project_out(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::union_set range() const;
+  inline isl::union_map range_curry() const;
+  inline isl::union_map range_factor_domain() const;
+  inline isl::union_map range_factor_range() const;
+  inline isl::union_map range_map() const;
+  inline isl::union_map range_product(isl::union_map umap2) const;
+  inline isl::union_map remove_divs() const;
+  inline isl::union_map remove_redundancies() const;
+  inline isl::union_map reset_user() const;
+  inline isl::union_map reverse() const;
+  inline isl::basic_map sample() const;
+  inline isl::union_map simple_hull() const;
+  inline isl::union_map subtract(isl::union_map umap2) const;
+  inline isl::union_map subtract_domain(isl::union_set dom) const;
+  inline isl::union_map subtract_range(isl::union_set dom) const;
+  inline isl::union_map uncurry() const;
+  inline isl::union_map unite(isl::union_map umap2) const;
+  inline isl::union_map universe() const;
+  inline isl::union_set wrap() const;
+  inline isl::union_map zip() const;
+};
+
+// declarations for isl::union_map_list
+inline isl::union_map_list manage(__isl_take isl_union_map_list *ptr);
+inline isl::union_map_list give(__isl_take isl_union_map_list *ptr);
+
+
+class union_map_list {
+  friend inline isl::union_map_list manage(__isl_take isl_union_map_list *ptr);
+
+  isl_union_map_list *ptr = nullptr;
+
+  inline explicit union_map_list(__isl_take isl_union_map_list *ptr);
+
+public:
+  inline /* implicit */ union_map_list();
+  inline /* implicit */ union_map_list(const isl::union_map_list &obj);
+  inline /* implicit */ union_map_list(std::nullptr_t);
+  inline isl::union_map_list &operator=(isl::union_map_list obj);
+  inline ~union_map_list();
+  inline __isl_give isl_union_map_list *copy() const &;
+  inline __isl_give isl_union_map_list *copy() && = delete;
+  inline __isl_keep isl_union_map_list *get() const;
+  inline __isl_give isl_union_map_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_map_list *keep() const;
+  inline __isl_give isl_union_map_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::union_pw_aff
+inline isl::union_pw_aff manage(__isl_take isl_union_pw_aff *ptr);
+inline isl::union_pw_aff give(__isl_take isl_union_pw_aff *ptr);
+
+
+class union_pw_aff {
+  friend inline isl::union_pw_aff manage(__isl_take isl_union_pw_aff *ptr);
+
+  isl_union_pw_aff *ptr = nullptr;
+
+  inline explicit union_pw_aff(__isl_take isl_union_pw_aff *ptr);
+
+public:
+  inline /* implicit */ union_pw_aff();
+  inline /* implicit */ union_pw_aff(const isl::union_pw_aff &obj);
+  inline /* implicit */ union_pw_aff(std::nullptr_t);
+  inline /* implicit */ union_pw_aff(isl::pw_aff pa);
+  inline explicit union_pw_aff(isl::union_set domain, isl::val v);
+  inline explicit union_pw_aff(isl::ctx ctx, const std::string &str);
+  inline isl::union_pw_aff &operator=(isl::union_pw_aff obj);
+  inline ~union_pw_aff();
+  inline __isl_give isl_union_pw_aff *copy() const &;
+  inline __isl_give isl_union_pw_aff *copy() && = delete;
+  inline __isl_keep isl_union_pw_aff *get() const;
+  inline __isl_give isl_union_pw_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_pw_aff *keep() const;
+  inline __isl_give isl_union_pw_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::union_pw_aff add(isl::union_pw_aff upa2) const;
+  inline isl::union_pw_aff add_pw_aff(isl::pw_aff pa) const;
+  static inline isl::union_pw_aff aff_on_domain(isl::union_set domain, isl::aff aff);
+  inline isl::union_pw_aff align_params(isl::space model) const;
+  inline isl::union_pw_aff coalesce() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::union_set domain() const;
+  inline isl::union_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::union_pw_aff empty(isl::space space);
+  inline isl::pw_aff extract_pw_aff(isl::space space) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::union_pw_aff floor() const;
+  inline isl::stat foreach_pw_aff(const std::function<isl::stat(isl::pw_aff)> &fn) const;
+  inline isl::space get_space() const;
+  inline isl::union_pw_aff gist(isl::union_set context) const;
+  inline isl::union_pw_aff gist_params(isl::set context) const;
+  inline isl::union_pw_aff intersect_domain(isl::union_set uset) const;
+  inline isl::union_pw_aff intersect_params(isl::set set) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::union_pw_aff mod_val(isl::val f) const;
+  inline isl::union_pw_aff neg() const;
+  inline isl::boolean plain_is_equal(const isl::union_pw_aff &upa2) const;
+  inline isl::union_pw_aff pullback(isl::union_pw_multi_aff upma) const;
+  inline isl::union_pw_aff reset_user() const;
+  inline isl::union_pw_aff scale_down_val(isl::val v) const;
+  inline isl::union_pw_aff scale_val(isl::val v) const;
+  inline isl::union_pw_aff sub(isl::union_pw_aff upa2) const;
+  inline isl::union_pw_aff subtract_domain(isl::union_set uset) const;
+  inline isl::union_pw_aff union_add(isl::union_pw_aff upa2) const;
+  inline isl::union_set zero_union_set() const;
+};
+
+// declarations for isl::union_pw_aff_list
+inline isl::union_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr);
+inline isl::union_pw_aff_list give(__isl_take isl_union_pw_aff_list *ptr);
+
+
+class union_pw_aff_list {
+  friend inline isl::union_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr);
+
+  isl_union_pw_aff_list *ptr = nullptr;
+
+  inline explicit union_pw_aff_list(__isl_take isl_union_pw_aff_list *ptr);
+
+public:
+  inline /* implicit */ union_pw_aff_list();
+  inline /* implicit */ union_pw_aff_list(const isl::union_pw_aff_list &obj);
+  inline /* implicit */ union_pw_aff_list(std::nullptr_t);
+  inline isl::union_pw_aff_list &operator=(isl::union_pw_aff_list obj);
+  inline ~union_pw_aff_list();
+  inline __isl_give isl_union_pw_aff_list *copy() const &;
+  inline __isl_give isl_union_pw_aff_list *copy() && = delete;
+  inline __isl_keep isl_union_pw_aff_list *get() const;
+  inline __isl_give isl_union_pw_aff_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_pw_aff_list *keep() const;
+  inline __isl_give isl_union_pw_aff_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::union_pw_multi_aff
+inline isl::union_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr);
+inline isl::union_pw_multi_aff give(__isl_take isl_union_pw_multi_aff *ptr);
+
+
+class union_pw_multi_aff {
+  friend inline isl::union_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr);
+
+  isl_union_pw_multi_aff *ptr = nullptr;
+
+  inline explicit union_pw_multi_aff(__isl_take isl_union_pw_multi_aff *ptr);
+
+public:
+  inline /* implicit */ union_pw_multi_aff();
+  inline /* implicit */ union_pw_multi_aff(const isl::union_pw_multi_aff &obj);
+  inline /* implicit */ union_pw_multi_aff(std::nullptr_t);
+  inline /* implicit */ union_pw_multi_aff(isl::pw_multi_aff pma);
+  inline explicit union_pw_multi_aff(isl::union_set uset);
+  inline explicit union_pw_multi_aff(isl::union_map umap);
+  inline explicit union_pw_multi_aff(isl::ctx ctx, const std::string &str);
+  inline /* implicit */ union_pw_multi_aff(isl::union_pw_aff upa);
+  inline isl::union_pw_multi_aff &operator=(isl::union_pw_multi_aff obj);
+  inline ~union_pw_multi_aff();
+  inline __isl_give isl_union_pw_multi_aff *copy() const &;
+  inline __isl_give isl_union_pw_multi_aff *copy() && = delete;
+  inline __isl_keep isl_union_pw_multi_aff *get() const;
+  inline __isl_give isl_union_pw_multi_aff *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_pw_multi_aff *keep() const;
+  inline __isl_give isl_union_pw_multi_aff *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::union_pw_multi_aff add(isl::union_pw_multi_aff upma2) const;
+  inline isl::union_pw_multi_aff add_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::union_pw_multi_aff align_params(isl::space model) const;
+  inline isl::union_pw_multi_aff coalesce() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::union_set domain() const;
+  inline isl::union_pw_multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  static inline isl::union_pw_multi_aff empty(isl::space space);
+  inline isl::pw_multi_aff extract_pw_multi_aff(isl::space space) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::union_pw_multi_aff flat_range_product(isl::union_pw_multi_aff upma2) const;
+  inline isl::stat foreach_pw_multi_aff(const std::function<isl::stat(isl::pw_multi_aff)> &fn) const;
+  static inline isl::union_pw_multi_aff from_aff(isl::aff aff);
+  static inline isl::union_pw_multi_aff from_multi_union_pw_aff(isl::multi_union_pw_aff mupa);
+  static inline isl::union_pw_multi_aff from_union_set(isl::union_set uset);
+  inline isl::space get_space() const;
+  inline isl::union_pw_aff get_union_pw_aff(int pos) const;
+  inline isl::union_pw_multi_aff gist(isl::union_set context) const;
+  inline isl::union_pw_multi_aff gist_params(isl::set context) const;
+  inline isl::union_pw_multi_aff intersect_domain(isl::union_set uset) const;
+  inline isl::union_pw_multi_aff intersect_params(isl::set set) const;
+  inline isl::boolean involves_nan() const;
+  static inline isl::union_pw_multi_aff multi_val_on_domain(isl::union_set domain, isl::multi_val mv);
+  inline isl::union_pw_multi_aff neg() const;
+  inline isl::boolean plain_is_equal(const isl::union_pw_multi_aff &upma2) const;
+  inline isl::union_pw_multi_aff pullback(isl::union_pw_multi_aff upma2) const;
+  inline isl::union_pw_multi_aff reset_user() const;
+  inline isl::union_pw_multi_aff scale_down_val(isl::val val) const;
+  inline isl::union_pw_multi_aff scale_multi_val(isl::multi_val mv) const;
+  inline isl::union_pw_multi_aff scale_val(isl::val val) const;
+  inline isl::union_pw_multi_aff sub(isl::union_pw_multi_aff upma2) const;
+  inline isl::union_pw_multi_aff subtract_domain(isl::union_set uset) const;
+  inline isl::union_pw_multi_aff union_add(isl::union_pw_multi_aff upma2) const;
+};
+
+// declarations for isl::union_pw_multi_aff_list
+inline isl::union_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr);
+inline isl::union_pw_multi_aff_list give(__isl_take isl_union_pw_multi_aff_list *ptr);
+
+
+class union_pw_multi_aff_list {
+  friend inline isl::union_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr);
+
+  isl_union_pw_multi_aff_list *ptr = nullptr;
+
+  inline explicit union_pw_multi_aff_list(__isl_take isl_union_pw_multi_aff_list *ptr);
+
+public:
+  inline /* implicit */ union_pw_multi_aff_list();
+  inline /* implicit */ union_pw_multi_aff_list(const isl::union_pw_multi_aff_list &obj);
+  inline /* implicit */ union_pw_multi_aff_list(std::nullptr_t);
+  inline isl::union_pw_multi_aff_list &operator=(isl::union_pw_multi_aff_list obj);
+  inline ~union_pw_multi_aff_list();
+  inline __isl_give isl_union_pw_multi_aff_list *copy() const &;
+  inline __isl_give isl_union_pw_multi_aff_list *copy() && = delete;
+  inline __isl_keep isl_union_pw_multi_aff_list *get() const;
+  inline __isl_give isl_union_pw_multi_aff_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_pw_multi_aff_list *keep() const;
+  inline __isl_give isl_union_pw_multi_aff_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::union_pw_qpolynomial
+inline isl::union_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr);
+inline isl::union_pw_qpolynomial give(__isl_take isl_union_pw_qpolynomial *ptr);
+
+
+class union_pw_qpolynomial {
+  friend inline isl::union_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr);
+
+  isl_union_pw_qpolynomial *ptr = nullptr;
+
+  inline explicit union_pw_qpolynomial(__isl_take isl_union_pw_qpolynomial *ptr);
+
+public:
+  inline /* implicit */ union_pw_qpolynomial();
+  inline /* implicit */ union_pw_qpolynomial(const isl::union_pw_qpolynomial &obj);
+  inline /* implicit */ union_pw_qpolynomial(std::nullptr_t);
+  inline explicit union_pw_qpolynomial(isl::ctx ctx, const std::string &str);
+  inline isl::union_pw_qpolynomial &operator=(isl::union_pw_qpolynomial obj);
+  inline ~union_pw_qpolynomial();
+  inline __isl_give isl_union_pw_qpolynomial *copy() const &;
+  inline __isl_give isl_union_pw_qpolynomial *copy() && = delete;
+  inline __isl_keep isl_union_pw_qpolynomial *get() const;
+  inline __isl_give isl_union_pw_qpolynomial *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_pw_qpolynomial *keep() const;
+  inline __isl_give isl_union_pw_qpolynomial *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+
+  inline isl::union_pw_qpolynomial add(isl::union_pw_qpolynomial upwqp2) const;
+  inline isl::union_pw_qpolynomial add_pw_qpolynomial(isl::pw_qpolynomial pwqp) const;
+  inline isl::union_pw_qpolynomial align_params(isl::space model) const;
+  inline isl::union_pw_qpolynomial coalesce() const;
+  inline unsigned int dim(isl::dim type) const;
+  inline isl::union_set domain() const;
+  inline isl::union_pw_qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::val eval(isl::point pnt) const;
+  inline isl::pw_qpolynomial extract_pw_qpolynomial(isl::space dim) const;
+  inline int find_dim_by_name(isl::dim type, const std::string &name) const;
+  inline isl::stat foreach_pw_qpolynomial(const std::function<isl::stat(isl::pw_qpolynomial)> &fn) const;
+  static inline isl::union_pw_qpolynomial from_pw_qpolynomial(isl::pw_qpolynomial pwqp);
+  inline isl::space get_space() const;
+  inline isl::union_pw_qpolynomial gist(isl::union_set context) const;
+  inline isl::union_pw_qpolynomial gist_params(isl::set context) const;
+  inline isl::union_pw_qpolynomial intersect_domain(isl::union_set uset) const;
+  inline isl::union_pw_qpolynomial intersect_params(isl::set set) const;
+  inline isl::boolean involves_nan() const;
+  inline isl::union_pw_qpolynomial mul(isl::union_pw_qpolynomial upwqp2) const;
+  inline isl::union_pw_qpolynomial neg() const;
+  inline isl::boolean plain_is_equal(const isl::union_pw_qpolynomial &upwqp2) const;
+  inline isl::union_pw_qpolynomial reset_user() const;
+  inline isl::union_pw_qpolynomial scale_down_val(isl::val v) const;
+  inline isl::union_pw_qpolynomial scale_val(isl::val v) const;
+  inline isl::union_pw_qpolynomial sub(isl::union_pw_qpolynomial upwqp2) const;
+  inline isl::union_pw_qpolynomial subtract_domain(isl::union_set uset) const;
+  inline isl::union_pw_qpolynomial to_polynomial(int sign) const;
+  static inline isl::union_pw_qpolynomial zero(isl::space dim);
+};
+
+// declarations for isl::union_set
+inline isl::union_set manage(__isl_take isl_union_set *ptr);
+inline isl::union_set give(__isl_take isl_union_set *ptr);
+
+
+class union_set {
+  friend inline isl::union_set manage(__isl_take isl_union_set *ptr);
+
+  isl_union_set *ptr = nullptr;
+
+  inline explicit union_set(__isl_take isl_union_set *ptr);
+
+public:
+  inline /* implicit */ union_set();
+  inline /* implicit */ union_set(const isl::union_set &obj);
+  inline /* implicit */ union_set(std::nullptr_t);
+  inline /* implicit */ union_set(isl::point pnt);
+  inline explicit union_set(isl::ctx ctx, const std::string &str);
+  inline /* implicit */ union_set(isl::basic_set bset);
+  inline /* implicit */ union_set(isl::set set);
+  inline isl::union_set &operator=(isl::union_set obj);
+  inline ~union_set();
+  inline __isl_give isl_union_set *copy() const &;
+  inline __isl_give isl_union_set *copy() && = delete;
+  inline __isl_keep isl_union_set *get() const;
+  inline __isl_give isl_union_set *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_set *keep() const;
+  inline __isl_give isl_union_set *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::union_set add_set(isl::set set) const;
+  inline isl::union_set affine_hull() const;
+  inline isl::union_set align_params(isl::space model) const;
+  inline isl::union_set apply(isl::union_map umap) const;
+  inline isl::union_set coalesce() const;
+  inline isl::union_set coefficients() const;
+  inline isl::schedule compute_schedule(isl::union_map validity, isl::union_map proximity) const;
+  inline isl::boolean contains(const isl::space &space) const;
+  inline isl::union_set detect_equalities() const;
+  inline unsigned int dim(isl::dim type) const;
+  static inline isl::union_set empty(isl::space dim);
+  inline isl::set extract_set(isl::space dim) const;
+  inline isl::stat foreach_point(const std::function<isl::stat(isl::point)> &fn) const;
+  inline isl::stat foreach_set(const std::function<isl::stat(isl::set)> &fn) const;
+  inline isl::basic_set_list get_basic_set_list() const;
+  inline uint32_t get_hash() const;
+  inline isl::space get_space() const;
+  inline isl::union_set gist(isl::union_set context) const;
+  inline isl::union_set gist_params(isl::set set) const;
+  inline isl::union_map identity() const;
+  inline isl::union_pw_multi_aff identity_union_pw_multi_aff() const;
+  inline isl::union_set intersect(isl::union_set uset2) const;
+  inline isl::union_set intersect_params(isl::set set) const;
+  inline isl::boolean is_disjoint(const isl::union_set &uset2) const;
+  inline isl::boolean is_empty() const;
+  inline isl::boolean is_equal(const isl::union_set &uset2) const;
+  inline isl::boolean is_params() const;
+  inline isl::boolean is_strict_subset(const isl::union_set &uset2) const;
+  inline isl::boolean is_subset(const isl::union_set &uset2) const;
+  inline isl::union_map lex_ge_union_set(isl::union_set uset2) const;
+  inline isl::union_map lex_gt_union_set(isl::union_set uset2) const;
+  inline isl::union_map lex_le_union_set(isl::union_set uset2) const;
+  inline isl::union_map lex_lt_union_set(isl::union_set uset2) const;
+  inline isl::union_set lexmax() const;
+  inline isl::union_set lexmin() const;
+  inline isl::multi_val min_multi_union_pw_aff(const isl::multi_union_pw_aff &obj) const;
+  inline isl::set params() const;
+  inline isl::union_set polyhedral_hull() const;
+  inline isl::union_set preimage_multi_aff(isl::multi_aff ma) const;
+  inline isl::union_set preimage_pw_multi_aff(isl::pw_multi_aff pma) const;
+  inline isl::union_set preimage_union_pw_multi_aff(isl::union_pw_multi_aff upma) const;
+  inline isl::union_set product(isl::union_set uset2) const;
+  inline isl::union_set project_out(isl::dim type, unsigned int first, unsigned int n) const;
+  inline isl::union_set remove_divs() const;
+  inline isl::union_set remove_redundancies() const;
+  inline isl::union_set reset_user() const;
+  inline isl::basic_set sample() const;
+  inline isl::point sample_point() const;
+  inline isl::union_set simple_hull() const;
+  inline isl::union_set solutions() const;
+  inline isl::union_set subtract(isl::union_set uset2) const;
+  inline isl::union_set unite(isl::union_set uset2) const;
+  inline isl::union_set universe() const;
+  inline isl::union_map unwrap() const;
+  inline isl::union_map wrapped_domain_map() const;
+};
+
+// declarations for isl::union_set_list
+inline isl::union_set_list manage(__isl_take isl_union_set_list *ptr);
+inline isl::union_set_list give(__isl_take isl_union_set_list *ptr);
+
+
+class union_set_list {
+  friend inline isl::union_set_list manage(__isl_take isl_union_set_list *ptr);
+
+  isl_union_set_list *ptr = nullptr;
+
+  inline explicit union_set_list(__isl_take isl_union_set_list *ptr);
+
+public:
+  inline /* implicit */ union_set_list();
+  inline /* implicit */ union_set_list(const isl::union_set_list &obj);
+  inline /* implicit */ union_set_list(std::nullptr_t);
+  inline isl::union_set_list &operator=(isl::union_set_list obj);
+  inline ~union_set_list();
+  inline __isl_give isl_union_set_list *copy() const &;
+  inline __isl_give isl_union_set_list *copy() && = delete;
+  inline __isl_keep isl_union_set_list *get() const;
+  inline __isl_give isl_union_set_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_union_set_list *keep() const;
+  inline __isl_give isl_union_set_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// declarations for isl::val
+inline isl::val manage(__isl_take isl_val *ptr);
+inline isl::val give(__isl_take isl_val *ptr);
+
+
+class val {
+  friend inline isl::val manage(__isl_take isl_val *ptr);
+
+  isl_val *ptr = nullptr;
+
+  inline explicit val(__isl_take isl_val *ptr);
+
+public:
+  inline /* implicit */ val();
+  inline /* implicit */ val(const isl::val &obj);
+  inline /* implicit */ val(std::nullptr_t);
+  inline explicit val(isl::ctx ctx, long i);
+  inline explicit val(isl::ctx ctx, const std::string &str);
+  inline isl::val &operator=(isl::val obj);
+  inline ~val();
+  inline __isl_give isl_val *copy() const &;
+  inline __isl_give isl_val *copy() && = delete;
+  inline __isl_keep isl_val *get() const;
+  inline __isl_give isl_val *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_val *keep() const;
+  inline __isl_give isl_val *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline std::string to_str() const;
+  inline void dump() const;
+
+  inline isl::val two_exp() const;
+  inline isl::val abs() const;
+  inline isl::boolean abs_eq(const isl::val &v2) const;
+  inline isl::val add(isl::val v2) const;
+  inline isl::val add_ui(unsigned long v2) const;
+  inline isl::val ceil() const;
+  inline int cmp_si(long i) const;
+  inline isl::val div(isl::val v2) const;
+  inline isl::val div_ui(unsigned long v2) const;
+  inline isl::boolean eq(const isl::val &v2) const;
+  inline isl::val floor() const;
+  inline isl::val gcd(isl::val v2) const;
+  inline isl::boolean ge(const isl::val &v2) const;
+  inline uint32_t get_hash() const;
+  inline long get_num_si() const;
+  inline isl::boolean gt(const isl::val &v2) const;
+  static inline isl::val infty(isl::ctx ctx);
+  static inline isl::val int_from_ui(isl::ctx ctx, unsigned long u);
+  inline isl::val inv() const;
+  inline isl::boolean is_divisible_by(const isl::val &v2) const;
+  inline isl::boolean is_infty() const;
+  inline isl::boolean is_int() const;
+  inline isl::boolean is_nan() const;
+  inline isl::boolean is_neg() const;
+  inline isl::boolean is_neginfty() const;
+  inline isl::boolean is_negone() const;
+  inline isl::boolean is_nonneg() const;
+  inline isl::boolean is_nonpos() const;
+  inline isl::boolean is_one() const;
+  inline isl::boolean is_pos() const;
+  inline isl::boolean is_rat() const;
+  inline isl::boolean is_zero() const;
+  inline isl::boolean le(const isl::val &v2) const;
+  inline isl::boolean lt(const isl::val &v2) const;
+  inline isl::val max(isl::val v2) const;
+  inline isl::val min(isl::val v2) const;
+  inline isl::val mod(isl::val v2) const;
+  inline isl::val mul(isl::val v2) const;
+  inline isl::val mul_ui(unsigned long v2) const;
+  static inline isl::val nan(isl::ctx ctx);
+  inline isl::boolean ne(const isl::val &v2) const;
+  inline isl::val neg() const;
+  static inline isl::val neginfty(isl::ctx ctx);
+  static inline isl::val negone(isl::ctx ctx);
+  static inline isl::val one(isl::ctx ctx);
+  inline isl::val set_si(long i) const;
+  inline int sgn() const;
+  inline isl::val sub(isl::val v2) const;
+  inline isl::val sub_ui(unsigned long v2) const;
+  inline isl::val trunc() const;
+  static inline isl::val zero(isl::ctx ctx);
+};
+
+// declarations for isl::val_list
+inline isl::val_list manage(__isl_take isl_val_list *ptr);
+inline isl::val_list give(__isl_take isl_val_list *ptr);
+
+
+class val_list {
+  friend inline isl::val_list manage(__isl_take isl_val_list *ptr);
+
+  isl_val_list *ptr = nullptr;
+
+  inline explicit val_list(__isl_take isl_val_list *ptr);
+
+public:
+  inline /* implicit */ val_list();
+  inline /* implicit */ val_list(const isl::val_list &obj);
+  inline /* implicit */ val_list(std::nullptr_t);
+  inline isl::val_list &operator=(isl::val_list obj);
+  inline ~val_list();
+  inline __isl_give isl_val_list *copy() const &;
+  inline __isl_give isl_val_list *copy() && = delete;
+  inline __isl_keep isl_val_list *get() const;
+  inline __isl_give isl_val_list *release();
+  inline bool is_null() const;
+  inline __isl_keep isl_val_list *keep() const;
+  inline __isl_give isl_val_list *take();
+  inline explicit operator bool() const;
+  inline isl::ctx get_ctx() const;
+  inline void dump() const;
+
+};
+
+// implementations for isl::aff
+isl::aff manage(__isl_take isl_aff *ptr) {
+  return aff(ptr);
+}
+isl::aff give(__isl_take isl_aff *ptr) {
+  return manage(ptr);
+}
+
+
+aff::aff()
+    : ptr(nullptr) {}
+
+aff::aff(const isl::aff &obj)
+    : ptr(obj.copy()) {}
+aff::aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+aff::aff(__isl_take isl_aff *ptr)
+    : ptr(ptr) {}
+
+aff::aff(isl::local_space ls) {
+  auto res = isl_aff_zero_on_domain(ls.release());
+  ptr = res;
+}
+aff::aff(isl::local_space ls, isl::val val) {
+  auto res = isl_aff_val_on_domain(ls.release(), val.release());
+  ptr = res;
+}
+aff::aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+aff &aff::operator=(isl::aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+aff::~aff() {
+  if (ptr)
+    isl_aff_free(ptr);
+}
+
+__isl_give isl_aff *aff::copy() const & {
+  return isl_aff_copy(ptr);
+}
+
+__isl_keep isl_aff *aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_aff *aff::release() {
+  isl_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_aff *aff::keep() const {
+  return get();
+}
+
+__isl_give isl_aff *aff::take() {
+  return release();
+}
+
+aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx aff::get_ctx() const {
+  return isl::ctx(isl_aff_get_ctx(ptr));
+}
+
+
+std::string aff::to_str() const {
+  char *Tmp = isl_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void aff::dump() const {
+  isl_aff_dump(get());
+}
+
+
+isl::aff aff::add(isl::aff aff2) const {
+  auto res = isl_aff_add(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::add_coefficient_si(isl::dim type, int pos, int v) const {
+  auto res = isl_aff_add_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);
+  return manage(res);
+}
+
+isl::aff aff::add_coefficient_val(isl::dim type, int pos, isl::val v) const {
+  auto res = isl_aff_add_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::aff aff::add_constant_num_si(int v) const {
+  auto res = isl_aff_add_constant_num_si(copy(), v);
+  return manage(res);
+}
+
+isl::aff aff::add_constant_si(int v) const {
+  auto res = isl_aff_add_constant_si(copy(), v);
+  return manage(res);
+}
+
+isl::aff aff::add_constant_val(isl::val v) const {
+  auto res = isl_aff_add_constant_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::aff aff::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::aff aff::align_params(isl::space model) const {
+  auto res = isl_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::aff aff::ceil() const {
+  auto res = isl_aff_ceil(copy());
+  return manage(res);
+}
+
+int aff::coefficient_sgn(isl::dim type, int pos) const {
+  auto res = isl_aff_coefficient_sgn(get(), static_cast<enum isl_dim_type>(type), pos);
+  return res;
+}
+
+int aff::dim(isl::dim type) const {
+  auto res = isl_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::aff aff::div(isl::aff aff2) const {
+  auto res = isl_aff_div(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set aff::eq_basic_set(isl::aff aff2) const {
+  auto res = isl_aff_eq_basic_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::set aff::eq_set(isl::aff aff2) const {
+  auto res = isl_aff_eq_set(copy(), aff2.release());
+  return manage(res);
+}
+
+int aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::aff aff::floor() const {
+  auto res = isl_aff_floor(copy());
+  return manage(res);
+}
+
+isl::basic_set aff::ge_basic_set(isl::aff aff2) const {
+  auto res = isl_aff_ge_basic_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::set aff::ge_set(isl::aff aff2) const {
+  auto res = isl_aff_ge_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::val aff::get_coefficient_val(isl::dim type, int pos) const {
+  auto res = isl_aff_get_coefficient_val(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::val aff::get_constant_val() const {
+  auto res = isl_aff_get_constant_val(get());
+  return manage(res);
+}
+
+isl::val aff::get_denominator_val() const {
+  auto res = isl_aff_get_denominator_val(get());
+  return manage(res);
+}
+
+std::string aff::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::aff aff::get_div(int pos) const {
+  auto res = isl_aff_get_div(get(), pos);
+  return manage(res);
+}
+
+isl::local_space aff::get_domain_local_space() const {
+  auto res = isl_aff_get_domain_local_space(get());
+  return manage(res);
+}
+
+isl::space aff::get_domain_space() const {
+  auto res = isl_aff_get_domain_space(get());
+  return manage(res);
+}
+
+uint32_t aff::get_hash() const {
+  auto res = isl_aff_get_hash(get());
+  return res;
+}
+
+isl::local_space aff::get_local_space() const {
+  auto res = isl_aff_get_local_space(get());
+  return manage(res);
+}
+
+isl::space aff::get_space() const {
+  auto res = isl_aff_get_space(get());
+  return manage(res);
+}
+
+isl::aff aff::gist(isl::set context) const {
+  auto res = isl_aff_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::aff aff::gist_params(isl::set context) const {
+  auto res = isl_aff_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::basic_set aff::gt_basic_set(isl::aff aff2) const {
+  auto res = isl_aff_gt_basic_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::set aff::gt_set(isl::aff aff2) const {
+  auto res = isl_aff_gt_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean aff::is_cst() const {
+  auto res = isl_aff_is_cst(get());
+  return manage(res);
+}
+
+isl::boolean aff::is_nan() const {
+  auto res = isl_aff_is_nan(get());
+  return manage(res);
+}
+
+isl::basic_set aff::le_basic_set(isl::aff aff2) const {
+  auto res = isl_aff_le_basic_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::set aff::le_set(isl::aff aff2) const {
+  auto res = isl_aff_le_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::basic_set aff::lt_basic_set(isl::aff aff2) const {
+  auto res = isl_aff_lt_basic_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::set aff::lt_set(isl::aff aff2) const {
+  auto res = isl_aff_lt_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::mod(isl::val mod) const {
+  auto res = isl_aff_mod_val(copy(), mod.release());
+  return manage(res);
+}
+
+isl::aff aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::aff aff::mul(isl::aff aff2) const {
+  auto res = isl_aff_mul(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::nan_on_domain(isl::local_space ls) {
+  auto res = isl_aff_nan_on_domain(ls.release());
+  return manage(res);
+}
+
+isl::set aff::ne_set(isl::aff aff2) const {
+  auto res = isl_aff_ne_set(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::neg() const {
+  auto res = isl_aff_neg(copy());
+  return manage(res);
+}
+
+isl::basic_set aff::neg_basic_set() const {
+  auto res = isl_aff_neg_basic_set(copy());
+  return manage(res);
+}
+
+isl::boolean aff::plain_is_equal(const isl::aff &aff2) const {
+  auto res = isl_aff_plain_is_equal(get(), aff2.get());
+  return manage(res);
+}
+
+isl::boolean aff::plain_is_zero() const {
+  auto res = isl_aff_plain_is_zero(get());
+  return manage(res);
+}
+
+isl::aff aff::project_domain_on_params() const {
+  auto res = isl_aff_project_domain_on_params(copy());
+  return manage(res);
+}
+
+isl::aff aff::pullback(isl::multi_aff ma) const {
+  auto res = isl_aff_pullback_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::aff aff::pullback_aff(isl::aff aff2) const {
+  auto res = isl_aff_pullback_aff(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::scale(isl::val v) const {
+  auto res = isl_aff_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::aff aff::scale_down(isl::val v) const {
+  auto res = isl_aff_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::aff aff::scale_down_ui(unsigned int f) const {
+  auto res = isl_aff_scale_down_ui(copy(), f);
+  return manage(res);
+}
+
+isl::aff aff::set_coefficient_si(isl::dim type, int pos, int v) const {
+  auto res = isl_aff_set_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);
+  return manage(res);
+}
+
+isl::aff aff::set_coefficient_val(isl::dim type, int pos, isl::val v) const {
+  auto res = isl_aff_set_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::aff aff::set_constant_si(int v) const {
+  auto res = isl_aff_set_constant_si(copy(), v);
+  return manage(res);
+}
+
+isl::aff aff::set_constant_val(isl::val v) const {
+  auto res = isl_aff_set_constant_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::aff aff::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::aff aff::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::aff aff::sub(isl::aff aff2) const {
+  auto res = isl_aff_sub(copy(), aff2.release());
+  return manage(res);
+}
+
+isl::aff aff::var_on_domain(isl::local_space ls, isl::dim type, unsigned int pos) {
+  auto res = isl_aff_var_on_domain(ls.release(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::basic_set aff::zero_basic_set() const {
+  auto res = isl_aff_zero_basic_set(copy());
+  return manage(res);
+}
+
+// implementations for isl::aff_list
+isl::aff_list manage(__isl_take isl_aff_list *ptr) {
+  return aff_list(ptr);
+}
+isl::aff_list give(__isl_take isl_aff_list *ptr) {
+  return manage(ptr);
+}
+
+
+aff_list::aff_list()
+    : ptr(nullptr) {}
+
+aff_list::aff_list(const isl::aff_list &obj)
+    : ptr(obj.copy()) {}
+aff_list::aff_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+aff_list::aff_list(__isl_take isl_aff_list *ptr)
+    : ptr(ptr) {}
+
+
+aff_list &aff_list::operator=(isl::aff_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+aff_list::~aff_list() {
+  if (ptr)
+    isl_aff_list_free(ptr);
+}
+
+__isl_give isl_aff_list *aff_list::copy() const & {
+  return isl_aff_list_copy(ptr);
+}
+
+__isl_keep isl_aff_list *aff_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_aff_list *aff_list::release() {
+  isl_aff_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool aff_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_aff_list *aff_list::keep() const {
+  return get();
+}
+
+__isl_give isl_aff_list *aff_list::take() {
+  return release();
+}
+
+aff_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx aff_list::get_ctx() const {
+  return isl::ctx(isl_aff_list_get_ctx(ptr));
+}
+
+
+
+void aff_list::dump() const {
+  isl_aff_list_dump(get());
+}
+
+
+
+// implementations for isl::ast_build
+isl::ast_build manage(__isl_take isl_ast_build *ptr) {
+  return ast_build(ptr);
+}
+isl::ast_build give(__isl_take isl_ast_build *ptr) {
+  return manage(ptr);
+}
+
+
+ast_build::ast_build()
+    : ptr(nullptr) {}
+
+ast_build::ast_build(const isl::ast_build &obj)
+    : ptr(obj.copy()) {}
+ast_build::ast_build(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+ast_build::ast_build(__isl_take isl_ast_build *ptr)
+    : ptr(ptr) {}
+
+ast_build::ast_build(isl::ctx ctx) {
+  auto res = isl_ast_build_alloc(ctx.release());
+  ptr = res;
+}
+
+ast_build &ast_build::operator=(isl::ast_build obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+ast_build::~ast_build() {
+  if (ptr)
+    isl_ast_build_free(ptr);
+}
+
+__isl_give isl_ast_build *ast_build::copy() const & {
+  return isl_ast_build_copy(ptr);
+}
+
+__isl_keep isl_ast_build *ast_build::get() const {
+  return ptr;
+}
+
+__isl_give isl_ast_build *ast_build::release() {
+  isl_ast_build *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool ast_build::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_ast_build *ast_build::keep() const {
+  return get();
+}
+
+__isl_give isl_ast_build *ast_build::take() {
+  return release();
+}
+
+ast_build::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx ast_build::get_ctx() const {
+  return isl::ctx(isl_ast_build_get_ctx(ptr));
+}
+
+
+
+
+isl::ast_expr ast_build::access_from(isl::pw_multi_aff pma) const {
+  auto res = isl_ast_build_access_from_pw_multi_aff(get(), pma.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_build::access_from(isl::multi_pw_aff mpa) const {
+  auto res = isl_ast_build_access_from_multi_pw_aff(get(), mpa.release());
+  return manage(res);
+}
+
+isl::ast_node ast_build::ast_from_schedule(isl::union_map schedule) const {
+  auto res = isl_ast_build_ast_from_schedule(get(), schedule.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_build::call_from(isl::pw_multi_aff pma) const {
+  auto res = isl_ast_build_call_from_pw_multi_aff(get(), pma.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_build::call_from(isl::multi_pw_aff mpa) const {
+  auto res = isl_ast_build_call_from_multi_pw_aff(get(), mpa.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_build::expr_from(isl::set set) const {
+  auto res = isl_ast_build_expr_from_set(get(), set.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_build::expr_from(isl::pw_aff pa) const {
+  auto res = isl_ast_build_expr_from_pw_aff(get(), pa.release());
+  return manage(res);
+}
+
+isl::ast_build ast_build::from_context(isl::set set) {
+  auto res = isl_ast_build_from_context(set.release());
+  return manage(res);
+}
+
+isl::union_map ast_build::get_schedule() const {
+  auto res = isl_ast_build_get_schedule(get());
+  return manage(res);
+}
+
+isl::space ast_build::get_schedule_space() const {
+  auto res = isl_ast_build_get_schedule_space(get());
+  return manage(res);
+}
+
+isl::ast_node ast_build::node_from_schedule(isl::schedule schedule) const {
+  auto res = isl_ast_build_node_from_schedule(get(), schedule.release());
+  return manage(res);
+}
+
+isl::ast_node ast_build::node_from_schedule_map(isl::union_map schedule) const {
+  auto res = isl_ast_build_node_from_schedule_map(get(), schedule.release());
+  return manage(res);
+}
+
+isl::ast_build ast_build::restrict(isl::set set) const {
+  auto res = isl_ast_build_restrict(copy(), set.release());
+  return manage(res);
+}
+
+// implementations for isl::ast_expr
+isl::ast_expr manage(__isl_take isl_ast_expr *ptr) {
+  return ast_expr(ptr);
+}
+isl::ast_expr give(__isl_take isl_ast_expr *ptr) {
+  return manage(ptr);
+}
+
+
+ast_expr::ast_expr()
+    : ptr(nullptr) {}
+
+ast_expr::ast_expr(const isl::ast_expr &obj)
+    : ptr(obj.copy()) {}
+ast_expr::ast_expr(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+ast_expr::ast_expr(__isl_take isl_ast_expr *ptr)
+    : ptr(ptr) {}
+
+
+ast_expr &ast_expr::operator=(isl::ast_expr obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+ast_expr::~ast_expr() {
+  if (ptr)
+    isl_ast_expr_free(ptr);
+}
+
+__isl_give isl_ast_expr *ast_expr::copy() const & {
+  return isl_ast_expr_copy(ptr);
+}
+
+__isl_keep isl_ast_expr *ast_expr::get() const {
+  return ptr;
+}
+
+__isl_give isl_ast_expr *ast_expr::release() {
+  isl_ast_expr *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool ast_expr::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_ast_expr *ast_expr::keep() const {
+  return get();
+}
+
+__isl_give isl_ast_expr *ast_expr::take() {
+  return release();
+}
+
+ast_expr::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx ast_expr::get_ctx() const {
+  return isl::ctx(isl_ast_expr_get_ctx(ptr));
+}
+
+
+std::string ast_expr::to_str() const {
+  char *Tmp = isl_ast_expr_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void ast_expr::dump() const {
+  isl_ast_expr_dump(get());
+}
+
+
+isl::ast_expr ast_expr::access(isl::ast_expr_list indices) const {
+  auto res = isl_ast_expr_access(copy(), indices.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::add(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_add(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::address_of() const {
+  auto res = isl_ast_expr_address_of(copy());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::call(isl::ast_expr_list arguments) const {
+  auto res = isl_ast_expr_call(copy(), arguments.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::div(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_div(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::eq(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_eq(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::from_id(isl::id id) {
+  auto res = isl_ast_expr_from_id(id.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::from_val(isl::val v) {
+  auto res = isl_ast_expr_from_val(v.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::ge(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_ge(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::id ast_expr::get_id() const {
+  auto res = isl_ast_expr_get_id(get());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::get_op_arg(int pos) const {
+  auto res = isl_ast_expr_get_op_arg(get(), pos);
+  return manage(res);
+}
+
+isl::val ast_expr::get_val() const {
+  auto res = isl_ast_expr_get_val(get());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::gt(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_gt(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::boolean ast_expr::is_equal(const isl::ast_expr &expr2) const {
+  auto res = isl_ast_expr_is_equal(get(), expr2.get());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::le(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_le(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::lt(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_lt(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::mul(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_mul(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::neg() const {
+  auto res = isl_ast_expr_neg(copy());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::pdiv_q(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_pdiv_q(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::pdiv_r(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_pdiv_r(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::set_op_arg(int pos, isl::ast_expr arg) const {
+  auto res = isl_ast_expr_set_op_arg(copy(), pos, arg.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::sub(isl::ast_expr expr2) const {
+  auto res = isl_ast_expr_sub(copy(), expr2.release());
+  return manage(res);
+}
+
+isl::ast_expr ast_expr::substitute_ids(isl::id_to_ast_expr id2expr) const {
+  auto res = isl_ast_expr_substitute_ids(copy(), id2expr.release());
+  return manage(res);
+}
+
+std::string ast_expr::to_C_str() const {
+  auto res = isl_ast_expr_to_C_str(get());
+  std::string tmp(res);
+  free(res);
+  return tmp;
+}
+
+// implementations for isl::ast_expr_list
+isl::ast_expr_list manage(__isl_take isl_ast_expr_list *ptr) {
+  return ast_expr_list(ptr);
+}
+isl::ast_expr_list give(__isl_take isl_ast_expr_list *ptr) {
+  return manage(ptr);
+}
+
+
+ast_expr_list::ast_expr_list()
+    : ptr(nullptr) {}
+
+ast_expr_list::ast_expr_list(const isl::ast_expr_list &obj)
+    : ptr(obj.copy()) {}
+ast_expr_list::ast_expr_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+ast_expr_list::ast_expr_list(__isl_take isl_ast_expr_list *ptr)
+    : ptr(ptr) {}
+
+
+ast_expr_list &ast_expr_list::operator=(isl::ast_expr_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+ast_expr_list::~ast_expr_list() {
+  if (ptr)
+    isl_ast_expr_list_free(ptr);
+}
+
+__isl_give isl_ast_expr_list *ast_expr_list::copy() const & {
+  return isl_ast_expr_list_copy(ptr);
+}
+
+__isl_keep isl_ast_expr_list *ast_expr_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_ast_expr_list *ast_expr_list::release() {
+  isl_ast_expr_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool ast_expr_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_ast_expr_list *ast_expr_list::keep() const {
+  return get();
+}
+
+__isl_give isl_ast_expr_list *ast_expr_list::take() {
+  return release();
+}
+
+ast_expr_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx ast_expr_list::get_ctx() const {
+  return isl::ctx(isl_ast_expr_list_get_ctx(ptr));
+}
+
+
+
+void ast_expr_list::dump() const {
+  isl_ast_expr_list_dump(get());
+}
+
+
+
+// implementations for isl::ast_node
+isl::ast_node manage(__isl_take isl_ast_node *ptr) {
+  return ast_node(ptr);
+}
+isl::ast_node give(__isl_take isl_ast_node *ptr) {
+  return manage(ptr);
+}
+
+
+ast_node::ast_node()
+    : ptr(nullptr) {}
+
+ast_node::ast_node(const isl::ast_node &obj)
+    : ptr(obj.copy()) {}
+ast_node::ast_node(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+ast_node::ast_node(__isl_take isl_ast_node *ptr)
+    : ptr(ptr) {}
+
+
+ast_node &ast_node::operator=(isl::ast_node obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+ast_node::~ast_node() {
+  if (ptr)
+    isl_ast_node_free(ptr);
+}
+
+__isl_give isl_ast_node *ast_node::copy() const & {
+  return isl_ast_node_copy(ptr);
+}
+
+__isl_keep isl_ast_node *ast_node::get() const {
+  return ptr;
+}
+
+__isl_give isl_ast_node *ast_node::release() {
+  isl_ast_node *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool ast_node::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_ast_node *ast_node::keep() const {
+  return get();
+}
+
+__isl_give isl_ast_node *ast_node::take() {
+  return release();
+}
+
+ast_node::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx ast_node::get_ctx() const {
+  return isl::ctx(isl_ast_node_get_ctx(ptr));
+}
+
+
+std::string ast_node::to_str() const {
+  char *Tmp = isl_ast_node_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void ast_node::dump() const {
+  isl_ast_node_dump(get());
+}
+
+
+isl::ast_node ast_node::alloc_user(isl::ast_expr expr) {
+  auto res = isl_ast_node_alloc_user(expr.release());
+  return manage(res);
+}
+
+isl::ast_node_list ast_node::block_get_children() const {
+  auto res = isl_ast_node_block_get_children(get());
+  return manage(res);
+}
+
+isl::ast_node ast_node::for_get_body() const {
+  auto res = isl_ast_node_for_get_body(get());
+  return manage(res);
+}
+
+isl::ast_expr ast_node::for_get_cond() const {
+  auto res = isl_ast_node_for_get_cond(get());
+  return manage(res);
+}
+
+isl::ast_expr ast_node::for_get_inc() const {
+  auto res = isl_ast_node_for_get_inc(get());
+  return manage(res);
+}
+
+isl::ast_expr ast_node::for_get_init() const {
+  auto res = isl_ast_node_for_get_init(get());
+  return manage(res);
+}
+
+isl::ast_expr ast_node::for_get_iterator() const {
+  auto res = isl_ast_node_for_get_iterator(get());
+  return manage(res);
+}
+
+isl::boolean ast_node::for_is_degenerate() const {
+  auto res = isl_ast_node_for_is_degenerate(get());
+  return manage(res);
+}
+
+isl::id ast_node::get_annotation() const {
+  auto res = isl_ast_node_get_annotation(get());
+  return manage(res);
+}
+
+isl::ast_expr ast_node::if_get_cond() const {
+  auto res = isl_ast_node_if_get_cond(get());
+  return manage(res);
+}
+
+isl::ast_node ast_node::if_get_else() const {
+  auto res = isl_ast_node_if_get_else(get());
+  return manage(res);
+}
+
+isl::ast_node ast_node::if_get_then() const {
+  auto res = isl_ast_node_if_get_then(get());
+  return manage(res);
+}
+
+isl::boolean ast_node::if_has_else() const {
+  auto res = isl_ast_node_if_has_else(get());
+  return manage(res);
+}
+
+isl::id ast_node::mark_get_id() const {
+  auto res = isl_ast_node_mark_get_id(get());
+  return manage(res);
+}
+
+isl::ast_node ast_node::mark_get_node() const {
+  auto res = isl_ast_node_mark_get_node(get());
+  return manage(res);
+}
+
+isl::ast_node ast_node::set_annotation(isl::id annotation) const {
+  auto res = isl_ast_node_set_annotation(copy(), annotation.release());
+  return manage(res);
+}
+
+std::string ast_node::to_C_str() const {
+  auto res = isl_ast_node_to_C_str(get());
+  std::string tmp(res);
+  free(res);
+  return tmp;
+}
+
+isl::ast_expr ast_node::user_get_expr() const {
+  auto res = isl_ast_node_user_get_expr(get());
+  return manage(res);
+}
+
+// implementations for isl::ast_node_list
+isl::ast_node_list manage(__isl_take isl_ast_node_list *ptr) {
+  return ast_node_list(ptr);
+}
+isl::ast_node_list give(__isl_take isl_ast_node_list *ptr) {
+  return manage(ptr);
+}
+
+
+ast_node_list::ast_node_list()
+    : ptr(nullptr) {}
+
+ast_node_list::ast_node_list(const isl::ast_node_list &obj)
+    : ptr(obj.copy()) {}
+ast_node_list::ast_node_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+ast_node_list::ast_node_list(__isl_take isl_ast_node_list *ptr)
+    : ptr(ptr) {}
+
+
+ast_node_list &ast_node_list::operator=(isl::ast_node_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+ast_node_list::~ast_node_list() {
+  if (ptr)
+    isl_ast_node_list_free(ptr);
+}
+
+__isl_give isl_ast_node_list *ast_node_list::copy() const & {
+  return isl_ast_node_list_copy(ptr);
+}
+
+__isl_keep isl_ast_node_list *ast_node_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_ast_node_list *ast_node_list::release() {
+  isl_ast_node_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool ast_node_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_ast_node_list *ast_node_list::keep() const {
+  return get();
+}
+
+__isl_give isl_ast_node_list *ast_node_list::take() {
+  return release();
+}
+
+ast_node_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx ast_node_list::get_ctx() const {
+  return isl::ctx(isl_ast_node_list_get_ctx(ptr));
+}
+
+
+
+void ast_node_list::dump() const {
+  isl_ast_node_list_dump(get());
+}
+
+
+
+// implementations for isl::band_list
+isl::band_list manage(__isl_take isl_band_list *ptr) {
+  return band_list(ptr);
+}
+isl::band_list give(__isl_take isl_band_list *ptr) {
+  return manage(ptr);
+}
+
+
+band_list::band_list()
+    : ptr(nullptr) {}
+
+band_list::band_list(const isl::band_list &obj)
+    : ptr(obj.copy()) {}
+band_list::band_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+band_list::band_list(__isl_take isl_band_list *ptr)
+    : ptr(ptr) {}
+
+
+band_list &band_list::operator=(isl::band_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+band_list::~band_list() {
+  if (ptr)
+    isl_band_list_free(ptr);
+}
+
+__isl_give isl_band_list *band_list::copy() const & {
+  return isl_band_list_copy(ptr);
+}
+
+__isl_keep isl_band_list *band_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_band_list *band_list::release() {
+  isl_band_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool band_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_band_list *band_list::keep() const {
+  return get();
+}
+
+__isl_give isl_band_list *band_list::take() {
+  return release();
+}
+
+band_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx band_list::get_ctx() const {
+  return isl::ctx(isl_band_list_get_ctx(ptr));
+}
+
+
+
+void band_list::dump() const {
+  isl_band_list_dump(get());
+}
+
+
+
+// implementations for isl::basic_map
+isl::basic_map manage(__isl_take isl_basic_map *ptr) {
+  return basic_map(ptr);
+}
+isl::basic_map give(__isl_take isl_basic_map *ptr) {
+  return manage(ptr);
+}
+
+
+basic_map::basic_map()
+    : ptr(nullptr) {}
+
+basic_map::basic_map(const isl::basic_map &obj)
+    : ptr(obj.copy()) {}
+basic_map::basic_map(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+basic_map::basic_map(__isl_take isl_basic_map *ptr)
+    : ptr(ptr) {}
+
+basic_map::basic_map(isl::ctx ctx, const std::string &str) {
+  auto res = isl_basic_map_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+basic_map &basic_map::operator=(isl::basic_map obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+basic_map::~basic_map() {
+  if (ptr)
+    isl_basic_map_free(ptr);
+}
+
+__isl_give isl_basic_map *basic_map::copy() const & {
+  return isl_basic_map_copy(ptr);
+}
+
+__isl_keep isl_basic_map *basic_map::get() const {
+  return ptr;
+}
+
+__isl_give isl_basic_map *basic_map::release() {
+  isl_basic_map *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool basic_map::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_basic_map *basic_map::keep() const {
+  return get();
+}
+
+__isl_give isl_basic_map *basic_map::take() {
+  return release();
+}
+
+basic_map::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx basic_map::get_ctx() const {
+  return isl::ctx(isl_basic_map_get_ctx(ptr));
+}
+
+
+std::string basic_map::to_str() const {
+  char *Tmp = isl_basic_map_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void basic_map::dump() const {
+  isl_basic_map_dump(get());
+}
+
+
+isl::basic_map basic_map::add_constraint(isl::constraint constraint) const {
+  auto res = isl_basic_map_add_constraint(copy(), constraint.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_basic_map_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::affine_hull() const {
+  auto res = isl_basic_map_affine_hull(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::align_params(isl::space model) const {
+  auto res = isl_basic_map_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::apply_domain(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_apply_domain(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::apply_range(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_apply_range(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::boolean basic_map::can_curry() const {
+  auto res = isl_basic_map_can_curry(get());
+  return manage(res);
+}
+
+isl::boolean basic_map::can_uncurry() const {
+  auto res = isl_basic_map_can_uncurry(get());
+  return manage(res);
+}
+
+isl::boolean basic_map::can_zip() const {
+  auto res = isl_basic_map_can_zip(get());
+  return manage(res);
+}
+
+isl::basic_map basic_map::curry() const {
+  auto res = isl_basic_map_curry(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_map::deltas() const {
+  auto res = isl_basic_map_deltas(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::deltas_map() const {
+  auto res = isl_basic_map_deltas_map(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::detect_equalities() const {
+  auto res = isl_basic_map_detect_equalities(copy());
+  return manage(res);
+}
+
+unsigned int basic_map::dim(isl::dim type) const {
+  auto res = isl_basic_map_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::basic_set basic_map::domain() const {
+  auto res = isl_basic_map_domain(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::domain_map() const {
+  auto res = isl_basic_map_domain_map(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::domain_product(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_domain_product(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_map_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_map_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::eliminate(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_map_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::empty(isl::space dim) {
+  auto res = isl_basic_map_empty(dim.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::equal(isl::space dim, unsigned int n_equal) {
+  auto res = isl_basic_map_equal(dim.release(), n_equal);
+  return manage(res);
+}
+
+isl::basic_map basic_map::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_basic_map_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+int basic_map::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_basic_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::basic_map basic_map::fix_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_basic_map_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::basic_map basic_map::fix_val(isl::dim type, unsigned int pos, isl::val v) const {
+  auto res = isl_basic_map_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::flat_product(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_flat_product(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::flat_range_product(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_flat_range_product(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::flatten() const {
+  auto res = isl_basic_map_flatten(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::flatten_domain() const {
+  auto res = isl_basic_map_flatten_domain(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::flatten_range() const {
+  auto res = isl_basic_map_flatten_range(copy());
+  return manage(res);
+}
+
+isl::stat basic_map::foreach_constraint(const std::function<isl::stat(isl::constraint)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::constraint)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_basic_map_foreach_constraint(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::basic_map basic_map::from_aff(isl::aff aff) {
+  auto res = isl_basic_map_from_aff(aff.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::from_aff_list(isl::space domain_dim, isl::aff_list list) {
+  auto res = isl_basic_map_from_aff_list(domain_dim.release(), list.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::from_constraint(isl::constraint constraint) {
+  auto res = isl_basic_map_from_constraint(constraint.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::from_domain(isl::basic_set bset) {
+  auto res = isl_basic_map_from_domain(bset.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::from_domain_and_range(isl::basic_set domain, isl::basic_set range) {
+  auto res = isl_basic_map_from_domain_and_range(domain.release(), range.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::from_multi_aff(isl::multi_aff maff) {
+  auto res = isl_basic_map_from_multi_aff(maff.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::from_qpolynomial(isl::qpolynomial qp) {
+  auto res = isl_basic_map_from_qpolynomial(qp.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::from_range(isl::basic_set bset) {
+  auto res = isl_basic_map_from_range(bset.release());
+  return manage(res);
+}
+
+isl::constraint_list basic_map::get_constraint_list() const {
+  auto res = isl_basic_map_get_constraint_list(get());
+  return manage(res);
+}
+
+std::string basic_map::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_basic_map_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::aff basic_map::get_div(int pos) const {
+  auto res = isl_basic_map_get_div(get(), pos);
+  return manage(res);
+}
+
+isl::local_space basic_map::get_local_space() const {
+  auto res = isl_basic_map_get_local_space(get());
+  return manage(res);
+}
+
+isl::space basic_map::get_space() const {
+  auto res = isl_basic_map_get_space(get());
+  return manage(res);
+}
+
+std::string basic_map::get_tuple_name(isl::dim type) const {
+  auto res = isl_basic_map_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::basic_map basic_map::gist(isl::basic_map context) const {
+  auto res = isl_basic_map_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::gist_domain(isl::basic_set context) const {
+  auto res = isl_basic_map_gist_domain(copy(), context.release());
+  return manage(res);
+}
+
+isl::boolean basic_map::has_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_basic_map_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::basic_map basic_map::identity(isl::space dim) {
+  auto res = isl_basic_map_identity(dim.release());
+  return manage(res);
+}
+
+isl::boolean basic_map::image_is_bounded() const {
+  auto res = isl_basic_map_image_is_bounded(get());
+  return manage(res);
+}
+
+isl::basic_map basic_map::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const {
+  auto res = isl_basic_map_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::intersect(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_intersect(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::intersect_domain(isl::basic_set bset) const {
+  auto res = isl_basic_map_intersect_domain(copy(), bset.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::intersect_range(isl::basic_set bset) const {
+  auto res = isl_basic_map_intersect_range(copy(), bset.release());
+  return manage(res);
+}
+
+isl::boolean basic_map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean basic_map::is_disjoint(const isl::basic_map &bmap2) const {
+  auto res = isl_basic_map_is_disjoint(get(), bmap2.get());
+  return manage(res);
+}
+
+isl::boolean basic_map::is_empty() const {
+  auto res = isl_basic_map_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean basic_map::is_equal(const isl::basic_map &bmap2) const {
+  auto res = isl_basic_map_is_equal(get(), bmap2.get());
+  return manage(res);
+}
+
+isl::boolean basic_map::is_rational() const {
+  auto res = isl_basic_map_is_rational(get());
+  return manage(res);
+}
+
+isl::boolean basic_map::is_single_valued() const {
+  auto res = isl_basic_map_is_single_valued(get());
+  return manage(res);
+}
+
+isl::boolean basic_map::is_strict_subset(const isl::basic_map &bmap2) const {
+  auto res = isl_basic_map_is_strict_subset(get(), bmap2.get());
+  return manage(res);
+}
+
+isl::boolean basic_map::is_subset(const isl::basic_map &bmap2) const {
+  auto res = isl_basic_map_is_subset(get(), bmap2.get());
+  return manage(res);
+}
+
+isl::boolean basic_map::is_universe() const {
+  auto res = isl_basic_map_is_universe(get());
+  return manage(res);
+}
+
+isl::basic_map basic_map::less_at(isl::space dim, unsigned int pos) {
+  auto res = isl_basic_map_less_at(dim.release(), pos);
+  return manage(res);
+}
+
+isl::map basic_map::lexmax() const {
+  auto res = isl_basic_map_lexmax(copy());
+  return manage(res);
+}
+
+isl::map basic_map::lexmin() const {
+  auto res = isl_basic_map_lexmin(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff basic_map::lexmin_pw_multi_aff() const {
+  auto res = isl_basic_map_lexmin_pw_multi_aff(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::lower_bound_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_basic_map_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::basic_map basic_map::more_at(isl::space dim, unsigned int pos) {
+  auto res = isl_basic_map_more_at(dim.release(), pos);
+  return manage(res);
+}
+
+isl::basic_map basic_map::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_basic_map_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::nat_universe(isl::space dim) {
+  auto res = isl_basic_map_nat_universe(dim.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::neg() const {
+  auto res = isl_basic_map_neg(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_basic_map_order_ge(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::basic_map basic_map::order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_basic_map_order_gt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::val basic_map::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const {
+  auto res = isl_basic_map_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean basic_map::plain_is_empty() const {
+  auto res = isl_basic_map_plain_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean basic_map::plain_is_universe() const {
+  auto res = isl_basic_map_plain_is_universe(get());
+  return manage(res);
+}
+
+isl::basic_map basic_map::preimage_domain_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_basic_map_preimage_domain_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::preimage_range_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_basic_map_preimage_range_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::product(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_product(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::project_out(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set basic_map::range() const {
+  auto res = isl_basic_map_range(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::range_map() const {
+  auto res = isl_basic_map_range_map(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::range_product(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_range_product(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::remove_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_map_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::remove_divs() const {
+  auto res = isl_basic_map_remove_divs(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_map_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_map basic_map::remove_redundancies() const {
+  auto res = isl_basic_map_remove_redundancies(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::reverse() const {
+  auto res = isl_basic_map_reverse(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::sample() const {
+  auto res = isl_basic_map_sample(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_basic_map_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::set_tuple_name(isl::dim type, const std::string &s) const {
+  auto res = isl_basic_map_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());
+  return manage(res);
+}
+
+isl::basic_map basic_map::sum(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_sum(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::uncurry() const {
+  auto res = isl_basic_map_uncurry(copy());
+  return manage(res);
+}
+
+isl::map basic_map::unite(isl::basic_map bmap2) const {
+  auto res = isl_basic_map_union(copy(), bmap2.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::universe(isl::space dim) {
+  auto res = isl_basic_map_universe(dim.release());
+  return manage(res);
+}
+
+isl::basic_map basic_map::upper_bound_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_basic_map_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::basic_set basic_map::wrap() const {
+  auto res = isl_basic_map_wrap(copy());
+  return manage(res);
+}
+
+isl::basic_map basic_map::zip() const {
+  auto res = isl_basic_map_zip(copy());
+  return manage(res);
+}
+
+// implementations for isl::basic_map_list
+isl::basic_map_list manage(__isl_take isl_basic_map_list *ptr) {
+  return basic_map_list(ptr);
+}
+isl::basic_map_list give(__isl_take isl_basic_map_list *ptr) {
+  return manage(ptr);
+}
+
+
+basic_map_list::basic_map_list()
+    : ptr(nullptr) {}
+
+basic_map_list::basic_map_list(const isl::basic_map_list &obj)
+    : ptr(obj.copy()) {}
+basic_map_list::basic_map_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+basic_map_list::basic_map_list(__isl_take isl_basic_map_list *ptr)
+    : ptr(ptr) {}
+
+
+basic_map_list &basic_map_list::operator=(isl::basic_map_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+basic_map_list::~basic_map_list() {
+  if (ptr)
+    isl_basic_map_list_free(ptr);
+}
+
+__isl_give isl_basic_map_list *basic_map_list::copy() const & {
+  return isl_basic_map_list_copy(ptr);
+}
+
+__isl_keep isl_basic_map_list *basic_map_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_basic_map_list *basic_map_list::release() {
+  isl_basic_map_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool basic_map_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_basic_map_list *basic_map_list::keep() const {
+  return get();
+}
+
+__isl_give isl_basic_map_list *basic_map_list::take() {
+  return release();
+}
+
+basic_map_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx basic_map_list::get_ctx() const {
+  return isl::ctx(isl_basic_map_list_get_ctx(ptr));
+}
+
+
+
+void basic_map_list::dump() const {
+  isl_basic_map_list_dump(get());
+}
+
+
+
+// implementations for isl::basic_set
+isl::basic_set manage(__isl_take isl_basic_set *ptr) {
+  return basic_set(ptr);
+}
+isl::basic_set give(__isl_take isl_basic_set *ptr) {
+  return manage(ptr);
+}
+
+
+basic_set::basic_set()
+    : ptr(nullptr) {}
+
+basic_set::basic_set(const isl::basic_set &obj)
+    : ptr(obj.copy()) {}
+basic_set::basic_set(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+basic_set::basic_set(__isl_take isl_basic_set *ptr)
+    : ptr(ptr) {}
+
+basic_set::basic_set(isl::ctx ctx, const std::string &str) {
+  auto res = isl_basic_set_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+basic_set::basic_set(isl::point pnt) {
+  auto res = isl_basic_set_from_point(pnt.release());
+  ptr = res;
+}
+
+basic_set &basic_set::operator=(isl::basic_set obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+basic_set::~basic_set() {
+  if (ptr)
+    isl_basic_set_free(ptr);
+}
+
+__isl_give isl_basic_set *basic_set::copy() const & {
+  return isl_basic_set_copy(ptr);
+}
+
+__isl_keep isl_basic_set *basic_set::get() const {
+  return ptr;
+}
+
+__isl_give isl_basic_set *basic_set::release() {
+  isl_basic_set *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool basic_set::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_basic_set *basic_set::keep() const {
+  return get();
+}
+
+__isl_give isl_basic_set *basic_set::take() {
+  return release();
+}
+
+basic_set::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx basic_set::get_ctx() const {
+  return isl::ctx(isl_basic_set_get_ctx(ptr));
+}
+
+
+std::string basic_set::to_str() const {
+  char *Tmp = isl_basic_set_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void basic_set::dump() const {
+  isl_basic_set_dump(get());
+}
+
+
+isl::basic_set basic_set::affine_hull() const {
+  auto res = isl_basic_set_affine_hull(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::align_params(isl::space model) const {
+  auto res = isl_basic_set_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::apply(isl::basic_map bmap) const {
+  auto res = isl_basic_set_apply(copy(), bmap.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::box_from_points(isl::point pnt1, isl::point pnt2) {
+  auto res = isl_basic_set_box_from_points(pnt1.release(), pnt2.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::coefficients() const {
+  auto res = isl_basic_set_coefficients(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::detect_equalities() const {
+  auto res = isl_basic_set_detect_equalities(copy());
+  return manage(res);
+}
+
+unsigned int basic_set::dim(isl::dim type) const {
+  auto res = isl_basic_set_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::basic_set basic_set::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_set_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_set_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::eliminate(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_set_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::empty(isl::space dim) {
+  auto res = isl_basic_set_empty(dim.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::fix_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_basic_set_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::basic_set basic_set::fix_val(isl::dim type, unsigned int pos, isl::val v) const {
+  auto res = isl_basic_set_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::flat_product(isl::basic_set bset2) const {
+  auto res = isl_basic_set_flat_product(copy(), bset2.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::flatten() const {
+  auto res = isl_basic_set_flatten(copy());
+  return manage(res);
+}
+
+isl::stat basic_set::foreach_bound_pair(isl::dim type, unsigned int pos, const std::function<isl::stat(isl::constraint, isl::constraint, isl::basic_set)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_constraint *arg_0, isl_constraint *arg_1, isl_basic_set *arg_2, void *arg_3) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::constraint, isl::constraint, isl::basic_set)> **>(arg_3);
+    stat ret = (*func)(isl::manage(arg_0), isl::manage(arg_1), isl::manage(arg_2));
+    return isl_stat(ret);
+  };
+  auto res = isl_basic_set_foreach_bound_pair(get(), static_cast<enum isl_dim_type>(type), pos, fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::stat basic_set::foreach_constraint(const std::function<isl::stat(isl::constraint)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::constraint)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_basic_set_foreach_constraint(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::basic_set basic_set::from_constraint(isl::constraint constraint) {
+  auto res = isl_basic_set_from_constraint(constraint.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::from_params() const {
+  auto res = isl_basic_set_from_params(copy());
+  return manage(res);
+}
+
+isl::constraint_list basic_set::get_constraint_list() const {
+  auto res = isl_basic_set_get_constraint_list(get());
+  return manage(res);
+}
+
+isl::id basic_set::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_basic_set_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+std::string basic_set::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_basic_set_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::aff basic_set::get_div(int pos) const {
+  auto res = isl_basic_set_get_div(get(), pos);
+  return manage(res);
+}
+
+isl::local_space basic_set::get_local_space() const {
+  auto res = isl_basic_set_get_local_space(get());
+  return manage(res);
+}
+
+isl::space basic_set::get_space() const {
+  auto res = isl_basic_set_get_space(get());
+  return manage(res);
+}
+
+std::string basic_set::get_tuple_name() const {
+  auto res = isl_basic_set_get_tuple_name(get());
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::basic_set basic_set::gist(isl::basic_set context) const {
+  auto res = isl_basic_set_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const {
+  auto res = isl_basic_set_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::intersect(isl::basic_set bset2) const {
+  auto res = isl_basic_set_intersect(copy(), bset2.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::intersect_params(isl::basic_set bset2) const {
+  auto res = isl_basic_set_intersect_params(copy(), bset2.release());
+  return manage(res);
+}
+
+isl::boolean basic_set::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_set_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean basic_set::is_bounded() const {
+  auto res = isl_basic_set_is_bounded(get());
+  return manage(res);
+}
+
+isl::boolean basic_set::is_disjoint(const isl::basic_set &bset2) const {
+  auto res = isl_basic_set_is_disjoint(get(), bset2.get());
+  return manage(res);
+}
+
+isl::boolean basic_set::is_empty() const {
+  auto res = isl_basic_set_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean basic_set::is_equal(const isl::basic_set &bset2) const {
+  auto res = isl_basic_set_is_equal(get(), bset2.get());
+  return manage(res);
+}
+
+int basic_set::is_rational() const {
+  auto res = isl_basic_set_is_rational(get());
+  return res;
+}
+
+isl::boolean basic_set::is_subset(const isl::basic_set &bset2) const {
+  auto res = isl_basic_set_is_subset(get(), bset2.get());
+  return manage(res);
+}
+
+isl::boolean basic_set::is_universe() const {
+  auto res = isl_basic_set_is_universe(get());
+  return manage(res);
+}
+
+isl::boolean basic_set::is_wrapping() const {
+  auto res = isl_basic_set_is_wrapping(get());
+  return manage(res);
+}
+
+isl::set basic_set::lexmax() const {
+  auto res = isl_basic_set_lexmax(copy());
+  return manage(res);
+}
+
+isl::set basic_set::lexmin() const {
+  auto res = isl_basic_set_lexmin(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::lower_bound_val(isl::dim type, unsigned int pos, isl::val value) const {
+  auto res = isl_basic_set_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());
+  return manage(res);
+}
+
+isl::val basic_set::max_val(const isl::aff &obj) const {
+  auto res = isl_basic_set_max_val(get(), obj.get());
+  return manage(res);
+}
+
+isl::basic_set basic_set::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_basic_set_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::nat_universe(isl::space dim) {
+  auto res = isl_basic_set_nat_universe(dim.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::neg() const {
+  auto res = isl_basic_set_neg(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::params() const {
+  auto res = isl_basic_set_params(copy());
+  return manage(res);
+}
+
+isl::boolean basic_set::plain_is_empty() const {
+  auto res = isl_basic_set_plain_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean basic_set::plain_is_equal(const isl::basic_set &bset2) const {
+  auto res = isl_basic_set_plain_is_equal(get(), bset2.get());
+  return manage(res);
+}
+
+isl::boolean basic_set::plain_is_universe() const {
+  auto res = isl_basic_set_plain_is_universe(get());
+  return manage(res);
+}
+
+isl::basic_set basic_set::positive_orthant(isl::space space) {
+  auto res = isl_basic_set_positive_orthant(space.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::preimage_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_basic_set_preimage_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::project_out(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::remove_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_set_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::remove_divs() const {
+  auto res = isl_basic_set_remove_divs(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_basic_set_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::basic_set basic_set::remove_redundancies() const {
+  auto res = isl_basic_set_remove_redundancies(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::remove_unknown_divs() const {
+  auto res = isl_basic_set_remove_unknown_divs(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::sample() const {
+  auto res = isl_basic_set_sample(copy());
+  return manage(res);
+}
+
+isl::point basic_set::sample_point() const {
+  auto res = isl_basic_set_sample_point(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::set_tuple_id(isl::id id) const {
+  auto res = isl_basic_set_set_tuple_id(copy(), id.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::set_tuple_name(const std::string &s) const {
+  auto res = isl_basic_set_set_tuple_name(copy(), s.c_str());
+  return manage(res);
+}
+
+isl::basic_set basic_set::solutions() const {
+  auto res = isl_basic_set_solutions(copy());
+  return manage(res);
+}
+
+isl::set basic_set::unite(isl::basic_set bset2) const {
+  auto res = isl_basic_set_union(copy(), bset2.release());
+  return manage(res);
+}
+
+isl::basic_set basic_set::universe(isl::space dim) {
+  auto res = isl_basic_set_universe(dim.release());
+  return manage(res);
+}
+
+isl::basic_map basic_set::unwrap() const {
+  auto res = isl_basic_set_unwrap(copy());
+  return manage(res);
+}
+
+isl::basic_set basic_set::upper_bound_val(isl::dim type, unsigned int pos, isl::val value) const {
+  auto res = isl_basic_set_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());
+  return manage(res);
+}
+
+// implementations for isl::basic_set_list
+isl::basic_set_list manage(__isl_take isl_basic_set_list *ptr) {
+  return basic_set_list(ptr);
+}
+isl::basic_set_list give(__isl_take isl_basic_set_list *ptr) {
+  return manage(ptr);
+}
+
+
+basic_set_list::basic_set_list()
+    : ptr(nullptr) {}
+
+basic_set_list::basic_set_list(const isl::basic_set_list &obj)
+    : ptr(obj.copy()) {}
+basic_set_list::basic_set_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+basic_set_list::basic_set_list(__isl_take isl_basic_set_list *ptr)
+    : ptr(ptr) {}
+
+
+basic_set_list &basic_set_list::operator=(isl::basic_set_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+basic_set_list::~basic_set_list() {
+  if (ptr)
+    isl_basic_set_list_free(ptr);
+}
+
+__isl_give isl_basic_set_list *basic_set_list::copy() const & {
+  return isl_basic_set_list_copy(ptr);
+}
+
+__isl_keep isl_basic_set_list *basic_set_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_basic_set_list *basic_set_list::release() {
+  isl_basic_set_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool basic_set_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_basic_set_list *basic_set_list::keep() const {
+  return get();
+}
+
+__isl_give isl_basic_set_list *basic_set_list::take() {
+  return release();
+}
+
+basic_set_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx basic_set_list::get_ctx() const {
+  return isl::ctx(isl_basic_set_list_get_ctx(ptr));
+}
+
+
+
+void basic_set_list::dump() const {
+  isl_basic_set_list_dump(get());
+}
+
+
+
+// implementations for isl::constraint
+isl::constraint manage(__isl_take isl_constraint *ptr) {
+  return constraint(ptr);
+}
+isl::constraint give(__isl_take isl_constraint *ptr) {
+  return manage(ptr);
+}
+
+
+constraint::constraint()
+    : ptr(nullptr) {}
+
+constraint::constraint(const isl::constraint &obj)
+    : ptr(obj.copy()) {}
+constraint::constraint(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+constraint::constraint(__isl_take isl_constraint *ptr)
+    : ptr(ptr) {}
+
+
+constraint &constraint::operator=(isl::constraint obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+constraint::~constraint() {
+  if (ptr)
+    isl_constraint_free(ptr);
+}
+
+__isl_give isl_constraint *constraint::copy() const & {
+  return isl_constraint_copy(ptr);
+}
+
+__isl_keep isl_constraint *constraint::get() const {
+  return ptr;
+}
+
+__isl_give isl_constraint *constraint::release() {
+  isl_constraint *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool constraint::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_constraint *constraint::keep() const {
+  return get();
+}
+
+__isl_give isl_constraint *constraint::take() {
+  return release();
+}
+
+constraint::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx constraint::get_ctx() const {
+  return isl::ctx(isl_constraint_get_ctx(ptr));
+}
+
+
+
+void constraint::dump() const {
+  isl_constraint_dump(get());
+}
+
+
+isl::constraint constraint::alloc_equality(isl::local_space ls) {
+  auto res = isl_constraint_alloc_equality(ls.release());
+  return manage(res);
+}
+
+isl::constraint constraint::alloc_inequality(isl::local_space ls) {
+  auto res = isl_constraint_alloc_inequality(ls.release());
+  return manage(res);
+}
+
+int constraint::cmp_last_non_zero(const isl::constraint &c2) const {
+  auto res = isl_constraint_cmp_last_non_zero(get(), c2.get());
+  return res;
+}
+
+isl::aff constraint::get_aff() const {
+  auto res = isl_constraint_get_aff(get());
+  return manage(res);
+}
+
+isl::aff constraint::get_bound(isl::dim type, int pos) const {
+  auto res = isl_constraint_get_bound(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::val constraint::get_coefficient_val(isl::dim type, int pos) const {
+  auto res = isl_constraint_get_coefficient_val(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::val constraint::get_constant_val() const {
+  auto res = isl_constraint_get_constant_val(get());
+  return manage(res);
+}
+
+std::string constraint::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_constraint_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::aff constraint::get_div(int pos) const {
+  auto res = isl_constraint_get_div(get(), pos);
+  return manage(res);
+}
+
+isl::local_space constraint::get_local_space() const {
+  auto res = isl_constraint_get_local_space(get());
+  return manage(res);
+}
+
+isl::space constraint::get_space() const {
+  auto res = isl_constraint_get_space(get());
+  return manage(res);
+}
+
+isl::boolean constraint::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_constraint_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+int constraint::is_div_constraint() const {
+  auto res = isl_constraint_is_div_constraint(get());
+  return res;
+}
+
+isl::boolean constraint::is_lower_bound(isl::dim type, unsigned int pos) const {
+  auto res = isl_constraint_is_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean constraint::is_upper_bound(isl::dim type, unsigned int pos) const {
+  auto res = isl_constraint_is_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+int constraint::plain_cmp(const isl::constraint &c2) const {
+  auto res = isl_constraint_plain_cmp(get(), c2.get());
+  return res;
+}
+
+isl::constraint constraint::set_coefficient_si(isl::dim type, int pos, int v) const {
+  auto res = isl_constraint_set_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);
+  return manage(res);
+}
+
+isl::constraint constraint::set_coefficient_val(isl::dim type, int pos, isl::val v) const {
+  auto res = isl_constraint_set_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::constraint constraint::set_constant_si(int v) const {
+  auto res = isl_constraint_set_constant_si(copy(), v);
+  return manage(res);
+}
+
+isl::constraint constraint::set_constant_val(isl::val v) const {
+  auto res = isl_constraint_set_constant_val(copy(), v.release());
+  return manage(res);
+}
+
+// implementations for isl::constraint_list
+isl::constraint_list manage(__isl_take isl_constraint_list *ptr) {
+  return constraint_list(ptr);
+}
+isl::constraint_list give(__isl_take isl_constraint_list *ptr) {
+  return manage(ptr);
+}
+
+
+constraint_list::constraint_list()
+    : ptr(nullptr) {}
+
+constraint_list::constraint_list(const isl::constraint_list &obj)
+    : ptr(obj.copy()) {}
+constraint_list::constraint_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+constraint_list::constraint_list(__isl_take isl_constraint_list *ptr)
+    : ptr(ptr) {}
+
+
+constraint_list &constraint_list::operator=(isl::constraint_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+constraint_list::~constraint_list() {
+  if (ptr)
+    isl_constraint_list_free(ptr);
+}
+
+__isl_give isl_constraint_list *constraint_list::copy() const & {
+  return isl_constraint_list_copy(ptr);
+}
+
+__isl_keep isl_constraint_list *constraint_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_constraint_list *constraint_list::release() {
+  isl_constraint_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool constraint_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_constraint_list *constraint_list::keep() const {
+  return get();
+}
+
+__isl_give isl_constraint_list *constraint_list::take() {
+  return release();
+}
+
+constraint_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx constraint_list::get_ctx() const {
+  return isl::ctx(isl_constraint_list_get_ctx(ptr));
+}
+
+
+
+void constraint_list::dump() const {
+  isl_constraint_list_dump(get());
+}
+
+
+
+// implementations for isl::id
+isl::id manage(__isl_take isl_id *ptr) {
+  return id(ptr);
+}
+isl::id give(__isl_take isl_id *ptr) {
+  return manage(ptr);
+}
+
+
+id::id()
+    : ptr(nullptr) {}
+
+id::id(const isl::id &obj)
+    : ptr(obj.copy()) {}
+id::id(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+id::id(__isl_take isl_id *ptr)
+    : ptr(ptr) {}
+
+
+id &id::operator=(isl::id obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+id::~id() {
+  if (ptr)
+    isl_id_free(ptr);
+}
+
+__isl_give isl_id *id::copy() const & {
+  return isl_id_copy(ptr);
+}
+
+__isl_keep isl_id *id::get() const {
+  return ptr;
+}
+
+__isl_give isl_id *id::release() {
+  isl_id *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool id::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_id *id::keep() const {
+  return get();
+}
+
+__isl_give isl_id *id::take() {
+  return release();
+}
+
+id::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx id::get_ctx() const {
+  return isl::ctx(isl_id_get_ctx(ptr));
+}
+
+
+std::string id::to_str() const {
+  char *Tmp = isl_id_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void id::dump() const {
+  isl_id_dump(get());
+}
+
+
+isl::id id::alloc(isl::ctx ctx, const std::string &name, void * user) {
+  auto res = isl_id_alloc(ctx.release(), name.c_str(), user);
+  return manage(res);
+}
+
+uint32_t id::get_hash() const {
+  auto res = isl_id_get_hash(get());
+  return res;
+}
+
+std::string id::get_name() const {
+  auto res = isl_id_get_name(get());
+  std::string tmp(res);
+  return tmp;
+}
+
+void * id::get_user() const {
+  auto res = isl_id_get_user(get());
+  return res;
+}
+
+// implementations for isl::id_list
+isl::id_list manage(__isl_take isl_id_list *ptr) {
+  return id_list(ptr);
+}
+isl::id_list give(__isl_take isl_id_list *ptr) {
+  return manage(ptr);
+}
+
+
+id_list::id_list()
+    : ptr(nullptr) {}
+
+id_list::id_list(const isl::id_list &obj)
+    : ptr(obj.copy()) {}
+id_list::id_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+id_list::id_list(__isl_take isl_id_list *ptr)
+    : ptr(ptr) {}
+
+
+id_list &id_list::operator=(isl::id_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+id_list::~id_list() {
+  if (ptr)
+    isl_id_list_free(ptr);
+}
+
+__isl_give isl_id_list *id_list::copy() const & {
+  return isl_id_list_copy(ptr);
+}
+
+__isl_keep isl_id_list *id_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_id_list *id_list::release() {
+  isl_id_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool id_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_id_list *id_list::keep() const {
+  return get();
+}
+
+__isl_give isl_id_list *id_list::take() {
+  return release();
+}
+
+id_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx id_list::get_ctx() const {
+  return isl::ctx(isl_id_list_get_ctx(ptr));
+}
+
+
+
+void id_list::dump() const {
+  isl_id_list_dump(get());
+}
+
+
+
+// implementations for isl::id_to_ast_expr
+isl::id_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr) {
+  return id_to_ast_expr(ptr);
+}
+isl::id_to_ast_expr give(__isl_take isl_id_to_ast_expr *ptr) {
+  return manage(ptr);
+}
+
+
+id_to_ast_expr::id_to_ast_expr()
+    : ptr(nullptr) {}
+
+id_to_ast_expr::id_to_ast_expr(const isl::id_to_ast_expr &obj)
+    : ptr(obj.copy()) {}
+id_to_ast_expr::id_to_ast_expr(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+id_to_ast_expr::id_to_ast_expr(__isl_take isl_id_to_ast_expr *ptr)
+    : ptr(ptr) {}
+
+
+id_to_ast_expr &id_to_ast_expr::operator=(isl::id_to_ast_expr obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+id_to_ast_expr::~id_to_ast_expr() {
+  if (ptr)
+    isl_id_to_ast_expr_free(ptr);
+}
+
+__isl_give isl_id_to_ast_expr *id_to_ast_expr::copy() const & {
+  return isl_id_to_ast_expr_copy(ptr);
+}
+
+__isl_keep isl_id_to_ast_expr *id_to_ast_expr::get() const {
+  return ptr;
+}
+
+__isl_give isl_id_to_ast_expr *id_to_ast_expr::release() {
+  isl_id_to_ast_expr *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool id_to_ast_expr::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_id_to_ast_expr *id_to_ast_expr::keep() const {
+  return get();
+}
+
+__isl_give isl_id_to_ast_expr *id_to_ast_expr::take() {
+  return release();
+}
+
+id_to_ast_expr::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx id_to_ast_expr::get_ctx() const {
+  return isl::ctx(isl_id_to_ast_expr_get_ctx(ptr));
+}
+
+
+
+void id_to_ast_expr::dump() const {
+  isl_id_to_ast_expr_dump(get());
+}
+
+
+isl::id_to_ast_expr id_to_ast_expr::alloc(isl::ctx ctx, int min_size) {
+  auto res = isl_id_to_ast_expr_alloc(ctx.release(), min_size);
+  return manage(res);
+}
+
+isl::id_to_ast_expr id_to_ast_expr::drop(isl::id key) const {
+  auto res = isl_id_to_ast_expr_drop(copy(), key.release());
+  return manage(res);
+}
+
+isl::stat id_to_ast_expr::foreach(const std::function<isl::stat(isl::id, isl::ast_expr)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_id *arg_0, isl_ast_expr *arg_1, void *arg_2) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::id, isl::ast_expr)> **>(arg_2);
+    stat ret = (*func)(isl::manage(arg_0), isl::manage(arg_1));
+    return isl_stat(ret);
+  };
+  auto res = isl_id_to_ast_expr_foreach(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::ast_expr id_to_ast_expr::get(isl::id key) const {
+  auto res = isl_id_to_ast_expr_get(get(), key.release());
+  return manage(res);
+}
+
+isl::boolean id_to_ast_expr::has(const isl::id &key) const {
+  auto res = isl_id_to_ast_expr_has(get(), key.get());
+  return manage(res);
+}
+
+isl::id_to_ast_expr id_to_ast_expr::set(isl::id key, isl::ast_expr val) const {
+  auto res = isl_id_to_ast_expr_set(copy(), key.release(), val.release());
+  return manage(res);
+}
+
+// implementations for isl::local_space
+isl::local_space manage(__isl_take isl_local_space *ptr) {
+  return local_space(ptr);
+}
+isl::local_space give(__isl_take isl_local_space *ptr) {
+  return manage(ptr);
+}
+
+
+local_space::local_space()
+    : ptr(nullptr) {}
+
+local_space::local_space(const isl::local_space &obj)
+    : ptr(obj.copy()) {}
+local_space::local_space(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+local_space::local_space(__isl_take isl_local_space *ptr)
+    : ptr(ptr) {}
+
+local_space::local_space(isl::space dim) {
+  auto res = isl_local_space_from_space(dim.release());
+  ptr = res;
+}
+
+local_space &local_space::operator=(isl::local_space obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+local_space::~local_space() {
+  if (ptr)
+    isl_local_space_free(ptr);
+}
+
+__isl_give isl_local_space *local_space::copy() const & {
+  return isl_local_space_copy(ptr);
+}
+
+__isl_keep isl_local_space *local_space::get() const {
+  return ptr;
+}
+
+__isl_give isl_local_space *local_space::release() {
+  isl_local_space *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool local_space::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_local_space *local_space::keep() const {
+  return get();
+}
+
+__isl_give isl_local_space *local_space::take() {
+  return release();
+}
+
+local_space::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx local_space::get_ctx() const {
+  return isl::ctx(isl_local_space_get_ctx(ptr));
+}
+
+
+
+void local_space::dump() const {
+  isl_local_space_dump(get());
+}
+
+
+isl::local_space local_space::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_local_space_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+int local_space::dim(isl::dim type) const {
+  auto res = isl_local_space_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::local_space local_space::domain() const {
+  auto res = isl_local_space_domain(copy());
+  return manage(res);
+}
+
+isl::local_space local_space::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_local_space_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+int local_space::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_local_space_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::local_space local_space::flatten_domain() const {
+  auto res = isl_local_space_flatten_domain(copy());
+  return manage(res);
+}
+
+isl::local_space local_space::flatten_range() const {
+  auto res = isl_local_space_flatten_range(copy());
+  return manage(res);
+}
+
+isl::local_space local_space::from_domain() const {
+  auto res = isl_local_space_from_domain(copy());
+  return manage(res);
+}
+
+isl::id local_space::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_local_space_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+std::string local_space::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_local_space_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::aff local_space::get_div(int pos) const {
+  auto res = isl_local_space_get_div(get(), pos);
+  return manage(res);
+}
+
+isl::space local_space::get_space() const {
+  auto res = isl_local_space_get_space(get());
+  return manage(res);
+}
+
+isl::boolean local_space::has_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_local_space_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean local_space::has_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_local_space_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::local_space local_space::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_local_space_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::local_space local_space::intersect(isl::local_space ls2) const {
+  auto res = isl_local_space_intersect(copy(), ls2.release());
+  return manage(res);
+}
+
+isl::boolean local_space::is_equal(const isl::local_space &ls2) const {
+  auto res = isl_local_space_is_equal(get(), ls2.get());
+  return manage(res);
+}
+
+isl::boolean local_space::is_params() const {
+  auto res = isl_local_space_is_params(get());
+  return manage(res);
+}
+
+isl::boolean local_space::is_set() const {
+  auto res = isl_local_space_is_set(get());
+  return manage(res);
+}
+
+isl::local_space local_space::range() const {
+  auto res = isl_local_space_range(copy());
+  return manage(res);
+}
+
+isl::local_space local_space::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_local_space_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::local_space local_space::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_local_space_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::local_space local_space::wrap() const {
+  auto res = isl_local_space_wrap(copy());
+  return manage(res);
+}
+
+// implementations for isl::map
+isl::map manage(__isl_take isl_map *ptr) {
+  return map(ptr);
+}
+isl::map give(__isl_take isl_map *ptr) {
+  return manage(ptr);
+}
+
+
+map::map()
+    : ptr(nullptr) {}
+
+map::map(const isl::map &obj)
+    : ptr(obj.copy()) {}
+map::map(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+map::map(__isl_take isl_map *ptr)
+    : ptr(ptr) {}
+
+map::map(isl::ctx ctx, const std::string &str) {
+  auto res = isl_map_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+map::map(isl::basic_map bmap) {
+  auto res = isl_map_from_basic_map(bmap.release());
+  ptr = res;
+}
+
+map &map::operator=(isl::map obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+map::~map() {
+  if (ptr)
+    isl_map_free(ptr);
+}
+
+__isl_give isl_map *map::copy() const & {
+  return isl_map_copy(ptr);
+}
+
+__isl_keep isl_map *map::get() const {
+  return ptr;
+}
+
+__isl_give isl_map *map::release() {
+  isl_map *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool map::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_map *map::keep() const {
+  return get();
+}
+
+__isl_give isl_map *map::take() {
+  return release();
+}
+
+map::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx map::get_ctx() const {
+  return isl::ctx(isl_map_get_ctx(ptr));
+}
+
+
+std::string map::to_str() const {
+  char *Tmp = isl_map_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void map::dump() const {
+  isl_map_dump(get());
+}
+
+
+isl::map map::add_constraint(isl::constraint constraint) const {
+  auto res = isl_map_add_constraint(copy(), constraint.release());
+  return manage(res);
+}
+
+isl::map map::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_map_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::basic_map map::affine_hull() const {
+  auto res = isl_map_affine_hull(copy());
+  return manage(res);
+}
+
+isl::map map::align_params(isl::space model) const {
+  auto res = isl_map_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::map map::apply_domain(isl::map map2) const {
+  auto res = isl_map_apply_domain(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::apply_range(isl::map map2) const {
+  auto res = isl_map_apply_range(copy(), map2.release());
+  return manage(res);
+}
+
+isl::boolean map::can_curry() const {
+  auto res = isl_map_can_curry(get());
+  return manage(res);
+}
+
+isl::boolean map::can_range_curry() const {
+  auto res = isl_map_can_range_curry(get());
+  return manage(res);
+}
+
+isl::boolean map::can_uncurry() const {
+  auto res = isl_map_can_uncurry(get());
+  return manage(res);
+}
+
+isl::boolean map::can_zip() const {
+  auto res = isl_map_can_zip(get());
+  return manage(res);
+}
+
+isl::map map::coalesce() const {
+  auto res = isl_map_coalesce(copy());
+  return manage(res);
+}
+
+isl::map map::complement() const {
+  auto res = isl_map_complement(copy());
+  return manage(res);
+}
+
+isl::basic_map map::convex_hull() const {
+  auto res = isl_map_convex_hull(copy());
+  return manage(res);
+}
+
+isl::map map::curry() const {
+  auto res = isl_map_curry(copy());
+  return manage(res);
+}
+
+isl::set map::deltas() const {
+  auto res = isl_map_deltas(copy());
+  return manage(res);
+}
+
+isl::map map::deltas_map() const {
+  auto res = isl_map_deltas_map(copy());
+  return manage(res);
+}
+
+isl::map map::detect_equalities() const {
+  auto res = isl_map_detect_equalities(copy());
+  return manage(res);
+}
+
+unsigned int map::dim(isl::dim type) const {
+  auto res = isl_map_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::pw_aff map::dim_max(int pos) const {
+  auto res = isl_map_dim_max(copy(), pos);
+  return manage(res);
+}
+
+isl::pw_aff map::dim_min(int pos) const {
+  auto res = isl_map_dim_min(copy(), pos);
+  return manage(res);
+}
+
+isl::set map::domain() const {
+  auto res = isl_map_domain(copy());
+  return manage(res);
+}
+
+isl::map map::domain_factor_domain() const {
+  auto res = isl_map_domain_factor_domain(copy());
+  return manage(res);
+}
+
+isl::map map::domain_factor_range() const {
+  auto res = isl_map_domain_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean map::domain_is_wrapping() const {
+  auto res = isl_map_domain_is_wrapping(get());
+  return manage(res);
+}
+
+isl::map map::domain_map() const {
+  auto res = isl_map_domain_map(copy());
+  return manage(res);
+}
+
+isl::map map::domain_product(isl::map map2) const {
+  auto res = isl_map_domain_product(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_map_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::map map::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_map_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::map map::eliminate(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_map_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::map map::empty(isl::space dim) {
+  auto res = isl_map_empty(dim.release());
+  return manage(res);
+}
+
+isl::map map::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_map_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::map map::factor_domain() const {
+  auto res = isl_map_factor_domain(copy());
+  return manage(res);
+}
+
+isl::map map::factor_range() const {
+  auto res = isl_map_factor_range(copy());
+  return manage(res);
+}
+
+int map::find_dim_by_id(isl::dim type, const isl::id &id) const {
+  auto res = isl_map_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());
+  return res;
+}
+
+int map::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::map map::fix_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_map_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::map map::fix_val(isl::dim type, unsigned int pos, isl::val v) const {
+  auto res = isl_map_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::map map::fixed_power_val(isl::val exp) const {
+  auto res = isl_map_fixed_power_val(copy(), exp.release());
+  return manage(res);
+}
+
+isl::map map::flat_domain_product(isl::map map2) const {
+  auto res = isl_map_flat_domain_product(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::flat_product(isl::map map2) const {
+  auto res = isl_map_flat_product(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::flat_range_product(isl::map map2) const {
+  auto res = isl_map_flat_range_product(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::flatten() const {
+  auto res = isl_map_flatten(copy());
+  return manage(res);
+}
+
+isl::map map::flatten_domain() const {
+  auto res = isl_map_flatten_domain(copy());
+  return manage(res);
+}
+
+isl::map map::flatten_range() const {
+  auto res = isl_map_flatten_range(copy());
+  return manage(res);
+}
+
+isl::map map::floordiv_val(isl::val d) const {
+  auto res = isl_map_floordiv_val(copy(), d.release());
+  return manage(res);
+}
+
+isl::stat map::foreach_basic_map(const std::function<isl::stat(isl::basic_map)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_basic_map *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::basic_map)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_map_foreach_basic_map(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::map map::from_aff(isl::aff aff) {
+  auto res = isl_map_from_aff(aff.release());
+  return manage(res);
+}
+
+isl::map map::from_domain(isl::set set) {
+  auto res = isl_map_from_domain(set.release());
+  return manage(res);
+}
+
+isl::map map::from_domain_and_range(isl::set domain, isl::set range) {
+  auto res = isl_map_from_domain_and_range(domain.release(), range.release());
+  return manage(res);
+}
+
+isl::map map::from_multi_aff(isl::multi_aff maff) {
+  auto res = isl_map_from_multi_aff(maff.release());
+  return manage(res);
+}
+
+isl::map map::from_multi_pw_aff(isl::multi_pw_aff mpa) {
+  auto res = isl_map_from_multi_pw_aff(mpa.release());
+  return manage(res);
+}
+
+isl::map map::from_pw_aff(isl::pw_aff pwaff) {
+  auto res = isl_map_from_pw_aff(pwaff.release());
+  return manage(res);
+}
+
+isl::map map::from_pw_multi_aff(isl::pw_multi_aff pma) {
+  auto res = isl_map_from_pw_multi_aff(pma.release());
+  return manage(res);
+}
+
+isl::map map::from_range(isl::set set) {
+  auto res = isl_map_from_range(set.release());
+  return manage(res);
+}
+
+isl::map map::from_union_map(isl::union_map umap) {
+  auto res = isl_map_from_union_map(umap.release());
+  return manage(res);
+}
+
+isl::id map::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_map_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+std::string map::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_map_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+uint32_t map::get_hash() const {
+  auto res = isl_map_get_hash(get());
+  return res;
+}
+
+isl::space map::get_space() const {
+  auto res = isl_map_get_space(get());
+  return manage(res);
+}
+
+isl::id map::get_tuple_id(isl::dim type) const {
+  auto res = isl_map_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+std::string map::get_tuple_name(isl::dim type) const {
+  auto res = isl_map_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::map map::gist(isl::map context) const {
+  auto res = isl_map_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::map map::gist_basic_map(isl::basic_map context) const {
+  auto res = isl_map_gist_basic_map(copy(), context.release());
+  return manage(res);
+}
+
+isl::map map::gist_domain(isl::set context) const {
+  auto res = isl_map_gist_domain(copy(), context.release());
+  return manage(res);
+}
+
+isl::map map::gist_params(isl::set context) const {
+  auto res = isl_map_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::map map::gist_range(isl::set context) const {
+  auto res = isl_map_gist_range(copy(), context.release());
+  return manage(res);
+}
+
+isl::boolean map::has_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_map_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean map::has_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_map_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean map::has_equal_space(const isl::map &map2) const {
+  auto res = isl_map_has_equal_space(get(), map2.get());
+  return manage(res);
+}
+
+isl::boolean map::has_tuple_id(isl::dim type) const {
+  auto res = isl_map_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::boolean map::has_tuple_name(isl::dim type) const {
+  auto res = isl_map_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::map map::identity(isl::space dim) {
+  auto res = isl_map_identity(dim.release());
+  return manage(res);
+}
+
+isl::map map::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const {
+  auto res = isl_map_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);
+  return manage(res);
+}
+
+isl::map map::intersect(isl::map map2) const {
+  auto res = isl_map_intersect(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::intersect_domain(isl::set set) const {
+  auto res = isl_map_intersect_domain(copy(), set.release());
+  return manage(res);
+}
+
+isl::map map::intersect_domain_factor_range(isl::map factor) const {
+  auto res = isl_map_intersect_domain_factor_range(copy(), factor.release());
+  return manage(res);
+}
+
+isl::map map::intersect_params(isl::set params) const {
+  auto res = isl_map_intersect_params(copy(), params.release());
+  return manage(res);
+}
+
+isl::map map::intersect_range(isl::set set) const {
+  auto res = isl_map_intersect_range(copy(), set.release());
+  return manage(res);
+}
+
+isl::map map::intersect_range_factor_range(isl::map factor) const {
+  auto res = isl_map_intersect_range_factor_range(copy(), factor.release());
+  return manage(res);
+}
+
+isl::boolean map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean map::is_bijective() const {
+  auto res = isl_map_is_bijective(get());
+  return manage(res);
+}
+
+isl::boolean map::is_disjoint(const isl::map &map2) const {
+  auto res = isl_map_is_disjoint(get(), map2.get());
+  return manage(res);
+}
+
+isl::boolean map::is_empty() const {
+  auto res = isl_map_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean map::is_equal(const isl::map &map2) const {
+  auto res = isl_map_is_equal(get(), map2.get());
+  return manage(res);
+}
+
+isl::boolean map::is_identity() const {
+  auto res = isl_map_is_identity(get());
+  return manage(res);
+}
+
+isl::boolean map::is_injective() const {
+  auto res = isl_map_is_injective(get());
+  return manage(res);
+}
+
+isl::boolean map::is_product() const {
+  auto res = isl_map_is_product(get());
+  return manage(res);
+}
+
+isl::boolean map::is_single_valued() const {
+  auto res = isl_map_is_single_valued(get());
+  return manage(res);
+}
+
+isl::boolean map::is_strict_subset(const isl::map &map2) const {
+  auto res = isl_map_is_strict_subset(get(), map2.get());
+  return manage(res);
+}
+
+isl::boolean map::is_subset(const isl::map &map2) const {
+  auto res = isl_map_is_subset(get(), map2.get());
+  return manage(res);
+}
+
+int map::is_translation() const {
+  auto res = isl_map_is_translation(get());
+  return res;
+}
+
+isl::map map::lex_ge(isl::space set_dim) {
+  auto res = isl_map_lex_ge(set_dim.release());
+  return manage(res);
+}
+
+isl::map map::lex_ge_first(isl::space dim, unsigned int n) {
+  auto res = isl_map_lex_ge_first(dim.release(), n);
+  return manage(res);
+}
+
+isl::map map::lex_ge_map(isl::map map2) const {
+  auto res = isl_map_lex_ge_map(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::lex_gt(isl::space set_dim) {
+  auto res = isl_map_lex_gt(set_dim.release());
+  return manage(res);
+}
+
+isl::map map::lex_gt_first(isl::space dim, unsigned int n) {
+  auto res = isl_map_lex_gt_first(dim.release(), n);
+  return manage(res);
+}
+
+isl::map map::lex_gt_map(isl::map map2) const {
+  auto res = isl_map_lex_gt_map(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::lex_le(isl::space set_dim) {
+  auto res = isl_map_lex_le(set_dim.release());
+  return manage(res);
+}
+
+isl::map map::lex_le_first(isl::space dim, unsigned int n) {
+  auto res = isl_map_lex_le_first(dim.release(), n);
+  return manage(res);
+}
+
+isl::map map::lex_le_map(isl::map map2) const {
+  auto res = isl_map_lex_le_map(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::lex_lt(isl::space set_dim) {
+  auto res = isl_map_lex_lt(set_dim.release());
+  return manage(res);
+}
+
+isl::map map::lex_lt_first(isl::space dim, unsigned int n) {
+  auto res = isl_map_lex_lt_first(dim.release(), n);
+  return manage(res);
+}
+
+isl::map map::lex_lt_map(isl::map map2) const {
+  auto res = isl_map_lex_lt_map(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::lexmax() const {
+  auto res = isl_map_lexmax(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff map::lexmax_pw_multi_aff() const {
+  auto res = isl_map_lexmax_pw_multi_aff(copy());
+  return manage(res);
+}
+
+isl::map map::lexmin() const {
+  auto res = isl_map_lexmin(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff map::lexmin_pw_multi_aff() const {
+  auto res = isl_map_lexmin_pw_multi_aff(copy());
+  return manage(res);
+}
+
+isl::map map::lower_bound_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_map_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::map map::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_map_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::map map::nat_universe(isl::space dim) {
+  auto res = isl_map_nat_universe(dim.release());
+  return manage(res);
+}
+
+isl::map map::neg() const {
+  auto res = isl_map_neg(copy());
+  return manage(res);
+}
+
+isl::map map::oppose(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_map_oppose(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::map map::order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_map_order_ge(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::map map::order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_map_order_gt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::map map::order_le(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_map_order_le(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::map map::order_lt(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_map_order_lt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+isl::set map::params() const {
+  auto res = isl_map_params(copy());
+  return manage(res);
+}
+
+isl::val map::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const {
+  auto res = isl_map_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean map::plain_is_empty() const {
+  auto res = isl_map_plain_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean map::plain_is_equal(const isl::map &map2) const {
+  auto res = isl_map_plain_is_equal(get(), map2.get());
+  return manage(res);
+}
+
+isl::boolean map::plain_is_injective() const {
+  auto res = isl_map_plain_is_injective(get());
+  return manage(res);
+}
+
+isl::boolean map::plain_is_single_valued() const {
+  auto res = isl_map_plain_is_single_valued(get());
+  return manage(res);
+}
+
+isl::boolean map::plain_is_universe() const {
+  auto res = isl_map_plain_is_universe(get());
+  return manage(res);
+}
+
+isl::basic_map map::plain_unshifted_simple_hull() const {
+  auto res = isl_map_plain_unshifted_simple_hull(copy());
+  return manage(res);
+}
+
+isl::basic_map map::polyhedral_hull() const {
+  auto res = isl_map_polyhedral_hull(copy());
+  return manage(res);
+}
+
+isl::map map::preimage_domain_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_map_preimage_domain_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::map map::preimage_domain_multi_pw_aff(isl::multi_pw_aff mpa) const {
+  auto res = isl_map_preimage_domain_multi_pw_aff(copy(), mpa.release());
+  return manage(res);
+}
+
+isl::map map::preimage_domain_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_map_preimage_domain_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::map map::preimage_range_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_map_preimage_range_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::map map::preimage_range_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_map_preimage_range_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::map map::product(isl::map map2) const {
+  auto res = isl_map_product(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::project_out(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set map::range() const {
+  auto res = isl_map_range(copy());
+  return manage(res);
+}
+
+isl::map map::range_curry() const {
+  auto res = isl_map_range_curry(copy());
+  return manage(res);
+}
+
+isl::map map::range_factor_domain() const {
+  auto res = isl_map_range_factor_domain(copy());
+  return manage(res);
+}
+
+isl::map map::range_factor_range() const {
+  auto res = isl_map_range_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean map::range_is_wrapping() const {
+  auto res = isl_map_range_is_wrapping(get());
+  return manage(res);
+}
+
+isl::map map::range_map() const {
+  auto res = isl_map_range_map(copy());
+  return manage(res);
+}
+
+isl::map map::range_product(isl::map map2) const {
+  auto res = isl_map_range_product(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::remove_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_map_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::map map::remove_divs() const {
+  auto res = isl_map_remove_divs(copy());
+  return manage(res);
+}
+
+isl::map map::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_map_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::map map::remove_redundancies() const {
+  auto res = isl_map_remove_redundancies(copy());
+  return manage(res);
+}
+
+isl::map map::remove_unknown_divs() const {
+  auto res = isl_map_remove_unknown_divs(copy());
+  return manage(res);
+}
+
+isl::map map::reset_tuple_id(isl::dim type) const {
+  auto res = isl_map_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::map map::reset_user() const {
+  auto res = isl_map_reset_user(copy());
+  return manage(res);
+}
+
+isl::map map::reverse() const {
+  auto res = isl_map_reverse(copy());
+  return manage(res);
+}
+
+isl::basic_map map::sample() const {
+  auto res = isl_map_sample(copy());
+  return manage(res);
+}
+
+isl::map map::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_map_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::map map::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_map_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::map map::set_tuple_name(isl::dim type, const std::string &s) const {
+  auto res = isl_map_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());
+  return manage(res);
+}
+
+isl::basic_map map::simple_hull() const {
+  auto res = isl_map_simple_hull(copy());
+  return manage(res);
+}
+
+isl::map map::subtract(isl::map map2) const {
+  auto res = isl_map_subtract(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::subtract_domain(isl::set dom) const {
+  auto res = isl_map_subtract_domain(copy(), dom.release());
+  return manage(res);
+}
+
+isl::map map::subtract_range(isl::set dom) const {
+  auto res = isl_map_subtract_range(copy(), dom.release());
+  return manage(res);
+}
+
+isl::map map::sum(isl::map map2) const {
+  auto res = isl_map_sum(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::uncurry() const {
+  auto res = isl_map_uncurry(copy());
+  return manage(res);
+}
+
+isl::map map::unite(isl::map map2) const {
+  auto res = isl_map_union(copy(), map2.release());
+  return manage(res);
+}
+
+isl::map map::universe(isl::space dim) {
+  auto res = isl_map_universe(dim.release());
+  return manage(res);
+}
+
+isl::basic_map map::unshifted_simple_hull() const {
+  auto res = isl_map_unshifted_simple_hull(copy());
+  return manage(res);
+}
+
+isl::basic_map map::unshifted_simple_hull_from_map_list(isl::map_list list) const {
+  auto res = isl_map_unshifted_simple_hull_from_map_list(copy(), list.release());
+  return manage(res);
+}
+
+isl::map map::upper_bound_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_map_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::set map::wrap() const {
+  auto res = isl_map_wrap(copy());
+  return manage(res);
+}
+
+isl::map map::zip() const {
+  auto res = isl_map_zip(copy());
+  return manage(res);
+}
+
+// implementations for isl::map_list
+isl::map_list manage(__isl_take isl_map_list *ptr) {
+  return map_list(ptr);
+}
+isl::map_list give(__isl_take isl_map_list *ptr) {
+  return manage(ptr);
+}
+
+
+map_list::map_list()
+    : ptr(nullptr) {}
+
+map_list::map_list(const isl::map_list &obj)
+    : ptr(obj.copy()) {}
+map_list::map_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+map_list::map_list(__isl_take isl_map_list *ptr)
+    : ptr(ptr) {}
+
+
+map_list &map_list::operator=(isl::map_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+map_list::~map_list() {
+  if (ptr)
+    isl_map_list_free(ptr);
+}
+
+__isl_give isl_map_list *map_list::copy() const & {
+  return isl_map_list_copy(ptr);
+}
+
+__isl_keep isl_map_list *map_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_map_list *map_list::release() {
+  isl_map_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool map_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_map_list *map_list::keep() const {
+  return get();
+}
+
+__isl_give isl_map_list *map_list::take() {
+  return release();
+}
+
+map_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx map_list::get_ctx() const {
+  return isl::ctx(isl_map_list_get_ctx(ptr));
+}
+
+
+
+void map_list::dump() const {
+  isl_map_list_dump(get());
+}
+
+
+
+// implementations for isl::multi_aff
+isl::multi_aff manage(__isl_take isl_multi_aff *ptr) {
+  return multi_aff(ptr);
+}
+isl::multi_aff give(__isl_take isl_multi_aff *ptr) {
+  return manage(ptr);
+}
+
+
+multi_aff::multi_aff()
+    : ptr(nullptr) {}
+
+multi_aff::multi_aff(const isl::multi_aff &obj)
+    : ptr(obj.copy()) {}
+multi_aff::multi_aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+multi_aff::multi_aff(__isl_take isl_multi_aff *ptr)
+    : ptr(ptr) {}
+
+multi_aff::multi_aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_multi_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+multi_aff::multi_aff(isl::aff aff) {
+  auto res = isl_multi_aff_from_aff(aff.release());
+  ptr = res;
+}
+
+multi_aff &multi_aff::operator=(isl::multi_aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+multi_aff::~multi_aff() {
+  if (ptr)
+    isl_multi_aff_free(ptr);
+}
+
+__isl_give isl_multi_aff *multi_aff::copy() const & {
+  return isl_multi_aff_copy(ptr);
+}
+
+__isl_keep isl_multi_aff *multi_aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_multi_aff *multi_aff::release() {
+  isl_multi_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool multi_aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_multi_aff *multi_aff::keep() const {
+  return get();
+}
+
+__isl_give isl_multi_aff *multi_aff::take() {
+  return release();
+}
+
+multi_aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx multi_aff::get_ctx() const {
+  return isl::ctx(isl_multi_aff_get_ctx(ptr));
+}
+
+
+std::string multi_aff::to_str() const {
+  char *Tmp = isl_multi_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void multi_aff::dump() const {
+  isl_multi_aff_dump(get());
+}
+
+
+isl::multi_aff multi_aff::add(isl::multi_aff multi2) const {
+  auto res = isl_multi_aff_add(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_multi_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::align_params(isl::space model) const {
+  auto res = isl_multi_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+unsigned int multi_aff::dim(isl::dim type) const {
+  auto res = isl_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::multi_aff multi_aff::domain_map(isl::space space) {
+  auto res = isl_multi_aff_domain_map(space.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::factor_range() const {
+  auto res = isl_multi_aff_factor_range(copy());
+  return manage(res);
+}
+
+int multi_aff::find_dim_by_id(isl::dim type, const isl::id &id) const {
+  auto res = isl_multi_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());
+  return res;
+}
+
+int multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::multi_aff multi_aff::flat_range_product(isl::multi_aff multi2) const {
+  auto res = isl_multi_aff_flat_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::flatten_domain() const {
+  auto res = isl_multi_aff_flatten_domain(copy());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::flatten_range() const {
+  auto res = isl_multi_aff_flatten_range(copy());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::floor() const {
+  auto res = isl_multi_aff_floor(copy());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::from_aff_list(isl::space space, isl::aff_list list) {
+  auto res = isl_multi_aff_from_aff_list(space.release(), list.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::from_range() const {
+  auto res = isl_multi_aff_from_range(copy());
+  return manage(res);
+}
+
+isl::aff multi_aff::get_aff(int pos) const {
+  auto res = isl_multi_aff_get_aff(get(), pos);
+  return manage(res);
+}
+
+isl::id multi_aff::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_multi_aff_get_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::space multi_aff::get_domain_space() const {
+  auto res = isl_multi_aff_get_domain_space(get());
+  return manage(res);
+}
+
+isl::space multi_aff::get_space() const {
+  auto res = isl_multi_aff_get_space(get());
+  return manage(res);
+}
+
+isl::id multi_aff::get_tuple_id(isl::dim type) const {
+  auto res = isl_multi_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+std::string multi_aff::get_tuple_name(isl::dim type) const {
+  auto res = isl_multi_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::multi_aff multi_aff::gist(isl::set context) const {
+  auto res = isl_multi_aff_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::gist_params(isl::set context) const {
+  auto res = isl_multi_aff_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::boolean multi_aff::has_tuple_id(isl::dim type) const {
+  auto res = isl_multi_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::identity(isl::space space) {
+  auto res = isl_multi_aff_identity(space.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean multi_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean multi_aff::involves_nan() const {
+  auto res = isl_multi_aff_involves_nan(get());
+  return manage(res);
+}
+
+isl::set multi_aff::lex_ge_set(isl::multi_aff ma2) const {
+  auto res = isl_multi_aff_lex_ge_set(copy(), ma2.release());
+  return manage(res);
+}
+
+isl::set multi_aff::lex_gt_set(isl::multi_aff ma2) const {
+  auto res = isl_multi_aff_lex_gt_set(copy(), ma2.release());
+  return manage(res);
+}
+
+isl::set multi_aff::lex_le_set(isl::multi_aff ma2) const {
+  auto res = isl_multi_aff_lex_le_set(copy(), ma2.release());
+  return manage(res);
+}
+
+isl::set multi_aff::lex_lt_set(isl::multi_aff ma2) const {
+  auto res = isl_multi_aff_lex_lt_set(copy(), ma2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::mod_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_aff_mod_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_multi_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::multi_val_on_space(isl::space space, isl::multi_val mv) {
+  auto res = isl_multi_aff_multi_val_on_space(space.release(), mv.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::neg() const {
+  auto res = isl_multi_aff_neg(copy());
+  return manage(res);
+}
+
+int multi_aff::plain_cmp(const isl::multi_aff &multi2) const {
+  auto res = isl_multi_aff_plain_cmp(get(), multi2.get());
+  return res;
+}
+
+isl::boolean multi_aff::plain_is_equal(const isl::multi_aff &multi2) const {
+  auto res = isl_multi_aff_plain_is_equal(get(), multi2.get());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::product(isl::multi_aff multi2) const {
+  auto res = isl_multi_aff_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::project_out_map(isl::space space, isl::dim type, unsigned int first, unsigned int n) {
+  auto res = isl_multi_aff_project_out_map(space.release(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::pullback(isl::multi_aff ma2) const {
+  auto res = isl_multi_aff_pullback_multi_aff(copy(), ma2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::range_factor_domain() const {
+  auto res = isl_multi_aff_range_factor_domain(copy());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::range_factor_range() const {
+  auto res = isl_multi_aff_range_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean multi_aff::range_is_wrapping() const {
+  auto res = isl_multi_aff_range_is_wrapping(get());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::range_map(isl::space space) {
+  auto res = isl_multi_aff_range_map(space.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::range_product(isl::multi_aff multi2) const {
+  auto res = isl_multi_aff_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::range_splice(unsigned int pos, isl::multi_aff multi2) const {
+  auto res = isl_multi_aff_range_splice(copy(), pos, multi2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::reset_tuple_id(isl::dim type) const {
+  auto res = isl_multi_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::reset_user() const {
+  auto res = isl_multi_aff_reset_user(copy());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::scale_down_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_aff_scale_down_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::scale_down_val(isl::val v) const {
+  auto res = isl_multi_aff_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::scale_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_aff_scale_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::scale_val(isl::val v) const {
+  auto res = isl_multi_aff_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::set_aff(int pos, isl::aff el) const {
+  auto res = isl_multi_aff_set_aff(copy(), pos, el.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_multi_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_multi_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::set_tuple_name(isl::dim type, const std::string &s) const {
+  auto res = isl_multi_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::splice(unsigned int in_pos, unsigned int out_pos, isl::multi_aff multi2) const {
+  auto res = isl_multi_aff_splice(copy(), in_pos, out_pos, multi2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::sub(isl::multi_aff multi2) const {
+  auto res = isl_multi_aff_sub(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_aff multi_aff::zero(isl::space space) {
+  auto res = isl_multi_aff_zero(space.release());
+  return manage(res);
+}
+
+// implementations for isl::multi_pw_aff
+isl::multi_pw_aff manage(__isl_take isl_multi_pw_aff *ptr) {
+  return multi_pw_aff(ptr);
+}
+isl::multi_pw_aff give(__isl_take isl_multi_pw_aff *ptr) {
+  return manage(ptr);
+}
+
+
+multi_pw_aff::multi_pw_aff()
+    : ptr(nullptr) {}
+
+multi_pw_aff::multi_pw_aff(const isl::multi_pw_aff &obj)
+    : ptr(obj.copy()) {}
+multi_pw_aff::multi_pw_aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+multi_pw_aff::multi_pw_aff(__isl_take isl_multi_pw_aff *ptr)
+    : ptr(ptr) {}
+
+multi_pw_aff::multi_pw_aff(isl::multi_aff ma) {
+  auto res = isl_multi_pw_aff_from_multi_aff(ma.release());
+  ptr = res;
+}
+multi_pw_aff::multi_pw_aff(isl::pw_aff pa) {
+  auto res = isl_multi_pw_aff_from_pw_aff(pa.release());
+  ptr = res;
+}
+multi_pw_aff::multi_pw_aff(isl::pw_multi_aff pma) {
+  auto res = isl_multi_pw_aff_from_pw_multi_aff(pma.release());
+  ptr = res;
+}
+multi_pw_aff::multi_pw_aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_multi_pw_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+multi_pw_aff &multi_pw_aff::operator=(isl::multi_pw_aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+multi_pw_aff::~multi_pw_aff() {
+  if (ptr)
+    isl_multi_pw_aff_free(ptr);
+}
+
+__isl_give isl_multi_pw_aff *multi_pw_aff::copy() const & {
+  return isl_multi_pw_aff_copy(ptr);
+}
+
+__isl_keep isl_multi_pw_aff *multi_pw_aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_multi_pw_aff *multi_pw_aff::release() {
+  isl_multi_pw_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool multi_pw_aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_multi_pw_aff *multi_pw_aff::keep() const {
+  return get();
+}
+
+__isl_give isl_multi_pw_aff *multi_pw_aff::take() {
+  return release();
+}
+
+multi_pw_aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx multi_pw_aff::get_ctx() const {
+  return isl::ctx(isl_multi_pw_aff_get_ctx(ptr));
+}
+
+
+std::string multi_pw_aff::to_str() const {
+  char *Tmp = isl_multi_pw_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void multi_pw_aff::dump() const {
+  isl_multi_pw_aff_dump(get());
+}
+
+
+isl::multi_pw_aff multi_pw_aff::add(isl::multi_pw_aff multi2) const {
+  auto res = isl_multi_pw_aff_add(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_multi_pw_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::align_params(isl::space model) const {
+  auto res = isl_multi_pw_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::coalesce() const {
+  auto res = isl_multi_pw_aff_coalesce(copy());
+  return manage(res);
+}
+
+unsigned int multi_pw_aff::dim(isl::dim type) const {
+  auto res = isl_multi_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::set multi_pw_aff::domain() const {
+  auto res = isl_multi_pw_aff_domain(copy());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::map multi_pw_aff::eq_map(isl::multi_pw_aff mpa2) const {
+  auto res = isl_multi_pw_aff_eq_map(copy(), mpa2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::factor_range() const {
+  auto res = isl_multi_pw_aff_factor_range(copy());
+  return manage(res);
+}
+
+int multi_pw_aff::find_dim_by_id(isl::dim type, const isl::id &id) const {
+  auto res = isl_multi_pw_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());
+  return res;
+}
+
+int multi_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_multi_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::multi_pw_aff multi_pw_aff::flat_range_product(isl::multi_pw_aff multi2) const {
+  auto res = isl_multi_pw_aff_flat_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::flatten_range() const {
+  auto res = isl_multi_pw_aff_flatten_range(copy());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::from_pw_aff_list(isl::space space, isl::pw_aff_list list) {
+  auto res = isl_multi_pw_aff_from_pw_aff_list(space.release(), list.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::from_range() const {
+  auto res = isl_multi_pw_aff_from_range(copy());
+  return manage(res);
+}
+
+isl::id multi_pw_aff::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_multi_pw_aff_get_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::space multi_pw_aff::get_domain_space() const {
+  auto res = isl_multi_pw_aff_get_domain_space(get());
+  return manage(res);
+}
+
+uint32_t multi_pw_aff::get_hash() const {
+  auto res = isl_multi_pw_aff_get_hash(get());
+  return res;
+}
+
+isl::pw_aff multi_pw_aff::get_pw_aff(int pos) const {
+  auto res = isl_multi_pw_aff_get_pw_aff(get(), pos);
+  return manage(res);
+}
+
+isl::space multi_pw_aff::get_space() const {
+  auto res = isl_multi_pw_aff_get_space(get());
+  return manage(res);
+}
+
+isl::id multi_pw_aff::get_tuple_id(isl::dim type) const {
+  auto res = isl_multi_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+std::string multi_pw_aff::get_tuple_name(isl::dim type) const {
+  auto res = isl_multi_pw_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::multi_pw_aff multi_pw_aff::gist(isl::set set) const {
+  auto res = isl_multi_pw_aff_gist(copy(), set.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::gist_params(isl::set set) const {
+  auto res = isl_multi_pw_aff_gist_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean multi_pw_aff::has_tuple_id(isl::dim type) const {
+  auto res = isl_multi_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::identity(isl::space space) {
+  auto res = isl_multi_pw_aff_identity(space.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_pw_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::intersect_domain(isl::set domain) const {
+  auto res = isl_multi_pw_aff_intersect_domain(copy(), domain.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::intersect_params(isl::set set) const {
+  auto res = isl_multi_pw_aff_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean multi_pw_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_pw_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean multi_pw_aff::involves_nan() const {
+  auto res = isl_multi_pw_aff_involves_nan(get());
+  return manage(res);
+}
+
+isl::boolean multi_pw_aff::is_cst() const {
+  auto res = isl_multi_pw_aff_is_cst(get());
+  return manage(res);
+}
+
+isl::boolean multi_pw_aff::is_equal(const isl::multi_pw_aff &mpa2) const {
+  auto res = isl_multi_pw_aff_is_equal(get(), mpa2.get());
+  return manage(res);
+}
+
+isl::map multi_pw_aff::lex_gt_map(isl::multi_pw_aff mpa2) const {
+  auto res = isl_multi_pw_aff_lex_gt_map(copy(), mpa2.release());
+  return manage(res);
+}
+
+isl::map multi_pw_aff::lex_lt_map(isl::multi_pw_aff mpa2) const {
+  auto res = isl_multi_pw_aff_lex_lt_map(copy(), mpa2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::mod_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_pw_aff_mod_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_multi_pw_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::neg() const {
+  auto res = isl_multi_pw_aff_neg(copy());
+  return manage(res);
+}
+
+isl::boolean multi_pw_aff::plain_is_equal(const isl::multi_pw_aff &multi2) const {
+  auto res = isl_multi_pw_aff_plain_is_equal(get(), multi2.get());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::product(isl::multi_pw_aff multi2) const {
+  auto res = isl_multi_pw_aff_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::pullback(isl::multi_aff ma) const {
+  auto res = isl_multi_pw_aff_pullback_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::pullback(isl::pw_multi_aff pma) const {
+  auto res = isl_multi_pw_aff_pullback_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::pullback(isl::multi_pw_aff mpa2) const {
+  auto res = isl_multi_pw_aff_pullback_multi_pw_aff(copy(), mpa2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::range_factor_domain() const {
+  auto res = isl_multi_pw_aff_range_factor_domain(copy());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::range_factor_range() const {
+  auto res = isl_multi_pw_aff_range_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean multi_pw_aff::range_is_wrapping() const {
+  auto res = isl_multi_pw_aff_range_is_wrapping(get());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::range_product(isl::multi_pw_aff multi2) const {
+  auto res = isl_multi_pw_aff_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::range_splice(unsigned int pos, isl::multi_pw_aff multi2) const {
+  auto res = isl_multi_pw_aff_range_splice(copy(), pos, multi2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::reset_tuple_id(isl::dim type) const {
+  auto res = isl_multi_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::reset_user() const {
+  auto res = isl_multi_pw_aff_reset_user(copy());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::scale_down_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_pw_aff_scale_down_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::scale_down_val(isl::val v) const {
+  auto res = isl_multi_pw_aff_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::scale_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_pw_aff_scale_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::scale_val(isl::val v) const {
+  auto res = isl_multi_pw_aff_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_multi_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::set_pw_aff(int pos, isl::pw_aff el) const {
+  auto res = isl_multi_pw_aff_set_pw_aff(copy(), pos, el.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_multi_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::set_tuple_name(isl::dim type, const std::string &s) const {
+  auto res = isl_multi_pw_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::splice(unsigned int in_pos, unsigned int out_pos, isl::multi_pw_aff multi2) const {
+  auto res = isl_multi_pw_aff_splice(copy(), in_pos, out_pos, multi2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::sub(isl::multi_pw_aff multi2) const {
+  auto res = isl_multi_pw_aff_sub(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_pw_aff::zero(isl::space space) {
+  auto res = isl_multi_pw_aff_zero(space.release());
+  return manage(res);
+}
+
+// implementations for isl::multi_union_pw_aff
+isl::multi_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr) {
+  return multi_union_pw_aff(ptr);
+}
+isl::multi_union_pw_aff give(__isl_take isl_multi_union_pw_aff *ptr) {
+  return manage(ptr);
+}
+
+
+multi_union_pw_aff::multi_union_pw_aff()
+    : ptr(nullptr) {}
+
+multi_union_pw_aff::multi_union_pw_aff(const isl::multi_union_pw_aff &obj)
+    : ptr(obj.copy()) {}
+multi_union_pw_aff::multi_union_pw_aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+multi_union_pw_aff::multi_union_pw_aff(__isl_take isl_multi_union_pw_aff *ptr)
+    : ptr(ptr) {}
+
+multi_union_pw_aff::multi_union_pw_aff(isl::union_pw_aff upa) {
+  auto res = isl_multi_union_pw_aff_from_union_pw_aff(upa.release());
+  ptr = res;
+}
+multi_union_pw_aff::multi_union_pw_aff(isl::multi_pw_aff mpa) {
+  auto res = isl_multi_union_pw_aff_from_multi_pw_aff(mpa.release());
+  ptr = res;
+}
+multi_union_pw_aff::multi_union_pw_aff(isl::union_pw_multi_aff upma) {
+  auto res = isl_multi_union_pw_aff_from_union_pw_multi_aff(upma.release());
+  ptr = res;
+}
+multi_union_pw_aff::multi_union_pw_aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_multi_union_pw_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+multi_union_pw_aff &multi_union_pw_aff::operator=(isl::multi_union_pw_aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+multi_union_pw_aff::~multi_union_pw_aff() {
+  if (ptr)
+    isl_multi_union_pw_aff_free(ptr);
+}
+
+__isl_give isl_multi_union_pw_aff *multi_union_pw_aff::copy() const & {
+  return isl_multi_union_pw_aff_copy(ptr);
+}
+
+__isl_keep isl_multi_union_pw_aff *multi_union_pw_aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_multi_union_pw_aff *multi_union_pw_aff::release() {
+  isl_multi_union_pw_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool multi_union_pw_aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_multi_union_pw_aff *multi_union_pw_aff::keep() const {
+  return get();
+}
+
+__isl_give isl_multi_union_pw_aff *multi_union_pw_aff::take() {
+  return release();
+}
+
+multi_union_pw_aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx multi_union_pw_aff::get_ctx() const {
+  return isl::ctx(isl_multi_union_pw_aff_get_ctx(ptr));
+}
+
+
+std::string multi_union_pw_aff::to_str() const {
+  char *Tmp = isl_multi_union_pw_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void multi_union_pw_aff::dump() const {
+  isl_multi_union_pw_aff_dump(get());
+}
+
+
+isl::multi_union_pw_aff multi_union_pw_aff::add(isl::multi_union_pw_aff multi2) const {
+  auto res = isl_multi_union_pw_aff_add(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::align_params(isl::space model) const {
+  auto res = isl_multi_union_pw_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::union_pw_aff multi_union_pw_aff::apply_aff(isl::aff aff) const {
+  auto res = isl_multi_union_pw_aff_apply_aff(copy(), aff.release());
+  return manage(res);
+}
+
+isl::union_pw_aff multi_union_pw_aff::apply_pw_aff(isl::pw_aff pa) const {
+  auto res = isl_multi_union_pw_aff_apply_pw_aff(copy(), pa.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::apply_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_multi_union_pw_aff_apply_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::coalesce() const {
+  auto res = isl_multi_union_pw_aff_coalesce(copy());
+  return manage(res);
+}
+
+unsigned int multi_union_pw_aff::dim(isl::dim type) const {
+  auto res = isl_multi_union_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::union_set multi_union_pw_aff::domain() const {
+  auto res = isl_multi_union_pw_aff_domain(copy());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_union_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::multi_pw_aff multi_union_pw_aff::extract_multi_pw_aff(isl::space space) const {
+  auto res = isl_multi_union_pw_aff_extract_multi_pw_aff(get(), space.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::factor_range() const {
+  auto res = isl_multi_union_pw_aff_factor_range(copy());
+  return manage(res);
+}
+
+int multi_union_pw_aff::find_dim_by_id(isl::dim type, const isl::id &id) const {
+  auto res = isl_multi_union_pw_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());
+  return res;
+}
+
+int multi_union_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_multi_union_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::flat_range_product(isl::multi_union_pw_aff multi2) const {
+  auto res = isl_multi_union_pw_aff_flat_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::flatten_range() const {
+  auto res = isl_multi_union_pw_aff_flatten_range(copy());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::floor() const {
+  auto res = isl_multi_union_pw_aff_floor(copy());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::from_multi_aff(isl::multi_aff ma) {
+  auto res = isl_multi_union_pw_aff_from_multi_aff(ma.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::from_range() const {
+  auto res = isl_multi_union_pw_aff_from_range(copy());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::from_union_map(isl::union_map umap) {
+  auto res = isl_multi_union_pw_aff_from_union_map(umap.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::from_union_pw_aff_list(isl::space space, isl::union_pw_aff_list list) {
+  auto res = isl_multi_union_pw_aff_from_union_pw_aff_list(space.release(), list.release());
+  return manage(res);
+}
+
+isl::id multi_union_pw_aff::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_multi_union_pw_aff_get_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::space multi_union_pw_aff::get_domain_space() const {
+  auto res = isl_multi_union_pw_aff_get_domain_space(get());
+  return manage(res);
+}
+
+isl::space multi_union_pw_aff::get_space() const {
+  auto res = isl_multi_union_pw_aff_get_space(get());
+  return manage(res);
+}
+
+isl::id multi_union_pw_aff::get_tuple_id(isl::dim type) const {
+  auto res = isl_multi_union_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+std::string multi_union_pw_aff::get_tuple_name(isl::dim type) const {
+  auto res = isl_multi_union_pw_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::union_pw_aff multi_union_pw_aff::get_union_pw_aff(int pos) const {
+  auto res = isl_multi_union_pw_aff_get_union_pw_aff(get(), pos);
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::gist(isl::union_set context) const {
+  auto res = isl_multi_union_pw_aff_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::gist_params(isl::set context) const {
+  auto res = isl_multi_union_pw_aff_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::boolean multi_union_pw_aff::has_tuple_id(isl::dim type) const {
+  auto res = isl_multi_union_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::intersect_domain(isl::union_set uset) const {
+  auto res = isl_multi_union_pw_aff_intersect_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::intersect_params(isl::set params) const {
+  auto res = isl_multi_union_pw_aff_intersect_params(copy(), params.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::intersect_range(isl::set set) const {
+  auto res = isl_multi_union_pw_aff_intersect_range(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean multi_union_pw_aff::involves_nan() const {
+  auto res = isl_multi_union_pw_aff_involves_nan(get());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::mod_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_union_pw_aff_mod_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::multi_aff_on_domain(isl::union_set domain, isl::multi_aff ma) {
+  auto res = isl_multi_union_pw_aff_multi_aff_on_domain(domain.release(), ma.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::multi_val_on_domain(isl::union_set domain, isl::multi_val mv) {
+  auto res = isl_multi_union_pw_aff_multi_val_on_domain(domain.release(), mv.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::neg() const {
+  auto res = isl_multi_union_pw_aff_neg(copy());
+  return manage(res);
+}
+
+isl::boolean multi_union_pw_aff::plain_is_equal(const isl::multi_union_pw_aff &multi2) const {
+  auto res = isl_multi_union_pw_aff_plain_is_equal(get(), multi2.get());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::pullback(isl::union_pw_multi_aff upma) const {
+  auto res = isl_multi_union_pw_aff_pullback_union_pw_multi_aff(copy(), upma.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::range_factor_domain() const {
+  auto res = isl_multi_union_pw_aff_range_factor_domain(copy());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::range_factor_range() const {
+  auto res = isl_multi_union_pw_aff_range_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean multi_union_pw_aff::range_is_wrapping() const {
+  auto res = isl_multi_union_pw_aff_range_is_wrapping(get());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::range_product(isl::multi_union_pw_aff multi2) const {
+  auto res = isl_multi_union_pw_aff_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::range_splice(unsigned int pos, isl::multi_union_pw_aff multi2) const {
+  auto res = isl_multi_union_pw_aff_range_splice(copy(), pos, multi2.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::reset_tuple_id(isl::dim type) const {
+  auto res = isl_multi_union_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::reset_user() const {
+  auto res = isl_multi_union_pw_aff_reset_user(copy());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::scale_down_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_union_pw_aff_scale_down_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::scale_down_val(isl::val v) const {
+  auto res = isl_multi_union_pw_aff_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::scale_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_union_pw_aff_scale_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::scale_val(isl::val v) const {
+  auto res = isl_multi_union_pw_aff_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_multi_union_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_multi_union_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::set_tuple_name(isl::dim type, const std::string &s) const {
+  auto res = isl_multi_union_pw_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::set_union_pw_aff(int pos, isl::union_pw_aff el) const {
+  auto res = isl_multi_union_pw_aff_set_union_pw_aff(copy(), pos, el.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::sub(isl::multi_union_pw_aff multi2) const {
+  auto res = isl_multi_union_pw_aff_sub(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::union_add(isl::multi_union_pw_aff mupa2) const {
+  auto res = isl_multi_union_pw_aff_union_add(copy(), mupa2.release());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff multi_union_pw_aff::zero(isl::space space) {
+  auto res = isl_multi_union_pw_aff_zero(space.release());
+  return manage(res);
+}
+
+isl::union_set multi_union_pw_aff::zero_union_set() const {
+  auto res = isl_multi_union_pw_aff_zero_union_set(copy());
+  return manage(res);
+}
+
+// implementations for isl::multi_val
+isl::multi_val manage(__isl_take isl_multi_val *ptr) {
+  return multi_val(ptr);
+}
+isl::multi_val give(__isl_take isl_multi_val *ptr) {
+  return manage(ptr);
+}
+
+
+multi_val::multi_val()
+    : ptr(nullptr) {}
+
+multi_val::multi_val(const isl::multi_val &obj)
+    : ptr(obj.copy()) {}
+multi_val::multi_val(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+multi_val::multi_val(__isl_take isl_multi_val *ptr)
+    : ptr(ptr) {}
+
+multi_val::multi_val(isl::ctx ctx, const std::string &str) {
+  auto res = isl_multi_val_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+multi_val &multi_val::operator=(isl::multi_val obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+multi_val::~multi_val() {
+  if (ptr)
+    isl_multi_val_free(ptr);
+}
+
+__isl_give isl_multi_val *multi_val::copy() const & {
+  return isl_multi_val_copy(ptr);
+}
+
+__isl_keep isl_multi_val *multi_val::get() const {
+  return ptr;
+}
+
+__isl_give isl_multi_val *multi_val::release() {
+  isl_multi_val *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool multi_val::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_multi_val *multi_val::keep() const {
+  return get();
+}
+
+__isl_give isl_multi_val *multi_val::take() {
+  return release();
+}
+
+multi_val::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx multi_val::get_ctx() const {
+  return isl::ctx(isl_multi_val_get_ctx(ptr));
+}
+
+
+std::string multi_val::to_str() const {
+  char *Tmp = isl_multi_val_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void multi_val::dump() const {
+  isl_multi_val_dump(get());
+}
+
+
+isl::multi_val multi_val::add(isl::multi_val multi2) const {
+  auto res = isl_multi_val_add(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_multi_val_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::multi_val multi_val::add_val(isl::val v) const {
+  auto res = isl_multi_val_add_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::align_params(isl::space model) const {
+  auto res = isl_multi_val_align_params(copy(), model.release());
+  return manage(res);
+}
+
+unsigned int multi_val::dim(isl::dim type) const {
+  auto res = isl_multi_val_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::multi_val multi_val::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_val_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::multi_val multi_val::factor_range() const {
+  auto res = isl_multi_val_factor_range(copy());
+  return manage(res);
+}
+
+int multi_val::find_dim_by_id(isl::dim type, const isl::id &id) const {
+  auto res = isl_multi_val_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());
+  return res;
+}
+
+int multi_val::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_multi_val_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::multi_val multi_val::flat_range_product(isl::multi_val multi2) const {
+  auto res = isl_multi_val_flat_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::flatten_range() const {
+  auto res = isl_multi_val_flatten_range(copy());
+  return manage(res);
+}
+
+isl::multi_val multi_val::from_range() const {
+  auto res = isl_multi_val_from_range(copy());
+  return manage(res);
+}
+
+isl::multi_val multi_val::from_val_list(isl::space space, isl::val_list list) {
+  auto res = isl_multi_val_from_val_list(space.release(), list.release());
+  return manage(res);
+}
+
+isl::id multi_val::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_multi_val_get_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::space multi_val::get_domain_space() const {
+  auto res = isl_multi_val_get_domain_space(get());
+  return manage(res);
+}
+
+isl::space multi_val::get_space() const {
+  auto res = isl_multi_val_get_space(get());
+  return manage(res);
+}
+
+isl::id multi_val::get_tuple_id(isl::dim type) const {
+  auto res = isl_multi_val_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+std::string multi_val::get_tuple_name(isl::dim type) const {
+  auto res = isl_multi_val_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::val multi_val::get_val(int pos) const {
+  auto res = isl_multi_val_get_val(get(), pos);
+  return manage(res);
+}
+
+isl::boolean multi_val::has_tuple_id(isl::dim type) const {
+  auto res = isl_multi_val_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_val multi_val::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_val_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean multi_val::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_multi_val_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean multi_val::involves_nan() const {
+  auto res = isl_multi_val_involves_nan(get());
+  return manage(res);
+}
+
+isl::multi_val multi_val::mod_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_val_mod_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::mod_val(isl::val v) const {
+  auto res = isl_multi_val_mod_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::neg() const {
+  auto res = isl_multi_val_neg(copy());
+  return manage(res);
+}
+
+isl::boolean multi_val::plain_is_equal(const isl::multi_val &multi2) const {
+  auto res = isl_multi_val_plain_is_equal(get(), multi2.get());
+  return manage(res);
+}
+
+isl::multi_val multi_val::product(isl::multi_val multi2) const {
+  auto res = isl_multi_val_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::range_factor_domain() const {
+  auto res = isl_multi_val_range_factor_domain(copy());
+  return manage(res);
+}
+
+isl::multi_val multi_val::range_factor_range() const {
+  auto res = isl_multi_val_range_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean multi_val::range_is_wrapping() const {
+  auto res = isl_multi_val_range_is_wrapping(get());
+  return manage(res);
+}
+
+isl::multi_val multi_val::range_product(isl::multi_val multi2) const {
+  auto res = isl_multi_val_range_product(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::range_splice(unsigned int pos, isl::multi_val multi2) const {
+  auto res = isl_multi_val_range_splice(copy(), pos, multi2.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::reset_tuple_id(isl::dim type) const {
+  auto res = isl_multi_val_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::multi_val multi_val::reset_user() const {
+  auto res = isl_multi_val_reset_user(copy());
+  return manage(res);
+}
+
+isl::multi_val multi_val::scale_down_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_val_scale_down_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::scale_down_val(isl::val v) const {
+  auto res = isl_multi_val_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::scale_multi_val(isl::multi_val mv) const {
+  auto res = isl_multi_val_scale_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::scale_val(isl::val v) const {
+  auto res = isl_multi_val_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_multi_val_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_multi_val_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::set_tuple_name(isl::dim type, const std::string &s) const {
+  auto res = isl_multi_val_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());
+  return manage(res);
+}
+
+isl::multi_val multi_val::set_val(int pos, isl::val el) const {
+  auto res = isl_multi_val_set_val(copy(), pos, el.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::splice(unsigned int in_pos, unsigned int out_pos, isl::multi_val multi2) const {
+  auto res = isl_multi_val_splice(copy(), in_pos, out_pos, multi2.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::sub(isl::multi_val multi2) const {
+  auto res = isl_multi_val_sub(copy(), multi2.release());
+  return manage(res);
+}
+
+isl::multi_val multi_val::zero(isl::space space) {
+  auto res = isl_multi_val_zero(space.release());
+  return manage(res);
+}
+
+// implementations for isl::point
+isl::point manage(__isl_take isl_point *ptr) {
+  return point(ptr);
+}
+isl::point give(__isl_take isl_point *ptr) {
+  return manage(ptr);
+}
+
+
+point::point()
+    : ptr(nullptr) {}
+
+point::point(const isl::point &obj)
+    : ptr(obj.copy()) {}
+point::point(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+point::point(__isl_take isl_point *ptr)
+    : ptr(ptr) {}
+
+point::point(isl::space dim) {
+  auto res = isl_point_zero(dim.release());
+  ptr = res;
+}
+
+point &point::operator=(isl::point obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+point::~point() {
+  if (ptr)
+    isl_point_free(ptr);
+}
+
+__isl_give isl_point *point::copy() const & {
+  return isl_point_copy(ptr);
+}
+
+__isl_keep isl_point *point::get() const {
+  return ptr;
+}
+
+__isl_give isl_point *point::release() {
+  isl_point *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool point::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_point *point::keep() const {
+  return get();
+}
+
+__isl_give isl_point *point::take() {
+  return release();
+}
+
+point::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx point::get_ctx() const {
+  return isl::ctx(isl_point_get_ctx(ptr));
+}
+
+
+std::string point::to_str() const {
+  char *Tmp = isl_point_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void point::dump() const {
+  isl_point_dump(get());
+}
+
+
+isl::point point::add_ui(isl::dim type, int pos, unsigned int val) const {
+  auto res = isl_point_add_ui(copy(), static_cast<enum isl_dim_type>(type), pos, val);
+  return manage(res);
+}
+
+isl::val point::get_coordinate_val(isl::dim type, int pos) const {
+  auto res = isl_point_get_coordinate_val(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::space point::get_space() const {
+  auto res = isl_point_get_space(get());
+  return manage(res);
+}
+
+isl::point point::set_coordinate_val(isl::dim type, int pos, isl::val v) const {
+  auto res = isl_point_set_coordinate_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::point point::sub_ui(isl::dim type, int pos, unsigned int val) const {
+  auto res = isl_point_sub_ui(copy(), static_cast<enum isl_dim_type>(type), pos, val);
+  return manage(res);
+}
+
+// implementations for isl::pw_aff
+isl::pw_aff manage(__isl_take isl_pw_aff *ptr) {
+  return pw_aff(ptr);
+}
+isl::pw_aff give(__isl_take isl_pw_aff *ptr) {
+  return manage(ptr);
+}
+
+
+pw_aff::pw_aff()
+    : ptr(nullptr) {}
+
+pw_aff::pw_aff(const isl::pw_aff &obj)
+    : ptr(obj.copy()) {}
+pw_aff::pw_aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+pw_aff::pw_aff(__isl_take isl_pw_aff *ptr)
+    : ptr(ptr) {}
+
+pw_aff::pw_aff(isl::aff aff) {
+  auto res = isl_pw_aff_from_aff(aff.release());
+  ptr = res;
+}
+pw_aff::pw_aff(isl::local_space ls) {
+  auto res = isl_pw_aff_zero_on_domain(ls.release());
+  ptr = res;
+}
+pw_aff::pw_aff(isl::set domain, isl::val v) {
+  auto res = isl_pw_aff_val_on_domain(domain.release(), v.release());
+  ptr = res;
+}
+pw_aff::pw_aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_pw_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+pw_aff &pw_aff::operator=(isl::pw_aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+pw_aff::~pw_aff() {
+  if (ptr)
+    isl_pw_aff_free(ptr);
+}
+
+__isl_give isl_pw_aff *pw_aff::copy() const & {
+  return isl_pw_aff_copy(ptr);
+}
+
+__isl_keep isl_pw_aff *pw_aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_pw_aff *pw_aff::release() {
+  isl_pw_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool pw_aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_pw_aff *pw_aff::keep() const {
+  return get();
+}
+
+__isl_give isl_pw_aff *pw_aff::take() {
+  return release();
+}
+
+pw_aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx pw_aff::get_ctx() const {
+  return isl::ctx(isl_pw_aff_get_ctx(ptr));
+}
+
+
+std::string pw_aff::to_str() const {
+  char *Tmp = isl_pw_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void pw_aff::dump() const {
+  isl_pw_aff_dump(get());
+}
+
+
+isl::pw_aff pw_aff::add(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_add(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_pw_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::align_params(isl::space model) const {
+  auto res = isl_pw_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::alloc(isl::set set, isl::aff aff) {
+  auto res = isl_pw_aff_alloc(set.release(), aff.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::ceil() const {
+  auto res = isl_pw_aff_ceil(copy());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::coalesce() const {
+  auto res = isl_pw_aff_coalesce(copy());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::cond(isl::pw_aff pwaff_true, isl::pw_aff pwaff_false) const {
+  auto res = isl_pw_aff_cond(copy(), pwaff_true.release(), pwaff_false.release());
+  return manage(res);
+}
+
+unsigned int pw_aff::dim(isl::dim type) const {
+  auto res = isl_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::pw_aff pw_aff::div(isl::pw_aff pa2) const {
+  auto res = isl_pw_aff_div(copy(), pa2.release());
+  return manage(res);
+}
+
+isl::set pw_aff::domain() const {
+  auto res = isl_pw_aff_domain(copy());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::empty(isl::space dim) {
+  auto res = isl_pw_aff_empty(dim.release());
+  return manage(res);
+}
+
+isl::map pw_aff::eq_map(isl::pw_aff pa2) const {
+  auto res = isl_pw_aff_eq_map(copy(), pa2.release());
+  return manage(res);
+}
+
+isl::set pw_aff::eq_set(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_eq_set(copy(), pwaff2.release());
+  return manage(res);
+}
+
+int pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::pw_aff pw_aff::floor() const {
+  auto res = isl_pw_aff_floor(copy());
+  return manage(res);
+}
+
+isl::stat pw_aff::foreach_piece(const std::function<isl::stat(isl::set, isl::aff)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_set *arg_0, isl_aff *arg_1, void *arg_2) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::set, isl::aff)> **>(arg_2);
+    stat ret = (*func)(isl::manage(arg_0), isl::manage(arg_1));
+    return isl_stat(ret);
+  };
+  auto res = isl_pw_aff_foreach_piece(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::pw_aff pw_aff::from_range() const {
+  auto res = isl_pw_aff_from_range(copy());
+  return manage(res);
+}
+
+isl::set pw_aff::ge_set(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_ge_set(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::id pw_aff::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_pw_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+std::string pw_aff::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_pw_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::space pw_aff::get_domain_space() const {
+  auto res = isl_pw_aff_get_domain_space(get());
+  return manage(res);
+}
+
+uint32_t pw_aff::get_hash() const {
+  auto res = isl_pw_aff_get_hash(get());
+  return res;
+}
+
+isl::space pw_aff::get_space() const {
+  auto res = isl_pw_aff_get_space(get());
+  return manage(res);
+}
+
+isl::id pw_aff::get_tuple_id(isl::dim type) const {
+  auto res = isl_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::gist(isl::set context) const {
+  auto res = isl_pw_aff_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::gist_params(isl::set context) const {
+  auto res = isl_pw_aff_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::map pw_aff::gt_map(isl::pw_aff pa2) const {
+  auto res = isl_pw_aff_gt_map(copy(), pa2.release());
+  return manage(res);
+}
+
+isl::set pw_aff::gt_set(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_gt_set(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::boolean pw_aff::has_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_pw_aff_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean pw_aff::has_tuple_id(isl::dim type) const {
+  auto res = isl_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::intersect_domain(isl::set set) const {
+  auto res = isl_pw_aff_intersect_domain(copy(), set.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::intersect_params(isl::set set) const {
+  auto res = isl_pw_aff_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean pw_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean pw_aff::involves_nan() const {
+  auto res = isl_pw_aff_involves_nan(get());
+  return manage(res);
+}
+
+isl::boolean pw_aff::is_cst() const {
+  auto res = isl_pw_aff_is_cst(get());
+  return manage(res);
+}
+
+isl::boolean pw_aff::is_empty() const {
+  auto res = isl_pw_aff_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean pw_aff::is_equal(const isl::pw_aff &pa2) const {
+  auto res = isl_pw_aff_is_equal(get(), pa2.get());
+  return manage(res);
+}
+
+isl::set pw_aff::le_set(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_le_set(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::map pw_aff::lt_map(isl::pw_aff pa2) const {
+  auto res = isl_pw_aff_lt_map(copy(), pa2.release());
+  return manage(res);
+}
+
+isl::set pw_aff::lt_set(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_lt_set(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::max(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_max(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::min(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_min(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::mod(isl::val mod) const {
+  auto res = isl_pw_aff_mod_val(copy(), mod.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_pw_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::mul(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_mul(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::nan_on_domain(isl::local_space ls) {
+  auto res = isl_pw_aff_nan_on_domain(ls.release());
+  return manage(res);
+}
+
+isl::set pw_aff::ne_set(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_ne_set(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::neg() const {
+  auto res = isl_pw_aff_neg(copy());
+  return manage(res);
+}
+
+isl::set pw_aff::non_zero_set() const {
+  auto res = isl_pw_aff_non_zero_set(copy());
+  return manage(res);
+}
+
+isl::set pw_aff::nonneg_set() const {
+  auto res = isl_pw_aff_nonneg_set(copy());
+  return manage(res);
+}
+
+isl::set pw_aff::params() const {
+  auto res = isl_pw_aff_params(copy());
+  return manage(res);
+}
+
+int pw_aff::plain_cmp(const isl::pw_aff &pa2) const {
+  auto res = isl_pw_aff_plain_cmp(get(), pa2.get());
+  return res;
+}
+
+isl::boolean pw_aff::plain_is_equal(const isl::pw_aff &pwaff2) const {
+  auto res = isl_pw_aff_plain_is_equal(get(), pwaff2.get());
+  return manage(res);
+}
+
+isl::set pw_aff::pos_set() const {
+  auto res = isl_pw_aff_pos_set(copy());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::project_domain_on_params() const {
+  auto res = isl_pw_aff_project_domain_on_params(copy());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::pullback(isl::multi_aff ma) const {
+  auto res = isl_pw_aff_pullback_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::pullback(isl::pw_multi_aff pma) const {
+  auto res = isl_pw_aff_pullback_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::pullback(isl::multi_pw_aff mpa) const {
+  auto res = isl_pw_aff_pullback_multi_pw_aff(copy(), mpa.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::reset_tuple_id(isl::dim type) const {
+  auto res = isl_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::reset_user() const {
+  auto res = isl_pw_aff_reset_user(copy());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::scale(isl::val v) const {
+  auto res = isl_pw_aff_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::scale_down(isl::val f) const {
+  auto res = isl_pw_aff_scale_down_val(copy(), f.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::sub(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_sub(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::subtract_domain(isl::set set) const {
+  auto res = isl_pw_aff_subtract_domain(copy(), set.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::tdiv_q(isl::pw_aff pa2) const {
+  auto res = isl_pw_aff_tdiv_q(copy(), pa2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::tdiv_r(isl::pw_aff pa2) const {
+  auto res = isl_pw_aff_tdiv_r(copy(), pa2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::union_add(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_union_add(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::union_max(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_union_max(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::union_min(isl::pw_aff pwaff2) const {
+  auto res = isl_pw_aff_union_min(copy(), pwaff2.release());
+  return manage(res);
+}
+
+isl::pw_aff pw_aff::var_on_domain(isl::local_space ls, isl::dim type, unsigned int pos) {
+  auto res = isl_pw_aff_var_on_domain(ls.release(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::set pw_aff::zero_set() const {
+  auto res = isl_pw_aff_zero_set(copy());
+  return manage(res);
+}
+
+// implementations for isl::pw_aff_list
+isl::pw_aff_list manage(__isl_take isl_pw_aff_list *ptr) {
+  return pw_aff_list(ptr);
+}
+isl::pw_aff_list give(__isl_take isl_pw_aff_list *ptr) {
+  return manage(ptr);
+}
+
+
+pw_aff_list::pw_aff_list()
+    : ptr(nullptr) {}
+
+pw_aff_list::pw_aff_list(const isl::pw_aff_list &obj)
+    : ptr(obj.copy()) {}
+pw_aff_list::pw_aff_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+pw_aff_list::pw_aff_list(__isl_take isl_pw_aff_list *ptr)
+    : ptr(ptr) {}
+
+
+pw_aff_list &pw_aff_list::operator=(isl::pw_aff_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+pw_aff_list::~pw_aff_list() {
+  if (ptr)
+    isl_pw_aff_list_free(ptr);
+}
+
+__isl_give isl_pw_aff_list *pw_aff_list::copy() const & {
+  return isl_pw_aff_list_copy(ptr);
+}
+
+__isl_keep isl_pw_aff_list *pw_aff_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_pw_aff_list *pw_aff_list::release() {
+  isl_pw_aff_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool pw_aff_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_pw_aff_list *pw_aff_list::keep() const {
+  return get();
+}
+
+__isl_give isl_pw_aff_list *pw_aff_list::take() {
+  return release();
+}
+
+pw_aff_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx pw_aff_list::get_ctx() const {
+  return isl::ctx(isl_pw_aff_list_get_ctx(ptr));
+}
+
+
+
+void pw_aff_list::dump() const {
+  isl_pw_aff_list_dump(get());
+}
+
+
+
+// implementations for isl::pw_multi_aff
+isl::pw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr) {
+  return pw_multi_aff(ptr);
+}
+isl::pw_multi_aff give(__isl_take isl_pw_multi_aff *ptr) {
+  return manage(ptr);
+}
+
+
+pw_multi_aff::pw_multi_aff()
+    : ptr(nullptr) {}
+
+pw_multi_aff::pw_multi_aff(const isl::pw_multi_aff &obj)
+    : ptr(obj.copy()) {}
+pw_multi_aff::pw_multi_aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+pw_multi_aff::pw_multi_aff(__isl_take isl_pw_multi_aff *ptr)
+    : ptr(ptr) {}
+
+pw_multi_aff::pw_multi_aff(isl::multi_aff ma) {
+  auto res = isl_pw_multi_aff_from_multi_aff(ma.release());
+  ptr = res;
+}
+pw_multi_aff::pw_multi_aff(isl::pw_aff pa) {
+  auto res = isl_pw_multi_aff_from_pw_aff(pa.release());
+  ptr = res;
+}
+pw_multi_aff::pw_multi_aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_pw_multi_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+pw_multi_aff &pw_multi_aff::operator=(isl::pw_multi_aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+pw_multi_aff::~pw_multi_aff() {
+  if (ptr)
+    isl_pw_multi_aff_free(ptr);
+}
+
+__isl_give isl_pw_multi_aff *pw_multi_aff::copy() const & {
+  return isl_pw_multi_aff_copy(ptr);
+}
+
+__isl_keep isl_pw_multi_aff *pw_multi_aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_pw_multi_aff *pw_multi_aff::release() {
+  isl_pw_multi_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool pw_multi_aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_pw_multi_aff *pw_multi_aff::keep() const {
+  return get();
+}
+
+__isl_give isl_pw_multi_aff *pw_multi_aff::take() {
+  return release();
+}
+
+pw_multi_aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx pw_multi_aff::get_ctx() const {
+  return isl::ctx(isl_pw_multi_aff_get_ctx(ptr));
+}
+
+
+std::string pw_multi_aff::to_str() const {
+  char *Tmp = isl_pw_multi_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void pw_multi_aff::dump() const {
+  isl_pw_multi_aff_dump(get());
+}
+
+
+isl::pw_multi_aff pw_multi_aff::add(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_add(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::align_params(isl::space model) const {
+  auto res = isl_pw_multi_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::alloc(isl::set set, isl::multi_aff maff) {
+  auto res = isl_pw_multi_aff_alloc(set.release(), maff.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::coalesce() const {
+  auto res = isl_pw_multi_aff_coalesce(copy());
+  return manage(res);
+}
+
+unsigned int pw_multi_aff::dim(isl::dim type) const {
+  auto res = isl_pw_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::set pw_multi_aff::domain() const {
+  auto res = isl_pw_multi_aff_domain(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::empty(isl::space space) {
+  auto res = isl_pw_multi_aff_empty(space.release());
+  return manage(res);
+}
+
+int pw_multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_pw_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::pw_multi_aff pw_multi_aff::fix_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_pw_multi_aff_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::flat_range_product(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_flat_range_product(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::stat pw_multi_aff::foreach_piece(const std::function<isl::stat(isl::set, isl::multi_aff)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_set *arg_0, isl_multi_aff *arg_1, void *arg_2) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::set, isl::multi_aff)> **>(arg_2);
+    stat ret = (*func)(isl::manage(arg_0), isl::manage(arg_1));
+    return isl_stat(ret);
+  };
+  auto res = isl_pw_multi_aff_foreach_piece(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::from_domain(isl::set set) {
+  auto res = isl_pw_multi_aff_from_domain(set.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::from_map(isl::map map) {
+  auto res = isl_pw_multi_aff_from_map(map.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::from_multi_pw_aff(isl::multi_pw_aff mpa) {
+  auto res = isl_pw_multi_aff_from_multi_pw_aff(mpa.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::from_set(isl::set set) {
+  auto res = isl_pw_multi_aff_from_set(set.release());
+  return manage(res);
+}
+
+isl::id pw_multi_aff::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_pw_multi_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+std::string pw_multi_aff::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_pw_multi_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::space pw_multi_aff::get_domain_space() const {
+  auto res = isl_pw_multi_aff_get_domain_space(get());
+  return manage(res);
+}
+
+isl::pw_aff pw_multi_aff::get_pw_aff(int pos) const {
+  auto res = isl_pw_multi_aff_get_pw_aff(get(), pos);
+  return manage(res);
+}
+
+isl::space pw_multi_aff::get_space() const {
+  auto res = isl_pw_multi_aff_get_space(get());
+  return manage(res);
+}
+
+isl::id pw_multi_aff::get_tuple_id(isl::dim type) const {
+  auto res = isl_pw_multi_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+std::string pw_multi_aff::get_tuple_name(isl::dim type) const {
+  auto res = isl_pw_multi_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::pw_multi_aff pw_multi_aff::gist(isl::set set) const {
+  auto res = isl_pw_multi_aff_gist(copy(), set.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::gist_params(isl::set set) const {
+  auto res = isl_pw_multi_aff_gist_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean pw_multi_aff::has_tuple_id(isl::dim type) const {
+  auto res = isl_pw_multi_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::boolean pw_multi_aff::has_tuple_name(isl::dim type) const {
+  auto res = isl_pw_multi_aff_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::identity(isl::space space) {
+  auto res = isl_pw_multi_aff_identity(space.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::intersect_domain(isl::set set) const {
+  auto res = isl_pw_multi_aff_intersect_domain(copy(), set.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::intersect_params(isl::set set) const {
+  auto res = isl_pw_multi_aff_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean pw_multi_aff::involves_nan() const {
+  auto res = isl_pw_multi_aff_involves_nan(get());
+  return manage(res);
+}
+
+isl::boolean pw_multi_aff::is_equal(const isl::pw_multi_aff &pma2) const {
+  auto res = isl_pw_multi_aff_is_equal(get(), pma2.get());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::multi_val_on_domain(isl::set domain, isl::multi_val mv) {
+  auto res = isl_pw_multi_aff_multi_val_on_domain(domain.release(), mv.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::neg() const {
+  auto res = isl_pw_multi_aff_neg(copy());
+  return manage(res);
+}
+
+isl::boolean pw_multi_aff::plain_is_equal(const isl::pw_multi_aff &pma2) const {
+  auto res = isl_pw_multi_aff_plain_is_equal(get(), pma2.get());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::product(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_product(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::project_domain_on_params() const {
+  auto res = isl_pw_multi_aff_project_domain_on_params(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::project_out_map(isl::space space, isl::dim type, unsigned int first, unsigned int n) {
+  auto res = isl_pw_multi_aff_project_out_map(space.release(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::pullback(isl::multi_aff ma) const {
+  auto res = isl_pw_multi_aff_pullback_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::pullback(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_pullback_pw_multi_aff(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::range_map(isl::space space) {
+  auto res = isl_pw_multi_aff_range_map(space.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::range_product(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_range_product(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::reset_tuple_id(isl::dim type) const {
+  auto res = isl_pw_multi_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::reset_user() const {
+  auto res = isl_pw_multi_aff_reset_user(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::scale_down_val(isl::val v) const {
+  auto res = isl_pw_multi_aff_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::scale_multi_val(isl::multi_val mv) const {
+  auto res = isl_pw_multi_aff_scale_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::scale_val(isl::val v) const {
+  auto res = isl_pw_multi_aff_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_pw_multi_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::set_pw_aff(unsigned int pos, isl::pw_aff pa) const {
+  auto res = isl_pw_multi_aff_set_pw_aff(copy(), pos, pa.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_pw_multi_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::sub(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_sub(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::subtract_domain(isl::set set) const {
+  auto res = isl_pw_multi_aff_subtract_domain(copy(), set.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::union_add(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_union_add(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::union_lexmax(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_union_lexmax(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::union_lexmin(isl::pw_multi_aff pma2) const {
+  auto res = isl_pw_multi_aff_union_lexmin(copy(), pma2.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff pw_multi_aff::zero(isl::space space) {
+  auto res = isl_pw_multi_aff_zero(space.release());
+  return manage(res);
+}
+
+// implementations for isl::pw_qpolynomial
+isl::pw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr) {
+  return pw_qpolynomial(ptr);
+}
+isl::pw_qpolynomial give(__isl_take isl_pw_qpolynomial *ptr) {
+  return manage(ptr);
+}
+
+
+pw_qpolynomial::pw_qpolynomial()
+    : ptr(nullptr) {}
+
+pw_qpolynomial::pw_qpolynomial(const isl::pw_qpolynomial &obj)
+    : ptr(obj.copy()) {}
+pw_qpolynomial::pw_qpolynomial(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+pw_qpolynomial::pw_qpolynomial(__isl_take isl_pw_qpolynomial *ptr)
+    : ptr(ptr) {}
+
+pw_qpolynomial::pw_qpolynomial(isl::ctx ctx, const std::string &str) {
+  auto res = isl_pw_qpolynomial_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+pw_qpolynomial &pw_qpolynomial::operator=(isl::pw_qpolynomial obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+pw_qpolynomial::~pw_qpolynomial() {
+  if (ptr)
+    isl_pw_qpolynomial_free(ptr);
+}
+
+__isl_give isl_pw_qpolynomial *pw_qpolynomial::copy() const & {
+  return isl_pw_qpolynomial_copy(ptr);
+}
+
+__isl_keep isl_pw_qpolynomial *pw_qpolynomial::get() const {
+  return ptr;
+}
+
+__isl_give isl_pw_qpolynomial *pw_qpolynomial::release() {
+  isl_pw_qpolynomial *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool pw_qpolynomial::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_pw_qpolynomial *pw_qpolynomial::keep() const {
+  return get();
+}
+
+__isl_give isl_pw_qpolynomial *pw_qpolynomial::take() {
+  return release();
+}
+
+pw_qpolynomial::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx pw_qpolynomial::get_ctx() const {
+  return isl::ctx(isl_pw_qpolynomial_get_ctx(ptr));
+}
+
+
+std::string pw_qpolynomial::to_str() const {
+  char *Tmp = isl_pw_qpolynomial_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void pw_qpolynomial::dump() const {
+  isl_pw_qpolynomial_dump(get());
+}
+
+
+isl::pw_qpolynomial pw_qpolynomial::add(isl::pw_qpolynomial pwqp2) const {
+  auto res = isl_pw_qpolynomial_add(copy(), pwqp2.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_pw_qpolynomial_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::alloc(isl::set set, isl::qpolynomial qp) {
+  auto res = isl_pw_qpolynomial_alloc(set.release(), qp.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::coalesce() const {
+  auto res = isl_pw_qpolynomial_coalesce(copy());
+  return manage(res);
+}
+
+unsigned int pw_qpolynomial::dim(isl::dim type) const {
+  auto res = isl_pw_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::set pw_qpolynomial::domain() const {
+  auto res = isl_pw_qpolynomial_domain(copy());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::val pw_qpolynomial::eval(isl::point pnt) const {
+  auto res = isl_pw_qpolynomial_eval(copy(), pnt.release());
+  return manage(res);
+}
+
+int pw_qpolynomial::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_pw_qpolynomial_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::pw_qpolynomial pw_qpolynomial::fix_val(isl::dim type, unsigned int n, isl::val v) const {
+  auto res = isl_pw_qpolynomial_fix_val(copy(), static_cast<enum isl_dim_type>(type), n, v.release());
+  return manage(res);
+}
+
+isl::stat pw_qpolynomial::foreach_piece(const std::function<isl::stat(isl::set, isl::qpolynomial)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_set *arg_0, isl_qpolynomial *arg_1, void *arg_2) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::set, isl::qpolynomial)> **>(arg_2);
+    stat ret = (*func)(isl::manage(arg_0), isl::manage(arg_1));
+    return isl_stat(ret);
+  };
+  auto res = isl_pw_qpolynomial_foreach_piece(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::from_pw_aff(isl::pw_aff pwaff) {
+  auto res = isl_pw_qpolynomial_from_pw_aff(pwaff.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::from_qpolynomial(isl::qpolynomial qp) {
+  auto res = isl_pw_qpolynomial_from_qpolynomial(qp.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::from_range() const {
+  auto res = isl_pw_qpolynomial_from_range(copy());
+  return manage(res);
+}
+
+isl::space pw_qpolynomial::get_domain_space() const {
+  auto res = isl_pw_qpolynomial_get_domain_space(get());
+  return manage(res);
+}
+
+isl::space pw_qpolynomial::get_space() const {
+  auto res = isl_pw_qpolynomial_get_space(get());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::gist(isl::set context) const {
+  auto res = isl_pw_qpolynomial_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::gist_params(isl::set context) const {
+  auto res = isl_pw_qpolynomial_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::boolean pw_qpolynomial::has_equal_space(const isl::pw_qpolynomial &pwqp2) const {
+  auto res = isl_pw_qpolynomial_has_equal_space(get(), pwqp2.get());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_qpolynomial_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::intersect_domain(isl::set set) const {
+  auto res = isl_pw_qpolynomial_intersect_domain(copy(), set.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::intersect_params(isl::set set) const {
+  auto res = isl_pw_qpolynomial_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean pw_qpolynomial::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_qpolynomial_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean pw_qpolynomial::involves_nan() const {
+  auto res = isl_pw_qpolynomial_involves_nan(get());
+  return manage(res);
+}
+
+isl::boolean pw_qpolynomial::is_zero() const {
+  auto res = isl_pw_qpolynomial_is_zero(get());
+  return manage(res);
+}
+
+isl::val pw_qpolynomial::max() const {
+  auto res = isl_pw_qpolynomial_max(copy());
+  return manage(res);
+}
+
+isl::val pw_qpolynomial::min() const {
+  auto res = isl_pw_qpolynomial_min(copy());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_pw_qpolynomial_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::mul(isl::pw_qpolynomial pwqp2) const {
+  auto res = isl_pw_qpolynomial_mul(copy(), pwqp2.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::neg() const {
+  auto res = isl_pw_qpolynomial_neg(copy());
+  return manage(res);
+}
+
+isl::boolean pw_qpolynomial::plain_is_equal(const isl::pw_qpolynomial &pwqp2) const {
+  auto res = isl_pw_qpolynomial_plain_is_equal(get(), pwqp2.get());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::pow(unsigned int exponent) const {
+  auto res = isl_pw_qpolynomial_pow(copy(), exponent);
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::project_domain_on_params() const {
+  auto res = isl_pw_qpolynomial_project_domain_on_params(copy());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::reset_domain_space(isl::space dim) const {
+  auto res = isl_pw_qpolynomial_reset_domain_space(copy(), dim.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::reset_user() const {
+  auto res = isl_pw_qpolynomial_reset_user(copy());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::scale_down_val(isl::val v) const {
+  auto res = isl_pw_qpolynomial_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::scale_val(isl::val v) const {
+  auto res = isl_pw_qpolynomial_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::split_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_pw_qpolynomial_split_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::split_periods(int max_periods) const {
+  auto res = isl_pw_qpolynomial_split_periods(copy(), max_periods);
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::sub(isl::pw_qpolynomial pwqp2) const {
+  auto res = isl_pw_qpolynomial_sub(copy(), pwqp2.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::subtract_domain(isl::set set) const {
+  auto res = isl_pw_qpolynomial_subtract_domain(copy(), set.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::to_polynomial(int sign) const {
+  auto res = isl_pw_qpolynomial_to_polynomial(copy(), sign);
+  return manage(res);
+}
+
+isl::pw_qpolynomial pw_qpolynomial::zero(isl::space dim) {
+  auto res = isl_pw_qpolynomial_zero(dim.release());
+  return manage(res);
+}
+
+// implementations for isl::qpolynomial
+isl::qpolynomial manage(__isl_take isl_qpolynomial *ptr) {
+  return qpolynomial(ptr);
+}
+isl::qpolynomial give(__isl_take isl_qpolynomial *ptr) {
+  return manage(ptr);
+}
+
+
+qpolynomial::qpolynomial()
+    : ptr(nullptr) {}
+
+qpolynomial::qpolynomial(const isl::qpolynomial &obj)
+    : ptr(obj.copy()) {}
+qpolynomial::qpolynomial(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+qpolynomial::qpolynomial(__isl_take isl_qpolynomial *ptr)
+    : ptr(ptr) {}
+
+
+qpolynomial &qpolynomial::operator=(isl::qpolynomial obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+qpolynomial::~qpolynomial() {
+  if (ptr)
+    isl_qpolynomial_free(ptr);
+}
+
+__isl_give isl_qpolynomial *qpolynomial::copy() const & {
+  return isl_qpolynomial_copy(ptr);
+}
+
+__isl_keep isl_qpolynomial *qpolynomial::get() const {
+  return ptr;
+}
+
+__isl_give isl_qpolynomial *qpolynomial::release() {
+  isl_qpolynomial *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool qpolynomial::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_qpolynomial *qpolynomial::keep() const {
+  return get();
+}
+
+__isl_give isl_qpolynomial *qpolynomial::take() {
+  return release();
+}
+
+qpolynomial::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx qpolynomial::get_ctx() const {
+  return isl::ctx(isl_qpolynomial_get_ctx(ptr));
+}
+
+
+
+void qpolynomial::dump() const {
+  isl_qpolynomial_dump(get());
+}
+
+
+isl::qpolynomial qpolynomial::add(isl::qpolynomial qp2) const {
+  auto res = isl_qpolynomial_add(copy(), qp2.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_qpolynomial_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::align_params(isl::space model) const {
+  auto res = isl_qpolynomial_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::stat qpolynomial::as_polynomial_on_domain(const isl::basic_set &bset, const std::function<isl::stat(isl::basic_set, isl::qpolynomial)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_basic_set *arg_0, isl_qpolynomial *arg_1, void *arg_2) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::basic_set, isl::qpolynomial)> **>(arg_2);
+    stat ret = (*func)(isl::manage(arg_0), isl::manage(arg_1));
+    return isl_stat(ret);
+  };
+  auto res = isl_qpolynomial_as_polynomial_on_domain(get(), bset.get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+unsigned int qpolynomial::dim(isl::dim type) const {
+  auto res = isl_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::qpolynomial qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::val qpolynomial::eval(isl::point pnt) const {
+  auto res = isl_qpolynomial_eval(copy(), pnt.release());
+  return manage(res);
+}
+
+isl::stat qpolynomial::foreach_term(const std::function<isl::stat(isl::term)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_term *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::term)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_qpolynomial_foreach_term(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::qpolynomial qpolynomial::from_aff(isl::aff aff) {
+  auto res = isl_qpolynomial_from_aff(aff.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::from_constraint(isl::constraint c, isl::dim type, unsigned int pos) {
+  auto res = isl_qpolynomial_from_constraint(c.release(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::from_term(isl::term term) {
+  auto res = isl_qpolynomial_from_term(term.release());
+  return manage(res);
+}
+
+isl::val qpolynomial::get_constant_val() const {
+  auto res = isl_qpolynomial_get_constant_val(get());
+  return manage(res);
+}
+
+isl::space qpolynomial::get_domain_space() const {
+  auto res = isl_qpolynomial_get_domain_space(get());
+  return manage(res);
+}
+
+isl::space qpolynomial::get_space() const {
+  auto res = isl_qpolynomial_get_space(get());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::gist(isl::set context) const {
+  auto res = isl_qpolynomial_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::gist_params(isl::set context) const {
+  auto res = isl_qpolynomial_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::homogenize() const {
+  auto res = isl_qpolynomial_homogenize(copy());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::infty_on_domain(isl::space dim) {
+  auto res = isl_qpolynomial_infty_on_domain(dim.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::insert_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_qpolynomial_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean qpolynomial::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_qpolynomial_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean qpolynomial::is_infty() const {
+  auto res = isl_qpolynomial_is_infty(get());
+  return manage(res);
+}
+
+isl::boolean qpolynomial::is_nan() const {
+  auto res = isl_qpolynomial_is_nan(get());
+  return manage(res);
+}
+
+isl::boolean qpolynomial::is_neginfty() const {
+  auto res = isl_qpolynomial_is_neginfty(get());
+  return manage(res);
+}
+
+isl::boolean qpolynomial::is_zero() const {
+  auto res = isl_qpolynomial_is_zero(get());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_qpolynomial_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::mul(isl::qpolynomial qp2) const {
+  auto res = isl_qpolynomial_mul(copy(), qp2.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::nan_on_domain(isl::space dim) {
+  auto res = isl_qpolynomial_nan_on_domain(dim.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::neg() const {
+  auto res = isl_qpolynomial_neg(copy());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::neginfty_on_domain(isl::space dim) {
+  auto res = isl_qpolynomial_neginfty_on_domain(dim.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::one_on_domain(isl::space dim) {
+  auto res = isl_qpolynomial_one_on_domain(dim.release());
+  return manage(res);
+}
+
+isl::boolean qpolynomial::plain_is_equal(const isl::qpolynomial &qp2) const {
+  auto res = isl_qpolynomial_plain_is_equal(get(), qp2.get());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::pow(unsigned int power) const {
+  auto res = isl_qpolynomial_pow(copy(), power);
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::project_domain_on_params() const {
+  auto res = isl_qpolynomial_project_domain_on_params(copy());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::scale_down_val(isl::val v) const {
+  auto res = isl_qpolynomial_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::scale_val(isl::val v) const {
+  auto res = isl_qpolynomial_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+int qpolynomial::sgn() const {
+  auto res = isl_qpolynomial_sgn(get());
+  return res;
+}
+
+isl::qpolynomial qpolynomial::sub(isl::qpolynomial qp2) const {
+  auto res = isl_qpolynomial_sub(copy(), qp2.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::val_on_domain(isl::space space, isl::val val) {
+  auto res = isl_qpolynomial_val_on_domain(space.release(), val.release());
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::var_on_domain(isl::space dim, isl::dim type, unsigned int pos) {
+  auto res = isl_qpolynomial_var_on_domain(dim.release(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::qpolynomial qpolynomial::zero_on_domain(isl::space dim) {
+  auto res = isl_qpolynomial_zero_on_domain(dim.release());
+  return manage(res);
+}
+
+// implementations for isl::schedule
+isl::schedule manage(__isl_take isl_schedule *ptr) {
+  return schedule(ptr);
+}
+isl::schedule give(__isl_take isl_schedule *ptr) {
+  return manage(ptr);
+}
+
+
+schedule::schedule()
+    : ptr(nullptr) {}
+
+schedule::schedule(const isl::schedule &obj)
+    : ptr(obj.copy()) {}
+schedule::schedule(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+schedule::schedule(__isl_take isl_schedule *ptr)
+    : ptr(ptr) {}
+
+schedule::schedule(isl::ctx ctx, const std::string &str) {
+  auto res = isl_schedule_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+schedule &schedule::operator=(isl::schedule obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+schedule::~schedule() {
+  if (ptr)
+    isl_schedule_free(ptr);
+}
+
+__isl_give isl_schedule *schedule::copy() const & {
+  return isl_schedule_copy(ptr);
+}
+
+__isl_keep isl_schedule *schedule::get() const {
+  return ptr;
+}
+
+__isl_give isl_schedule *schedule::release() {
+  isl_schedule *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool schedule::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_schedule *schedule::keep() const {
+  return get();
+}
+
+__isl_give isl_schedule *schedule::take() {
+  return release();
+}
+
+schedule::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx schedule::get_ctx() const {
+  return isl::ctx(isl_schedule_get_ctx(ptr));
+}
+
+
+std::string schedule::to_str() const {
+  char *Tmp = isl_schedule_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void schedule::dump() const {
+  isl_schedule_dump(get());
+}
+
+
+isl::schedule schedule::align_params(isl::space space) const {
+  auto res = isl_schedule_align_params(copy(), space.release());
+  return manage(res);
+}
+
+isl::schedule schedule::empty(isl::space space) {
+  auto res = isl_schedule_empty(space.release());
+  return manage(res);
+}
+
+isl::schedule schedule::from_domain(isl::union_set domain) {
+  auto res = isl_schedule_from_domain(domain.release());
+  return manage(res);
+}
+
+isl::union_set schedule::get_domain() const {
+  auto res = isl_schedule_get_domain(get());
+  return manage(res);
+}
+
+isl::union_map schedule::get_map() const {
+  auto res = isl_schedule_get_map(get());
+  return manage(res);
+}
+
+isl::schedule_node schedule::get_root() const {
+  auto res = isl_schedule_get_root(get());
+  return manage(res);
+}
+
+isl::schedule schedule::gist_domain_params(isl::set context) const {
+  auto res = isl_schedule_gist_domain_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::schedule schedule::insert_context(isl::set context) const {
+  auto res = isl_schedule_insert_context(copy(), context.release());
+  return manage(res);
+}
+
+isl::schedule schedule::insert_guard(isl::set guard) const {
+  auto res = isl_schedule_insert_guard(copy(), guard.release());
+  return manage(res);
+}
+
+isl::schedule schedule::insert_partial_schedule(isl::multi_union_pw_aff partial) const {
+  auto res = isl_schedule_insert_partial_schedule(copy(), partial.release());
+  return manage(res);
+}
+
+isl::schedule schedule::intersect_domain(isl::union_set domain) const {
+  auto res = isl_schedule_intersect_domain(copy(), domain.release());
+  return manage(res);
+}
+
+isl::boolean schedule::plain_is_equal(const isl::schedule &schedule2) const {
+  auto res = isl_schedule_plain_is_equal(get(), schedule2.get());
+  return manage(res);
+}
+
+isl::schedule schedule::pullback(isl::union_pw_multi_aff upma) const {
+  auto res = isl_schedule_pullback_union_pw_multi_aff(copy(), upma.release());
+  return manage(res);
+}
+
+isl::schedule schedule::reset_user() const {
+  auto res = isl_schedule_reset_user(copy());
+  return manage(res);
+}
+
+isl::schedule schedule::sequence(isl::schedule schedule2) const {
+  auto res = isl_schedule_sequence(copy(), schedule2.release());
+  return manage(res);
+}
+
+isl::schedule schedule::set(isl::schedule schedule2) const {
+  auto res = isl_schedule_set(copy(), schedule2.release());
+  return manage(res);
+}
+
+// implementations for isl::schedule_constraints
+isl::schedule_constraints manage(__isl_take isl_schedule_constraints *ptr) {
+  return schedule_constraints(ptr);
+}
+isl::schedule_constraints give(__isl_take isl_schedule_constraints *ptr) {
+  return manage(ptr);
+}
+
+
+schedule_constraints::schedule_constraints()
+    : ptr(nullptr) {}
+
+schedule_constraints::schedule_constraints(const isl::schedule_constraints &obj)
+    : ptr(obj.copy()) {}
+schedule_constraints::schedule_constraints(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+schedule_constraints::schedule_constraints(__isl_take isl_schedule_constraints *ptr)
+    : ptr(ptr) {}
+
+schedule_constraints::schedule_constraints(isl::ctx ctx, const std::string &str) {
+  auto res = isl_schedule_constraints_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+schedule_constraints &schedule_constraints::operator=(isl::schedule_constraints obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+schedule_constraints::~schedule_constraints() {
+  if (ptr)
+    isl_schedule_constraints_free(ptr);
+}
+
+__isl_give isl_schedule_constraints *schedule_constraints::copy() const & {
+  return isl_schedule_constraints_copy(ptr);
+}
+
+__isl_keep isl_schedule_constraints *schedule_constraints::get() const {
+  return ptr;
+}
+
+__isl_give isl_schedule_constraints *schedule_constraints::release() {
+  isl_schedule_constraints *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool schedule_constraints::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_schedule_constraints *schedule_constraints::keep() const {
+  return get();
+}
+
+__isl_give isl_schedule_constraints *schedule_constraints::take() {
+  return release();
+}
+
+schedule_constraints::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx schedule_constraints::get_ctx() const {
+  return isl::ctx(isl_schedule_constraints_get_ctx(ptr));
+}
+
+
+std::string schedule_constraints::to_str() const {
+  char *Tmp = isl_schedule_constraints_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void schedule_constraints::dump() const {
+  isl_schedule_constraints_dump(get());
+}
+
+
+isl::schedule_constraints schedule_constraints::apply(isl::union_map umap) const {
+  auto res = isl_schedule_constraints_apply(copy(), umap.release());
+  return manage(res);
+}
+
+isl::schedule schedule_constraints::compute_schedule() const {
+  auto res = isl_schedule_constraints_compute_schedule(copy());
+  return manage(res);
+}
+
+isl::union_map schedule_constraints::get_coincidence() const {
+  auto res = isl_schedule_constraints_get_coincidence(get());
+  return manage(res);
+}
+
+isl::union_map schedule_constraints::get_conditional_validity() const {
+  auto res = isl_schedule_constraints_get_conditional_validity(get());
+  return manage(res);
+}
+
+isl::union_map schedule_constraints::get_conditional_validity_condition() const {
+  auto res = isl_schedule_constraints_get_conditional_validity_condition(get());
+  return manage(res);
+}
+
+isl::set schedule_constraints::get_context() const {
+  auto res = isl_schedule_constraints_get_context(get());
+  return manage(res);
+}
+
+isl::union_set schedule_constraints::get_domain() const {
+  auto res = isl_schedule_constraints_get_domain(get());
+  return manage(res);
+}
+
+isl::union_map schedule_constraints::get_proximity() const {
+  auto res = isl_schedule_constraints_get_proximity(get());
+  return manage(res);
+}
+
+isl::union_map schedule_constraints::get_validity() const {
+  auto res = isl_schedule_constraints_get_validity(get());
+  return manage(res);
+}
+
+isl::schedule_constraints schedule_constraints::on_domain(isl::union_set domain) {
+  auto res = isl_schedule_constraints_on_domain(domain.release());
+  return manage(res);
+}
+
+isl::schedule_constraints schedule_constraints::set_coincidence(isl::union_map coincidence) const {
+  auto res = isl_schedule_constraints_set_coincidence(copy(), coincidence.release());
+  return manage(res);
+}
+
+isl::schedule_constraints schedule_constraints::set_conditional_validity(isl::union_map condition, isl::union_map validity) const {
+  auto res = isl_schedule_constraints_set_conditional_validity(copy(), condition.release(), validity.release());
+  return manage(res);
+}
+
+isl::schedule_constraints schedule_constraints::set_context(isl::set context) const {
+  auto res = isl_schedule_constraints_set_context(copy(), context.release());
+  return manage(res);
+}
+
+isl::schedule_constraints schedule_constraints::set_proximity(isl::union_map proximity) const {
+  auto res = isl_schedule_constraints_set_proximity(copy(), proximity.release());
+  return manage(res);
+}
+
+isl::schedule_constraints schedule_constraints::set_validity(isl::union_map validity) const {
+  auto res = isl_schedule_constraints_set_validity(copy(), validity.release());
+  return manage(res);
+}
+
+// implementations for isl::schedule_node
+isl::schedule_node manage(__isl_take isl_schedule_node *ptr) {
+  return schedule_node(ptr);
+}
+isl::schedule_node give(__isl_take isl_schedule_node *ptr) {
+  return manage(ptr);
+}
+
+
+schedule_node::schedule_node()
+    : ptr(nullptr) {}
+
+schedule_node::schedule_node(const isl::schedule_node &obj)
+    : ptr(obj.copy()) {}
+schedule_node::schedule_node(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+schedule_node::schedule_node(__isl_take isl_schedule_node *ptr)
+    : ptr(ptr) {}
+
+
+schedule_node &schedule_node::operator=(isl::schedule_node obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+schedule_node::~schedule_node() {
+  if (ptr)
+    isl_schedule_node_free(ptr);
+}
+
+__isl_give isl_schedule_node *schedule_node::copy() const & {
+  return isl_schedule_node_copy(ptr);
+}
+
+__isl_keep isl_schedule_node *schedule_node::get() const {
+  return ptr;
+}
+
+__isl_give isl_schedule_node *schedule_node::release() {
+  isl_schedule_node *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool schedule_node::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_schedule_node *schedule_node::keep() const {
+  return get();
+}
+
+__isl_give isl_schedule_node *schedule_node::take() {
+  return release();
+}
+
+schedule_node::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx schedule_node::get_ctx() const {
+  return isl::ctx(isl_schedule_node_get_ctx(ptr));
+}
+
+
+std::string schedule_node::to_str() const {
+  char *Tmp = isl_schedule_node_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void schedule_node::dump() const {
+  isl_schedule_node_dump(get());
+}
+
+
+isl::schedule_node schedule_node::align_params(isl::space space) const {
+  auto res = isl_schedule_node_align_params(copy(), space.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::ancestor(int generation) const {
+  auto res = isl_schedule_node_ancestor(copy(), generation);
+  return manage(res);
+}
+
+isl::boolean schedule_node::band_member_get_coincident(int pos) const {
+  auto res = isl_schedule_node_band_member_get_coincident(get(), pos);
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::band_member_set_coincident(int pos, int coincident) const {
+  auto res = isl_schedule_node_band_member_set_coincident(copy(), pos, coincident);
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::band_set_ast_build_options(isl::union_set options) const {
+  auto res = isl_schedule_node_band_set_ast_build_options(copy(), options.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::child(int pos) const {
+  auto res = isl_schedule_node_child(copy(), pos);
+  return manage(res);
+}
+
+isl::set schedule_node::context_get_context() const {
+  auto res = isl_schedule_node_context_get_context(get());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::cut() const {
+  auto res = isl_schedule_node_cut(copy());
+  return manage(res);
+}
+
+isl::union_set schedule_node::domain_get_domain() const {
+  auto res = isl_schedule_node_domain_get_domain(get());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff schedule_node::expansion_get_contraction() const {
+  auto res = isl_schedule_node_expansion_get_contraction(get());
+  return manage(res);
+}
+
+isl::union_map schedule_node::expansion_get_expansion() const {
+  auto res = isl_schedule_node_expansion_get_expansion(get());
+  return manage(res);
+}
+
+isl::union_map schedule_node::extension_get_extension() const {
+  auto res = isl_schedule_node_extension_get_extension(get());
+  return manage(res);
+}
+
+isl::union_set schedule_node::filter_get_filter() const {
+  auto res = isl_schedule_node_filter_get_filter(get());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::first_child() const {
+  auto res = isl_schedule_node_first_child(copy());
+  return manage(res);
+}
+
+isl::stat schedule_node::foreach_ancestor_top_down(const std::function<isl::stat(isl::schedule_node)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_schedule_node *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::schedule_node)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_schedule_node_foreach_ancestor_top_down(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::schedule_node schedule_node::from_domain(isl::union_set domain) {
+  auto res = isl_schedule_node_from_domain(domain.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::from_extension(isl::union_map extension) {
+  auto res = isl_schedule_node_from_extension(extension.release());
+  return manage(res);
+}
+
+int schedule_node::get_ancestor_child_position(const isl::schedule_node &ancestor) const {
+  auto res = isl_schedule_node_get_ancestor_child_position(get(), ancestor.get());
+  return res;
+}
+
+isl::schedule_node schedule_node::get_child(int pos) const {
+  auto res = isl_schedule_node_get_child(get(), pos);
+  return manage(res);
+}
+
+int schedule_node::get_child_position() const {
+  auto res = isl_schedule_node_get_child_position(get());
+  return res;
+}
+
+isl::union_set schedule_node::get_domain() const {
+  auto res = isl_schedule_node_get_domain(get());
+  return manage(res);
+}
+
+isl::multi_union_pw_aff schedule_node::get_prefix_schedule_multi_union_pw_aff() const {
+  auto res = isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(get());
+  return manage(res);
+}
+
+isl::union_map schedule_node::get_prefix_schedule_relation() const {
+  auto res = isl_schedule_node_get_prefix_schedule_relation(get());
+  return manage(res);
+}
+
+isl::union_map schedule_node::get_prefix_schedule_union_map() const {
+  auto res = isl_schedule_node_get_prefix_schedule_union_map(get());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff schedule_node::get_prefix_schedule_union_pw_multi_aff() const {
+  auto res = isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(get());
+  return manage(res);
+}
+
+isl::schedule schedule_node::get_schedule() const {
+  auto res = isl_schedule_node_get_schedule(get());
+  return manage(res);
+}
+
+int schedule_node::get_schedule_depth() const {
+  auto res = isl_schedule_node_get_schedule_depth(get());
+  return res;
+}
+
+isl::schedule_node schedule_node::get_shared_ancestor(const isl::schedule_node &node2) const {
+  auto res = isl_schedule_node_get_shared_ancestor(get(), node2.get());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff schedule_node::get_subtree_contraction() const {
+  auto res = isl_schedule_node_get_subtree_contraction(get());
+  return manage(res);
+}
+
+isl::union_map schedule_node::get_subtree_expansion() const {
+  auto res = isl_schedule_node_get_subtree_expansion(get());
+  return manage(res);
+}
+
+isl::union_map schedule_node::get_subtree_schedule_union_map() const {
+  auto res = isl_schedule_node_get_subtree_schedule_union_map(get());
+  return manage(res);
+}
+
+int schedule_node::get_tree_depth() const {
+  auto res = isl_schedule_node_get_tree_depth(get());
+  return res;
+}
+
+isl::union_set schedule_node::get_universe_domain() const {
+  auto res = isl_schedule_node_get_universe_domain(get());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::graft_after(isl::schedule_node graft) const {
+  auto res = isl_schedule_node_graft_after(copy(), graft.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::graft_before(isl::schedule_node graft) const {
+  auto res = isl_schedule_node_graft_before(copy(), graft.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::group(isl::id group_id) const {
+  auto res = isl_schedule_node_group(copy(), group_id.release());
+  return manage(res);
+}
+
+isl::set schedule_node::guard_get_guard() const {
+  auto res = isl_schedule_node_guard_get_guard(get());
+  return manage(res);
+}
+
+isl::boolean schedule_node::has_children() const {
+  auto res = isl_schedule_node_has_children(get());
+  return manage(res);
+}
+
+isl::boolean schedule_node::has_next_sibling() const {
+  auto res = isl_schedule_node_has_next_sibling(get());
+  return manage(res);
+}
+
+isl::boolean schedule_node::has_parent() const {
+  auto res = isl_schedule_node_has_parent(get());
+  return manage(res);
+}
+
+isl::boolean schedule_node::has_previous_sibling() const {
+  auto res = isl_schedule_node_has_previous_sibling(get());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::insert_context(isl::set context) const {
+  auto res = isl_schedule_node_insert_context(copy(), context.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::insert_filter(isl::union_set filter) const {
+  auto res = isl_schedule_node_insert_filter(copy(), filter.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::insert_guard(isl::set context) const {
+  auto res = isl_schedule_node_insert_guard(copy(), context.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::insert_mark(isl::id mark) const {
+  auto res = isl_schedule_node_insert_mark(copy(), mark.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::insert_partial_schedule(isl::multi_union_pw_aff schedule) const {
+  auto res = isl_schedule_node_insert_partial_schedule(copy(), schedule.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::insert_sequence(isl::union_set_list filters) const {
+  auto res = isl_schedule_node_insert_sequence(copy(), filters.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::insert_set(isl::union_set_list filters) const {
+  auto res = isl_schedule_node_insert_set(copy(), filters.release());
+  return manage(res);
+}
+
+isl::boolean schedule_node::is_equal(const isl::schedule_node &node2) const {
+  auto res = isl_schedule_node_is_equal(get(), node2.get());
+  return manage(res);
+}
+
+isl::boolean schedule_node::is_subtree_anchored() const {
+  auto res = isl_schedule_node_is_subtree_anchored(get());
+  return manage(res);
+}
+
+isl::id schedule_node::mark_get_id() const {
+  auto res = isl_schedule_node_mark_get_id(get());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::next_sibling() const {
+  auto res = isl_schedule_node_next_sibling(copy());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::order_after(isl::union_set filter) const {
+  auto res = isl_schedule_node_order_after(copy(), filter.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::order_before(isl::union_set filter) const {
+  auto res = isl_schedule_node_order_before(copy(), filter.release());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::parent() const {
+  auto res = isl_schedule_node_parent(copy());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::previous_sibling() const {
+  auto res = isl_schedule_node_previous_sibling(copy());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::reset_user() const {
+  auto res = isl_schedule_node_reset_user(copy());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::root() const {
+  auto res = isl_schedule_node_root(copy());
+  return manage(res);
+}
+
+isl::schedule_node schedule_node::sequence_splice_child(int pos) const {
+  auto res = isl_schedule_node_sequence_splice_child(copy(), pos);
+  return manage(res);
+}
+
+// implementations for isl::set
+isl::set manage(__isl_take isl_set *ptr) {
+  return set(ptr);
+}
+isl::set give(__isl_take isl_set *ptr) {
+  return manage(ptr);
+}
+
+
+set::set()
+    : ptr(nullptr) {}
+
+set::set(const isl::set &obj)
+    : ptr(obj.copy()) {}
+set::set(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+set::set(__isl_take isl_set *ptr)
+    : ptr(ptr) {}
+
+set::set(isl::union_set uset) {
+  auto res = isl_set_from_union_set(uset.release());
+  ptr = res;
+}
+set::set(isl::ctx ctx, const std::string &str) {
+  auto res = isl_set_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+set::set(isl::basic_set bset) {
+  auto res = isl_set_from_basic_set(bset.release());
+  ptr = res;
+}
+set::set(isl::point pnt) {
+  auto res = isl_set_from_point(pnt.release());
+  ptr = res;
+}
+
+set &set::operator=(isl::set obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+set::~set() {
+  if (ptr)
+    isl_set_free(ptr);
+}
+
+__isl_give isl_set *set::copy() const & {
+  return isl_set_copy(ptr);
+}
+
+__isl_keep isl_set *set::get() const {
+  return ptr;
+}
+
+__isl_give isl_set *set::release() {
+  isl_set *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool set::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_set *set::keep() const {
+  return get();
+}
+
+__isl_give isl_set *set::take() {
+  return release();
+}
+
+set::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx set::get_ctx() const {
+  return isl::ctx(isl_set_get_ctx(ptr));
+}
+
+
+std::string set::to_str() const {
+  char *Tmp = isl_set_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void set::dump() const {
+  isl_set_dump(get());
+}
+
+
+isl::set set::add_constraint(isl::constraint constraint) const {
+  auto res = isl_set_add_constraint(copy(), constraint.release());
+  return manage(res);
+}
+
+isl::set set::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_set_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::basic_set set::affine_hull() const {
+  auto res = isl_set_affine_hull(copy());
+  return manage(res);
+}
+
+isl::set set::align_params(isl::space model) const {
+  auto res = isl_set_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::set set::apply(isl::map map) const {
+  auto res = isl_set_apply(copy(), map.release());
+  return manage(res);
+}
+
+isl::basic_set set::bounded_simple_hull() const {
+  auto res = isl_set_bounded_simple_hull(copy());
+  return manage(res);
+}
+
+isl::set set::box_from_points(isl::point pnt1, isl::point pnt2) {
+  auto res = isl_set_box_from_points(pnt1.release(), pnt2.release());
+  return manage(res);
+}
+
+isl::set set::coalesce() const {
+  auto res = isl_set_coalesce(copy());
+  return manage(res);
+}
+
+isl::basic_set set::coefficients() const {
+  auto res = isl_set_coefficients(copy());
+  return manage(res);
+}
+
+isl::set set::complement() const {
+  auto res = isl_set_complement(copy());
+  return manage(res);
+}
+
+isl::basic_set set::convex_hull() const {
+  auto res = isl_set_convex_hull(copy());
+  return manage(res);
+}
+
+isl::val set::count_val() const {
+  auto res = isl_set_count_val(get());
+  return manage(res);
+}
+
+isl::set set::detect_equalities() const {
+  auto res = isl_set_detect_equalities(copy());
+  return manage(res);
+}
+
+unsigned int set::dim(isl::dim type) const {
+  auto res = isl_set_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::boolean set::dim_has_any_lower_bound(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_dim_has_any_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean set::dim_has_any_upper_bound(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_dim_has_any_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean set::dim_has_lower_bound(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_dim_has_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean set::dim_has_upper_bound(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_dim_has_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean set::dim_is_bounded(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_dim_is_bounded(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::pw_aff set::dim_max(int pos) const {
+  auto res = isl_set_dim_max(copy(), pos);
+  return manage(res);
+}
+
+isl::pw_aff set::dim_min(int pos) const {
+  auto res = isl_set_dim_min(copy(), pos);
+  return manage(res);
+}
+
+isl::set set::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::eliminate(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::empty(isl::space dim) {
+  auto res = isl_set_empty(dim.release());
+  return manage(res);
+}
+
+isl::set set::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const {
+  auto res = isl_set_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);
+  return manage(res);
+}
+
+int set::find_dim_by_id(isl::dim type, const isl::id &id) const {
+  auto res = isl_set_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());
+  return res;
+}
+
+int set::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_set_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::set set::fix_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_set_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::set set::fix_val(isl::dim type, unsigned int pos, isl::val v) const {
+  auto res = isl_set_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());
+  return manage(res);
+}
+
+isl::set set::flat_product(isl::set set2) const {
+  auto res = isl_set_flat_product(copy(), set2.release());
+  return manage(res);
+}
+
+isl::set set::flatten() const {
+  auto res = isl_set_flatten(copy());
+  return manage(res);
+}
+
+isl::map set::flatten_map() const {
+  auto res = isl_set_flatten_map(copy());
+  return manage(res);
+}
+
+int set::follows_at(const isl::set &set2, int pos) const {
+  auto res = isl_set_follows_at(get(), set2.get(), pos);
+  return res;
+}
+
+isl::stat set::foreach_basic_set(const std::function<isl::stat(isl::basic_set)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_basic_set *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::basic_set)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_set_foreach_basic_set(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::stat set::foreach_point(const std::function<isl::stat(isl::point)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_point *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::point)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_set_foreach_point(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::set set::from_multi_pw_aff(isl::multi_pw_aff mpa) {
+  auto res = isl_set_from_multi_pw_aff(mpa.release());
+  return manage(res);
+}
+
+isl::set set::from_params() const {
+  auto res = isl_set_from_params(copy());
+  return manage(res);
+}
+
+isl::set set::from_pw_aff(isl::pw_aff pwaff) {
+  auto res = isl_set_from_pw_aff(pwaff.release());
+  return manage(res);
+}
+
+isl::set set::from_pw_multi_aff(isl::pw_multi_aff pma) {
+  auto res = isl_set_from_pw_multi_aff(pma.release());
+  return manage(res);
+}
+
+isl::basic_set_list set::get_basic_set_list() const {
+  auto res = isl_set_get_basic_set_list(get());
+  return manage(res);
+}
+
+isl::id set::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+std::string set::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::space set::get_space() const {
+  auto res = isl_set_get_space(get());
+  return manage(res);
+}
+
+isl::id set::get_tuple_id() const {
+  auto res = isl_set_get_tuple_id(get());
+  return manage(res);
+}
+
+std::string set::get_tuple_name() const {
+  auto res = isl_set_get_tuple_name(get());
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::set set::gist(isl::set context) const {
+  auto res = isl_set_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::set set::gist_basic_set(isl::basic_set context) const {
+  auto res = isl_set_gist_basic_set(copy(), context.release());
+  return manage(res);
+}
+
+isl::set set::gist_params(isl::set context) const {
+  auto res = isl_set_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::boolean set::has_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean set::has_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean set::has_equal_space(const isl::set &set2) const {
+  auto res = isl_set_has_equal_space(get(), set2.get());
+  return manage(res);
+}
+
+isl::boolean set::has_tuple_id() const {
+  auto res = isl_set_has_tuple_id(get());
+  return manage(res);
+}
+
+isl::boolean set::has_tuple_name() const {
+  auto res = isl_set_has_tuple_name(get());
+  return manage(res);
+}
+
+isl::map set::identity() const {
+  auto res = isl_set_identity(copy());
+  return manage(res);
+}
+
+isl::pw_aff set::indicator_function() const {
+  auto res = isl_set_indicator_function(copy());
+  return manage(res);
+}
+
+isl::set set::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const {
+  auto res = isl_set_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);
+  return manage(res);
+}
+
+isl::set set::intersect(isl::set set2) const {
+  auto res = isl_set_intersect(copy(), set2.release());
+  return manage(res);
+}
+
+isl::set set::intersect_params(isl::set params) const {
+  auto res = isl_set_intersect_params(copy(), params.release());
+  return manage(res);
+}
+
+isl::boolean set::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean set::is_bounded() const {
+  auto res = isl_set_is_bounded(get());
+  return manage(res);
+}
+
+isl::boolean set::is_box() const {
+  auto res = isl_set_is_box(get());
+  return manage(res);
+}
+
+isl::boolean set::is_disjoint(const isl::set &set2) const {
+  auto res = isl_set_is_disjoint(get(), set2.get());
+  return manage(res);
+}
+
+isl::boolean set::is_empty() const {
+  auto res = isl_set_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean set::is_equal(const isl::set &set2) const {
+  auto res = isl_set_is_equal(get(), set2.get());
+  return manage(res);
+}
+
+isl::boolean set::is_params() const {
+  auto res = isl_set_is_params(get());
+  return manage(res);
+}
+
+isl::boolean set::is_singleton() const {
+  auto res = isl_set_is_singleton(get());
+  return manage(res);
+}
+
+isl::boolean set::is_strict_subset(const isl::set &set2) const {
+  auto res = isl_set_is_strict_subset(get(), set2.get());
+  return manage(res);
+}
+
+isl::boolean set::is_subset(const isl::set &set2) const {
+  auto res = isl_set_is_subset(get(), set2.get());
+  return manage(res);
+}
+
+isl::boolean set::is_wrapping() const {
+  auto res = isl_set_is_wrapping(get());
+  return manage(res);
+}
+
+isl::map set::lex_ge_set(isl::set set2) const {
+  auto res = isl_set_lex_ge_set(copy(), set2.release());
+  return manage(res);
+}
+
+isl::map set::lex_gt_set(isl::set set2) const {
+  auto res = isl_set_lex_gt_set(copy(), set2.release());
+  return manage(res);
+}
+
+isl::map set::lex_le_set(isl::set set2) const {
+  auto res = isl_set_lex_le_set(copy(), set2.release());
+  return manage(res);
+}
+
+isl::map set::lex_lt_set(isl::set set2) const {
+  auto res = isl_set_lex_lt_set(copy(), set2.release());
+  return manage(res);
+}
+
+isl::set set::lexmax() const {
+  auto res = isl_set_lexmax(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff set::lexmax_pw_multi_aff() const {
+  auto res = isl_set_lexmax_pw_multi_aff(copy());
+  return manage(res);
+}
+
+isl::set set::lexmin() const {
+  auto res = isl_set_lexmin(copy());
+  return manage(res);
+}
+
+isl::pw_multi_aff set::lexmin_pw_multi_aff() const {
+  auto res = isl_set_lexmin_pw_multi_aff(copy());
+  return manage(res);
+}
+
+isl::set set::lower_bound_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_set_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::set set::lower_bound_val(isl::dim type, unsigned int pos, isl::val value) const {
+  auto res = isl_set_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());
+  return manage(res);
+}
+
+isl::val set::max_val(const isl::aff &obj) const {
+  auto res = isl_set_max_val(get(), obj.get());
+  return manage(res);
+}
+
+isl::val set::min_val(const isl::aff &obj) const {
+  auto res = isl_set_min_val(get(), obj.get());
+  return manage(res);
+}
+
+isl::set set::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_set_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::set set::nat_universe(isl::space dim) {
+  auto res = isl_set_nat_universe(dim.release());
+  return manage(res);
+}
+
+isl::set set::neg() const {
+  auto res = isl_set_neg(copy());
+  return manage(res);
+}
+
+isl::set set::params() const {
+  auto res = isl_set_params(copy());
+  return manage(res);
+}
+
+int set::plain_cmp(const isl::set &set2) const {
+  auto res = isl_set_plain_cmp(get(), set2.get());
+  return res;
+}
+
+isl::val set::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const {
+  auto res = isl_set_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean set::plain_is_disjoint(const isl::set &set2) const {
+  auto res = isl_set_plain_is_disjoint(get(), set2.get());
+  return manage(res);
+}
+
+isl::boolean set::plain_is_empty() const {
+  auto res = isl_set_plain_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean set::plain_is_equal(const isl::set &set2) const {
+  auto res = isl_set_plain_is_equal(get(), set2.get());
+  return manage(res);
+}
+
+isl::boolean set::plain_is_universe() const {
+  auto res = isl_set_plain_is_universe(get());
+  return manage(res);
+}
+
+isl::basic_set set::plain_unshifted_simple_hull() const {
+  auto res = isl_set_plain_unshifted_simple_hull(copy());
+  return manage(res);
+}
+
+isl::basic_set set::polyhedral_hull() const {
+  auto res = isl_set_polyhedral_hull(copy());
+  return manage(res);
+}
+
+isl::set set::preimage_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_set_preimage_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::set set::preimage_multi_pw_aff(isl::multi_pw_aff mpa) const {
+  auto res = isl_set_preimage_multi_pw_aff(copy(), mpa.release());
+  return manage(res);
+}
+
+isl::set set::preimage_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_set_preimage_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::set set::product(isl::set set2) const {
+  auto res = isl_set_product(copy(), set2.release());
+  return manage(res);
+}
+
+isl::map set::project_onto_map(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_project_onto_map(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::project_out(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::remove_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::remove_divs() const {
+  auto res = isl_set_remove_divs(copy());
+  return manage(res);
+}
+
+isl::set set::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::remove_redundancies() const {
+  auto res = isl_set_remove_redundancies(copy());
+  return manage(res);
+}
+
+isl::set set::remove_unknown_divs() const {
+  auto res = isl_set_remove_unknown_divs(copy());
+  return manage(res);
+}
+
+isl::set set::reset_space(isl::space dim) const {
+  auto res = isl_set_reset_space(copy(), dim.release());
+  return manage(res);
+}
+
+isl::set set::reset_tuple_id() const {
+  auto res = isl_set_reset_tuple_id(copy());
+  return manage(res);
+}
+
+isl::set set::reset_user() const {
+  auto res = isl_set_reset_user(copy());
+  return manage(res);
+}
+
+isl::basic_set set::sample() const {
+  auto res = isl_set_sample(copy());
+  return manage(res);
+}
+
+isl::point set::sample_point() const {
+  auto res = isl_set_sample_point(copy());
+  return manage(res);
+}
+
+isl::set set::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_set_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::set set::set_tuple_id(isl::id id) const {
+  auto res = isl_set_set_tuple_id(copy(), id.release());
+  return manage(res);
+}
+
+isl::set set::set_tuple_name(const std::string &s) const {
+  auto res = isl_set_set_tuple_name(copy(), s.c_str());
+  return manage(res);
+}
+
+isl::basic_set set::simple_hull() const {
+  auto res = isl_set_simple_hull(copy());
+  return manage(res);
+}
+
+int set::size() const {
+  auto res = isl_set_size(get());
+  return res;
+}
+
+isl::basic_set set::solutions() const {
+  auto res = isl_set_solutions(copy());
+  return manage(res);
+}
+
+isl::set set::split_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_set_split_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::set set::subtract(isl::set set2) const {
+  auto res = isl_set_subtract(copy(), set2.release());
+  return manage(res);
+}
+
+isl::set set::sum(isl::set set2) const {
+  auto res = isl_set_sum(copy(), set2.release());
+  return manage(res);
+}
+
+isl::set set::unite(isl::set set2) const {
+  auto res = isl_set_union(copy(), set2.release());
+  return manage(res);
+}
+
+isl::set set::universe(isl::space dim) {
+  auto res = isl_set_universe(dim.release());
+  return manage(res);
+}
+
+isl::basic_set set::unshifted_simple_hull() const {
+  auto res = isl_set_unshifted_simple_hull(copy());
+  return manage(res);
+}
+
+isl::basic_set set::unshifted_simple_hull_from_set_list(isl::set_list list) const {
+  auto res = isl_set_unshifted_simple_hull_from_set_list(copy(), list.release());
+  return manage(res);
+}
+
+isl::map set::unwrap() const {
+  auto res = isl_set_unwrap(copy());
+  return manage(res);
+}
+
+isl::set set::upper_bound_si(isl::dim type, unsigned int pos, int value) const {
+  auto res = isl_set_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);
+  return manage(res);
+}
+
+isl::set set::upper_bound_val(isl::dim type, unsigned int pos, isl::val value) const {
+  auto res = isl_set_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());
+  return manage(res);
+}
+
+isl::map set::wrapped_domain_map() const {
+  auto res = isl_set_wrapped_domain_map(copy());
+  return manage(res);
+}
+
+// implementations for isl::set_list
+isl::set_list manage(__isl_take isl_set_list *ptr) {
+  return set_list(ptr);
+}
+isl::set_list give(__isl_take isl_set_list *ptr) {
+  return manage(ptr);
+}
+
+
+set_list::set_list()
+    : ptr(nullptr) {}
+
+set_list::set_list(const isl::set_list &obj)
+    : ptr(obj.copy()) {}
+set_list::set_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+set_list::set_list(__isl_take isl_set_list *ptr)
+    : ptr(ptr) {}
+
+
+set_list &set_list::operator=(isl::set_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+set_list::~set_list() {
+  if (ptr)
+    isl_set_list_free(ptr);
+}
+
+__isl_give isl_set_list *set_list::copy() const & {
+  return isl_set_list_copy(ptr);
+}
+
+__isl_keep isl_set_list *set_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_set_list *set_list::release() {
+  isl_set_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool set_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_set_list *set_list::keep() const {
+  return get();
+}
+
+__isl_give isl_set_list *set_list::take() {
+  return release();
+}
+
+set_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx set_list::get_ctx() const {
+  return isl::ctx(isl_set_list_get_ctx(ptr));
+}
+
+
+
+void set_list::dump() const {
+  isl_set_list_dump(get());
+}
+
+
+
+// implementations for isl::space
+isl::space manage(__isl_take isl_space *ptr) {
+  return space(ptr);
+}
+isl::space give(__isl_take isl_space *ptr) {
+  return manage(ptr);
+}
+
+
+space::space()
+    : ptr(nullptr) {}
+
+space::space(const isl::space &obj)
+    : ptr(obj.copy()) {}
+space::space(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+space::space(__isl_take isl_space *ptr)
+    : ptr(ptr) {}
+
+space::space(isl::ctx ctx, unsigned int nparam, unsigned int n_in, unsigned int n_out) {
+  auto res = isl_space_alloc(ctx.release(), nparam, n_in, n_out);
+  ptr = res;
+}
+space::space(isl::ctx ctx, unsigned int nparam, unsigned int dim) {
+  auto res = isl_space_set_alloc(ctx.release(), nparam, dim);
+  ptr = res;
+}
+
+space &space::operator=(isl::space obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+space::~space() {
+  if (ptr)
+    isl_space_free(ptr);
+}
+
+__isl_give isl_space *space::copy() const & {
+  return isl_space_copy(ptr);
+}
+
+__isl_keep isl_space *space::get() const {
+  return ptr;
+}
+
+__isl_give isl_space *space::release() {
+  isl_space *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool space::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_space *space::keep() const {
+  return get();
+}
+
+__isl_give isl_space *space::take() {
+  return release();
+}
+
+space::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx space::get_ctx() const {
+  return isl::ctx(isl_space_get_ctx(ptr));
+}
+
+
+std::string space::to_str() const {
+  char *Tmp = isl_space_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void space::dump() const {
+  isl_space_dump(get());
+}
+
+
+isl::space space::add_dims(isl::dim type, unsigned int n) const {
+  auto res = isl_space_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);
+  return manage(res);
+}
+
+isl::space space::align_params(isl::space dim2) const {
+  auto res = isl_space_align_params(copy(), dim2.release());
+  return manage(res);
+}
+
+isl::boolean space::can_curry() const {
+  auto res = isl_space_can_curry(get());
+  return manage(res);
+}
+
+isl::boolean space::can_range_curry() const {
+  auto res = isl_space_can_range_curry(get());
+  return manage(res);
+}
+
+isl::boolean space::can_uncurry() const {
+  auto res = isl_space_can_uncurry(get());
+  return manage(res);
+}
+
+isl::boolean space::can_zip() const {
+  auto res = isl_space_can_zip(get());
+  return manage(res);
+}
+
+isl::space space::curry() const {
+  auto res = isl_space_curry(copy());
+  return manage(res);
+}
+
+unsigned int space::dim(isl::dim type) const {
+  auto res = isl_space_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::space space::domain() const {
+  auto res = isl_space_domain(copy());
+  return manage(res);
+}
+
+isl::space space::domain_factor_domain() const {
+  auto res = isl_space_domain_factor_domain(copy());
+  return manage(res);
+}
+
+isl::space space::domain_factor_range() const {
+  auto res = isl_space_domain_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean space::domain_is_wrapping() const {
+  auto res = isl_space_domain_is_wrapping(get());
+  return manage(res);
+}
+
+isl::space space::domain_map() const {
+  auto res = isl_space_domain_map(copy());
+  return manage(res);
+}
+
+isl::space space::domain_product(isl::space right) const {
+  auto res = isl_space_domain_product(copy(), right.release());
+  return manage(res);
+}
+
+isl::space space::drop_dims(isl::dim type, unsigned int first, unsigned int num) const {
+  auto res = isl_space_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, num);
+  return manage(res);
+}
+
+isl::space space::factor_domain() const {
+  auto res = isl_space_factor_domain(copy());
+  return manage(res);
+}
+
+isl::space space::factor_range() const {
+  auto res = isl_space_factor_range(copy());
+  return manage(res);
+}
+
+int space::find_dim_by_id(isl::dim type, const isl::id &id) const {
+  auto res = isl_space_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());
+  return res;
+}
+
+int space::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_space_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::space space::from_domain() const {
+  auto res = isl_space_from_domain(copy());
+  return manage(res);
+}
+
+isl::space space::from_range() const {
+  auto res = isl_space_from_range(copy());
+  return manage(res);
+}
+
+isl::id space::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_space_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+std::string space::get_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_space_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::id space::get_tuple_id(isl::dim type) const {
+  auto res = isl_space_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+std::string space::get_tuple_name(isl::dim type) const {
+  auto res = isl_space_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  std::string tmp(res);
+  return tmp;
+}
+
+isl::boolean space::has_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_space_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean space::has_dim_name(isl::dim type, unsigned int pos) const {
+  auto res = isl_space_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+isl::boolean space::has_equal_params(const isl::space &space2) const {
+  auto res = isl_space_has_equal_params(get(), space2.get());
+  return manage(res);
+}
+
+isl::boolean space::has_equal_tuples(const isl::space &space2) const {
+  auto res = isl_space_has_equal_tuples(get(), space2.get());
+  return manage(res);
+}
+
+isl::boolean space::has_tuple_id(isl::dim type) const {
+  auto res = isl_space_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::boolean space::has_tuple_name(isl::dim type) const {
+  auto res = isl_space_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::space space::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const {
+  auto res = isl_space_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);
+  return manage(res);
+}
+
+isl::boolean space::is_domain(const isl::space &space2) const {
+  auto res = isl_space_is_domain(get(), space2.get());
+  return manage(res);
+}
+
+isl::boolean space::is_equal(const isl::space &space2) const {
+  auto res = isl_space_is_equal(get(), space2.get());
+  return manage(res);
+}
+
+isl::boolean space::is_map() const {
+  auto res = isl_space_is_map(get());
+  return manage(res);
+}
+
+isl::boolean space::is_params() const {
+  auto res = isl_space_is_params(get());
+  return manage(res);
+}
+
+isl::boolean space::is_product() const {
+  auto res = isl_space_is_product(get());
+  return manage(res);
+}
+
+isl::boolean space::is_range(const isl::space &space2) const {
+  auto res = isl_space_is_range(get(), space2.get());
+  return manage(res);
+}
+
+isl::boolean space::is_set() const {
+  auto res = isl_space_is_set(get());
+  return manage(res);
+}
+
+isl::boolean space::is_wrapping() const {
+  auto res = isl_space_is_wrapping(get());
+  return manage(res);
+}
+
+isl::space space::join(isl::space right) const {
+  auto res = isl_space_join(copy(), right.release());
+  return manage(res);
+}
+
+isl::space space::map_from_domain_and_range(isl::space range) const {
+  auto res = isl_space_map_from_domain_and_range(copy(), range.release());
+  return manage(res);
+}
+
+isl::space space::map_from_set() const {
+  auto res = isl_space_map_from_set(copy());
+  return manage(res);
+}
+
+isl::space space::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const {
+  auto res = isl_space_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);
+  return manage(res);
+}
+
+isl::space space::params() const {
+  auto res = isl_space_params(copy());
+  return manage(res);
+}
+
+isl::space space::params_alloc(isl::ctx ctx, unsigned int nparam) {
+  auto res = isl_space_params_alloc(ctx.release(), nparam);
+  return manage(res);
+}
+
+isl::space space::product(isl::space right) const {
+  auto res = isl_space_product(copy(), right.release());
+  return manage(res);
+}
+
+isl::space space::range() const {
+  auto res = isl_space_range(copy());
+  return manage(res);
+}
+
+isl::space space::range_curry() const {
+  auto res = isl_space_range_curry(copy());
+  return manage(res);
+}
+
+isl::space space::range_factor_domain() const {
+  auto res = isl_space_range_factor_domain(copy());
+  return manage(res);
+}
+
+isl::space space::range_factor_range() const {
+  auto res = isl_space_range_factor_range(copy());
+  return manage(res);
+}
+
+isl::boolean space::range_is_wrapping() const {
+  auto res = isl_space_range_is_wrapping(get());
+  return manage(res);
+}
+
+isl::space space::range_map() const {
+  auto res = isl_space_range_map(copy());
+  return manage(res);
+}
+
+isl::space space::range_product(isl::space right) const {
+  auto res = isl_space_range_product(copy(), right.release());
+  return manage(res);
+}
+
+isl::space space::reset_tuple_id(isl::dim type) const {
+  auto res = isl_space_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));
+  return manage(res);
+}
+
+isl::space space::reset_user() const {
+  auto res = isl_space_reset_user(copy());
+  return manage(res);
+}
+
+isl::space space::reverse() const {
+  auto res = isl_space_reverse(copy());
+  return manage(res);
+}
+
+isl::space space::set_dim_id(isl::dim type, unsigned int pos, isl::id id) const {
+  auto res = isl_space_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());
+  return manage(res);
+}
+
+isl::space space::set_from_params() const {
+  auto res = isl_space_set_from_params(copy());
+  return manage(res);
+}
+
+isl::space space::set_tuple_id(isl::dim type, isl::id id) const {
+  auto res = isl_space_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());
+  return manage(res);
+}
+
+isl::space space::set_tuple_name(isl::dim type, const std::string &s) const {
+  auto res = isl_space_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());
+  return manage(res);
+}
+
+isl::boolean space::tuple_is_equal(isl::dim type1, const isl::space &space2, isl::dim type2) const {
+  auto res = isl_space_tuple_is_equal(get(), static_cast<enum isl_dim_type>(type1), space2.get(), static_cast<enum isl_dim_type>(type2));
+  return manage(res);
+}
+
+isl::space space::uncurry() const {
+  auto res = isl_space_uncurry(copy());
+  return manage(res);
+}
+
+isl::space space::unwrap() const {
+  auto res = isl_space_unwrap(copy());
+  return manage(res);
+}
+
+isl::space space::wrap() const {
+  auto res = isl_space_wrap(copy());
+  return manage(res);
+}
+
+isl::space space::zip() const {
+  auto res = isl_space_zip(copy());
+  return manage(res);
+}
+
+// implementations for isl::term
+isl::term manage(__isl_take isl_term *ptr) {
+  return term(ptr);
+}
+isl::term give(__isl_take isl_term *ptr) {
+  return manage(ptr);
+}
+
+
+term::term()
+    : ptr(nullptr) {}
+
+term::term(const isl::term &obj)
+    : ptr(obj.copy()) {}
+term::term(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+term::term(__isl_take isl_term *ptr)
+    : ptr(ptr) {}
+
+
+term &term::operator=(isl::term obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+term::~term() {
+  if (ptr)
+    isl_term_free(ptr);
+}
+
+__isl_give isl_term *term::copy() const & {
+  return isl_term_copy(ptr);
+}
+
+__isl_keep isl_term *term::get() const {
+  return ptr;
+}
+
+__isl_give isl_term *term::release() {
+  isl_term *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool term::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_term *term::keep() const {
+  return get();
+}
+
+__isl_give isl_term *term::take() {
+  return release();
+}
+
+term::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx term::get_ctx() const {
+  return isl::ctx(isl_term_get_ctx(ptr));
+}
+
+
+
+
+unsigned int term::dim(isl::dim type) const {
+  auto res = isl_term_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::val term::get_coefficient_val() const {
+  auto res = isl_term_get_coefficient_val(get());
+  return manage(res);
+}
+
+isl::aff term::get_div(unsigned int pos) const {
+  auto res = isl_term_get_div(get(), pos);
+  return manage(res);
+}
+
+int term::get_exp(isl::dim type, unsigned int pos) const {
+  auto res = isl_term_get_exp(get(), static_cast<enum isl_dim_type>(type), pos);
+  return res;
+}
+
+// implementations for isl::union_access_info
+isl::union_access_info manage(__isl_take isl_union_access_info *ptr) {
+  return union_access_info(ptr);
+}
+isl::union_access_info give(__isl_take isl_union_access_info *ptr) {
+  return manage(ptr);
+}
+
+
+union_access_info::union_access_info()
+    : ptr(nullptr) {}
+
+union_access_info::union_access_info(const isl::union_access_info &obj)
+    : ptr(obj.copy()) {}
+union_access_info::union_access_info(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_access_info::union_access_info(__isl_take isl_union_access_info *ptr)
+    : ptr(ptr) {}
+
+union_access_info::union_access_info(isl::union_map sink) {
+  auto res = isl_union_access_info_from_sink(sink.release());
+  ptr = res;
+}
+
+union_access_info &union_access_info::operator=(isl::union_access_info obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_access_info::~union_access_info() {
+  if (ptr)
+    isl_union_access_info_free(ptr);
+}
+
+__isl_give isl_union_access_info *union_access_info::copy() const & {
+  return isl_union_access_info_copy(ptr);
+}
+
+__isl_keep isl_union_access_info *union_access_info::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_access_info *union_access_info::release() {
+  isl_union_access_info *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_access_info::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_access_info *union_access_info::keep() const {
+  return get();
+}
+
+__isl_give isl_union_access_info *union_access_info::take() {
+  return release();
+}
+
+union_access_info::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_access_info::get_ctx() const {
+  return isl::ctx(isl_union_access_info_get_ctx(ptr));
+}
+
+
+std::string union_access_info::to_str() const {
+  char *Tmp = isl_union_access_info_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+
+isl::union_flow union_access_info::compute_flow() const {
+  auto res = isl_union_access_info_compute_flow(copy());
+  return manage(res);
+}
+
+isl::union_access_info union_access_info::set_kill(isl::union_map kill) const {
+  auto res = isl_union_access_info_set_kill(copy(), kill.release());
+  return manage(res);
+}
+
+isl::union_access_info union_access_info::set_may_source(isl::union_map may_source) const {
+  auto res = isl_union_access_info_set_may_source(copy(), may_source.release());
+  return manage(res);
+}
+
+isl::union_access_info union_access_info::set_must_source(isl::union_map must_source) const {
+  auto res = isl_union_access_info_set_must_source(copy(), must_source.release());
+  return manage(res);
+}
+
+isl::union_access_info union_access_info::set_schedule(isl::schedule schedule) const {
+  auto res = isl_union_access_info_set_schedule(copy(), schedule.release());
+  return manage(res);
+}
+
+isl::union_access_info union_access_info::set_schedule_map(isl::union_map schedule_map) const {
+  auto res = isl_union_access_info_set_schedule_map(copy(), schedule_map.release());
+  return manage(res);
+}
+
+// implementations for isl::union_flow
+isl::union_flow manage(__isl_take isl_union_flow *ptr) {
+  return union_flow(ptr);
+}
+isl::union_flow give(__isl_take isl_union_flow *ptr) {
+  return manage(ptr);
+}
+
+
+union_flow::union_flow()
+    : ptr(nullptr) {}
+
+union_flow::union_flow(const isl::union_flow &obj)
+    : ptr(obj.copy()) {}
+union_flow::union_flow(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_flow::union_flow(__isl_take isl_union_flow *ptr)
+    : ptr(ptr) {}
+
+
+union_flow &union_flow::operator=(isl::union_flow obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_flow::~union_flow() {
+  if (ptr)
+    isl_union_flow_free(ptr);
+}
+
+__isl_give isl_union_flow *union_flow::copy() const & {
+  return isl_union_flow_copy(ptr);
+}
+
+__isl_keep isl_union_flow *union_flow::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_flow *union_flow::release() {
+  isl_union_flow *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_flow::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_flow *union_flow::keep() const {
+  return get();
+}
+
+__isl_give isl_union_flow *union_flow::take() {
+  return release();
+}
+
+union_flow::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_flow::get_ctx() const {
+  return isl::ctx(isl_union_flow_get_ctx(ptr));
+}
+
+
+std::string union_flow::to_str() const {
+  char *Tmp = isl_union_flow_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+
+isl::union_map union_flow::get_full_may_dependence() const {
+  auto res = isl_union_flow_get_full_may_dependence(get());
+  return manage(res);
+}
+
+isl::union_map union_flow::get_full_must_dependence() const {
+  auto res = isl_union_flow_get_full_must_dependence(get());
+  return manage(res);
+}
+
+isl::union_map union_flow::get_may_dependence() const {
+  auto res = isl_union_flow_get_may_dependence(get());
+  return manage(res);
+}
+
+isl::union_map union_flow::get_may_no_source() const {
+  auto res = isl_union_flow_get_may_no_source(get());
+  return manage(res);
+}
+
+isl::union_map union_flow::get_must_dependence() const {
+  auto res = isl_union_flow_get_must_dependence(get());
+  return manage(res);
+}
+
+isl::union_map union_flow::get_must_no_source() const {
+  auto res = isl_union_flow_get_must_no_source(get());
+  return manage(res);
+}
+
+// implementations for isl::union_map
+isl::union_map manage(__isl_take isl_union_map *ptr) {
+  return union_map(ptr);
+}
+isl::union_map give(__isl_take isl_union_map *ptr) {
+  return manage(ptr);
+}
+
+
+union_map::union_map()
+    : ptr(nullptr) {}
+
+union_map::union_map(const isl::union_map &obj)
+    : ptr(obj.copy()) {}
+union_map::union_map(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_map::union_map(__isl_take isl_union_map *ptr)
+    : ptr(ptr) {}
+
+union_map::union_map(isl::union_pw_aff upa) {
+  auto res = isl_union_map_from_union_pw_aff(upa.release());
+  ptr = res;
+}
+union_map::union_map(isl::basic_map bmap) {
+  auto res = isl_union_map_from_basic_map(bmap.release());
+  ptr = res;
+}
+union_map::union_map(isl::map map) {
+  auto res = isl_union_map_from_map(map.release());
+  ptr = res;
+}
+union_map::union_map(isl::ctx ctx, const std::string &str) {
+  auto res = isl_union_map_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+union_map &union_map::operator=(isl::union_map obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_map::~union_map() {
+  if (ptr)
+    isl_union_map_free(ptr);
+}
+
+__isl_give isl_union_map *union_map::copy() const & {
+  return isl_union_map_copy(ptr);
+}
+
+__isl_keep isl_union_map *union_map::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_map *union_map::release() {
+  isl_union_map *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_map::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_map *union_map::keep() const {
+  return get();
+}
+
+__isl_give isl_union_map *union_map::take() {
+  return release();
+}
+
+union_map::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_map::get_ctx() const {
+  return isl::ctx(isl_union_map_get_ctx(ptr));
+}
+
+
+std::string union_map::to_str() const {
+  char *Tmp = isl_union_map_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void union_map::dump() const {
+  isl_union_map_dump(get());
+}
+
+
+isl::union_map union_map::add_map(isl::map map) const {
+  auto res = isl_union_map_add_map(copy(), map.release());
+  return manage(res);
+}
+
+isl::union_map union_map::affine_hull() const {
+  auto res = isl_union_map_affine_hull(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::align_params(isl::space model) const {
+  auto res = isl_union_map_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::union_map union_map::apply_domain(isl::union_map umap2) const {
+  auto res = isl_union_map_apply_domain(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::apply_range(isl::union_map umap2) const {
+  auto res = isl_union_map_apply_range(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::coalesce() const {
+  auto res = isl_union_map_coalesce(copy());
+  return manage(res);
+}
+
+isl::boolean union_map::contains(const isl::space &space) const {
+  auto res = isl_union_map_contains(get(), space.get());
+  return manage(res);
+}
+
+isl::union_map union_map::curry() const {
+  auto res = isl_union_map_curry(copy());
+  return manage(res);
+}
+
+isl::union_set union_map::deltas() const {
+  auto res = isl_union_map_deltas(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::deltas_map() const {
+  auto res = isl_union_map_deltas_map(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::detect_equalities() const {
+  auto res = isl_union_map_detect_equalities(copy());
+  return manage(res);
+}
+
+unsigned int union_map::dim(isl::dim type) const {
+  auto res = isl_union_map_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::union_set union_map::domain() const {
+  auto res = isl_union_map_domain(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::domain_factor_domain() const {
+  auto res = isl_union_map_domain_factor_domain(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::domain_factor_range() const {
+  auto res = isl_union_map_domain_factor_range(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::domain_map() const {
+  auto res = isl_union_map_domain_map(copy());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_map::domain_map_union_pw_multi_aff() const {
+  auto res = isl_union_map_domain_map_union_pw_multi_aff(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::domain_product(isl::union_map umap2) const {
+  auto res = isl_union_map_domain_product(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::empty(isl::space dim) {
+  auto res = isl_union_map_empty(dim.release());
+  return manage(res);
+}
+
+isl::union_map union_map::eq_at_multi_union_pw_aff(isl::multi_union_pw_aff mupa) const {
+  auto res = isl_union_map_eq_at_multi_union_pw_aff(copy(), mupa.release());
+  return manage(res);
+}
+
+isl::map union_map::extract_map(isl::space dim) const {
+  auto res = isl_union_map_extract_map(get(), dim.release());
+  return manage(res);
+}
+
+isl::union_map union_map::factor_domain() const {
+  auto res = isl_union_map_factor_domain(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::factor_range() const {
+  auto res = isl_union_map_factor_range(copy());
+  return manage(res);
+}
+
+int union_map::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_union_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::union_map union_map::fixed_power(isl::val exp) const {
+  auto res = isl_union_map_fixed_power_val(copy(), exp.release());
+  return manage(res);
+}
+
+isl::union_map union_map::flat_domain_product(isl::union_map umap2) const {
+  auto res = isl_union_map_flat_domain_product(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::flat_range_product(isl::union_map umap2) const {
+  auto res = isl_union_map_flat_range_product(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::stat union_map::foreach_map(const std::function<isl::stat(isl::map)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_map *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::map)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_union_map_foreach_map(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::union_map union_map::from(isl::union_pw_multi_aff upma) {
+  auto res = isl_union_map_from_union_pw_multi_aff(upma.release());
+  return manage(res);
+}
+
+isl::union_map union_map::from(isl::multi_union_pw_aff mupa) {
+  auto res = isl_union_map_from_multi_union_pw_aff(mupa.release());
+  return manage(res);
+}
+
+isl::union_map union_map::from_domain(isl::union_set uset) {
+  auto res = isl_union_map_from_domain(uset.release());
+  return manage(res);
+}
+
+isl::union_map union_map::from_domain_and_range(isl::union_set domain, isl::union_set range) {
+  auto res = isl_union_map_from_domain_and_range(domain.release(), range.release());
+  return manage(res);
+}
+
+isl::union_map union_map::from_range(isl::union_set uset) {
+  auto res = isl_union_map_from_range(uset.release());
+  return manage(res);
+}
+
+isl::id union_map::get_dim_id(isl::dim type, unsigned int pos) const {
+  auto res = isl_union_map_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);
+  return manage(res);
+}
+
+uint32_t union_map::get_hash() const {
+  auto res = isl_union_map_get_hash(get());
+  return res;
+}
+
+isl::space union_map::get_space() const {
+  auto res = isl_union_map_get_space(get());
+  return manage(res);
+}
+
+isl::union_map union_map::gist(isl::union_map context) const {
+  auto res = isl_union_map_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_map union_map::gist_domain(isl::union_set uset) const {
+  auto res = isl_union_map_gist_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_map union_map::gist_params(isl::set set) const {
+  auto res = isl_union_map_gist_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::union_map union_map::gist_range(isl::union_set uset) const {
+  auto res = isl_union_map_gist_range(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_map union_map::intersect(isl::union_map umap2) const {
+  auto res = isl_union_map_intersect(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::intersect_domain(isl::union_set uset) const {
+  auto res = isl_union_map_intersect_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_map union_map::intersect_params(isl::set set) const {
+  auto res = isl_union_map_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::union_map union_map::intersect_range(isl::union_set uset) const {
+  auto res = isl_union_map_intersect_range(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_map union_map::intersect_range_factor_range(isl::union_map factor) const {
+  auto res = isl_union_map_intersect_range_factor_range(copy(), factor.release());
+  return manage(res);
+}
+
+isl::boolean union_map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_union_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::boolean union_map::is_bijective() const {
+  auto res = isl_union_map_is_bijective(get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_disjoint(const isl::union_map &umap2) const {
+  auto res = isl_union_map_is_disjoint(get(), umap2.get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_empty() const {
+  auto res = isl_union_map_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_equal(const isl::union_map &umap2) const {
+  auto res = isl_union_map_is_equal(get(), umap2.get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_identity() const {
+  auto res = isl_union_map_is_identity(get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_injective() const {
+  auto res = isl_union_map_is_injective(get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_single_valued() const {
+  auto res = isl_union_map_is_single_valued(get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_strict_subset(const isl::union_map &umap2) const {
+  auto res = isl_union_map_is_strict_subset(get(), umap2.get());
+  return manage(res);
+}
+
+isl::boolean union_map::is_subset(const isl::union_map &umap2) const {
+  auto res = isl_union_map_is_subset(get(), umap2.get());
+  return manage(res);
+}
+
+isl::union_map union_map::lex_ge_union_map(isl::union_map umap2) const {
+  auto res = isl_union_map_lex_ge_union_map(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::lex_gt_at_multi_union_pw_aff(isl::multi_union_pw_aff mupa) const {
+  auto res = isl_union_map_lex_gt_at_multi_union_pw_aff(copy(), mupa.release());
+  return manage(res);
+}
+
+isl::union_map union_map::lex_gt_union_map(isl::union_map umap2) const {
+  auto res = isl_union_map_lex_gt_union_map(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::lex_le_union_map(isl::union_map umap2) const {
+  auto res = isl_union_map_lex_le_union_map(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::lex_lt_at_multi_union_pw_aff(isl::multi_union_pw_aff mupa) const {
+  auto res = isl_union_map_lex_lt_at_multi_union_pw_aff(copy(), mupa.release());
+  return manage(res);
+}
+
+isl::union_map union_map::lex_lt_union_map(isl::union_map umap2) const {
+  auto res = isl_union_map_lex_lt_union_map(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::lexmax() const {
+  auto res = isl_union_map_lexmax(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::lexmin() const {
+  auto res = isl_union_map_lexmin(copy());
+  return manage(res);
+}
+
+isl::set union_map::params() const {
+  auto res = isl_union_map_params(copy());
+  return manage(res);
+}
+
+isl::boolean union_map::plain_is_injective() const {
+  auto res = isl_union_map_plain_is_injective(get());
+  return manage(res);
+}
+
+isl::union_map union_map::polyhedral_hull() const {
+  auto res = isl_union_map_polyhedral_hull(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::preimage_domain_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_union_map_preimage_domain_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::union_map union_map::preimage_domain_multi_pw_aff(isl::multi_pw_aff mpa) const {
+  auto res = isl_union_map_preimage_domain_multi_pw_aff(copy(), mpa.release());
+  return manage(res);
+}
+
+isl::union_map union_map::preimage_domain_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_union_map_preimage_domain_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::union_map union_map::preimage_domain_union_pw_multi_aff(isl::union_pw_multi_aff upma) const {
+  auto res = isl_union_map_preimage_domain_union_pw_multi_aff(copy(), upma.release());
+  return manage(res);
+}
+
+isl::union_map union_map::preimage_range_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_union_map_preimage_range_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::union_map union_map::preimage_range_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_union_map_preimage_range_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::union_map union_map::preimage_range_union_pw_multi_aff(isl::union_pw_multi_aff upma) const {
+  auto res = isl_union_map_preimage_range_union_pw_multi_aff(copy(), upma.release());
+  return manage(res);
+}
+
+isl::union_map union_map::product(isl::union_map umap2) const {
+  auto res = isl_union_map_product(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::project_out(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_union_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::union_set union_map::range() const {
+  auto res = isl_union_map_range(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::range_curry() const {
+  auto res = isl_union_map_range_curry(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::range_factor_domain() const {
+  auto res = isl_union_map_range_factor_domain(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::range_factor_range() const {
+  auto res = isl_union_map_range_factor_range(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::range_map() const {
+  auto res = isl_union_map_range_map(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::range_product(isl::union_map umap2) const {
+  auto res = isl_union_map_range_product(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::remove_divs() const {
+  auto res = isl_union_map_remove_divs(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::remove_redundancies() const {
+  auto res = isl_union_map_remove_redundancies(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::reset_user() const {
+  auto res = isl_union_map_reset_user(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::reverse() const {
+  auto res = isl_union_map_reverse(copy());
+  return manage(res);
+}
+
+isl::basic_map union_map::sample() const {
+  auto res = isl_union_map_sample(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::simple_hull() const {
+  auto res = isl_union_map_simple_hull(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::subtract(isl::union_map umap2) const {
+  auto res = isl_union_map_subtract(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::subtract_domain(isl::union_set dom) const {
+  auto res = isl_union_map_subtract_domain(copy(), dom.release());
+  return manage(res);
+}
+
+isl::union_map union_map::subtract_range(isl::union_set dom) const {
+  auto res = isl_union_map_subtract_range(copy(), dom.release());
+  return manage(res);
+}
+
+isl::union_map union_map::uncurry() const {
+  auto res = isl_union_map_uncurry(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::unite(isl::union_map umap2) const {
+  auto res = isl_union_map_union(copy(), umap2.release());
+  return manage(res);
+}
+
+isl::union_map union_map::universe() const {
+  auto res = isl_union_map_universe(copy());
+  return manage(res);
+}
+
+isl::union_set union_map::wrap() const {
+  auto res = isl_union_map_wrap(copy());
+  return manage(res);
+}
+
+isl::union_map union_map::zip() const {
+  auto res = isl_union_map_zip(copy());
+  return manage(res);
+}
+
+// implementations for isl::union_map_list
+isl::union_map_list manage(__isl_take isl_union_map_list *ptr) {
+  return union_map_list(ptr);
+}
+isl::union_map_list give(__isl_take isl_union_map_list *ptr) {
+  return manage(ptr);
+}
+
+
+union_map_list::union_map_list()
+    : ptr(nullptr) {}
+
+union_map_list::union_map_list(const isl::union_map_list &obj)
+    : ptr(obj.copy()) {}
+union_map_list::union_map_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_map_list::union_map_list(__isl_take isl_union_map_list *ptr)
+    : ptr(ptr) {}
+
+
+union_map_list &union_map_list::operator=(isl::union_map_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_map_list::~union_map_list() {
+  if (ptr)
+    isl_union_map_list_free(ptr);
+}
+
+__isl_give isl_union_map_list *union_map_list::copy() const & {
+  return isl_union_map_list_copy(ptr);
+}
+
+__isl_keep isl_union_map_list *union_map_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_map_list *union_map_list::release() {
+  isl_union_map_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_map_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_map_list *union_map_list::keep() const {
+  return get();
+}
+
+__isl_give isl_union_map_list *union_map_list::take() {
+  return release();
+}
+
+union_map_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_map_list::get_ctx() const {
+  return isl::ctx(isl_union_map_list_get_ctx(ptr));
+}
+
+
+
+void union_map_list::dump() const {
+  isl_union_map_list_dump(get());
+}
+
+
+
+// implementations for isl::union_pw_aff
+isl::union_pw_aff manage(__isl_take isl_union_pw_aff *ptr) {
+  return union_pw_aff(ptr);
+}
+isl::union_pw_aff give(__isl_take isl_union_pw_aff *ptr) {
+  return manage(ptr);
+}
+
+
+union_pw_aff::union_pw_aff()
+    : ptr(nullptr) {}
+
+union_pw_aff::union_pw_aff(const isl::union_pw_aff &obj)
+    : ptr(obj.copy()) {}
+union_pw_aff::union_pw_aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_pw_aff::union_pw_aff(__isl_take isl_union_pw_aff *ptr)
+    : ptr(ptr) {}
+
+union_pw_aff::union_pw_aff(isl::pw_aff pa) {
+  auto res = isl_union_pw_aff_from_pw_aff(pa.release());
+  ptr = res;
+}
+union_pw_aff::union_pw_aff(isl::union_set domain, isl::val v) {
+  auto res = isl_union_pw_aff_val_on_domain(domain.release(), v.release());
+  ptr = res;
+}
+union_pw_aff::union_pw_aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_union_pw_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+union_pw_aff &union_pw_aff::operator=(isl::union_pw_aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_pw_aff::~union_pw_aff() {
+  if (ptr)
+    isl_union_pw_aff_free(ptr);
+}
+
+__isl_give isl_union_pw_aff *union_pw_aff::copy() const & {
+  return isl_union_pw_aff_copy(ptr);
+}
+
+__isl_keep isl_union_pw_aff *union_pw_aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_pw_aff *union_pw_aff::release() {
+  isl_union_pw_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_pw_aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_pw_aff *union_pw_aff::keep() const {
+  return get();
+}
+
+__isl_give isl_union_pw_aff *union_pw_aff::take() {
+  return release();
+}
+
+union_pw_aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_pw_aff::get_ctx() const {
+  return isl::ctx(isl_union_pw_aff_get_ctx(ptr));
+}
+
+
+std::string union_pw_aff::to_str() const {
+  char *Tmp = isl_union_pw_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void union_pw_aff::dump() const {
+  isl_union_pw_aff_dump(get());
+}
+
+
+isl::union_pw_aff union_pw_aff::add(isl::union_pw_aff upa2) const {
+  auto res = isl_union_pw_aff_add(copy(), upa2.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::add_pw_aff(isl::pw_aff pa) const {
+  auto res = isl_union_pw_aff_add_pw_aff(copy(), pa.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::aff_on_domain(isl::union_set domain, isl::aff aff) {
+  auto res = isl_union_pw_aff_aff_on_domain(domain.release(), aff.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::align_params(isl::space model) const {
+  auto res = isl_union_pw_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::coalesce() const {
+  auto res = isl_union_pw_aff_coalesce(copy());
+  return manage(res);
+}
+
+unsigned int union_pw_aff::dim(isl::dim type) const {
+  auto res = isl_union_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::union_set union_pw_aff::domain() const {
+  auto res = isl_union_pw_aff_domain(copy());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_union_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::empty(isl::space space) {
+  auto res = isl_union_pw_aff_empty(space.release());
+  return manage(res);
+}
+
+isl::pw_aff union_pw_aff::extract_pw_aff(isl::space space) const {
+  auto res = isl_union_pw_aff_extract_pw_aff(get(), space.release());
+  return manage(res);
+}
+
+int union_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_union_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::union_pw_aff union_pw_aff::floor() const {
+  auto res = isl_union_pw_aff_floor(copy());
+  return manage(res);
+}
+
+isl::stat union_pw_aff::foreach_pw_aff(const std::function<isl::stat(isl::pw_aff)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_pw_aff *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::pw_aff)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_union_pw_aff_foreach_pw_aff(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::space union_pw_aff::get_space() const {
+  auto res = isl_union_pw_aff_get_space(get());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::gist(isl::union_set context) const {
+  auto res = isl_union_pw_aff_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::gist_params(isl::set context) const {
+  auto res = isl_union_pw_aff_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::intersect_domain(isl::union_set uset) const {
+  auto res = isl_union_pw_aff_intersect_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::intersect_params(isl::set set) const {
+  auto res = isl_union_pw_aff_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean union_pw_aff::involves_nan() const {
+  auto res = isl_union_pw_aff_involves_nan(get());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::mod_val(isl::val f) const {
+  auto res = isl_union_pw_aff_mod_val(copy(), f.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::neg() const {
+  auto res = isl_union_pw_aff_neg(copy());
+  return manage(res);
+}
+
+isl::boolean union_pw_aff::plain_is_equal(const isl::union_pw_aff &upa2) const {
+  auto res = isl_union_pw_aff_plain_is_equal(get(), upa2.get());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::pullback(isl::union_pw_multi_aff upma) const {
+  auto res = isl_union_pw_aff_pullback_union_pw_multi_aff(copy(), upma.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::reset_user() const {
+  auto res = isl_union_pw_aff_reset_user(copy());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::scale_down_val(isl::val v) const {
+  auto res = isl_union_pw_aff_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::scale_val(isl::val v) const {
+  auto res = isl_union_pw_aff_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::sub(isl::union_pw_aff upa2) const {
+  auto res = isl_union_pw_aff_sub(copy(), upa2.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::subtract_domain(isl::union_set uset) const {
+  auto res = isl_union_pw_aff_subtract_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_aff::union_add(isl::union_pw_aff upa2) const {
+  auto res = isl_union_pw_aff_union_add(copy(), upa2.release());
+  return manage(res);
+}
+
+isl::union_set union_pw_aff::zero_union_set() const {
+  auto res = isl_union_pw_aff_zero_union_set(copy());
+  return manage(res);
+}
+
+// implementations for isl::union_pw_aff_list
+isl::union_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr) {
+  return union_pw_aff_list(ptr);
+}
+isl::union_pw_aff_list give(__isl_take isl_union_pw_aff_list *ptr) {
+  return manage(ptr);
+}
+
+
+union_pw_aff_list::union_pw_aff_list()
+    : ptr(nullptr) {}
+
+union_pw_aff_list::union_pw_aff_list(const isl::union_pw_aff_list &obj)
+    : ptr(obj.copy()) {}
+union_pw_aff_list::union_pw_aff_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_pw_aff_list::union_pw_aff_list(__isl_take isl_union_pw_aff_list *ptr)
+    : ptr(ptr) {}
+
+
+union_pw_aff_list &union_pw_aff_list::operator=(isl::union_pw_aff_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_pw_aff_list::~union_pw_aff_list() {
+  if (ptr)
+    isl_union_pw_aff_list_free(ptr);
+}
+
+__isl_give isl_union_pw_aff_list *union_pw_aff_list::copy() const & {
+  return isl_union_pw_aff_list_copy(ptr);
+}
+
+__isl_keep isl_union_pw_aff_list *union_pw_aff_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_pw_aff_list *union_pw_aff_list::release() {
+  isl_union_pw_aff_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_pw_aff_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_pw_aff_list *union_pw_aff_list::keep() const {
+  return get();
+}
+
+__isl_give isl_union_pw_aff_list *union_pw_aff_list::take() {
+  return release();
+}
+
+union_pw_aff_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_pw_aff_list::get_ctx() const {
+  return isl::ctx(isl_union_pw_aff_list_get_ctx(ptr));
+}
+
+
+
+void union_pw_aff_list::dump() const {
+  isl_union_pw_aff_list_dump(get());
+}
+
+
+
+// implementations for isl::union_pw_multi_aff
+isl::union_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr) {
+  return union_pw_multi_aff(ptr);
+}
+isl::union_pw_multi_aff give(__isl_take isl_union_pw_multi_aff *ptr) {
+  return manage(ptr);
+}
+
+
+union_pw_multi_aff::union_pw_multi_aff()
+    : ptr(nullptr) {}
+
+union_pw_multi_aff::union_pw_multi_aff(const isl::union_pw_multi_aff &obj)
+    : ptr(obj.copy()) {}
+union_pw_multi_aff::union_pw_multi_aff(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_pw_multi_aff::union_pw_multi_aff(__isl_take isl_union_pw_multi_aff *ptr)
+    : ptr(ptr) {}
+
+union_pw_multi_aff::union_pw_multi_aff(isl::pw_multi_aff pma) {
+  auto res = isl_union_pw_multi_aff_from_pw_multi_aff(pma.release());
+  ptr = res;
+}
+union_pw_multi_aff::union_pw_multi_aff(isl::union_set uset) {
+  auto res = isl_union_pw_multi_aff_from_domain(uset.release());
+  ptr = res;
+}
+union_pw_multi_aff::union_pw_multi_aff(isl::union_map umap) {
+  auto res = isl_union_pw_multi_aff_from_union_map(umap.release());
+  ptr = res;
+}
+union_pw_multi_aff::union_pw_multi_aff(isl::ctx ctx, const std::string &str) {
+  auto res = isl_union_pw_multi_aff_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+union_pw_multi_aff::union_pw_multi_aff(isl::union_pw_aff upa) {
+  auto res = isl_union_pw_multi_aff_from_union_pw_aff(upa.release());
+  ptr = res;
+}
+
+union_pw_multi_aff &union_pw_multi_aff::operator=(isl::union_pw_multi_aff obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_pw_multi_aff::~union_pw_multi_aff() {
+  if (ptr)
+    isl_union_pw_multi_aff_free(ptr);
+}
+
+__isl_give isl_union_pw_multi_aff *union_pw_multi_aff::copy() const & {
+  return isl_union_pw_multi_aff_copy(ptr);
+}
+
+__isl_keep isl_union_pw_multi_aff *union_pw_multi_aff::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_pw_multi_aff *union_pw_multi_aff::release() {
+  isl_union_pw_multi_aff *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_pw_multi_aff::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_pw_multi_aff *union_pw_multi_aff::keep() const {
+  return get();
+}
+
+__isl_give isl_union_pw_multi_aff *union_pw_multi_aff::take() {
+  return release();
+}
+
+union_pw_multi_aff::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_pw_multi_aff::get_ctx() const {
+  return isl::ctx(isl_union_pw_multi_aff_get_ctx(ptr));
+}
+
+
+std::string union_pw_multi_aff::to_str() const {
+  char *Tmp = isl_union_pw_multi_aff_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void union_pw_multi_aff::dump() const {
+  isl_union_pw_multi_aff_dump(get());
+}
+
+
+isl::union_pw_multi_aff union_pw_multi_aff::add(isl::union_pw_multi_aff upma2) const {
+  auto res = isl_union_pw_multi_aff_add(copy(), upma2.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::add_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_union_pw_multi_aff_add_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::align_params(isl::space model) const {
+  auto res = isl_union_pw_multi_aff_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::coalesce() const {
+  auto res = isl_union_pw_multi_aff_coalesce(copy());
+  return manage(res);
+}
+
+unsigned int union_pw_multi_aff::dim(isl::dim type) const {
+  auto res = isl_union_pw_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::union_set union_pw_multi_aff::domain() const {
+  auto res = isl_union_pw_multi_aff_domain(copy());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_union_pw_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::empty(isl::space space) {
+  auto res = isl_union_pw_multi_aff_empty(space.release());
+  return manage(res);
+}
+
+isl::pw_multi_aff union_pw_multi_aff::extract_pw_multi_aff(isl::space space) const {
+  auto res = isl_union_pw_multi_aff_extract_pw_multi_aff(get(), space.release());
+  return manage(res);
+}
+
+int union_pw_multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_union_pw_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::flat_range_product(isl::union_pw_multi_aff upma2) const {
+  auto res = isl_union_pw_multi_aff_flat_range_product(copy(), upma2.release());
+  return manage(res);
+}
+
+isl::stat union_pw_multi_aff::foreach_pw_multi_aff(const std::function<isl::stat(isl::pw_multi_aff)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_pw_multi_aff *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::pw_multi_aff)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_union_pw_multi_aff_foreach_pw_multi_aff(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::from_aff(isl::aff aff) {
+  auto res = isl_union_pw_multi_aff_from_aff(aff.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::from_multi_union_pw_aff(isl::multi_union_pw_aff mupa) {
+  auto res = isl_union_pw_multi_aff_from_multi_union_pw_aff(mupa.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::from_union_set(isl::union_set uset) {
+  auto res = isl_union_pw_multi_aff_from_union_set(uset.release());
+  return manage(res);
+}
+
+isl::space union_pw_multi_aff::get_space() const {
+  auto res = isl_union_pw_multi_aff_get_space(get());
+  return manage(res);
+}
+
+isl::union_pw_aff union_pw_multi_aff::get_union_pw_aff(int pos) const {
+  auto res = isl_union_pw_multi_aff_get_union_pw_aff(get(), pos);
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::gist(isl::union_set context) const {
+  auto res = isl_union_pw_multi_aff_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::gist_params(isl::set context) const {
+  auto res = isl_union_pw_multi_aff_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::intersect_domain(isl::union_set uset) const {
+  auto res = isl_union_pw_multi_aff_intersect_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::intersect_params(isl::set set) const {
+  auto res = isl_union_pw_multi_aff_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean union_pw_multi_aff::involves_nan() const {
+  auto res = isl_union_pw_multi_aff_involves_nan(get());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::multi_val_on_domain(isl::union_set domain, isl::multi_val mv) {
+  auto res = isl_union_pw_multi_aff_multi_val_on_domain(domain.release(), mv.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::neg() const {
+  auto res = isl_union_pw_multi_aff_neg(copy());
+  return manage(res);
+}
+
+isl::boolean union_pw_multi_aff::plain_is_equal(const isl::union_pw_multi_aff &upma2) const {
+  auto res = isl_union_pw_multi_aff_plain_is_equal(get(), upma2.get());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::pullback(isl::union_pw_multi_aff upma2) const {
+  auto res = isl_union_pw_multi_aff_pullback_union_pw_multi_aff(copy(), upma2.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::reset_user() const {
+  auto res = isl_union_pw_multi_aff_reset_user(copy());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::scale_down_val(isl::val val) const {
+  auto res = isl_union_pw_multi_aff_scale_down_val(copy(), val.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::scale_multi_val(isl::multi_val mv) const {
+  auto res = isl_union_pw_multi_aff_scale_multi_val(copy(), mv.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::scale_val(isl::val val) const {
+  auto res = isl_union_pw_multi_aff_scale_val(copy(), val.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::sub(isl::union_pw_multi_aff upma2) const {
+  auto res = isl_union_pw_multi_aff_sub(copy(), upma2.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::subtract_domain(isl::union_set uset) const {
+  auto res = isl_union_pw_multi_aff_subtract_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_pw_multi_aff::union_add(isl::union_pw_multi_aff upma2) const {
+  auto res = isl_union_pw_multi_aff_union_add(copy(), upma2.release());
+  return manage(res);
+}
+
+// implementations for isl::union_pw_multi_aff_list
+isl::union_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr) {
+  return union_pw_multi_aff_list(ptr);
+}
+isl::union_pw_multi_aff_list give(__isl_take isl_union_pw_multi_aff_list *ptr) {
+  return manage(ptr);
+}
+
+
+union_pw_multi_aff_list::union_pw_multi_aff_list()
+    : ptr(nullptr) {}
+
+union_pw_multi_aff_list::union_pw_multi_aff_list(const isl::union_pw_multi_aff_list &obj)
+    : ptr(obj.copy()) {}
+union_pw_multi_aff_list::union_pw_multi_aff_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_pw_multi_aff_list::union_pw_multi_aff_list(__isl_take isl_union_pw_multi_aff_list *ptr)
+    : ptr(ptr) {}
+
+
+union_pw_multi_aff_list &union_pw_multi_aff_list::operator=(isl::union_pw_multi_aff_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_pw_multi_aff_list::~union_pw_multi_aff_list() {
+  if (ptr)
+    isl_union_pw_multi_aff_list_free(ptr);
+}
+
+__isl_give isl_union_pw_multi_aff_list *union_pw_multi_aff_list::copy() const & {
+  return isl_union_pw_multi_aff_list_copy(ptr);
+}
+
+__isl_keep isl_union_pw_multi_aff_list *union_pw_multi_aff_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_pw_multi_aff_list *union_pw_multi_aff_list::release() {
+  isl_union_pw_multi_aff_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_pw_multi_aff_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_pw_multi_aff_list *union_pw_multi_aff_list::keep() const {
+  return get();
+}
+
+__isl_give isl_union_pw_multi_aff_list *union_pw_multi_aff_list::take() {
+  return release();
+}
+
+union_pw_multi_aff_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_pw_multi_aff_list::get_ctx() const {
+  return isl::ctx(isl_union_pw_multi_aff_list_get_ctx(ptr));
+}
+
+
+
+void union_pw_multi_aff_list::dump() const {
+  isl_union_pw_multi_aff_list_dump(get());
+}
+
+
+
+// implementations for isl::union_pw_qpolynomial
+isl::union_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr) {
+  return union_pw_qpolynomial(ptr);
+}
+isl::union_pw_qpolynomial give(__isl_take isl_union_pw_qpolynomial *ptr) {
+  return manage(ptr);
+}
+
+
+union_pw_qpolynomial::union_pw_qpolynomial()
+    : ptr(nullptr) {}
+
+union_pw_qpolynomial::union_pw_qpolynomial(const isl::union_pw_qpolynomial &obj)
+    : ptr(obj.copy()) {}
+union_pw_qpolynomial::union_pw_qpolynomial(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_pw_qpolynomial::union_pw_qpolynomial(__isl_take isl_union_pw_qpolynomial *ptr)
+    : ptr(ptr) {}
+
+union_pw_qpolynomial::union_pw_qpolynomial(isl::ctx ctx, const std::string &str) {
+  auto res = isl_union_pw_qpolynomial_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+union_pw_qpolynomial &union_pw_qpolynomial::operator=(isl::union_pw_qpolynomial obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_pw_qpolynomial::~union_pw_qpolynomial() {
+  if (ptr)
+    isl_union_pw_qpolynomial_free(ptr);
+}
+
+__isl_give isl_union_pw_qpolynomial *union_pw_qpolynomial::copy() const & {
+  return isl_union_pw_qpolynomial_copy(ptr);
+}
+
+__isl_keep isl_union_pw_qpolynomial *union_pw_qpolynomial::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_pw_qpolynomial *union_pw_qpolynomial::release() {
+  isl_union_pw_qpolynomial *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_pw_qpolynomial::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_pw_qpolynomial *union_pw_qpolynomial::keep() const {
+  return get();
+}
+
+__isl_give isl_union_pw_qpolynomial *union_pw_qpolynomial::take() {
+  return release();
+}
+
+union_pw_qpolynomial::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_pw_qpolynomial::get_ctx() const {
+  return isl::ctx(isl_union_pw_qpolynomial_get_ctx(ptr));
+}
+
+
+std::string union_pw_qpolynomial::to_str() const {
+  char *Tmp = isl_union_pw_qpolynomial_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::add(isl::union_pw_qpolynomial upwqp2) const {
+  auto res = isl_union_pw_qpolynomial_add(copy(), upwqp2.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::add_pw_qpolynomial(isl::pw_qpolynomial pwqp) const {
+  auto res = isl_union_pw_qpolynomial_add_pw_qpolynomial(copy(), pwqp.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::align_params(isl::space model) const {
+  auto res = isl_union_pw_qpolynomial_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::coalesce() const {
+  auto res = isl_union_pw_qpolynomial_coalesce(copy());
+  return manage(res);
+}
+
+unsigned int union_pw_qpolynomial::dim(isl::dim type) const {
+  auto res = isl_union_pw_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::union_set union_pw_qpolynomial::domain() const {
+  auto res = isl_union_pw_qpolynomial_domain(copy());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_union_pw_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::val union_pw_qpolynomial::eval(isl::point pnt) const {
+  auto res = isl_union_pw_qpolynomial_eval(copy(), pnt.release());
+  return manage(res);
+}
+
+isl::pw_qpolynomial union_pw_qpolynomial::extract_pw_qpolynomial(isl::space dim) const {
+  auto res = isl_union_pw_qpolynomial_extract_pw_qpolynomial(get(), dim.release());
+  return manage(res);
+}
+
+int union_pw_qpolynomial::find_dim_by_name(isl::dim type, const std::string &name) const {
+  auto res = isl_union_pw_qpolynomial_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());
+  return res;
+}
+
+isl::stat union_pw_qpolynomial::foreach_pw_qpolynomial(const std::function<isl::stat(isl::pw_qpolynomial)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_pw_qpolynomial *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::pw_qpolynomial)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_union_pw_qpolynomial_foreach_pw_qpolynomial(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::from_pw_qpolynomial(isl::pw_qpolynomial pwqp) {
+  auto res = isl_union_pw_qpolynomial_from_pw_qpolynomial(pwqp.release());
+  return manage(res);
+}
+
+isl::space union_pw_qpolynomial::get_space() const {
+  auto res = isl_union_pw_qpolynomial_get_space(get());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::gist(isl::union_set context) const {
+  auto res = isl_union_pw_qpolynomial_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::gist_params(isl::set context) const {
+  auto res = isl_union_pw_qpolynomial_gist_params(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::intersect_domain(isl::union_set uset) const {
+  auto res = isl_union_pw_qpolynomial_intersect_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::intersect_params(isl::set set) const {
+  auto res = isl_union_pw_qpolynomial_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean union_pw_qpolynomial::involves_nan() const {
+  auto res = isl_union_pw_qpolynomial_involves_nan(get());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::mul(isl::union_pw_qpolynomial upwqp2) const {
+  auto res = isl_union_pw_qpolynomial_mul(copy(), upwqp2.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::neg() const {
+  auto res = isl_union_pw_qpolynomial_neg(copy());
+  return manage(res);
+}
+
+isl::boolean union_pw_qpolynomial::plain_is_equal(const isl::union_pw_qpolynomial &upwqp2) const {
+  auto res = isl_union_pw_qpolynomial_plain_is_equal(get(), upwqp2.get());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::reset_user() const {
+  auto res = isl_union_pw_qpolynomial_reset_user(copy());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::scale_down_val(isl::val v) const {
+  auto res = isl_union_pw_qpolynomial_scale_down_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::scale_val(isl::val v) const {
+  auto res = isl_union_pw_qpolynomial_scale_val(copy(), v.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::sub(isl::union_pw_qpolynomial upwqp2) const {
+  auto res = isl_union_pw_qpolynomial_sub(copy(), upwqp2.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::subtract_domain(isl::union_set uset) const {
+  auto res = isl_union_pw_qpolynomial_subtract_domain(copy(), uset.release());
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::to_polynomial(int sign) const {
+  auto res = isl_union_pw_qpolynomial_to_polynomial(copy(), sign);
+  return manage(res);
+}
+
+isl::union_pw_qpolynomial union_pw_qpolynomial::zero(isl::space dim) {
+  auto res = isl_union_pw_qpolynomial_zero(dim.release());
+  return manage(res);
+}
+
+// implementations for isl::union_set
+isl::union_set manage(__isl_take isl_union_set *ptr) {
+  return union_set(ptr);
+}
+isl::union_set give(__isl_take isl_union_set *ptr) {
+  return manage(ptr);
+}
+
+
+union_set::union_set()
+    : ptr(nullptr) {}
+
+union_set::union_set(const isl::union_set &obj)
+    : ptr(obj.copy()) {}
+union_set::union_set(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_set::union_set(__isl_take isl_union_set *ptr)
+    : ptr(ptr) {}
+
+union_set::union_set(isl::point pnt) {
+  auto res = isl_union_set_from_point(pnt.release());
+  ptr = res;
+}
+union_set::union_set(isl::ctx ctx, const std::string &str) {
+  auto res = isl_union_set_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+union_set::union_set(isl::basic_set bset) {
+  auto res = isl_union_set_from_basic_set(bset.release());
+  ptr = res;
+}
+union_set::union_set(isl::set set) {
+  auto res = isl_union_set_from_set(set.release());
+  ptr = res;
+}
+
+union_set &union_set::operator=(isl::union_set obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_set::~union_set() {
+  if (ptr)
+    isl_union_set_free(ptr);
+}
+
+__isl_give isl_union_set *union_set::copy() const & {
+  return isl_union_set_copy(ptr);
+}
+
+__isl_keep isl_union_set *union_set::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_set *union_set::release() {
+  isl_union_set *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_set::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_set *union_set::keep() const {
+  return get();
+}
+
+__isl_give isl_union_set *union_set::take() {
+  return release();
+}
+
+union_set::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_set::get_ctx() const {
+  return isl::ctx(isl_union_set_get_ctx(ptr));
+}
+
+
+std::string union_set::to_str() const {
+  char *Tmp = isl_union_set_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void union_set::dump() const {
+  isl_union_set_dump(get());
+}
+
+
+isl::union_set union_set::add_set(isl::set set) const {
+  auto res = isl_union_set_add_set(copy(), set.release());
+  return manage(res);
+}
+
+isl::union_set union_set::affine_hull() const {
+  auto res = isl_union_set_affine_hull(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::align_params(isl::space model) const {
+  auto res = isl_union_set_align_params(copy(), model.release());
+  return manage(res);
+}
+
+isl::union_set union_set::apply(isl::union_map umap) const {
+  auto res = isl_union_set_apply(copy(), umap.release());
+  return manage(res);
+}
+
+isl::union_set union_set::coalesce() const {
+  auto res = isl_union_set_coalesce(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::coefficients() const {
+  auto res = isl_union_set_coefficients(copy());
+  return manage(res);
+}
+
+isl::schedule union_set::compute_schedule(isl::union_map validity, isl::union_map proximity) const {
+  auto res = isl_union_set_compute_schedule(copy(), validity.release(), proximity.release());
+  return manage(res);
+}
+
+isl::boolean union_set::contains(const isl::space &space) const {
+  auto res = isl_union_set_contains(get(), space.get());
+  return manage(res);
+}
+
+isl::union_set union_set::detect_equalities() const {
+  auto res = isl_union_set_detect_equalities(copy());
+  return manage(res);
+}
+
+unsigned int union_set::dim(isl::dim type) const {
+  auto res = isl_union_set_dim(get(), static_cast<enum isl_dim_type>(type));
+  return res;
+}
+
+isl::union_set union_set::empty(isl::space dim) {
+  auto res = isl_union_set_empty(dim.release());
+  return manage(res);
+}
+
+isl::set union_set::extract_set(isl::space dim) const {
+  auto res = isl_union_set_extract_set(get(), dim.release());
+  return manage(res);
+}
+
+isl::stat union_set::foreach_point(const std::function<isl::stat(isl::point)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_point *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::point)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_union_set_foreach_point(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::stat union_set::foreach_set(const std::function<isl::stat(isl::set)> &fn) const {
+  auto fn_p = &fn;
+  auto fn_lambda = [](isl_set *arg_0, void *arg_1) -> isl_stat {
+    auto *func = *static_cast<const std::function<isl::stat(isl::set)> **>(arg_1);
+    stat ret = (*func)(isl::manage(arg_0));
+    return isl_stat(ret);
+  };
+  auto res = isl_union_set_foreach_set(get(), fn_lambda, &fn_p);
+  return isl::stat(res);
+}
+
+isl::basic_set_list union_set::get_basic_set_list() const {
+  auto res = isl_union_set_get_basic_set_list(get());
+  return manage(res);
+}
+
+uint32_t union_set::get_hash() const {
+  auto res = isl_union_set_get_hash(get());
+  return res;
+}
+
+isl::space union_set::get_space() const {
+  auto res = isl_union_set_get_space(get());
+  return manage(res);
+}
+
+isl::union_set union_set::gist(isl::union_set context) const {
+  auto res = isl_union_set_gist(copy(), context.release());
+  return manage(res);
+}
+
+isl::union_set union_set::gist_params(isl::set set) const {
+  auto res = isl_union_set_gist_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::union_map union_set::identity() const {
+  auto res = isl_union_set_identity(copy());
+  return manage(res);
+}
+
+isl::union_pw_multi_aff union_set::identity_union_pw_multi_aff() const {
+  auto res = isl_union_set_identity_union_pw_multi_aff(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::intersect(isl::union_set uset2) const {
+  auto res = isl_union_set_intersect(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_set union_set::intersect_params(isl::set set) const {
+  auto res = isl_union_set_intersect_params(copy(), set.release());
+  return manage(res);
+}
+
+isl::boolean union_set::is_disjoint(const isl::union_set &uset2) const {
+  auto res = isl_union_set_is_disjoint(get(), uset2.get());
+  return manage(res);
+}
+
+isl::boolean union_set::is_empty() const {
+  auto res = isl_union_set_is_empty(get());
+  return manage(res);
+}
+
+isl::boolean union_set::is_equal(const isl::union_set &uset2) const {
+  auto res = isl_union_set_is_equal(get(), uset2.get());
+  return manage(res);
+}
+
+isl::boolean union_set::is_params() const {
+  auto res = isl_union_set_is_params(get());
+  return manage(res);
+}
+
+isl::boolean union_set::is_strict_subset(const isl::union_set &uset2) const {
+  auto res = isl_union_set_is_strict_subset(get(), uset2.get());
+  return manage(res);
+}
+
+isl::boolean union_set::is_subset(const isl::union_set &uset2) const {
+  auto res = isl_union_set_is_subset(get(), uset2.get());
+  return manage(res);
+}
+
+isl::union_map union_set::lex_ge_union_set(isl::union_set uset2) const {
+  auto res = isl_union_set_lex_ge_union_set(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_map union_set::lex_gt_union_set(isl::union_set uset2) const {
+  auto res = isl_union_set_lex_gt_union_set(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_map union_set::lex_le_union_set(isl::union_set uset2) const {
+  auto res = isl_union_set_lex_le_union_set(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_map union_set::lex_lt_union_set(isl::union_set uset2) const {
+  auto res = isl_union_set_lex_lt_union_set(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_set union_set::lexmax() const {
+  auto res = isl_union_set_lexmax(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::lexmin() const {
+  auto res = isl_union_set_lexmin(copy());
+  return manage(res);
+}
+
+isl::multi_val union_set::min_multi_union_pw_aff(const isl::multi_union_pw_aff &obj) const {
+  auto res = isl_union_set_min_multi_union_pw_aff(get(), obj.get());
+  return manage(res);
+}
+
+isl::set union_set::params() const {
+  auto res = isl_union_set_params(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::polyhedral_hull() const {
+  auto res = isl_union_set_polyhedral_hull(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::preimage_multi_aff(isl::multi_aff ma) const {
+  auto res = isl_union_set_preimage_multi_aff(copy(), ma.release());
+  return manage(res);
+}
+
+isl::union_set union_set::preimage_pw_multi_aff(isl::pw_multi_aff pma) const {
+  auto res = isl_union_set_preimage_pw_multi_aff(copy(), pma.release());
+  return manage(res);
+}
+
+isl::union_set union_set::preimage_union_pw_multi_aff(isl::union_pw_multi_aff upma) const {
+  auto res = isl_union_set_preimage_union_pw_multi_aff(copy(), upma.release());
+  return manage(res);
+}
+
+isl::union_set union_set::product(isl::union_set uset2) const {
+  auto res = isl_union_set_product(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_set union_set::project_out(isl::dim type, unsigned int first, unsigned int n) const {
+  auto res = isl_union_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);
+  return manage(res);
+}
+
+isl::union_set union_set::remove_divs() const {
+  auto res = isl_union_set_remove_divs(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::remove_redundancies() const {
+  auto res = isl_union_set_remove_redundancies(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::reset_user() const {
+  auto res = isl_union_set_reset_user(copy());
+  return manage(res);
+}
+
+isl::basic_set union_set::sample() const {
+  auto res = isl_union_set_sample(copy());
+  return manage(res);
+}
+
+isl::point union_set::sample_point() const {
+  auto res = isl_union_set_sample_point(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::simple_hull() const {
+  auto res = isl_union_set_simple_hull(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::solutions() const {
+  auto res = isl_union_set_solutions(copy());
+  return manage(res);
+}
+
+isl::union_set union_set::subtract(isl::union_set uset2) const {
+  auto res = isl_union_set_subtract(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_set union_set::unite(isl::union_set uset2) const {
+  auto res = isl_union_set_union(copy(), uset2.release());
+  return manage(res);
+}
+
+isl::union_set union_set::universe() const {
+  auto res = isl_union_set_universe(copy());
+  return manage(res);
+}
+
+isl::union_map union_set::unwrap() const {
+  auto res = isl_union_set_unwrap(copy());
+  return manage(res);
+}
+
+isl::union_map union_set::wrapped_domain_map() const {
+  auto res = isl_union_set_wrapped_domain_map(copy());
+  return manage(res);
+}
+
+// implementations for isl::union_set_list
+isl::union_set_list manage(__isl_take isl_union_set_list *ptr) {
+  return union_set_list(ptr);
+}
+isl::union_set_list give(__isl_take isl_union_set_list *ptr) {
+  return manage(ptr);
+}
+
+
+union_set_list::union_set_list()
+    : ptr(nullptr) {}
+
+union_set_list::union_set_list(const isl::union_set_list &obj)
+    : ptr(obj.copy()) {}
+union_set_list::union_set_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+union_set_list::union_set_list(__isl_take isl_union_set_list *ptr)
+    : ptr(ptr) {}
+
+
+union_set_list &union_set_list::operator=(isl::union_set_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+union_set_list::~union_set_list() {
+  if (ptr)
+    isl_union_set_list_free(ptr);
+}
+
+__isl_give isl_union_set_list *union_set_list::copy() const & {
+  return isl_union_set_list_copy(ptr);
+}
+
+__isl_keep isl_union_set_list *union_set_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_union_set_list *union_set_list::release() {
+  isl_union_set_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool union_set_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_union_set_list *union_set_list::keep() const {
+  return get();
+}
+
+__isl_give isl_union_set_list *union_set_list::take() {
+  return release();
+}
+
+union_set_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx union_set_list::get_ctx() const {
+  return isl::ctx(isl_union_set_list_get_ctx(ptr));
+}
+
+
+
+void union_set_list::dump() const {
+  isl_union_set_list_dump(get());
+}
+
+
+
+// implementations for isl::val
+isl::val manage(__isl_take isl_val *ptr) {
+  return val(ptr);
+}
+isl::val give(__isl_take isl_val *ptr) {
+  return manage(ptr);
+}
+
+
+val::val()
+    : ptr(nullptr) {}
+
+val::val(const isl::val &obj)
+    : ptr(obj.copy()) {}
+val::val(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+val::val(__isl_take isl_val *ptr)
+    : ptr(ptr) {}
+
+val::val(isl::ctx ctx, long i) {
+  auto res = isl_val_int_from_si(ctx.release(), i);
+  ptr = res;
+}
+val::val(isl::ctx ctx, const std::string &str) {
+  auto res = isl_val_read_from_str(ctx.release(), str.c_str());
+  ptr = res;
+}
+
+val &val::operator=(isl::val obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+val::~val() {
+  if (ptr)
+    isl_val_free(ptr);
+}
+
+__isl_give isl_val *val::copy() const & {
+  return isl_val_copy(ptr);
+}
+
+__isl_keep isl_val *val::get() const {
+  return ptr;
+}
+
+__isl_give isl_val *val::release() {
+  isl_val *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool val::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_val *val::keep() const {
+  return get();
+}
+
+__isl_give isl_val *val::take() {
+  return release();
+}
+
+val::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx val::get_ctx() const {
+  return isl::ctx(isl_val_get_ctx(ptr));
+}
+
+
+std::string val::to_str() const {
+  char *Tmp = isl_val_to_str(get());
+  if (!Tmp)
+    return "";
+  std::string S(Tmp);
+  free(Tmp);
+  return S;
+}
+
+
+void val::dump() const {
+  isl_val_dump(get());
+}
+
+
+isl::val val::two_exp() const {
+  auto res = isl_val_2exp(copy());
+  return manage(res);
+}
+
+isl::val val::abs() const {
+  auto res = isl_val_abs(copy());
+  return manage(res);
+}
+
+isl::boolean val::abs_eq(const isl::val &v2) const {
+  auto res = isl_val_abs_eq(get(), v2.get());
+  return manage(res);
+}
+
+isl::val val::add(isl::val v2) const {
+  auto res = isl_val_add(copy(), v2.release());
+  return manage(res);
+}
+
+isl::val val::add_ui(unsigned long v2) const {
+  auto res = isl_val_add_ui(copy(), v2);
+  return manage(res);
+}
+
+isl::val val::ceil() const {
+  auto res = isl_val_ceil(copy());
+  return manage(res);
+}
+
+int val::cmp_si(long i) const {
+  auto res = isl_val_cmp_si(get(), i);
+  return res;
+}
+
+isl::val val::div(isl::val v2) const {
+  auto res = isl_val_div(copy(), v2.release());
+  return manage(res);
+}
+
+isl::val val::div_ui(unsigned long v2) const {
+  auto res = isl_val_div_ui(copy(), v2);
+  return manage(res);
+}
+
+isl::boolean val::eq(const isl::val &v2) const {
+  auto res = isl_val_eq(get(), v2.get());
+  return manage(res);
+}
+
+isl::val val::floor() const {
+  auto res = isl_val_floor(copy());
+  return manage(res);
+}
+
+isl::val val::gcd(isl::val v2) const {
+  auto res = isl_val_gcd(copy(), v2.release());
+  return manage(res);
+}
+
+isl::boolean val::ge(const isl::val &v2) const {
+  auto res = isl_val_ge(get(), v2.get());
+  return manage(res);
+}
+
+uint32_t val::get_hash() const {
+  auto res = isl_val_get_hash(get());
+  return res;
+}
+
+long val::get_num_si() const {
+  auto res = isl_val_get_num_si(get());
+  return res;
+}
+
+isl::boolean val::gt(const isl::val &v2) const {
+  auto res = isl_val_gt(get(), v2.get());
+  return manage(res);
+}
+
+isl::val val::infty(isl::ctx ctx) {
+  auto res = isl_val_infty(ctx.release());
+  return manage(res);
+}
+
+isl::val val::int_from_ui(isl::ctx ctx, unsigned long u) {
+  auto res = isl_val_int_from_ui(ctx.release(), u);
+  return manage(res);
+}
+
+isl::val val::inv() const {
+  auto res = isl_val_inv(copy());
+  return manage(res);
+}
+
+isl::boolean val::is_divisible_by(const isl::val &v2) const {
+  auto res = isl_val_is_divisible_by(get(), v2.get());
+  return manage(res);
+}
+
+isl::boolean val::is_infty() const {
+  auto res = isl_val_is_infty(get());
+  return manage(res);
+}
+
+isl::boolean val::is_int() const {
+  auto res = isl_val_is_int(get());
+  return manage(res);
+}
+
+isl::boolean val::is_nan() const {
+  auto res = isl_val_is_nan(get());
+  return manage(res);
+}
+
+isl::boolean val::is_neg() const {
+  auto res = isl_val_is_neg(get());
+  return manage(res);
+}
+
+isl::boolean val::is_neginfty() const {
+  auto res = isl_val_is_neginfty(get());
+  return manage(res);
+}
+
+isl::boolean val::is_negone() const {
+  auto res = isl_val_is_negone(get());
+  return manage(res);
+}
+
+isl::boolean val::is_nonneg() const {
+  auto res = isl_val_is_nonneg(get());
+  return manage(res);
+}
+
+isl::boolean val::is_nonpos() const {
+  auto res = isl_val_is_nonpos(get());
+  return manage(res);
+}
+
+isl::boolean val::is_one() const {
+  auto res = isl_val_is_one(get());
+  return manage(res);
+}
+
+isl::boolean val::is_pos() const {
+  auto res = isl_val_is_pos(get());
+  return manage(res);
+}
+
+isl::boolean val::is_rat() const {
+  auto res = isl_val_is_rat(get());
+  return manage(res);
+}
+
+isl::boolean val::is_zero() const {
+  auto res = isl_val_is_zero(get());
+  return manage(res);
+}
+
+isl::boolean val::le(const isl::val &v2) const {
+  auto res = isl_val_le(get(), v2.get());
+  return manage(res);
+}
+
+isl::boolean val::lt(const isl::val &v2) const {
+  auto res = isl_val_lt(get(), v2.get());
+  return manage(res);
+}
+
+isl::val val::max(isl::val v2) const {
+  auto res = isl_val_max(copy(), v2.release());
+  return manage(res);
+}
+
+isl::val val::min(isl::val v2) const {
+  auto res = isl_val_min(copy(), v2.release());
+  return manage(res);
+}
+
+isl::val val::mod(isl::val v2) const {
+  auto res = isl_val_mod(copy(), v2.release());
+  return manage(res);
+}
+
+isl::val val::mul(isl::val v2) const {
+  auto res = isl_val_mul(copy(), v2.release());
+  return manage(res);
+}
+
+isl::val val::mul_ui(unsigned long v2) const {
+  auto res = isl_val_mul_ui(copy(), v2);
+  return manage(res);
+}
+
+isl::val val::nan(isl::ctx ctx) {
+  auto res = isl_val_nan(ctx.release());
+  return manage(res);
+}
+
+isl::boolean val::ne(const isl::val &v2) const {
+  auto res = isl_val_ne(get(), v2.get());
+  return manage(res);
+}
+
+isl::val val::neg() const {
+  auto res = isl_val_neg(copy());
+  return manage(res);
+}
+
+isl::val val::neginfty(isl::ctx ctx) {
+  auto res = isl_val_neginfty(ctx.release());
+  return manage(res);
+}
+
+isl::val val::negone(isl::ctx ctx) {
+  auto res = isl_val_negone(ctx.release());
+  return manage(res);
+}
+
+isl::val val::one(isl::ctx ctx) {
+  auto res = isl_val_one(ctx.release());
+  return manage(res);
+}
+
+isl::val val::set_si(long i) const {
+  auto res = isl_val_set_si(copy(), i);
+  return manage(res);
+}
+
+int val::sgn() const {
+  auto res = isl_val_sgn(get());
+  return res;
+}
+
+isl::val val::sub(isl::val v2) const {
+  auto res = isl_val_sub(copy(), v2.release());
+  return manage(res);
+}
+
+isl::val val::sub_ui(unsigned long v2) const {
+  auto res = isl_val_sub_ui(copy(), v2);
+  return manage(res);
+}
+
+isl::val val::trunc() const {
+  auto res = isl_val_trunc(copy());
+  return manage(res);
+}
+
+isl::val val::zero(isl::ctx ctx) {
+  auto res = isl_val_zero(ctx.release());
+  return manage(res);
+}
+
+// implementations for isl::val_list
+isl::val_list manage(__isl_take isl_val_list *ptr) {
+  return val_list(ptr);
+}
+isl::val_list give(__isl_take isl_val_list *ptr) {
+  return manage(ptr);
+}
+
+
+val_list::val_list()
+    : ptr(nullptr) {}
+
+val_list::val_list(const isl::val_list &obj)
+    : ptr(obj.copy()) {}
+val_list::val_list(std::nullptr_t)
+    : ptr(nullptr) {}
+
+
+val_list::val_list(__isl_take isl_val_list *ptr)
+    : ptr(ptr) {}
+
+
+val_list &val_list::operator=(isl::val_list obj) {
+  std::swap(this->ptr, obj.ptr);
+  return *this;
+}
+
+val_list::~val_list() {
+  if (ptr)
+    isl_val_list_free(ptr);
+}
+
+__isl_give isl_val_list *val_list::copy() const & {
+  return isl_val_list_copy(ptr);
+}
+
+__isl_keep isl_val_list *val_list::get() const {
+  return ptr;
+}
+
+__isl_give isl_val_list *val_list::release() {
+  isl_val_list *tmp = ptr;
+  ptr = nullptr;
+  return tmp;
+}
+
+bool val_list::is_null() const {
+  return ptr == nullptr;
+}
+__isl_keep isl_val_list *val_list::keep() const {
+  return get();
+}
+
+__isl_give isl_val_list *val_list::take() {
+  return release();
+}
+
+val_list::operator bool() const {
+  return !is_null();
+}
+
+isl::ctx val_list::get_ctx() const {
+  return isl::ctx(isl_val_list_get_ctx(ptr));
+}
+
+
+
+void val_list::dump() const {
+  isl_val_list_dump(get());
+}
+
+
+} // namespace noexceptions
+} // namespace isl
+
+#endif /* ISL_CPP_NOEXCEPTIONS */
diff --git a/lib/Analysis/isl/include/isl/list.h b/lib/Analysis/isl/include/isl/list.h
index 948e565..803fd3a 100644
--- a/lib/Analysis/isl/include/isl/list.h
+++ b/lib/Analysis/isl/include/isl/list.h
@@ -50,6 +50,11 @@ __isl_give struct isl_##EL##_list *isl_##EL##_list_set_##EL(		\
 isl_stat isl_##EL##_list_foreach(__isl_keep isl_##EL##_list *list,	\
 	isl_stat (*fn)(__isl_take struct isl_##EL *el, void *user),	\
 	void *user);							\
+__isl_give isl_##EL##_list *isl_##EL##_list_map(			\
+	__isl_take isl_##EL##_list *list,				\
+	__isl_give isl_##EL * (*fn)(__isl_take isl_##EL *el,		\
+		void *user),						\
+	void *user);							\
 __isl_give isl_##EL##_list *isl_##EL##_list_sort(			\
 	__isl_take isl_##EL##_list *list,				\
 	int (*cmp)(__isl_keep struct isl_##EL *a,			\
diff --git a/lib/Analysis/isl/include/isl/map.h b/lib/Analysis/isl/include/isl/map.h
index 43de1de..a4e6533 100644
--- a/lib/Analysis/isl/include/isl/map.h
+++ b/lib/Analysis/isl/include/isl/map.h
@@ -28,31 +28,24 @@
 extern "C" {
 #endif
 
-/* General notes:
- *
- * All structures are reference counted to allow reuse without duplication.
- * A *_copy operation will increase the reference count, while a *_free
- * operation will decrease the reference count and only actually release
- * the structures when the reference count drops to zero.
- *
- * Functions that return an isa structure will in general _destroy_
- * all argument isa structures (the obvious execption begin the _copy
- * functions).  A pointer passed to such a function may therefore
- * never be used after the function call.  If you want to keep a
- * reference to the old structure(s), use the appropriate _copy function.
- */
-
-unsigned isl_basic_map_n_in(const struct isl_basic_map *bmap);
-unsigned isl_basic_map_n_out(const struct isl_basic_map *bmap);
-unsigned isl_basic_map_n_param(const struct isl_basic_map *bmap);
-unsigned isl_basic_map_n_div(const struct isl_basic_map *bmap);
-unsigned isl_basic_map_total_dim(const struct isl_basic_map *bmap);
+ISL_DEPRECATED
+unsigned isl_basic_map_n_in(__isl_keep const isl_basic_map *bmap);
+ISL_DEPRECATED
+unsigned isl_basic_map_n_out(__isl_keep const isl_basic_map *bmap);
+ISL_DEPRECATED
+unsigned isl_basic_map_n_param(__isl_keep const isl_basic_map *bmap);
+ISL_DEPRECATED
+unsigned isl_basic_map_n_div(__isl_keep const isl_basic_map *bmap);
+unsigned isl_basic_map_total_dim(__isl_keep const isl_basic_map *bmap);
 unsigned isl_basic_map_dim(__isl_keep isl_basic_map *bmap,
 				enum isl_dim_type type);
 
-unsigned isl_map_n_in(const struct isl_map *map);
-unsigned isl_map_n_out(const struct isl_map *map);
-unsigned isl_map_n_param(const struct isl_map *map);
+ISL_DEPRECATED
+unsigned isl_map_n_in(__isl_keep const isl_map *map);
+ISL_DEPRECATED
+unsigned isl_map_n_out(__isl_keep const isl_map *map);
+ISL_DEPRECATED
+unsigned isl_map_n_param(__isl_keep const isl_map *map);
 unsigned isl_map_dim(__isl_keep isl_map *map, enum isl_dim_type type);
 
 isl_ctx *isl_basic_map_get_ctx(__isl_keep isl_basic_map *bmap);
@@ -115,7 +108,7 @@ int isl_map_find_dim_by_id(__isl_keep isl_map *map, enum isl_dim_type type,
 int isl_map_find_dim_by_name(__isl_keep isl_map *map, enum isl_dim_type type,
 	const char *name);
 
-int isl_basic_map_is_rational(__isl_keep isl_basic_map *bmap);
+isl_bool isl_basic_map_is_rational(__isl_keep isl_basic_map *bmap);
 
 __isl_give isl_basic_map *isl_basic_map_identity(__isl_take isl_space *dim);
 __isl_null isl_basic_map *isl_basic_map_free(__isl_take isl_basic_map *bmap);
@@ -188,8 +181,6 @@ __isl_give isl_basic_map *isl_basic_map_remove_dims(
 __isl_give isl_basic_map *isl_basic_map_eliminate(
 	__isl_take isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned first, unsigned n);
-__isl_give isl_basic_map *isl_basic_map_from_basic_set(
-	__isl_take isl_basic_set *bset, __isl_take isl_space *dim);
 __isl_export
 __isl_give isl_basic_map *isl_basic_map_sample(__isl_take isl_basic_map *bmap);
 __isl_export
@@ -205,6 +196,7 @@ __isl_constructor
 __isl_give isl_map *isl_map_read_from_str(isl_ctx *ctx, const char *str);
 void isl_basic_map_dump(__isl_keep isl_basic_map *bmap);
 void isl_map_dump(__isl_keep isl_map *map);
+__isl_give char *isl_basic_map_to_str(__isl_keep isl_basic_map *bmap);
 __isl_give isl_printer *isl_printer_print_basic_map(
 	__isl_take isl_printer *printer, __isl_keep isl_basic_map *bmap);
 __isl_give char *isl_map_to_str(__isl_keep isl_map *map);
@@ -221,9 +213,9 @@ __isl_give isl_basic_map *isl_basic_map_upper_bound_si(
 	__isl_take isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned pos, int value);
 
-struct isl_basic_map *isl_basic_map_sum(
-		struct isl_basic_map *bmap1, struct isl_basic_map *bmap2);
-struct isl_basic_map *isl_basic_map_neg(struct isl_basic_map *bmap);
+__isl_give isl_basic_map *isl_basic_map_sum(__isl_take isl_basic_map *bmap1,
+	__isl_take isl_basic_map *bmap2);
+__isl_give isl_basic_map *isl_basic_map_neg(__isl_take isl_basic_map *bmap);
 
 __isl_give isl_map *isl_map_sum(__isl_take isl_map *map1,
 	__isl_take isl_map *map2);
@@ -273,15 +265,11 @@ __isl_give isl_pw_multi_aff *isl_map_lexmax_pw_multi_aff(
 void isl_basic_map_print_internal(__isl_keep isl_basic_map *bmap,
 	FILE *out, int indent);
 
-struct isl_basic_map *isl_map_copy_basic_map(struct isl_map *map);
-__isl_give isl_map *isl_map_drop_basic_map(__isl_take isl_map *map,
-						__isl_keep isl_basic_map *bmap);
-
 __isl_give isl_val *isl_basic_map_plain_get_val_if_fixed(
 	__isl_keep isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned pos);
 
-int isl_basic_map_image_is_bounded(__isl_keep isl_basic_map *bmap);
+isl_bool isl_basic_map_image_is_bounded(__isl_keep isl_basic_map *bmap);
 isl_bool isl_basic_map_plain_is_universe(__isl_keep isl_basic_map *bmap);
 isl_bool isl_basic_map_is_universe(__isl_keep isl_basic_map *bmap);
 isl_bool isl_basic_map_plain_is_empty(__isl_keep isl_basic_map *bmap);
@@ -313,8 +301,8 @@ __isl_export
 __isl_give isl_map *isl_map_union(
 		__isl_take isl_map *map1,
 		__isl_take isl_map *map2);
-struct isl_map *isl_map_union_disjoint(
-			struct isl_map *map1, struct isl_map *map2);
+__isl_give isl_map *isl_map_union_disjoint(
+		__isl_take isl_map *map1, __isl_take isl_map *map2);
 __isl_export
 __isl_give isl_map *isl_map_intersect_domain(
 		__isl_take isl_map *map,
@@ -323,6 +311,10 @@ __isl_export
 __isl_give isl_map *isl_map_intersect_range(
 		__isl_take isl_map *map,
 		__isl_take isl_set *set);
+__isl_give isl_map *isl_map_intersect_domain_factor_range(
+	__isl_take isl_map *map, __isl_take isl_map *factor);
+__isl_give isl_map *isl_map_intersect_range_factor_range(
+	__isl_take isl_map *map, __isl_take isl_map *factor);
 __isl_export
 __isl_give isl_map *isl_map_apply_domain(
 		__isl_take isl_map *map1,
@@ -365,6 +357,7 @@ __isl_give isl_map *isl_map_flat_range_product(__isl_take isl_map *map1,
 	__isl_take isl_map *map2);
 isl_bool isl_map_domain_is_wrapping(__isl_keep isl_map *map);
 isl_bool isl_map_range_is_wrapping(__isl_keep isl_map *map);
+isl_bool isl_map_is_product(__isl_keep isl_map *map);
 __isl_give isl_map *isl_map_factor_domain(__isl_take isl_map *map);
 __isl_give isl_map *isl_map_factor_range(__isl_take isl_map *map);
 __isl_give isl_map *isl_map_domain_factor_domain(__isl_take isl_map *map);
@@ -515,8 +508,6 @@ __isl_give isl_basic_map *isl_basic_map_from_domain_and_range(
 	__isl_take isl_basic_set *domain, __isl_take isl_basic_set *range);
 __isl_give isl_map *isl_map_from_domain_and_range(__isl_take isl_set *domain,
 	__isl_take isl_set *range);
-__isl_give isl_map *isl_map_from_set(__isl_take isl_set *set,
-	__isl_take isl_space *dim);
 __isl_export
 __isl_give isl_basic_map *isl_map_sample(__isl_take isl_map *map);
 
@@ -545,7 +536,8 @@ __isl_export
 isl_bool isl_map_is_bijective(__isl_keep isl_map *map);
 isl_bool isl_map_is_identity(__isl_keep isl_map *map);
 int isl_map_is_translation(__isl_keep isl_map *map);
-int isl_map_has_equal_space(__isl_keep isl_map *map1, __isl_keep isl_map *map2);
+isl_bool isl_map_has_equal_space(__isl_keep isl_map *map1,
+	__isl_keep isl_map *map2);
 
 isl_bool isl_basic_map_can_zip(__isl_keep isl_basic_map *bmap);
 isl_bool isl_map_can_zip(__isl_keep isl_map *map);
@@ -568,6 +560,7 @@ __isl_give isl_map *isl_map_uncurry(__isl_take isl_map *map);
 __isl_give isl_map *isl_map_make_disjoint(__isl_take isl_map *map);
 __isl_give isl_map *isl_basic_map_compute_divs(__isl_take isl_basic_map *bmap);
 __isl_give isl_map *isl_map_compute_divs(__isl_take isl_map *map);
+ISL_DEPRECATED
 __isl_give isl_map *isl_map_align_divs(__isl_take isl_map *map);
 
 __isl_give isl_basic_map *isl_basic_map_drop_constraints_involving_dims(
@@ -624,8 +617,6 @@ __isl_export
 isl_stat isl_map_foreach_basic_map(__isl_keep isl_map *map,
 	isl_stat (*fn)(__isl_take isl_basic_map *bmap, void *user), void *user);
 
-__isl_give isl_map *isl_set_lifting(__isl_take isl_set *set);
-
 __isl_give isl_map *isl_map_fixed_power_val(__isl_take isl_map *map,
 	__isl_take isl_val *exp);
 __isl_give isl_map *isl_map_power(__isl_take isl_map *map, int *exact);
@@ -671,6 +662,7 @@ __isl_give isl_basic_map *isl_basic_map_from_aff_list(
 __isl_give isl_map *isl_map_from_aff(__isl_take isl_aff *aff);
 __isl_give isl_map *isl_map_from_multi_aff(__isl_take isl_multi_aff *maff);
 
+__isl_give isl_pw_aff *isl_map_dim_min(__isl_take isl_map *map, int pos);
 __isl_give isl_pw_aff *isl_map_dim_max(__isl_take isl_map *map, int pos);
 
 ISL_DECLARE_LIST_FN(basic_map)
diff --git a/lib/Analysis/isl/include/isl/mat.h b/lib/Analysis/isl/include/isl/mat.h
index 7a43ccb..8764c96 100644
--- a/lib/Analysis/isl/include/isl/mat.h
+++ b/lib/Analysis/isl/include/isl/mat.h
@@ -27,12 +27,12 @@ isl_ctx *isl_mat_get_ctx(__isl_keep isl_mat *mat);
 
 __isl_give isl_mat *isl_mat_alloc(isl_ctx *ctx,
 	unsigned n_row, unsigned n_col);
-struct isl_mat *isl_mat_dup(struct isl_mat *mat);
+__isl_give isl_mat *isl_mat_dup(__isl_keep isl_mat *mat);
 struct isl_mat *isl_mat_extend(struct isl_mat *mat,
 	unsigned n_row, unsigned n_col);
 struct isl_mat *isl_mat_identity(struct isl_ctx *ctx, unsigned n_row);
 __isl_give isl_mat *isl_mat_copy(__isl_keep isl_mat *mat);
-struct isl_mat *isl_mat_cow(struct isl_mat *mat);
+__isl_give isl_mat *isl_mat_cow(__isl_take isl_mat *mat);
 __isl_null isl_mat *isl_mat_free(__isl_take isl_mat *mat);
 
 int isl_mat_rows(__isl_keep isl_mat *mat);
@@ -44,34 +44,38 @@ __isl_give isl_mat *isl_mat_set_element_si(__isl_take isl_mat *mat,
 __isl_give isl_mat *isl_mat_set_element_val(__isl_take isl_mat *mat,
 	int row, int col, __isl_take isl_val *v);
 
-struct isl_mat *isl_mat_swap_cols(struct isl_mat *mat, unsigned i, unsigned j);
-struct isl_mat *isl_mat_swap_rows(struct isl_mat *mat, unsigned i, unsigned j);
+__isl_give isl_mat *isl_mat_swap_cols(__isl_take isl_mat *mat,
+	unsigned i, unsigned j);
+__isl_give isl_mat *isl_mat_swap_rows(__isl_take isl_mat *mat,
+	unsigned i, unsigned j);
 
-struct isl_vec *isl_mat_vec_product(struct isl_mat *mat, struct isl_vec *vec);
-struct isl_vec *isl_vec_mat_product(struct isl_vec *vec, struct isl_mat *mat);
+__isl_give isl_vec *isl_mat_vec_product(__isl_take isl_mat *mat,
+	__isl_take isl_vec *vec);
+__isl_give isl_vec *isl_vec_mat_product(__isl_take isl_vec *vec,
+	__isl_take isl_mat *mat);
 __isl_give isl_vec *isl_mat_vec_inverse_product(__isl_take isl_mat *mat,
 						__isl_take isl_vec *vec);
-struct isl_mat *isl_mat_aff_direct_sum(struct isl_mat *left,
-					struct isl_mat *right);
+__isl_give isl_mat *isl_mat_aff_direct_sum(__isl_take isl_mat *left,
+	__isl_take isl_mat *right);
 __isl_give isl_mat *isl_mat_diagonal(__isl_take isl_mat *mat1,
 	__isl_take isl_mat *mat2);
-struct isl_mat *isl_mat_left_hermite(struct isl_mat *M,
-	int neg, struct isl_mat **U, struct isl_mat **Q);
-struct isl_mat *isl_mat_lin_to_aff(struct isl_mat *mat);
-struct isl_mat *isl_mat_inverse_product(struct isl_mat *left,
-	struct isl_mat *right);
+__isl_give isl_mat *isl_mat_left_hermite(__isl_take isl_mat *M, int neg,
+	__isl_give isl_mat **U, __isl_give isl_mat **Q);
+__isl_give isl_mat *isl_mat_lin_to_aff(__isl_take isl_mat *mat);
+__isl_give isl_mat *isl_mat_inverse_product(__isl_take isl_mat *left,
+	__isl_take isl_mat *right);
 __isl_give isl_mat *isl_mat_product(__isl_take isl_mat *left,
 	__isl_take isl_mat *right);
-struct isl_mat *isl_mat_transpose(struct isl_mat *mat);
+__isl_give isl_mat *isl_mat_transpose(__isl_take isl_mat *mat);
 __isl_give isl_mat *isl_mat_right_inverse(__isl_take isl_mat *mat);
 __isl_give isl_mat *isl_mat_right_kernel(__isl_take isl_mat *mat);
 
 __isl_give isl_mat *isl_mat_normalize(__isl_take isl_mat *mat);
 __isl_give isl_mat *isl_mat_normalize_row(__isl_take isl_mat *mat, int row);
 
-struct isl_mat *isl_mat_drop_cols(struct isl_mat *mat,
-				unsigned col, unsigned n);
-struct isl_mat *isl_mat_drop_rows(struct isl_mat *mat,
+__isl_give isl_mat *isl_mat_drop_cols(__isl_take isl_mat *mat,
+	unsigned col, unsigned n);
+__isl_give isl_mat *isl_mat_drop_rows(__isl_take isl_mat *mat,
 				unsigned row, unsigned n);
 __isl_give isl_mat *isl_mat_insert_cols(__isl_take isl_mat *mat,
 				unsigned col, unsigned n);
@@ -89,7 +93,7 @@ __isl_give isl_mat *isl_mat_add_zero_rows(__isl_take isl_mat *mat, unsigned n);
 
 void isl_mat_col_add(__isl_keep isl_mat *mat, int dst_col, int src_col);
 
-struct isl_mat *isl_mat_unimodular_complete(struct isl_mat *M, int row);
+__isl_give isl_mat *isl_mat_unimodular_complete(__isl_take isl_mat *M, int row);
 
 __isl_give isl_mat *isl_mat_from_row_vec(__isl_take isl_vec *vec);
 __isl_give isl_mat *isl_mat_concat(__isl_take isl_mat *top,
@@ -97,7 +101,7 @@ __isl_give isl_mat *isl_mat_concat(__isl_take isl_mat *top,
 __isl_give isl_mat *isl_mat_vec_concat(__isl_take isl_mat *top,
 	__isl_take isl_vec *bot);
 
-int isl_mat_is_equal(__isl_keep isl_mat *mat1, __isl_keep isl_mat *mat2);
+isl_bool isl_mat_is_equal(__isl_keep isl_mat *mat1, __isl_keep isl_mat *mat2);
 
 int isl_mat_initial_non_zero_cols(__isl_keep isl_mat *mat);
 
diff --git a/lib/Analysis/isl/include/isl/multi.h b/lib/Analysis/isl/include/isl/multi.h
index 612bafc..a678b32 100644
--- a/lib/Analysis/isl/include/isl/multi.h
+++ b/lib/Analysis/isl/include/isl/multi.h
@@ -32,6 +32,8 @@ __isl_null isl_multi_##BASE *isl_multi_##BASE##_free(			\
 isl_bool isl_multi_##BASE##_plain_is_equal(				\
 	__isl_keep isl_multi_##BASE *multi1,				\
 	__isl_keep isl_multi_##BASE *multi2);				\
+isl_bool isl_multi_##BASE##_involves_nan(				\
+	__isl_keep isl_multi_##BASE *multi);				\
 int isl_multi_##BASE##_find_dim_by_id(					\
 	__isl_keep isl_multi_##BASE *multi, enum isl_dim_type type,	\
 	__isl_keep isl_id *id);						\
@@ -115,6 +117,10 @@ __isl_give isl_multi_##BASE *isl_multi_##BASE##_align_params(		\
 __isl_give isl_multi_##BASE *isl_multi_##BASE##_from_range(		\
 	__isl_take isl_multi_##BASE *multi);
 
+#define ISL_DECLARE_MULTI_CMP(BASE)					\
+int isl_multi_##BASE##_plain_cmp(__isl_keep isl_multi_##BASE *multi1,	\
+	__isl_keep isl_multi_##BASE *multi2);
+
 #define ISL_DECLARE_MULTI_NEG(BASE)					\
 __isl_give isl_multi_##BASE *isl_multi_##BASE##_neg(		 	\
 	__isl_take isl_multi_##BASE *multi);
diff --git a/lib/Analysis/isl/include/isl/point.h b/lib/Analysis/isl/include/isl/point.h
index 53970d3..97c3c46 100644
--- a/lib/Analysis/isl/include/isl/point.h
+++ b/lib/Analysis/isl/include/isl/point.h
@@ -17,7 +17,7 @@ __isl_give isl_space *isl_point_get_space(__isl_keep isl_point *pnt);
 
 __isl_give isl_point *isl_point_zero(__isl_take isl_space *dim);
 __isl_give isl_point *isl_point_copy(__isl_keep isl_point *pnt);
-void isl_point_free(__isl_take isl_point *pnt);
+__isl_null isl_point *isl_point_free(__isl_take isl_point *pnt);
 
 __isl_give isl_val *isl_point_get_coordinate_val(__isl_keep isl_point *pnt,
 	enum isl_dim_type type, int pos);
@@ -34,6 +34,7 @@ isl_bool isl_point_is_void(__isl_keep isl_point *pnt);
 
 __isl_give isl_printer *isl_printer_print_point(
 	__isl_take isl_printer *printer, __isl_keep isl_point *pnt);
+__isl_give char *isl_point_to_str(__isl_keep isl_point *pnt);
 void isl_point_dump(__isl_keep isl_point *pnt);
 
 #if defined(__cplusplus)
diff --git a/lib/Analysis/isl/include/isl/polynomial.h b/lib/Analysis/isl/include/isl/polynomial.h
index 5a24295..bb285ab 100644
--- a/lib/Analysis/isl/include/isl/polynomial.h
+++ b/lib/Analysis/isl/include/isl/polynomial.h
@@ -87,9 +87,9 @@ __isl_give isl_qpolynomial *isl_qpolynomial_substitute(
 	enum isl_dim_type type, unsigned first, unsigned n,
 	__isl_keep isl_qpolynomial **subs);
 
-int isl_qpolynomial_as_polynomial_on_domain(__isl_keep isl_qpolynomial *qp,
+isl_stat isl_qpolynomial_as_polynomial_on_domain(__isl_keep isl_qpolynomial *qp,
 	__isl_keep isl_basic_set *bset,
-	int (*fn)(__isl_take isl_basic_set *bset,
+	isl_stat (*fn)(__isl_take isl_basic_set *bset,
 		  __isl_take isl_qpolynomial *poly, void *user), void *user);
 
 __isl_give isl_qpolynomial *isl_qpolynomial_homogenize(
@@ -135,6 +135,7 @@ void isl_qpolynomial_dump(__isl_keep isl_qpolynomial *qp);
 
 isl_ctx *isl_pw_qpolynomial_get_ctx(__isl_keep isl_pw_qpolynomial *pwqp);
 
+isl_bool isl_pw_qpolynomial_involves_nan(__isl_keep isl_pw_qpolynomial *pwqp);
 isl_bool isl_pw_qpolynomial_plain_is_equal(__isl_keep isl_pw_qpolynomial *pwqp1,
 	__isl_keep isl_pw_qpolynomial *pwqp2);
 
@@ -160,7 +161,8 @@ unsigned isl_pw_qpolynomial_dim(__isl_keep isl_pw_qpolynomial *pwqp,
 	enum isl_dim_type type);
 isl_bool isl_pw_qpolynomial_involves_dims(__isl_keep isl_pw_qpolynomial *pwqp,
 	enum isl_dim_type type, unsigned first, unsigned n);
-int isl_pw_qpolynomial_has_equal_space(__isl_keep isl_pw_qpolynomial *pwqp1,
+isl_bool isl_pw_qpolynomial_has_equal_space(
+	__isl_keep isl_pw_qpolynomial *pwqp1,
 	__isl_keep isl_pw_qpolynomial *pwqp2);
 
 __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_set_dim_name(
@@ -173,6 +175,7 @@ int isl_pw_qpolynomial_find_dim_by_name(__isl_keep isl_pw_qpolynomial *pwqp,
 __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_reset_user(
 	__isl_take isl_pw_qpolynomial *pwqp);
 
+__isl_export
 __isl_give isl_set *isl_pw_qpolynomial_domain(__isl_take isl_pw_qpolynomial *pwqp);
 __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_intersect_domain(
 	__isl_take isl_pw_qpolynomial *pwpq, __isl_take isl_set *set);
@@ -183,6 +186,8 @@ __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_subtract_domain(
 
 __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_project_domain_on_params(
 	__isl_take isl_pw_qpolynomial *pwqp);
+__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_from_range(
+	__isl_take isl_pw_qpolynomial *pwqp);
 __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_drop_dims(
 	__isl_take isl_pw_qpolynomial *pwqp,
 	enum isl_dim_type type, unsigned first, unsigned n);
@@ -226,12 +231,14 @@ __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_fix_val(
 	__isl_take isl_pw_qpolynomial *pwqp,
 	enum isl_dim_type type, unsigned n, __isl_take isl_val *v);
 
+__isl_export
 __isl_give isl_val *isl_pw_qpolynomial_eval(
 	__isl_take isl_pw_qpolynomial *pwqp, __isl_take isl_point *pnt);
 
 __isl_give isl_val *isl_pw_qpolynomial_max(__isl_take isl_pw_qpolynomial *pwqp);
 __isl_give isl_val *isl_pw_qpolynomial_min(__isl_take isl_pw_qpolynomial *pwqp);
 
+int isl_pw_qpolynomial_n_piece(__isl_keep isl_pw_qpolynomial *pwqp);
 isl_stat isl_pw_qpolynomial_foreach_piece(__isl_keep isl_pw_qpolynomial *pwqp,
 	isl_stat (*fn)(__isl_take isl_set *set, __isl_take isl_qpolynomial *qp,
 		    void *user), void *user);
@@ -248,6 +255,7 @@ __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_read_from_str(isl_ctx *ctx,
 		const char *str);
 __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_read_from_file(isl_ctx *ctx,
 		FILE *input);
+__isl_give char *isl_pw_qpolynomial_to_str(__isl_keep isl_pw_qpolynomial *pwqp);
 __isl_give isl_printer *isl_printer_print_pw_qpolynomial(
 	__isl_take isl_printer *p, __isl_keep isl_pw_qpolynomial *pwqp);
 void isl_pw_qpolynomial_print(__isl_keep isl_pw_qpolynomial *pwqp, FILE *out,
@@ -328,6 +336,8 @@ void isl_qpolynomial_fold_dump(__isl_keep isl_qpolynomial_fold *fold);
 
 isl_ctx *isl_pw_qpolynomial_fold_get_ctx(__isl_keep isl_pw_qpolynomial_fold *pwf);
 
+isl_bool isl_pw_qpolynomial_fold_involves_nan(
+	__isl_keep isl_pw_qpolynomial_fold *pwf);
 isl_bool isl_pw_qpolynomial_fold_plain_is_equal(
 	__isl_keep isl_pw_qpolynomial_fold *pwf1,
 	__isl_keep isl_pw_qpolynomial_fold *pwf2);
@@ -354,7 +364,7 @@ __isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_reset_space(
 	__isl_take isl_pw_qpolynomial_fold *pwf, __isl_take isl_space *dim);
 unsigned isl_pw_qpolynomial_fold_dim(__isl_keep isl_pw_qpolynomial_fold *pwf,
 	enum isl_dim_type type);
-int isl_pw_qpolynomial_fold_has_equal_space(
+isl_bool isl_pw_qpolynomial_fold_has_equal_space(
 	__isl_keep isl_pw_qpolynomial_fold *pwf1,
 	__isl_keep isl_pw_qpolynomial_fold *pwf2);
 
@@ -399,6 +409,8 @@ __isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_scale_down_val(
 
 __isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_project_domain_on_params(
 	__isl_take isl_pw_qpolynomial_fold *pwf);
+__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_from_range(
+	__isl_take isl_pw_qpolynomial_fold *pwf);
 __isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_drop_dims(
 	__isl_take isl_pw_qpolynomial_fold *pwf,
 	enum isl_dim_type type, unsigned first, unsigned n);
@@ -410,6 +422,7 @@ __isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_move_dims(
 __isl_give isl_val *isl_pw_qpolynomial_fold_eval(
 	__isl_take isl_pw_qpolynomial_fold *pwf, __isl_take isl_point *pnt);
 
+int isl_pw_qpolynomial_fold_n_piece(__isl_keep isl_pw_qpolynomial_fold *pwf);
 isl_stat isl_pw_qpolynomial_fold_foreach_piece(
 	__isl_keep isl_pw_qpolynomial_fold *pwf,
 	isl_stat (*fn)(__isl_take isl_set *set,
@@ -457,6 +470,8 @@ isl_ctx *isl_union_pw_qpolynomial_get_ctx(
 unsigned isl_union_pw_qpolynomial_dim(
 	__isl_keep isl_union_pw_qpolynomial *upwqp, enum isl_dim_type type);
 
+isl_bool isl_union_pw_qpolynomial_involves_nan(
+	__isl_keep isl_union_pw_qpolynomial *upwqp);
 isl_bool isl_union_pw_qpolynomial_plain_is_equal(
 	__isl_keep isl_union_pw_qpolynomial *upwqp1,
 	__isl_keep isl_union_pw_qpolynomial *upwqp2);
@@ -475,6 +490,8 @@ __isl_null isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_free(
 __isl_constructor
 __isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_read_from_str(
 	isl_ctx *ctx, const char *str);
+__isl_give char *isl_union_pw_qpolynomial_to_str(
+	__isl_keep isl_union_pw_qpolynomial *upwqp);
 
 __isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_neg(
 	__isl_take isl_union_pw_qpolynomial *upwqp);
@@ -493,6 +510,7 @@ __isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_scale_val(
 __isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_scale_down_val(
 	__isl_take isl_union_pw_qpolynomial *upwqp, __isl_take isl_val *v);
 
+__isl_export
 __isl_give isl_union_set *isl_union_pw_qpolynomial_domain(
 	__isl_take isl_union_pw_qpolynomial *upwqp);
 __isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_intersect_domain(
@@ -522,6 +540,7 @@ __isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_drop_dims(
 __isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_reset_user(
 	__isl_take isl_union_pw_qpolynomial *upwqp);
 
+__isl_export
 __isl_give isl_val *isl_union_pw_qpolynomial_eval(
 	__isl_take isl_union_pw_qpolynomial *upwqp, __isl_take isl_point *pnt);
 
@@ -556,6 +575,8 @@ isl_ctx *isl_union_pw_qpolynomial_fold_get_ctx(
 unsigned isl_union_pw_qpolynomial_fold_dim(
 	__isl_keep isl_union_pw_qpolynomial_fold *upwf, enum isl_dim_type type);
 
+isl_bool isl_union_pw_qpolynomial_fold_involves_nan(
+	__isl_keep isl_union_pw_qpolynomial_fold *upwf);
 isl_bool isl_union_pw_qpolynomial_fold_plain_is_equal(
 	__isl_keep isl_union_pw_qpolynomial_fold *upwf1,
 	__isl_keep isl_union_pw_qpolynomial_fold *upwf2);
diff --git a/lib/Analysis/isl/include/isl/schedule.h b/lib/Analysis/isl/include/isl/schedule.h
index ea71fc6..7970b64 100644
--- a/lib/Analysis/isl/include/isl/schedule.h
+++ b/lib/Analysis/isl/include/isl/schedule.h
@@ -14,7 +14,7 @@
 extern "C" {
 #endif
 
-struct isl_schedule_constraints;
+struct __isl_export isl_schedule_constraints;
 typedef struct isl_schedule_constraints isl_schedule_constraints;
 
 isl_stat isl_options_set_schedule_max_coefficient(isl_ctx *ctx, int val);
@@ -47,21 +47,30 @@ int isl_options_get_schedule_serialize_sccs(isl_ctx *ctx);
 isl_stat isl_options_set_schedule_whole_component(isl_ctx *ctx, int val);
 int isl_options_get_schedule_whole_component(isl_ctx *ctx);
 
+isl_stat isl_options_set_schedule_carry_self_first(isl_ctx *ctx, int val);
+int isl_options_get_schedule_carry_self_first(isl_ctx *ctx);
+
 __isl_give isl_schedule_constraints *isl_schedule_constraints_copy(
 	__isl_keep isl_schedule_constraints *sc);
+__isl_export
 __isl_give isl_schedule_constraints *isl_schedule_constraints_on_domain(
 	__isl_take isl_union_set *domain);
+__isl_export
 __isl_give isl_schedule_constraints *isl_schedule_constraints_set_context(
 	__isl_take isl_schedule_constraints *sc, __isl_take isl_set *context);
+__isl_export
 __isl_give isl_schedule_constraints *isl_schedule_constraints_set_validity(
 	__isl_take isl_schedule_constraints *sc,
 	__isl_take isl_union_map *validity);
+__isl_export
 __isl_give isl_schedule_constraints *isl_schedule_constraints_set_coincidence(
 	__isl_take isl_schedule_constraints *sc,
 	__isl_take isl_union_map *coincidence);
+__isl_export
 __isl_give isl_schedule_constraints *isl_schedule_constraints_set_proximity(
 	__isl_take isl_schedule_constraints *sc,
 	__isl_take isl_union_map *proximity);
+__isl_export
 __isl_give isl_schedule_constraints *
 isl_schedule_constraints_set_conditional_validity(
 	__isl_take isl_schedule_constraints *sc,
@@ -72,16 +81,25 @@ __isl_null isl_schedule_constraints *isl_schedule_constraints_free(
 
 isl_ctx *isl_schedule_constraints_get_ctx(
 	__isl_keep isl_schedule_constraints *sc);
+__isl_export
 __isl_give isl_union_set *isl_schedule_constraints_get_domain(
 	__isl_keep isl_schedule_constraints *sc);
+__isl_export
+__isl_give isl_set *isl_schedule_constraints_get_context(
+	__isl_keep isl_schedule_constraints *sc);
+__isl_export
 __isl_give isl_union_map *isl_schedule_constraints_get_validity(
 	__isl_keep isl_schedule_constraints *sc);
+__isl_export
 __isl_give isl_union_map *isl_schedule_constraints_get_coincidence(
 	__isl_keep isl_schedule_constraints *sc);
+__isl_export
 __isl_give isl_union_map *isl_schedule_constraints_get_proximity(
 	__isl_keep isl_schedule_constraints *sc);
+__isl_export
 __isl_give isl_union_map *isl_schedule_constraints_get_conditional_validity(
 	__isl_keep isl_schedule_constraints *sc);
+__isl_export
 __isl_give isl_union_map *
 isl_schedule_constraints_get_conditional_validity_condition(
 	__isl_keep isl_schedule_constraints *sc);
@@ -90,8 +108,18 @@ __isl_give isl_schedule_constraints *isl_schedule_constraints_apply(
 	__isl_take isl_schedule_constraints *sc,
 	__isl_take isl_union_map *umap);
 
+__isl_constructor
+__isl_give isl_schedule_constraints *isl_schedule_constraints_read_from_str(
+	isl_ctx *ctx, const char *str);
+__isl_give isl_schedule_constraints *isl_schedule_constraints_read_from_file(
+	isl_ctx *ctx, FILE *input);
+__isl_give isl_printer *isl_printer_print_schedule_constraints(
+	__isl_take isl_printer *p, __isl_keep isl_schedule_constraints *sc);
 void isl_schedule_constraints_dump(__isl_keep isl_schedule_constraints *sc);
+__isl_give char *isl_schedule_constraints_to_str(
+	__isl_keep isl_schedule_constraints *sc);
 
+__isl_export
 __isl_give isl_schedule *isl_schedule_constraints_compute_schedule(
 	__isl_take isl_schedule_constraints *sc);
 
diff --git a/lib/Analysis/isl/include/isl/set.h b/lib/Analysis/isl/include/isl/set.h
index 2d5901b..76c00fa 100644
--- a/lib/Analysis/isl/include/isl/set.h
+++ b/lib/Analysis/isl/include/isl/set.h
@@ -25,7 +25,7 @@ extern "C" {
 
 unsigned isl_basic_set_n_dim(__isl_keep isl_basic_set *bset);
 unsigned isl_basic_set_n_param(__isl_keep isl_basic_set *bset);
-unsigned isl_basic_set_total_dim(const struct isl_basic_set *bset);
+unsigned isl_basic_set_total_dim(__isl_keep const isl_basic_set *bset);
 unsigned isl_basic_set_dim(__isl_keep isl_basic_set *bset,
 				enum isl_dim_type type);
 
@@ -127,8 +127,6 @@ __isl_give isl_basic_set *isl_basic_set_remove_redundancies(
 __isl_give isl_set *isl_set_remove_redundancies(__isl_take isl_set *set);
 __isl_give isl_basic_set *isl_basic_set_list_intersect(
 	__isl_take struct isl_basic_set_list *list);
-__isl_give isl_basic_set *isl_basic_set_list_product(
-	__isl_take struct isl_basic_set_list *list);
 
 __isl_give isl_set *isl_set_list_union(__isl_take isl_set_list *list);
 
@@ -154,10 +152,16 @@ __isl_give isl_set *isl_set_fix_si(__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, int value);
 __isl_give isl_set *isl_set_lower_bound_si(__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, int value);
+__isl_give isl_basic_set *isl_basic_set_lower_bound_val(
+	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,
+	__isl_take isl_val *value);
 __isl_give isl_set *isl_set_lower_bound_val(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned pos, __isl_take isl_val *value);
 __isl_give isl_set *isl_set_upper_bound_si(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned pos, int value);
+__isl_give isl_basic_set *isl_basic_set_upper_bound_val(
+	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,
+	__isl_take isl_val *value);
 __isl_give isl_set *isl_set_upper_bound_val(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned pos, __isl_take isl_val *value);
 
@@ -217,7 +221,7 @@ __isl_give isl_basic_set *isl_basic_set_from_params(
 __isl_give isl_set *isl_set_params(__isl_take isl_set *set);
 __isl_give isl_set *isl_set_from_params(__isl_take isl_set *set);
 
-int isl_basic_set_dims_get_sign(__isl_keep isl_basic_set *bset,
+isl_stat isl_basic_set_dims_get_sign(__isl_keep isl_basic_set *bset,
 	enum isl_dim_type type, unsigned pos, unsigned n, int *signs);
 
 isl_bool isl_basic_set_plain_is_universe(__isl_keep isl_basic_set *bset);
@@ -225,7 +229,7 @@ isl_bool isl_basic_set_is_universe(__isl_keep isl_basic_set *bset);
 isl_bool isl_basic_set_plain_is_empty(__isl_keep isl_basic_set *bset);
 __isl_export
 isl_bool isl_basic_set_is_empty(__isl_keep isl_basic_set *bset);
-int isl_basic_set_is_bounded(__isl_keep isl_basic_set *bset);
+isl_bool isl_basic_set_is_bounded(__isl_keep isl_basic_set *bset);
 __isl_export
 isl_bool isl_basic_set_is_subset(__isl_keep isl_basic_set *bset1,
 	__isl_keep isl_basic_set *bset2);
@@ -241,7 +245,9 @@ __isl_constructor
 __isl_give isl_set *isl_set_from_basic_set(__isl_take isl_basic_set *bset);
 __isl_export
 __isl_give isl_basic_set *isl_set_sample(__isl_take isl_set *set);
+__isl_export
 __isl_give isl_point *isl_basic_set_sample_point(__isl_take isl_basic_set *bset);
+__isl_export
 __isl_give isl_point *isl_set_sample_point(__isl_take isl_set *set);
 __isl_export
 __isl_give isl_set *isl_set_detect_equalities(__isl_take isl_set *set);
@@ -258,11 +264,10 @@ __isl_give isl_basic_set *isl_set_plain_unshifted_simple_hull(
 	__isl_take isl_set *set);
 __isl_give isl_basic_set *isl_set_unshifted_simple_hull_from_set_list(
 	__isl_take isl_set *set, __isl_take isl_set_list *list);
-struct isl_basic_set *isl_set_bounded_simple_hull(struct isl_set *set);
-__isl_give isl_set *isl_set_recession_cone(__isl_take isl_set *set);
+__isl_give isl_basic_set *isl_set_bounded_simple_hull(__isl_take isl_set *set);
 
-struct isl_set *isl_set_union_disjoint(
-			struct isl_set *set1, struct isl_set *set2);
+__isl_give isl_set *isl_set_union_disjoint(
+	__isl_take isl_set *set1, __isl_take isl_set *set2);
 __isl_export
 __isl_give isl_set *isl_set_union(
 		__isl_take isl_set *set1,
@@ -332,7 +337,7 @@ __isl_give isl_basic_set *isl_basic_set_eliminate(
 	enum isl_dim_type type, unsigned first, unsigned n);
 __isl_give isl_set *isl_set_eliminate(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned first, unsigned n);
-struct isl_set *isl_set_eliminate_dims(struct isl_set *set,
+__isl_give isl_set *isl_set_eliminate_dims(__isl_take isl_set *set,
 		unsigned first, unsigned n);
 __isl_give isl_set *isl_set_remove_dims(__isl_take isl_set *bset,
 	enum isl_dim_type type, unsigned first, unsigned n);
@@ -372,7 +377,7 @@ isl_bool isl_set_plain_is_universe(__isl_keep isl_set *set);
 isl_bool isl_set_is_params(__isl_keep isl_set *set);
 __isl_export
 isl_bool isl_set_is_empty(__isl_keep isl_set *set);
-int isl_set_is_bounded(__isl_keep isl_set *set);
+isl_bool isl_set_is_bounded(__isl_keep isl_set *set);
 __isl_export
 isl_bool isl_set_is_subset(__isl_keep isl_set *set1, __isl_keep isl_set *set2);
 __isl_export
@@ -384,8 +389,9 @@ __isl_export
 isl_bool isl_set_is_disjoint(__isl_keep isl_set *set1,
 	__isl_keep isl_set *set2);
 isl_bool isl_set_is_singleton(__isl_keep isl_set *set);
-int isl_set_is_box(__isl_keep isl_set *set);
-int isl_set_has_equal_space(__isl_keep isl_set *set1, __isl_keep isl_set *set2);
+isl_bool isl_set_is_box(__isl_keep isl_set *set);
+isl_bool isl_set_has_equal_space(__isl_keep isl_set *set1,
+	__isl_keep isl_set *set2);
 
 __isl_give isl_set *isl_set_sum(__isl_take isl_set *set1,
 	__isl_take isl_set *set2);
@@ -393,17 +399,14 @@ __isl_give isl_basic_set *isl_basic_set_neg(__isl_take isl_basic_set *bset);
 __isl_give isl_set *isl_set_neg(__isl_take isl_set *set);
 
 __isl_give isl_set *isl_set_make_disjoint(__isl_take isl_set *set);
-struct isl_set *isl_basic_set_compute_divs(struct isl_basic_set *bset);
+__isl_give isl_set *isl_basic_set_compute_divs(__isl_take isl_basic_set *bset);
 __isl_give isl_set *isl_set_compute_divs(__isl_take isl_set *set);
+ISL_DEPRECATED
 __isl_give isl_set *isl_set_align_divs(__isl_take isl_set *set);
 
-struct isl_basic_set *isl_set_copy_basic_set(struct isl_set *set);
-struct isl_set *isl_set_drop_basic_set(struct isl_set *set,
-						struct isl_basic_set *bset);
-
 __isl_give isl_val *isl_set_plain_get_val_if_fixed(__isl_keep isl_set *set,
 	enum isl_dim_type type, unsigned pos);
-int isl_set_dim_is_bounded(__isl_keep isl_set *set,
+isl_bool isl_set_dim_is_bounded(__isl_keep isl_set *set,
 	enum isl_dim_type type, unsigned pos);
 isl_bool isl_set_dim_has_lower_bound(__isl_keep isl_set *set,
 	enum isl_dim_type type, unsigned pos);
@@ -438,8 +441,6 @@ isl_bool isl_set_plain_is_disjoint(__isl_keep isl_set *set1,
 
 uint32_t isl_set_get_hash(struct isl_set *set);
 
-int isl_set_dim_is_unique(struct isl_set *set, unsigned dim);
-
 int isl_set_n_basic_set(__isl_keep isl_set *set);
 __isl_export
 isl_stat isl_set_foreach_basic_set(__isl_keep isl_set *set,
@@ -494,6 +495,8 @@ __isl_give isl_mat *isl_basic_set_reduced_basis(__isl_keep isl_basic_set *bset);
 
 __isl_give isl_basic_set *isl_basic_set_coefficients(
 	__isl_take isl_basic_set *bset);
+__isl_give isl_basic_set_list *isl_basic_set_list_coefficients(
+	__isl_take isl_basic_set_list *list);
 __isl_give isl_basic_set *isl_set_coefficients(__isl_take isl_set *set);
 __isl_give isl_basic_set *isl_basic_set_solutions(
 	__isl_take isl_basic_set *bset);
@@ -502,6 +505,7 @@ __isl_give isl_basic_set *isl_set_solutions(__isl_take isl_set *set);
 __isl_give isl_pw_aff *isl_set_dim_max(__isl_take isl_set *set, int pos);
 __isl_give isl_pw_aff *isl_set_dim_min(__isl_take isl_set *set, int pos);
 
+__isl_give char *isl_basic_set_to_str(__isl_keep isl_basic_set *bset);
 __isl_give char *isl_set_to_str(__isl_keep isl_set *set);
 
 #if defined(__cplusplus)
diff --git a/lib/Analysis/isl/include/isl/space.h b/lib/Analysis/isl/include/isl/space.h
index c03a99e..78a1818 100644
--- a/lib/Analysis/isl/include/isl/space.h
+++ b/lib/Analysis/isl/include/isl/space.h
@@ -48,7 +48,7 @@ __isl_give isl_space *isl_space_set_tuple_name(__isl_take isl_space *dim,
 	enum isl_dim_type type, const char *s);
 isl_bool isl_space_has_tuple_name(__isl_keep isl_space *space,
 	enum isl_dim_type type);
-const char *isl_space_get_tuple_name(__isl_keep isl_space *dim,
+__isl_keep const char *isl_space_get_tuple_name(__isl_keep isl_space *dim,
 				 enum isl_dim_type type);
 __isl_give isl_space *isl_space_set_tuple_id(__isl_take isl_space *dim,
 	enum isl_dim_type type, __isl_take isl_id *id);
@@ -80,11 +80,12 @@ __isl_give isl_space *isl_space_set_dim_name(__isl_take isl_space *dim,
 __isl_keep const char *isl_space_get_dim_name(__isl_keep isl_space *dim,
 				 enum isl_dim_type type, unsigned pos);
 
+ISL_DEPRECATED
 __isl_give isl_space *isl_space_extend(__isl_take isl_space *dim,
 			unsigned nparam, unsigned n_in, unsigned n_out);
-__isl_give isl_space *isl_space_add_dims(__isl_take isl_space *dim, enum isl_dim_type type,
-		unsigned n);
-__isl_give isl_space *isl_space_move_dims(__isl_take isl_space *dim,
+__isl_give isl_space *isl_space_add_dims(__isl_take isl_space *space,
+	enum isl_dim_type type, unsigned n);
+__isl_give isl_space *isl_space_move_dims(__isl_take isl_space *space,
 	enum isl_dim_type dst_type, unsigned dst_pos,
 	enum isl_dim_type src_type, unsigned src_pos, unsigned n);
 __isl_give isl_space *isl_space_insert_dims(__isl_take isl_space *dim,
@@ -107,19 +108,21 @@ __isl_give isl_space *isl_space_range_factor_domain(
 	__isl_take isl_space *space);
 __isl_give isl_space *isl_space_range_factor_range(
 	__isl_take isl_space *space);
-__isl_give isl_space *isl_space_map_from_set(__isl_take isl_space *dim);
+__isl_give isl_space *isl_space_map_from_set(__isl_take isl_space *space);
 __isl_give isl_space *isl_space_map_from_domain_and_range(
 	__isl_take isl_space *domain, __isl_take isl_space *range);
 __isl_give isl_space *isl_space_reverse(__isl_take isl_space *dim);
 __isl_give isl_space *isl_space_drop_dims(__isl_take isl_space *dim,
 	enum isl_dim_type type, unsigned first, unsigned num);
+ISL_DEPRECATED
 __isl_give isl_space *isl_space_drop_inputs(__isl_take isl_space *dim,
 		unsigned first, unsigned n);
+ISL_DEPRECATED
 __isl_give isl_space *isl_space_drop_outputs(__isl_take isl_space *dim,
 		unsigned first, unsigned n);
-__isl_give isl_space *isl_space_domain(__isl_take isl_space *dim);
+__isl_give isl_space *isl_space_domain(__isl_take isl_space *space);
 __isl_give isl_space *isl_space_from_domain(__isl_take isl_space *dim);
-__isl_give isl_space *isl_space_range(__isl_take isl_space *dim);
+__isl_give isl_space *isl_space_range(__isl_take isl_space *space);
 __isl_give isl_space *isl_space_from_range(__isl_take isl_space *dim);
 __isl_give isl_space *isl_space_domain_map(__isl_take isl_space *space);
 __isl_give isl_space *isl_space_range_map(__isl_take isl_space *space);
@@ -132,10 +135,11 @@ __isl_give isl_space *isl_space_align_params(__isl_take isl_space *dim1,
 isl_bool isl_space_is_wrapping(__isl_keep isl_space *dim);
 isl_bool isl_space_domain_is_wrapping(__isl_keep isl_space *space);
 isl_bool isl_space_range_is_wrapping(__isl_keep isl_space *space);
+isl_bool isl_space_is_product(__isl_keep isl_space *space);
 __isl_give isl_space *isl_space_wrap(__isl_take isl_space *dim);
 __isl_give isl_space *isl_space_unwrap(__isl_take isl_space *dim);
 
-isl_bool isl_space_can_zip(__isl_keep isl_space *dim);
+isl_bool isl_space_can_zip(__isl_keep isl_space *space);
 __isl_give isl_space *isl_space_zip(__isl_take isl_space *dim);
 
 isl_bool isl_space_can_curry(__isl_keep isl_space *space);
@@ -153,16 +157,19 @@ isl_bool isl_space_is_range(__isl_keep isl_space *space1,
 	__isl_keep isl_space *space2);
 isl_bool isl_space_is_equal(__isl_keep isl_space *space1,
 	__isl_keep isl_space *space2);
+isl_bool isl_space_has_equal_params(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2);
+isl_bool isl_space_has_equal_tuples(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2);
 isl_bool isl_space_tuple_is_equal(__isl_keep isl_space *space1,
 	enum isl_dim_type type1, __isl_keep isl_space *space2,
 	enum isl_dim_type type2);
-int isl_space_match(__isl_keep isl_space *dim1, enum isl_dim_type dim1_type,
-	__isl_keep isl_space *dim2, enum isl_dim_type dim2_type);
+ISL_DEPRECATED
+isl_bool isl_space_match(__isl_keep isl_space *space1, enum isl_dim_type type1,
+	__isl_keep isl_space *space2, enum isl_dim_type type2);
 ISL_DEPRECATED
 int isl_space_tuple_match(__isl_keep isl_space *space1, enum isl_dim_type type1,
 	__isl_keep isl_space *space2, enum isl_dim_type type2);
-int isl_space_compatible(__isl_keep isl_space *dim1,
-	__isl_keep isl_space *dim2);
 unsigned isl_space_dim(__isl_keep isl_space *dim, enum isl_dim_type type);
 
 __isl_give char *isl_space_to_str(__isl_keep isl_space *space);
diff --git a/lib/Analysis/isl/include/isl/stream.h b/lib/Analysis/isl/include/isl/stream.h
index 603ae25..b0eb096 100644
--- a/lib/Analysis/isl/include/isl/stream.h
+++ b/lib/Analysis/isl/include/isl/stream.h
@@ -80,6 +80,7 @@ __isl_give isl_map *isl_stream_read_map(__isl_keep isl_stream *s);
 __isl_give isl_set *isl_stream_read_set(__isl_keep isl_stream *s);
 __isl_give isl_pw_qpolynomial *isl_stream_read_pw_qpolynomial(
 	__isl_keep isl_stream *s);
+__isl_give isl_union_set *isl_stream_read_union_set(__isl_keep isl_stream *s);
 __isl_give isl_union_map *isl_stream_read_union_map(__isl_keep isl_stream *s);
 __isl_give isl_schedule *isl_stream_read_schedule(isl_stream *s);
 
diff --git a/lib/Analysis/isl/include/isl/union_map.h b/lib/Analysis/isl/include/isl/union_map.h
index cdb89ee..a3efe6f 100644
--- a/lib/Analysis/isl/include/isl/union_map.h
+++ b/lib/Analysis/isl/include/isl/union_map.h
@@ -145,6 +145,8 @@ __isl_give isl_union_map *isl_union_map_intersect_domain(
 __isl_export
 __isl_give isl_union_map *isl_union_map_intersect_range(
 	__isl_take isl_union_map *umap, __isl_take isl_union_set *uset);
+__isl_give isl_union_map *isl_union_map_intersect_range_factor_range(
+	__isl_take isl_union_map *umap, __isl_take isl_union_map *factor);
 
 __isl_export
 __isl_give isl_union_map *isl_union_map_subtract_domain(
@@ -194,6 +196,8 @@ __isl_give isl_union_map *isl_union_set_identity(__isl_take isl_union_set *uset)
 __isl_give isl_union_map *isl_union_map_project_out(
 	__isl_take isl_union_map *umap,
 	enum isl_dim_type type, unsigned first, unsigned n);
+__isl_give isl_union_map *isl_union_map_remove_divs(
+	__isl_take isl_union_map *bmap);
 
 __isl_export
 isl_bool isl_union_map_is_empty(__isl_keep isl_union_map *umap);
@@ -224,8 +228,8 @@ int isl_union_map_n_map(__isl_keep isl_union_map *umap);
 __isl_export
 isl_stat isl_union_map_foreach_map(__isl_keep isl_union_map *umap,
 	isl_stat (*fn)(__isl_take isl_map *map, void *user), void *user);
-__isl_give int isl_union_map_contains(__isl_keep isl_union_map *umap,
-	__isl_keep isl_space *dim);
+isl_bool isl_union_map_contains(__isl_keep isl_union_map *umap,
+	__isl_keep isl_space *space);
 __isl_give isl_map *isl_union_map_extract_map(__isl_keep isl_union_map *umap,
 	__isl_take isl_space *dim);
 __isl_give isl_map *isl_map_from_union_map(__isl_take isl_union_map *umap);
diff --git a/lib/Analysis/isl/include/isl/union_set.h b/lib/Analysis/isl/include/isl/union_set.h
index b069479..ca4090b 100644
--- a/lib/Analysis/isl/include/isl/union_set.h
+++ b/lib/Analysis/isl/include/isl/union_set.h
@@ -91,6 +91,8 @@ __isl_give isl_union_set *isl_union_set_preimage_union_pw_multi_aff(
 __isl_give isl_union_set *isl_union_set_project_out(
 	__isl_take isl_union_set *uset,
 	enum isl_dim_type type, unsigned first, unsigned n);
+__isl_give isl_union_set *isl_union_set_remove_divs(
+	__isl_take isl_union_set *bset);
 
 isl_bool isl_union_set_is_params(__isl_keep isl_union_set *uset);
 __isl_export
@@ -114,8 +116,10 @@ int isl_union_set_n_set(__isl_keep isl_union_set *uset);
 __isl_export
 isl_stat isl_union_set_foreach_set(__isl_keep isl_union_set *uset,
 	isl_stat (*fn)(__isl_take isl_set *set, void *user), void *user);
-__isl_give int isl_union_set_contains(__isl_keep isl_union_set *uset,
-	__isl_keep isl_space *dim);
+__isl_give isl_basic_set_list *isl_union_set_get_basic_set_list(
+	__isl_keep isl_union_set *uset);
+isl_bool isl_union_set_contains(__isl_keep isl_union_set *uset,
+	__isl_keep isl_space *space);
 __isl_give isl_set *isl_union_set_extract_set(__isl_keep isl_union_set *uset,
 	__isl_take isl_space *dim);
 __isl_give isl_set *isl_set_from_union_set(__isl_take isl_union_set *uset);
diff --git a/lib/Analysis/isl/include/isl/val.h b/lib/Analysis/isl/include/isl/val.h
index e0a8ae5..fb50eaa 100644
--- a/lib/Analysis/isl/include/isl/val.h
+++ b/lib/Analysis/isl/include/isl/val.h
@@ -84,6 +84,7 @@ __isl_give isl_val *isl_val_mul(__isl_take isl_val *v1, __isl_take isl_val *v2);
 __isl_give isl_val *isl_val_mul_ui(__isl_take isl_val *v1, unsigned long v2);
 __isl_export
 __isl_give isl_val *isl_val_div(__isl_take isl_val *v1, __isl_take isl_val *v2);
+__isl_give isl_val *isl_val_div_ui(__isl_take isl_val *v1, unsigned long v2);
 __isl_export
 __isl_give isl_val *isl_val_mod(__isl_take isl_val *v1, __isl_take isl_val *v2);
 __isl_export
diff --git a/lib/Analysis/isl/include/isl/vec.h b/lib/Analysis/isl/include/isl/vec.h
index e73278c..6b58794 100644
--- a/lib/Analysis/isl/include/isl/vec.h
+++ b/lib/Analysis/isl/include/isl/vec.h
@@ -44,7 +44,7 @@ void isl_vec_dump(__isl_keep isl_vec *vec);
 __isl_give isl_printer *isl_printer_print_vec(__isl_take isl_printer *printer,
 	__isl_keep isl_vec *vec);
 
-struct isl_vec *isl_vec_ceil(struct isl_vec *vec);
+__isl_give isl_vec *isl_vec_ceil(__isl_take isl_vec *vec);
 struct isl_vec *isl_vec_normalize(struct isl_vec *vec);
 __isl_give isl_vec *isl_vec_set_si(__isl_take isl_vec *vec, int v);
 __isl_give isl_vec *isl_vec_set_val(__isl_take isl_vec *vec,
diff --git a/lib/Analysis/isl/include/isl/vertices.h b/lib/Analysis/isl/include/isl/vertices.h
index a10b4f3..6a7ee6a 100644
--- a/lib/Analysis/isl/include/isl/vertices.h
+++ b/lib/Analysis/isl/include/isl/vertices.h
@@ -29,7 +29,7 @@ isl_ctx *isl_vertices_get_ctx(__isl_keep isl_vertices *vertices);
 int isl_vertices_get_n_vertices(__isl_keep isl_vertices *vertices);
 isl_stat isl_vertices_foreach_vertex(__isl_keep isl_vertices *vertices,
 	isl_stat (*fn)(__isl_take isl_vertex *vertex, void *user), void *user);
-void isl_vertices_free(__isl_take isl_vertices *vertices);
+__isl_null isl_vertices *isl_vertices_free(__isl_take isl_vertices *vertices);
 
 isl_ctx *isl_cell_get_ctx(__isl_keep isl_cell *cell);
 __isl_give isl_basic_set *isl_cell_get_domain(__isl_keep isl_cell *cell);
diff --git a/lib/Analysis/isl/install-sh b/lib/Analysis/isl/install-sh
index 0b0fdcb..59990a1 100755
--- a/lib/Analysis/isl/install-sh
+++ b/lib/Analysis/isl/install-sh
@@ -1,7 +1,7 @@
 #!/bin/sh
 # install - install a program, script, or datafile
 
-scriptversion=2013-12-25.23; # UTC
+scriptversion=2014-09-12.12; # UTC
 
 # This originates from X11R5 (mit/util/scripts/install.sh), which was
 # later released in X11R6 (xc/config/util/install.sh) with the
@@ -324,34 +324,41 @@ do
             # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
             ;;
           *)
+            # $RANDOM is not portable (e.g. dash);  use it when possible to
+            # lower collision chance
             tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
-            trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
+            trap 'ret=$?; rmdir "$tmpdir/a/b" "$tmpdir/a" "$tmpdir" 2>/dev/null; exit $ret' 0
 
+            # As "mkdir -p" follows symlinks and we work in /tmp possibly;  so
+            # create the $tmpdir first (and fail if unsuccessful) to make sure
+            # that nobody tries to guess the $tmpdir name.
             if (umask $mkdir_umask &&
-                exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
+                $mkdirprog $mkdir_mode "$tmpdir" &&
+                exec $mkdirprog $mkdir_mode -p -- "$tmpdir/a/b") >/dev/null 2>&1
             then
               if test -z "$dir_arg" || {
                    # Check for POSIX incompatibilities with -m.
                    # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
                    # other-writable bit of parent directory when it shouldn't.
                    # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
-                   ls_ld_tmpdir=`ls -ld "$tmpdir"`
+                   test_tmpdir="$tmpdir/a"
+                   ls_ld_tmpdir=`ls -ld "$test_tmpdir"`
                    case $ls_ld_tmpdir in
                      d????-?r-*) different_mode=700;;
                      d????-?--*) different_mode=755;;
                      *) false;;
                    esac &&
-                   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
-                     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
+                   $mkdirprog -m$different_mode -p -- "$test_tmpdir" && {
+                     ls_ld_tmpdir_1=`ls -ld "$test_tmpdir"`
                      test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
                    }
                  }
               then posix_mkdir=:
               fi
-              rmdir "$tmpdir/d" "$tmpdir"
+              rmdir "$tmpdir/a/b" "$tmpdir/a" "$tmpdir"
             else
               # Remove any dirs left behind by ancient mkdir implementations.
-              rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
+              rmdir ./$mkdir_mode ./-p ./-- "$tmpdir" 2>/dev/null
             fi
             trap '' 0;;
         esac;;
diff --git a/lib/Analysis/isl/interface/all.h b/lib/Analysis/isl/interface/all.h
index ebd2a54..ea0b498 100644
--- a/lib/Analysis/isl/interface/all.h
+++ b/lib/Analysis/isl/interface/all.h
@@ -8,3 +8,4 @@
 #include <isl/flow.h>
 #include <isl/schedule.h>
 #include <isl/schedule_node.h>
+#include <isl/ast_build.h>
diff --git a/lib/Analysis/isl/interface/isl.h.top b/lib/Analysis/isl/interface/isl.h.top
new file mode 100644
index 0000000..37749c2
--- /dev/null
+++ b/lib/Analysis/isl/interface/isl.h.top
@@ -0,0 +1,95 @@
+/// These are automatically generated C++ bindings for isl.
+///
+/// isl is a library for computing with integer sets and maps described by
+/// Presburger formulas. On top of this, isl provides various tools for
+/// polyhedral compilation, ranging from dependence analysis over scheduling
+/// to AST generation.
+
+#ifndef ISL_CPP_NOEXCEPTIONS
+#define ISL_CPP_NOEXCEPTIONS
+
+#include <isl/aff.h>
+#include <isl/ast_build.h>
+#include <isl/flow.h>
+#include <isl/ilp.h>
+#include <isl/map.h>
+#include <isl/schedule.h>
+#include <isl/schedule_node.h>
+#include <isl/set.h>
+#include <isl/union_map.h>
+#include <isl/union_set.h>
+#include <isl/val.h>
+
+#include <functional>
+#include <string>
+
+namespace isl {
+inline namespace noexceptions {
+
+#define ISLPP_STRINGIZE_(X) #X
+#define ISLPP_STRINGIZE(X) ISLPP_STRINGIZE_(X)
+
+#define ISLPP_ASSERT(test, message)                          \
+  do {                                                       \
+    if (test)                                                \
+      break;                                                 \
+    fputs("Assertion \"" #test "\" failed at " __FILE__      \
+      ":" ISLPP_STRINGIZE(__LINE__) "\n  " message "\n",     \
+      stderr);                                               \
+  } while (0)
+
+class boolean {
+private:
+  isl_bool val;
+
+  friend isl::boolean manage(isl_bool val);
+  boolean(isl_bool val): val(val) {}
+public:
+  boolean()
+      : val(isl_bool_error) {}
+
+  /* implicit */ boolean(bool val)
+      : val(val ? isl_bool_true : isl_bool_false) {}
+
+  bool is_error() const { return val == isl_bool_error; }
+  bool is_false() const { return val == isl_bool_false; }
+  bool is_true() const { return val == isl_bool_true; }
+
+  explicit operator bool() const {
+    ISLPP_ASSERT(!is_error(), "IMPLEMENTATION ERROR: Unhandled error state");
+    return is_true();
+  }
+
+  boolean operator!() const {
+    if (is_error())
+      return *this;
+    return !is_true();
+  }
+};
+
+inline isl::boolean manage(isl_bool val) {
+  return isl::boolean(val);
+}
+
+class ctx {
+  isl_ctx *ptr;
+public:
+  /* implicit */ ctx(isl_ctx *ctx)
+      : ptr(ctx) {}
+  isl_ctx *release() {
+    auto tmp = ptr;
+    ptr = nullptr;
+    return tmp;
+  }
+  isl_ctx *get() {
+    return ptr;
+  }
+};
+
+enum class stat {
+  ok = isl_stat_ok,
+  error = isl_stat_error
+};
+
+}
+} // namespace isl
diff --git a/lib/Analysis/isl/interface/isl.py.top b/lib/Analysis/isl/interface/isl.py.top
index 6d4ae49..71c2b0d 100644
--- a/lib/Analysis/isl/interface/isl.py.top
+++ b/lib/Analysis/isl/interface/isl.py.top
@@ -17,7 +17,7 @@ class Context:
         isl.isl_ctx_free(self)
 
     def from_param(self):
-        return self.ptr
+        return c_void_p(self.ptr)
 
     @staticmethod
     def getDefaultInstance():
diff --git a/lib/Analysis/isl/isl_aff.c b/lib/Analysis/isl/isl_aff.c
index 79aed95..8b3f82b 100644
--- a/lib/Analysis/isl/isl_aff.c
+++ b/lib/Analysis/isl/isl_aff.c
@@ -401,7 +401,7 @@ __isl_give isl_aff *isl_aff_reset_space_and_domain(__isl_take isl_aff *aff,
 }
 
 /* Reorder the coefficients of the affine expression based
- * on the given reodering.
+ * on the given reordering.
  * The reordering r is assumed to have been extended with the local
  * variables.
  */
@@ -416,6 +416,8 @@ static __isl_give isl_vec *vec_reorder(__isl_take isl_vec *vec,
 
 	res = isl_vec_alloc(vec->ctx,
 			    2 + isl_space_dim(r->dim, isl_dim_all) + n_div);
+	if (!res)
+		goto error;
 	isl_seq_cpy(res->el, vec->el, 2);
 	isl_seq_clr(res->el + 2, res->size - 2);
 	for (i = 0; i < r->len; ++i)
@@ -458,11 +460,15 @@ error:
 __isl_give isl_aff *isl_aff_align_params(__isl_take isl_aff *aff,
 	__isl_take isl_space *model)
 {
+	isl_bool equal_params;
+
 	if (!aff || !model)
 		goto error;
 
-	if (!isl_space_match(aff->ls->dim, isl_dim_param,
-			     model, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(aff->ls->dim, model);
+	if (equal_params < 0)
+		goto error;
+	if (!equal_params) {
 		isl_reordering *exp;
 
 		model = isl_space_drop_dims(model, isl_dim_in,
@@ -507,26 +513,6 @@ isl_bool isl_aff_is_nan(__isl_keep isl_aff *aff)
 	return isl_seq_first_non_zero(aff->v->el, 2) < 0;
 }
 
-/* Does "pa" involve any NaNs?
- */
-isl_bool isl_pw_aff_involves_nan(__isl_keep isl_pw_aff *pa)
-{
-	int i;
-
-	if (!pa)
-		return isl_bool_error;
-	if (pa->n == 0)
-		return isl_bool_false;
-
-	for (i = 0; i < pa->n; ++i) {
-		isl_bool is_nan = isl_aff_is_nan(pa->p[i].aff);
-		if (is_nan < 0 || is_nan)
-			return is_nan;
-	}
-
-	return isl_bool_false;
-}
-
 /* Are "aff1" and "aff2" obviously equal?
  *
  * NaN is not equal to anything, not even to another NaN.
@@ -553,15 +539,15 @@ isl_bool isl_aff_plain_is_equal(__isl_keep isl_aff *aff1,
  *
  * We cannot return anything meaningful in case of a NaN.
  */
-int isl_aff_get_denominator(__isl_keep isl_aff *aff, isl_int *v)
+isl_stat isl_aff_get_denominator(__isl_keep isl_aff *aff, isl_int *v)
 {
 	if (!aff)
-		return -1;
+		return isl_stat_error;
 	if (isl_aff_is_nan(aff))
 		isl_die(isl_aff_get_ctx(aff), isl_error_invalid,
-			"cannot get denominator of NaN", return -1);
+			"cannot get denominator of NaN", return isl_stat_error);
 	isl_int_set(*v, aff->v->el[0]);
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Return the common denominator of "aff".
@@ -1288,36 +1274,6 @@ __isl_give isl_aff *isl_aff_remove_unused_divs(__isl_take isl_aff *aff)
 	return aff;
 }
 
-/* Given two affine expressions "p" of length p_len (including the
- * denominator and the constant term) and "subs" of length subs_len,
- * plug in "subs" for the variable at position "pos".
- * The variables of "subs" and "p" are assumed to match up to subs_len,
- * but "p" may have additional variables.
- * "v" is an initialized isl_int that can be used internally.
- *
- * In particular, if "p" represents the expression
- *
- *	(a i + g)/m
- *
- * with i the variable at position "pos" and "subs" represents the expression
- *
- *	f/d
- *
- * then the result represents the expression
- *
- *	(a f + d g)/(m d)
- *
- */
-void isl_seq_substitute(isl_int *p, int pos, isl_int *subs,
-	int p_len, int subs_len, isl_int v)
-{
-	isl_int_set(v, p[1 + pos]);
-	isl_int_set_si(p[1 + pos], 0);
-	isl_seq_combine(p + 1, subs[0], p + 1, v, subs + 1, subs_len - 1);
-	isl_seq_scale(p + subs_len, p + subs_len, subs[0], p_len - subs_len);
-	isl_int_mul(p[0], p[0], subs[0]);
-}
-
 /* Look for any divs in the aff->ls with a denominator equal to one
  * and plug them into the affine expression and any subsequent divs
  * that may reference the div.
@@ -1527,6 +1483,8 @@ __isl_give isl_aff *isl_aff_normalize(__isl_take isl_aff *aff)
  * create a new div d = [r/m] and return the expression q + d.
  * The coefficients in r are taken to lie between -m/2 and m/2.
  *
+ * reduce_div_coefficients performs the same normalization.
+ *
  * As a special case, floor(NaN) = NaN.
  */
 __isl_give isl_aff *isl_aff_floor(__isl_take isl_aff *aff)
@@ -2241,13 +2199,21 @@ __isl_give isl_basic_set *isl_aff_nonneg_basic_set(__isl_take isl_aff *aff)
 }
 
 /* Return a basic set containing those elements in the domain space
+ * of "aff" where it is positive.
+ */
+__isl_give isl_basic_set *isl_aff_pos_basic_set(__isl_take isl_aff *aff)
+{
+	aff = isl_aff_add_constant_num_si(aff, -1);
+	return isl_aff_nonneg_basic_set(aff);
+}
+
+/* Return a basic set containing those elements in the domain space
  * of aff where it is negative.
  */
 __isl_give isl_basic_set *isl_aff_neg_basic_set(__isl_take isl_aff *aff)
 {
 	aff = isl_aff_neg(aff);
-	aff = isl_aff_add_constant_num_si(aff, -1);
-	return isl_aff_nonneg_basic_set(aff);
+	return isl_aff_pos_basic_set(aff);
 }
 
 /* Return a basic set containing those elements in the space
@@ -2298,6 +2264,17 @@ __isl_give isl_basic_set *isl_aff_ge_basic_set(__isl_take isl_aff *aff1,
 	return isl_aff_nonneg_basic_set(aff1);
 }
 
+/* Return a basic set containing those elements in the shared domain space
+ * of "aff1" and "aff2" where "aff1" is greater than "aff2".
+ */
+__isl_give isl_basic_set *isl_aff_gt_basic_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2)
+{
+	aff1 = isl_aff_sub(aff1, aff2);
+
+	return isl_aff_pos_basic_set(aff1);
+}
+
 /* Return a set containing those elements in the shared space
  * of aff1 and aff2 where aff1 is greater than or equal to aff2.
  */
@@ -2307,6 +2284,18 @@ __isl_give isl_set *isl_aff_ge_set(__isl_take isl_aff *aff1,
 	return isl_set_from_basic_set(isl_aff_ge_basic_set(aff1, aff2));
 }
 
+/* Return a set containing those elements in the shared domain space
+ * of aff1 and aff2 where aff1 is greater than aff2.
+ *
+ * If either of the two inputs is NaN, then the result is empty,
+ * as comparisons with NaN always return false.
+ */
+__isl_give isl_set *isl_aff_gt_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2)
+{
+	return isl_set_from_basic_set(isl_aff_gt_basic_set(aff1, aff2));
+}
+
 /* Return a basic set containing those elements in the shared space
  * of aff1 and aff2 where aff1 is smaller than or equal to aff2.
  */
@@ -2316,6 +2305,15 @@ __isl_give isl_basic_set *isl_aff_le_basic_set(__isl_take isl_aff *aff1,
 	return isl_aff_ge_basic_set(aff2, aff1);
 }
 
+/* Return a basic set containing those elements in the shared domain space
+ * of "aff1" and "aff2" where "aff1" is smaller than "aff2".
+ */
+__isl_give isl_basic_set *isl_aff_lt_basic_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2)
+{
+	return isl_aff_gt_basic_set(aff2, aff1);
+}
+
 /* Return a set containing those elements in the shared space
  * of aff1 and aff2 where aff1 is smaller than or equal to aff2.
  */
@@ -2325,6 +2323,15 @@ __isl_give isl_set *isl_aff_le_set(__isl_take isl_aff *aff1,
 	return isl_aff_ge_set(aff2, aff1);
 }
 
+/* Return a set containing those elements in the shared domain space
+ * of "aff1" and "aff2" where "aff1" is smaller than "aff2".
+ */
+__isl_give isl_set *isl_aff_lt_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2)
+{
+	return isl_set_from_basic_set(isl_aff_lt_basic_set(aff1, aff2));
+}
+
 /* Return a basic set containing those elements in the shared space
  * of aff1 and aff2 where aff1 and aff2 are equal.
  */
@@ -2345,6 +2352,23 @@ __isl_give isl_set *isl_aff_eq_set(__isl_take isl_aff *aff1,
 	return isl_set_from_basic_set(isl_aff_eq_basic_set(aff1, aff2));
 }
 
+/* Return a set containing those elements in the shared domain space
+ * of aff1 and aff2 where aff1 and aff2 are not equal.
+ *
+ * If either of the two inputs is NaN, then the result is empty,
+ * as comparisons with NaN always return false.
+ */
+__isl_give isl_set *isl_aff_ne_set(__isl_take isl_aff *aff1,
+	__isl_take isl_aff *aff2)
+{
+	isl_set *set_lt, *set_gt;
+
+	set_lt = isl_aff_lt_set(isl_aff_copy(aff1),
+				isl_aff_copy(aff2));
+	set_gt = isl_aff_gt_set(aff1, aff2);
+	return isl_set_union_disjoint(set_lt, set_gt);
+}
+
 __isl_give isl_aff *isl_aff_add_on_domain(__isl_keep isl_set *dom,
 	__isl_take isl_aff *aff1, __isl_take isl_aff *aff2)
 {
@@ -2586,6 +2610,8 @@ __isl_give isl_pw_aff *isl_pw_aff_from_aff(__isl_take isl_aff *aff)
 	return isl_pw_aff_alloc(dom, aff);
 }
 
+#define isl_aff_involves_nan isl_aff_is_nan
+
 #undef PW
 #define PW isl_pw_aff
 #undef EL
@@ -2625,10 +2651,14 @@ static __isl_give isl_set *align_params_pw_pw_set_and(
 	__isl_give isl_set *(*fn)(__isl_take isl_pw_aff *pwaff1,
 				    __isl_take isl_pw_aff *pwaff2))
 {
+	isl_bool equal_params;
+
 	if (!pwaff1 || !pwaff2)
 		goto error;
-	if (isl_space_match(pwaff1->dim, isl_dim_param,
-			  pwaff2->dim, isl_dim_param))
+	equal_params = isl_space_has_equal_params(pwaff1->dim, pwaff2->dim);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return fn(pwaff1, pwaff2);
 	if (!isl_space_has_named_params(pwaff1->dim) ||
 	    !isl_space_has_named_params(pwaff2->dim))
@@ -2651,9 +2681,14 @@ static __isl_give isl_map *align_params_pw_pw_map_and(
 	__isl_give isl_map *(*fn)(__isl_take isl_pw_aff *pa1,
 				    __isl_take isl_pw_aff *pa2))
 {
+	isl_bool equal_params;
+
 	if (!pa1 || !pa2)
 		goto error;
-	if (isl_space_match(pa1->dim, isl_dim_param, pa2->dim, isl_dim_param))
+	equal_params = isl_space_has_equal_params(pa1->dim, pa2->dim);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return fn(pa1, pa2);
 	if (!isl_space_has_named_params(pa1->dim) ||
 	    !isl_space_has_named_params(pa2->dim))
@@ -2801,7 +2836,7 @@ static __isl_give isl_set *pw_aff_locus(__isl_take isl_pw_aff *pwaff,
 	for (i = 0; i < pwaff->n; ++i) {
 		isl_basic_set *bset;
 		isl_set *set_i, *locus;
-		int rational;
+		isl_bool rational;
 
 		if (isl_aff_is_nan(pwaff->p[i].aff))
 			continue;
@@ -3542,6 +3577,40 @@ error:
 	return NULL;
 }
 
+/* Does either of "pa1" or "pa2" involve any NaN2?
+ */
+static isl_bool either_involves_nan(__isl_keep isl_pw_aff *pa1,
+	__isl_keep isl_pw_aff *pa2)
+{
+	isl_bool has_nan;
+
+	has_nan = isl_pw_aff_involves_nan(pa1);
+	if (has_nan < 0 || has_nan)
+		return has_nan;
+	return isl_pw_aff_involves_nan(pa2);
+}
+
+/* Replace "pa1" and "pa2" (at least one of which involves a NaN)
+ * by a NaN on their shared domain.
+ *
+ * In principle, the result could be refined to only being NaN
+ * on the parts of this domain where at least one of "pa1" or "pa2" is NaN.
+ */
+static __isl_give isl_pw_aff *replace_by_nan(__isl_take isl_pw_aff *pa1,
+	__isl_take isl_pw_aff *pa2)
+{
+	isl_local_space *ls;
+	isl_set *dom;
+	isl_pw_aff *pa;
+
+	dom = isl_set_intersect(isl_pw_aff_domain(pa1), isl_pw_aff_domain(pa2));
+	ls = isl_local_space_from_space(isl_set_get_space(dom));
+	pa = isl_pw_aff_nan_on_domain(ls);
+	pa = isl_pw_aff_intersect_domain(pa, dom);
+
+	return pa;
+}
+
 static __isl_give isl_pw_aff *pw_aff_min(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2)
 {
@@ -3556,12 +3625,6 @@ static __isl_give isl_pw_aff *pw_aff_min(__isl_take isl_pw_aff *pwaff1,
 	return isl_pw_aff_select(le, pwaff1, dom, pwaff2);
 }
 
-__isl_give isl_pw_aff *isl_pw_aff_min(__isl_take isl_pw_aff *pwaff1,
-	__isl_take isl_pw_aff *pwaff2)
-{
-	return isl_pw_aff_align_params_pw_pw_and(pwaff1, pwaff2, &pw_aff_min);
-}
-
 static __isl_give isl_pw_aff *pw_aff_max(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2)
 {
@@ -3576,10 +3639,42 @@ static __isl_give isl_pw_aff *pw_aff_max(__isl_take isl_pw_aff *pwaff1,
 	return isl_pw_aff_select(ge, pwaff1, dom, pwaff2);
 }
 
+/* Return an expression for the minimum (if "max" is not set) or
+ * the maximum (if "max" is set) of "pa1" and "pa2".
+ * If either expression involves any NaN, then return a NaN
+ * on the shared domain as result.
+ */
+static __isl_give isl_pw_aff *pw_aff_min_max(__isl_take isl_pw_aff *pa1,
+	__isl_take isl_pw_aff *pa2, int max)
+{
+	isl_bool has_nan;
+
+	has_nan = either_involves_nan(pa1, pa2);
+	if (has_nan < 0)
+		pa1 = isl_pw_aff_free(pa1);
+	else if (has_nan)
+		return replace_by_nan(pa1, pa2);
+
+	if (max)
+		return isl_pw_aff_align_params_pw_pw_and(pa1, pa2, &pw_aff_max);
+	else
+		return isl_pw_aff_align_params_pw_pw_and(pa1, pa2, &pw_aff_min);
+}
+
+/* Return an expression for the minimum of "pwaff1" and "pwaff2".
+ */
+__isl_give isl_pw_aff *isl_pw_aff_min(__isl_take isl_pw_aff *pwaff1,
+	__isl_take isl_pw_aff *pwaff2)
+{
+	return pw_aff_min_max(pwaff1, pwaff2, 0);
+}
+
+/* Return an expression for the maximum of "pwaff1" and "pwaff2".
+ */
 __isl_give isl_pw_aff *isl_pw_aff_max(__isl_take isl_pw_aff *pwaff1,
 	__isl_take isl_pw_aff *pwaff2)
 {
-	return isl_pw_aff_align_params_pw_pw_and(pwaff1, pwaff2, &pw_aff_max);
+	return pw_aff_min_max(pwaff1, pwaff2, 1);
 }
 
 static __isl_give isl_pw_aff *pw_aff_list_reduce(
@@ -3675,39 +3770,37 @@ __isl_give isl_pw_aff_list *isl_pw_aff_list_set_rational(
 
 /* Do the parameters of "aff" match those of "space"?
  */
-int isl_aff_matching_params(__isl_keep isl_aff *aff,
+isl_bool isl_aff_matching_params(__isl_keep isl_aff *aff,
 	__isl_keep isl_space *space)
 {
 	isl_space *aff_space;
-	int match;
+	isl_bool match;
 
 	if (!aff || !space)
-		return -1;
+		return isl_bool_error;
 
 	aff_space = isl_aff_get_domain_space(aff);
 
-	match = isl_space_match(space, isl_dim_param, aff_space, isl_dim_param);
+	match = isl_space_has_equal_params(space, aff_space);
 
 	isl_space_free(aff_space);
 	return match;
 }
 
 /* Check that the domain space of "aff" matches "space".
- *
- * Return 0 on success and -1 on error.
  */
-int isl_aff_check_match_domain_space(__isl_keep isl_aff *aff,
+isl_stat isl_aff_check_match_domain_space(__isl_keep isl_aff *aff,
 	__isl_keep isl_space *space)
 {
 	isl_space *aff_space;
-	int match;
+	isl_bool match;
 
 	if (!aff || !space)
-		return -1;
+		return isl_stat_error;
 
 	aff_space = isl_aff_get_domain_space(aff);
 
-	match = isl_space_match(space, isl_dim_param, aff_space, isl_dim_param);
+	match = isl_space_has_equal_params(space, aff_space);
 	if (match < 0)
 		goto error;
 	if (!match)
@@ -3721,10 +3814,10 @@ int isl_aff_check_match_domain_space(__isl_keep isl_aff *aff,
 		isl_die(isl_aff_get_ctx(aff), isl_error_invalid,
 			"domains don't match", goto error);
 	isl_space_free(aff_space);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_space_free(aff_space);
-	return -1;
+	return isl_stat_error;
 }
 
 #undef BASE
@@ -3741,6 +3834,64 @@ error:
 
 #undef NO_DOMAIN
 
+/* Construct an isl_multi_aff living in "space" that corresponds
+ * to the affine transformation matrix "mat".
+ */
+__isl_give isl_multi_aff *isl_multi_aff_from_aff_mat(
+	__isl_take isl_space *space, __isl_take isl_mat *mat)
+{
+	isl_ctx *ctx;
+	isl_local_space *ls = NULL;
+	isl_multi_aff *ma = NULL;
+	int n_row, n_col, n_out, total;
+	int i;
+
+	if (!space || !mat)
+		goto error;
+
+	ctx = isl_mat_get_ctx(mat);
+
+	n_row = isl_mat_rows(mat);
+	n_col = isl_mat_cols(mat);
+	if (n_row < 1)
+		isl_die(ctx, isl_error_invalid,
+			"insufficient number of rows", goto error);
+	if (n_col < 1)
+		isl_die(ctx, isl_error_invalid,
+			"insufficient number of columns", goto error);
+	n_out = isl_space_dim(space, isl_dim_out);
+	total = isl_space_dim(space, isl_dim_all);
+	if (1 + n_out != n_row || 2 + total != n_row + n_col)
+		isl_die(ctx, isl_error_invalid,
+			"dimension mismatch", goto error);
+
+	ma = isl_multi_aff_zero(isl_space_copy(space));
+	ls = isl_local_space_from_space(isl_space_domain(space));
+
+	for (i = 0; i < n_row - 1; ++i) {
+		isl_vec *v;
+		isl_aff *aff;
+
+		v = isl_vec_alloc(ctx, 1 + n_col);
+		if (!v)
+			goto error;
+		isl_int_set(v->el[0], mat->row[0][0]);
+		isl_seq_cpy(v->el + 1, mat->row[1 + i], n_col);
+		v = isl_vec_normalize(v);
+		aff = isl_aff_alloc_vec(isl_local_space_copy(ls), v);
+		ma = isl_multi_aff_set_aff(ma, i, aff);
+	}
+
+	isl_local_space_free(ls);
+	isl_mat_free(mat);
+	return ma;
+error:
+	isl_local_space_free(ls);
+	isl_mat_free(mat);
+	isl_multi_aff_free(ma);
+	return NULL;
+}
+
 /* Remove any internal structure of the domain of "ma".
  * If there is any such internal structure in the input,
  * then the name of the corresponding space is also removed.
@@ -4251,6 +4402,8 @@ __isl_give isl_pw_multi_aff *isl_pw_multi_aff_product(
 /* Construct a map mapping the domain of the piecewise multi-affine expression
  * to its range, with each dimension in the range equated to the
  * corresponding affine expression on its cell.
+ *
+ * If the domain of "pma" is rational, then so is the constructed "map".
  */
 __isl_give isl_map *isl_map_from_pw_multi_aff(__isl_take isl_pw_multi_aff *pma)
 {
@@ -4263,12 +4416,16 @@ __isl_give isl_map *isl_map_from_pw_multi_aff(__isl_take isl_pw_multi_aff *pma)
 	map = isl_map_empty(isl_pw_multi_aff_get_space(pma));
 
 	for (i = 0; i < pma->n; ++i) {
+		isl_bool rational;
 		isl_multi_aff *maff;
 		isl_basic_map *bmap;
 		isl_map *map_i;
 
+		rational = isl_set_is_rational(pma->p[i].set);
+		if (rational < 0)
+			map = isl_map_free(map);
 		maff = isl_multi_aff_copy(pma->p[i].maff);
-		bmap = isl_basic_map_from_multi_aff(maff);
+		bmap = isl_basic_map_from_multi_aff2(maff, rational);
 		map_i = isl_map_from_basic_map(bmap);
 		map_i = isl_map_intersect_domain(map_i,
 						isl_set_copy(pma->p[i].set));
@@ -4641,9 +4798,11 @@ static __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_div(
 	int n;
 	int n_in;
 	isl_pw_multi_aff *pma;
-	int is_set;
+	isl_bool is_set;
 
 	is_set = isl_map_is_set(map);
+	if (is_set < 0)
+		goto error;
 
 	offset = isl_basic_map_offset(hull, isl_dim_out);
 	ctx = isl_map_get_ctx(map);
@@ -4677,6 +4836,10 @@ static __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_div(
 	pma = isl_pw_multi_aff_pullback_multi_aff(pma, ma);
 
 	return pma;
+error:
+	isl_map_free(map);
+	isl_basic_map_free(hull);
+	return NULL;
 }
 
 /* Is constraint "c" of the form
@@ -4912,9 +5075,11 @@ static __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_stride(
 	unsigned n_in;
 	unsigned o_out;
 	unsigned n_out;
-	int is_set;
+	isl_bool is_set;
 
 	is_set = isl_map_is_set(map);
+	if (is_set < 0)
+		goto error;
 
 	n_in = isl_basic_map_dim(hull, isl_dim_in);
 	n_out = isl_basic_map_dim(hull, isl_dim_out);
@@ -4960,6 +5125,10 @@ static __isl_give isl_pw_multi_aff *pw_multi_aff_from_map_stride(
 
 	isl_basic_map_free(hull);
 	return pma;
+error:
+	isl_map_free(map);
+	isl_basic_map_free(hull);
+	return NULL;
 }
 
 /* Try and create an isl_pw_multi_aff that is equivalent to the given isl_map.
@@ -6021,9 +6190,14 @@ __isl_give isl_pw_multi_aff *isl_pw_multi_aff_set_pw_aff(
 	__isl_take isl_pw_multi_aff *pma, unsigned pos,
 	__isl_take isl_pw_aff *pa)
 {
+	isl_bool equal_params;
+
 	if (!pma || !pa)
 		goto error;
-	if (isl_space_match(pma->dim, isl_dim_param, pa->dim, isl_dim_param))
+	equal_params = isl_space_has_equal_params(pma->dim, pa->dim);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return pw_multi_aff_set_pw_aff(pma, pos, pa);
 	if (!isl_space_has_named_params(pma->dim) ||
 	    !isl_space_has_named_params(pa->dim))
@@ -6040,39 +6214,37 @@ error:
 
 /* Do the parameters of "pa" match those of "space"?
  */
-int isl_pw_aff_matching_params(__isl_keep isl_pw_aff *pa,
+isl_bool isl_pw_aff_matching_params(__isl_keep isl_pw_aff *pa,
 	__isl_keep isl_space *space)
 {
 	isl_space *pa_space;
-	int match;
+	isl_bool match;
 
 	if (!pa || !space)
-		return -1;
+		return isl_bool_error;
 
 	pa_space = isl_pw_aff_get_space(pa);
 
-	match = isl_space_match(space, isl_dim_param, pa_space, isl_dim_param);
+	match = isl_space_has_equal_params(space, pa_space);
 
 	isl_space_free(pa_space);
 	return match;
 }
 
 /* Check that the domain space of "pa" matches "space".
- *
- * Return 0 on success and -1 on error.
  */
-int isl_pw_aff_check_match_domain_space(__isl_keep isl_pw_aff *pa,
+isl_stat isl_pw_aff_check_match_domain_space(__isl_keep isl_pw_aff *pa,
 	__isl_keep isl_space *space)
 {
 	isl_space *pa_space;
-	int match;
+	isl_bool match;
 
 	if (!pa || !space)
-		return -1;
+		return isl_stat_error;
 
 	pa_space = isl_pw_aff_get_space(pa);
 
-	match = isl_space_match(space, isl_dim_param, pa_space, isl_dim_param);
+	match = isl_space_has_equal_params(space, pa_space);
 	if (match < 0)
 		goto error;
 	if (!match)
@@ -6086,10 +6258,10 @@ int isl_pw_aff_check_match_domain_space(__isl_keep isl_pw_aff *pa,
 		isl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,
 			"domains don't match", goto error);
 	isl_space_free(pa_space);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_space_free(pa_space);
-	return -1;
+	return isl_stat_error;
 }
 
 #undef BASE
@@ -6110,6 +6282,7 @@ __isl_give isl_pw_multi_aff *isl_pw_multi_aff_scale_multi_val(
 	__isl_take isl_pw_multi_aff *pma, __isl_take isl_multi_val *mv)
 {
 	int i;
+	isl_bool equal_params;
 
 	pma = isl_pw_multi_aff_cow(pma);
 	if (!pma || !mv)
@@ -6118,8 +6291,10 @@ __isl_give isl_pw_multi_aff *isl_pw_multi_aff_scale_multi_val(
 					mv->space, isl_dim_set))
 		isl_die(isl_pw_multi_aff_get_ctx(pma), isl_error_invalid,
 			"spaces don't match", goto error);
-	if (!isl_space_match(pma->dim, isl_dim_param,
-					mv->space, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(pma->dim, mv->space);
+	if (equal_params < 0)
+		goto error;
+	if (!equal_params) {
 		pma = isl_pw_multi_aff_align_params(pma,
 					    isl_multi_val_get_space(mv));
 		mv = isl_multi_val_align_params(mv,
@@ -6408,25 +6583,24 @@ __isl_give isl_multi_pw_aff *isl_multi_pw_aff_from_pw_multi_aff(
  * not to be the same.  A NaN is not equal to anything, not even
  * to another NaN.
  */
-int isl_pw_aff_is_equal(__isl_keep isl_pw_aff *pa1, __isl_keep isl_pw_aff *pa2)
+isl_bool isl_pw_aff_is_equal(__isl_keep isl_pw_aff *pa1,
+	__isl_keep isl_pw_aff *pa2)
 {
-	int equal;
+	isl_bool equal;
 	isl_bool has_nan;
 	isl_map *map1, *map2;
 
 	if (!pa1 || !pa2)
-		return -1;
+		return isl_bool_error;
 
 	equal = isl_pw_aff_plain_is_equal(pa1, pa2);
 	if (equal < 0 || equal)
 		return equal;
-	has_nan = isl_pw_aff_involves_nan(pa1);
-	if (has_nan >= 0 && !has_nan)
-		has_nan = isl_pw_aff_involves_nan(pa2);
+	has_nan = either_involves_nan(pa1, pa2);
 	if (has_nan < 0)
-		return -1;
+		return isl_bool_error;
 	if (has_nan)
-		return 0;
+		return isl_bool_false;
 
 	map1 = map_from_pw_aff(isl_pw_aff_copy(pa1));
 	map2 = map_from_pw_aff(isl_pw_aff_copy(pa2));
@@ -6447,13 +6621,15 @@ isl_bool isl_multi_pw_aff_is_equal(__isl_keep isl_multi_pw_aff *mpa1,
 	__isl_keep isl_multi_pw_aff *mpa2)
 {
 	int i;
-	isl_bool equal;
+	isl_bool equal, equal_params;
 
 	if (!mpa1 || !mpa2)
 		return isl_bool_error;
 
-	if (!isl_space_match(mpa1->space, isl_dim_param,
-			     mpa2->space, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(mpa1->space, mpa2->space);
+	if (equal_params < 0)
+		return isl_bool_error;
+	if (!equal_params) {
 		if (!isl_space_has_named_params(mpa1->space))
 			return isl_bool_false;
 		if (!isl_space_has_named_params(mpa2->space))
@@ -6483,6 +6659,43 @@ isl_bool isl_multi_pw_aff_is_equal(__isl_keep isl_multi_pw_aff *mpa1,
 	return isl_bool_true;
 }
 
+/* Do "pma1" and "pma2" represent the same function?
+ *
+ * First check if they are obviously equal.
+ * If not, then convert them to maps and check if those are equal.
+ *
+ * If "pa1" or "pa2" contain any NaNs, then they are considered
+ * not to be the same.  A NaN is not equal to anything, not even
+ * to another NaN.
+ */
+isl_bool isl_pw_multi_aff_is_equal(__isl_keep isl_pw_multi_aff *pma1,
+	__isl_keep isl_pw_multi_aff *pma2)
+{
+	isl_bool equal;
+	isl_bool has_nan;
+	isl_map *map1, *map2;
+
+	if (!pma1 || !pma2)
+		return isl_bool_error;
+
+	equal = isl_pw_multi_aff_plain_is_equal(pma1, pma2);
+	if (equal < 0 || equal)
+		return equal;
+	has_nan = isl_pw_multi_aff_involves_nan(pma1);
+	if (has_nan >= 0 && !has_nan)
+		has_nan = isl_pw_multi_aff_involves_nan(pma2);
+	if (has_nan < 0 || has_nan)
+		return isl_bool_not(has_nan);
+
+	map1 = isl_map_from_pw_multi_aff(isl_pw_multi_aff_copy(pma1));
+	map2 = isl_map_from_pw_multi_aff(isl_pw_multi_aff_copy(pma2));
+	equal = isl_map_is_equal(map1, map2);
+	isl_map_free(map1);
+	isl_map_free(map2);
+
+	return equal;
+}
+
 /* Compute the pullback of "mpa" by the function represented by "ma".
  * In other words, plug in "ma" in "mpa".
  *
@@ -6527,10 +6740,14 @@ error:
 __isl_give isl_multi_pw_aff *isl_multi_pw_aff_pullback_multi_aff(
 	__isl_take isl_multi_pw_aff *mpa, __isl_take isl_multi_aff *ma)
 {
+	isl_bool equal_params;
+
 	if (!mpa || !ma)
 		goto error;
-	if (isl_space_match(mpa->space, isl_dim_param,
-			    ma->space, isl_dim_param))
+	equal_params = isl_space_has_equal_params(mpa->space, ma->space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return isl_multi_pw_aff_pullback_multi_aff_aligned(mpa, ma);
 	mpa = isl_multi_pw_aff_align_params(mpa, isl_multi_aff_get_space(ma));
 	ma = isl_multi_aff_align_params(ma, isl_multi_pw_aff_get_space(mpa));
@@ -6584,9 +6801,14 @@ error:
 __isl_give isl_multi_pw_aff *isl_multi_pw_aff_pullback_pw_multi_aff(
 	__isl_take isl_multi_pw_aff *mpa, __isl_take isl_pw_multi_aff *pma)
 {
+	isl_bool equal_params;
+
 	if (!mpa || !pma)
 		goto error;
-	if (isl_space_match(mpa->space, isl_dim_param, pma->dim, isl_dim_param))
+	equal_params = isl_space_has_equal_params(mpa->space, pma->dim);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return isl_multi_pw_aff_pullback_pw_multi_aff_aligned(mpa, pma);
 	mpa = isl_multi_pw_aff_align_params(mpa,
 					    isl_pw_multi_aff_get_space(pma));
@@ -6669,10 +6891,14 @@ static __isl_give isl_pw_aff *isl_multi_pw_aff_apply_aff_aligned(
 __isl_give isl_pw_aff *isl_multi_pw_aff_apply_aff(
 	__isl_take isl_multi_pw_aff *mpa, __isl_take isl_aff *aff)
 {
+	isl_bool equal_params;
+
 	if (!aff || !mpa)
 		goto error;
-	if (isl_space_match(aff->ls->dim, isl_dim_param,
-				mpa->space, isl_dim_param))
+	equal_params = isl_space_has_equal_params(aff->ls->dim, mpa->space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return isl_multi_pw_aff_apply_aff_aligned(mpa, aff);
 
 	aff = isl_aff_align_params(aff, isl_multi_pw_aff_get_space(mpa));
@@ -6738,9 +6964,14 @@ error:
 __isl_give isl_pw_aff *isl_multi_pw_aff_apply_pw_aff(
 	__isl_take isl_multi_pw_aff *mpa, __isl_take isl_pw_aff *pa)
 {
+	isl_bool equal_params;
+
 	if (!pa || !mpa)
 		goto error;
-	if (isl_space_match(pa->dim, isl_dim_param, mpa->space, isl_dim_param))
+	equal_params = isl_space_has_equal_params(pa->dim, mpa->space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return isl_multi_pw_aff_apply_pw_aff_aligned(mpa, pa);
 
 	pa = isl_pw_aff_align_params(pa, isl_multi_pw_aff_get_space(mpa));
@@ -6917,7 +7148,7 @@ __isl_give isl_map *isl_multi_pw_aff_eq_map(__isl_take isl_multi_pw_aff *mpa1,
  * pairwise equal.
  */
 static __isl_give isl_map *isl_multi_pw_aff_lex_map_on_space(
-	__isl_take isl_multi_pw_aff *mpa1, __isl_take isl_multi_pw_aff *mpa2,
+	__isl_keep isl_multi_pw_aff *mpa1, __isl_keep isl_multi_pw_aff *mpa2,
 	__isl_give isl_map *(*base)(__isl_take isl_pw_aff *pa1,
 		__isl_take isl_pw_aff *pa2),
 	__isl_take isl_space *space)
@@ -6962,7 +7193,7 @@ static __isl_give isl_map *isl_multi_pw_aff_lex_map_on_space(
  * pairwise equal.
  */
 __isl_give isl_map *isl_multi_pw_aff_lex_lt_map_on_space(
-	__isl_take isl_multi_pw_aff *mpa1, __isl_take isl_multi_pw_aff *mpa2,
+	__isl_keep isl_multi_pw_aff *mpa1, __isl_keep isl_multi_pw_aff *mpa2,
 	__isl_take isl_space *space)
 {
 	return isl_multi_pw_aff_lex_map_on_space(mpa1, mpa2,
@@ -6990,7 +7221,7 @@ __isl_give isl_map *isl_multi_pw_aff_lex_lt_map(
  * pairwise equal.
  */
 __isl_give isl_map *isl_multi_pw_aff_lex_gt_map_on_space(
-	__isl_take isl_multi_pw_aff *mpa1, __isl_take isl_multi_pw_aff *mpa2,
+	__isl_keep isl_multi_pw_aff *mpa1, __isl_keep isl_multi_pw_aff *mpa2,
 	__isl_take isl_space *space)
 {
 	return isl_multi_pw_aff_lex_map_on_space(mpa1, mpa2,
@@ -7233,8 +7464,6 @@ isl_union_pw_multi_aff_pullback_union_pw_multi_aff(
 
 /* Check that the domain space of "upa" matches "space".
  *
- * Return 0 on success and -1 on error.
- *
  * This function is called from isl_multi_union_pw_aff_set_union_pw_aff and
  * can in principle never fail since the space "space" is that
  * of the isl_multi_union_pw_aff and is a set space such that
@@ -7243,24 +7472,24 @@ isl_union_pw_multi_aff_pullback_union_pw_multi_aff(
  * We check the parameters and double-check that "space" is
  * indeed that of a set.
  */
-static int isl_union_pw_aff_check_match_domain_space(
+static isl_stat isl_union_pw_aff_check_match_domain_space(
 	__isl_keep isl_union_pw_aff *upa, __isl_keep isl_space *space)
 {
 	isl_space *upa_space;
-	int match;
+	isl_bool match;
 
 	if (!upa || !space)
-		return -1;
+		return isl_stat_error;
 
 	match = isl_space_is_set(space);
 	if (match < 0)
-		return -1;
+		return isl_stat_error;
 	if (!match)
 		isl_die(isl_space_get_ctx(space), isl_error_invalid,
 			"expecting set space", return -1);
 
 	upa_space = isl_union_pw_aff_get_space(upa);
-	match = isl_space_match(space, isl_dim_param, upa_space, isl_dim_param);
+	match = isl_space_has_equal_params(space, upa_space);
 	if (match < 0)
 		goto error;
 	if (!match)
@@ -7268,26 +7497,26 @@ static int isl_union_pw_aff_check_match_domain_space(
 			"parameters don't match", goto error);
 
 	isl_space_free(upa_space);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_space_free(upa_space);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Do the parameters of "upa" match those of "space"?
  */
-static int isl_union_pw_aff_matching_params(__isl_keep isl_union_pw_aff *upa,
-	__isl_keep isl_space *space)
+static isl_bool isl_union_pw_aff_matching_params(
+	__isl_keep isl_union_pw_aff *upa, __isl_keep isl_space *space)
 {
 	isl_space *upa_space;
-	int match;
+	isl_bool match;
 
 	if (!upa || !space)
-		return -1;
+		return isl_bool_error;
 
 	upa_space = isl_union_pw_aff_get_space(upa);
 
-	match = isl_space_match(space, isl_dim_param, upa_space, isl_dim_param);
+	match = isl_space_has_equal_params(space, upa_space);
 
 	isl_space_free(upa_space);
 	return match;
@@ -7329,7 +7558,7 @@ static __isl_give isl_union_pw_aff *isl_union_pw_aff_reset_domain_space(
 	__isl_take isl_union_pw_aff *upa, __isl_take isl_space *space)
 {
 	struct isl_union_pw_aff_reset_params_data data = { space };
-	int match;
+	isl_bool match;
 
 	match = isl_union_pw_aff_matching_params(upa, space);
 	if (match < 0)
@@ -8012,10 +8241,14 @@ error:
 __isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_multi_val_on_domain(
 	__isl_take isl_union_set *domain, __isl_take isl_multi_val *mv)
 {
+	isl_bool equal_params;
+
 	if (!domain || !mv)
 		goto error;
-	if (isl_space_match(domain->dim, isl_dim_param,
-			    mv->space, isl_dim_param))
+	equal_params = isl_space_has_equal_params(domain->dim, mv->space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return isl_multi_union_pw_aff_multi_val_on_domain_aligned(
 								    domain, mv);
 	domain = isl_union_set_align_params(domain,
@@ -8071,10 +8304,14 @@ error:
 __isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_multi_aff_on_domain(
 	__isl_take isl_union_set *domain, __isl_take isl_multi_aff *ma)
 {
+	isl_bool equal_params;
+
 	if (!domain || !ma)
 		goto error;
-	if (isl_space_match(domain->dim, isl_dim_param,
-			    ma->space, isl_dim_param))
+	equal_params = isl_space_has_equal_params(domain->dim, ma->space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return isl_multi_union_pw_aff_multi_aff_on_domain_aligned(
 								    domain, ma);
 	domain = isl_union_set_align_params(domain,
@@ -8679,6 +8916,7 @@ __isl_give isl_multi_pw_aff *isl_multi_union_pw_aff_extract_multi_pw_aff(
 	__isl_keep isl_multi_union_pw_aff *mupa, __isl_take isl_space *space)
 {
 	int i, n;
+	isl_bool equal_params;
 	isl_space *space_mpa = NULL;
 	isl_multi_pw_aff *mpa;
 
@@ -8686,7 +8924,10 @@ __isl_give isl_multi_pw_aff *isl_multi_union_pw_aff_extract_multi_pw_aff(
 		goto error;
 
 	space_mpa = isl_multi_union_pw_aff_get_space(mupa);
-	if (!isl_space_match(space_mpa, isl_dim_param, space, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(space_mpa, space);
+	if (equal_params < 0)
+		goto error;
+	if (!equal_params) {
 		space = isl_space_drop_dims(space, isl_dim_param,
 					0, isl_space_dim(space, isl_dim_param));
 		space = isl_space_align_params(space,
diff --git a/lib/Analysis/isl/isl_aff_private.h b/lib/Analysis/isl/isl_aff_private.h
index fc6555f..d503c41 100644
--- a/lib/Analysis/isl/isl_aff_private.h
+++ b/lib/Analysis/isl/isl_aff_private.h
@@ -107,9 +107,9 @@ __isl_give isl_pw_aff *isl_pw_aff_scale(__isl_take isl_pw_aff *pwaff,
 __isl_give isl_pw_aff *isl_pw_aff_scale_down(__isl_take isl_pw_aff *pwaff,
 	isl_int f);
 
-int isl_aff_matching_params(__isl_keep isl_aff *aff,
+isl_bool isl_aff_matching_params(__isl_keep isl_aff *aff,
 	__isl_keep isl_space *space);
-int isl_aff_check_match_domain_space(__isl_keep isl_aff *aff,
+isl_stat isl_aff_check_match_domain_space(__isl_keep isl_aff *aff,
 	__isl_keep isl_space *space);
 
 #undef BASE
@@ -125,6 +125,9 @@ __isl_give isl_multi_aff *isl_multi_aff_align_divs(
 __isl_give isl_multi_aff *isl_multi_aff_from_basic_set_equalities(
 	__isl_take isl_basic_set *bset);
 
+__isl_give isl_multi_aff *isl_multi_aff_from_aff_mat(
+	__isl_take isl_space *space, __isl_take isl_mat *mat);
+
 __isl_give isl_pw_multi_aff *isl_pw_multi_aff_reset_domain_space(
 	__isl_take isl_pw_multi_aff *pwmaff, __isl_take isl_space *space);
 __isl_give isl_pw_multi_aff *isl_pw_multi_aff_reset_space(
@@ -136,8 +139,6 @@ __isl_give isl_pw_multi_aff *isl_pw_multi_aff_project_out(
 	__isl_take isl_pw_multi_aff *pma,
 	enum isl_dim_type type, unsigned first, unsigned n);
 
-void isl_seq_substitute(isl_int *p, int pos, isl_int *subs,
-	int p_len, int subs_len, isl_int v);
 void isl_seq_preimage(isl_int *dst, isl_int *src,
 	__isl_keep isl_multi_aff *ma, int n_before, int n_after,
 	int n_div_ma, int n_div_bmap,
@@ -149,11 +150,13 @@ __isl_give isl_pw_multi_aff *isl_pw_multi_aff_substitute(
 	__isl_take isl_pw_multi_aff *pma, enum isl_dim_type type, unsigned pos,
 	__isl_keep isl_pw_aff *subs);
 
-int isl_pw_aff_matching_params(__isl_keep isl_pw_aff *pa,
+isl_bool isl_pw_aff_matching_params(__isl_keep isl_pw_aff *pa,
 	__isl_keep isl_space *space);
-int isl_pw_aff_check_match_domain_space(__isl_keep isl_pw_aff *pa,
+isl_stat isl_pw_aff_check_match_domain_space(__isl_keep isl_pw_aff *pa,
 	__isl_keep isl_space *space);
 
+__isl_give isl_basic_set *isl_aff_pos_basic_set(__isl_take isl_aff *aff);
+
 #undef BASE
 #define BASE pw_aff
 
diff --git a/lib/Analysis/isl/isl_affine_hull.c b/lib/Analysis/isl/isl_affine_hull.c
index f1214a3..a60a34c 100644
--- a/lib/Analysis/isl/isl_affine_hull.c
+++ b/lib/Analysis/isl/isl_affine_hull.c
@@ -24,8 +24,13 @@
 #include <isl_mat_private.h>
 #include <isl_vec_private.h>
 
-struct isl_basic_map *isl_basic_map_implicit_equalities(
-						struct isl_basic_map *bmap)
+#include <bset_to_bmap.c>
+#include <bset_from_bmap.c>
+#include <set_to_map.c>
+#include <set_from_map.c>
+
+__isl_give isl_basic_map *isl_basic_map_implicit_equalities(
+	__isl_take isl_basic_map *bmap)
 {
 	struct isl_tab *tab;
 
@@ -57,27 +62,8 @@ error:
 struct isl_basic_set *isl_basic_set_implicit_equalities(
 						struct isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_implicit_equalities((struct isl_basic_map*)bset);
-}
-
-struct isl_map *isl_map_implicit_equalities(struct isl_map *map)
-{
-	int i;
-
-	if (!map)
-		return map;
-
-	for (i = 0; i < map->n; ++i) {
-		map->p[i] = isl_basic_map_implicit_equalities(map->p[i]);
-		if (!map->p[i])
-			goto error;
-	}
-
-	return map;
-error:
-	isl_map_free(map);
-	return NULL;
+	return bset_from_bmap(
+		isl_basic_map_implicit_equalities(bset_to_bmap(bset)));
 }
 
 /* Make eq[row][col] of both bmaps equal so we can add the row
@@ -311,7 +297,8 @@ error:
 	return NULL;
 }
 
-struct isl_basic_set *isl_basic_set_recession_cone(struct isl_basic_set *bset)
+__isl_give isl_basic_set *isl_basic_set_recession_cone(
+	__isl_take isl_basic_set *bset)
 {
 	int i;
 
@@ -333,32 +320,6 @@ error:
 	return NULL;
 }
 
-__isl_give isl_set *isl_set_recession_cone(__isl_take isl_set *set)
-{
-	int i;
-
-	if (!set)
-		return NULL;
-	if (set->n == 0)
-		return set;
-
-	set = isl_set_remove_divs(set);
-	set = isl_set_cow(set);
-	if (!set)
-		return NULL;
-
-	for (i = 0; i < set->n; ++i) {
-		set->p[i] = isl_basic_set_recession_cone(set->p[i]);
-		if (!set->p[i])
-			goto error;
-	}
-
-	return set;
-error:
-	isl_set_free(set);
-	return NULL;
-}
-
 /* Move "sample" to a point that is one up (or down) from the original
  * point in dimension "pos".
  */
@@ -492,218 +453,6 @@ error:
 	return NULL;
 }
 
-/* Drop all constraints in bmap that involve any of the dimensions
- * first to first+n-1.
- */
-static __isl_give isl_basic_map *isl_basic_map_drop_constraints_involving(
-	__isl_take isl_basic_map *bmap, unsigned first, unsigned n)
-{
-	int i;
-
-	if (n == 0)
-		return bmap;
-
-	bmap = isl_basic_map_cow(bmap);
-
-	if (!bmap)
-		return NULL;
-
-	for (i = bmap->n_eq - 1; i >= 0; --i) {
-		if (isl_seq_first_non_zero(bmap->eq[i] + 1 + first, n) == -1)
-			continue;
-		isl_basic_map_drop_equality(bmap, i);
-	}
-
-	for (i = bmap->n_ineq - 1; i >= 0; --i) {
-		if (isl_seq_first_non_zero(bmap->ineq[i] + 1 + first, n) == -1)
-			continue;
-		isl_basic_map_drop_inequality(bmap, i);
-	}
-
-	bmap = isl_basic_map_add_known_div_constraints(bmap);
-	return bmap;
-}
-
-/* Drop all constraints in bset that involve any of the dimensions
- * first to first+n-1.
- */
-__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving(
-	__isl_take isl_basic_set *bset, unsigned first, unsigned n)
-{
-	return isl_basic_map_drop_constraints_involving(bset, first, n);
-}
-
-/* Drop all constraints in bmap that do not involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_basic_map *isl_basic_map_drop_constraints_not_involving_dims(
-	__isl_take isl_basic_map *bmap,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	int i;
-	unsigned dim;
-
-	if (n == 0) {
-		isl_space *space = isl_basic_map_get_space(bmap);
-		isl_basic_map_free(bmap);
-		return isl_basic_map_universe(space);
-	}
-	bmap = isl_basic_map_cow(bmap);
-	if (!bmap)
-		return NULL;
-
-	dim = isl_basic_map_dim(bmap, type);
-	if (first + n > dim || first + n < first)
-		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
-			"index out of bounds", return isl_basic_map_free(bmap));
-
-	first += isl_basic_map_offset(bmap, type) - 1;
-
-	for (i = bmap->n_eq - 1; i >= 0; --i) {
-		if (isl_seq_first_non_zero(bmap->eq[i] + 1 + first, n) != -1)
-			continue;
-		isl_basic_map_drop_equality(bmap, i);
-	}
-
-	for (i = bmap->n_ineq - 1; i >= 0; --i) {
-		if (isl_seq_first_non_zero(bmap->ineq[i] + 1 + first, n) != -1)
-			continue;
-		isl_basic_map_drop_inequality(bmap, i);
-	}
-
-	bmap = isl_basic_map_add_known_div_constraints(bmap);
-	return bmap;
-}
-
-/* Drop all constraints in bset that do not involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_basic_set *isl_basic_set_drop_constraints_not_involving_dims(
-	__isl_take isl_basic_set *bset,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	return isl_basic_map_drop_constraints_not_involving_dims(bset,
-							    type, first, n);
-}
-
-/* Drop all constraints in bmap that involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving_dims(
-	__isl_take isl_basic_map *bmap,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	unsigned dim;
-
-	if (!bmap)
-		return NULL;
-	if (n == 0)
-		return bmap;
-
-	dim = isl_basic_map_dim(bmap, type);
-	if (first + n > dim || first + n < first)
-		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
-			"index out of bounds", return isl_basic_map_free(bmap));
-
-	bmap = isl_basic_map_remove_divs_involving_dims(bmap, type, first, n);
-	first += isl_basic_map_offset(bmap, type) - 1;
-	return isl_basic_map_drop_constraints_involving(bmap, first, n);
-}
-
-/* Drop all constraints in bset that involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving_dims(
-	__isl_take isl_basic_set *bset,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	return isl_basic_map_drop_constraints_involving_dims(bset,
-							    type, first, n);
-}
-
-/* Drop constraints from "map" by applying "drop" to each basic map.
- */
-__isl_give isl_map *drop_constraints(__isl_take isl_map *map,
-	enum isl_dim_type type, unsigned first, unsigned n,
-	__isl_give isl_basic_map *(*drop)(__isl_take isl_basic_map *bmap,
-		enum isl_dim_type type, unsigned first, unsigned n))
-{
-	int i;
-	unsigned dim;
-
-	if (!map)
-		return NULL;
-
-	dim = isl_map_dim(map, type);
-	if (first + n > dim || first + n < first)
-		isl_die(isl_map_get_ctx(map), isl_error_invalid,
-			"index out of bounds", return isl_map_free(map));
-
-	map = isl_map_cow(map);
-	if (!map)
-		return NULL;
-
-	for (i = 0; i < map->n; ++i) {
-		map->p[i] = drop(map->p[i], type, first, n);
-		if (!map->p[i])
-			return isl_map_free(map);
-	}
-
-	if (map->n > 1)
-		ISL_F_CLR(map, ISL_MAP_DISJOINT);
-
-	return map;
-}
-
-/* Drop all constraints in map that involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_map *isl_map_drop_constraints_involving_dims(
-	__isl_take isl_map *map,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	if (n == 0)
-		return map;
-	return drop_constraints(map, type, first, n,
-				&isl_basic_map_drop_constraints_involving_dims);
-}
-
-/* Drop all constraints in "map" that do not involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_map *isl_map_drop_constraints_not_involving_dims(
-	__isl_take isl_map *map,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	if (n == 0) {
-		isl_space *space = isl_map_get_space(map);
-		isl_map_free(map);
-		return isl_map_universe(space);
-	}
-	return drop_constraints(map, type, first, n,
-			    &isl_basic_map_drop_constraints_not_involving_dims);
-}
-
-/* Drop all constraints in set that involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_set *isl_set_drop_constraints_involving_dims(
-	__isl_take isl_set *set,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	return isl_map_drop_constraints_involving_dims(set, type, first, n);
-}
-
-/* Drop all constraints in "set" that do not involve any of the dimensions
- * first to first + n - 1 of the given type.
- */
-__isl_give isl_set *isl_set_drop_constraints_not_involving_dims(
-	__isl_take isl_set *set,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	return isl_map_drop_constraints_not_involving_dims(set, type, first, n);
-}
-
 /* Construct an initial underapproximation of the hull of "bset"
  * from "sample" and any of its adjacent points that also belong to "bset".
  */
@@ -1123,8 +872,8 @@ error:
 /* Detect and make explicit all equalities satisfied by the (integer)
  * points in bmap.
  */
-struct isl_basic_map *isl_basic_map_detect_equalities(
-						struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_detect_equalities(
+	__isl_take isl_basic_map *bmap)
 {
 	int i, j;
 	struct isl_basic_set *hull = NULL;
@@ -1171,8 +920,8 @@ error:
 __isl_give isl_basic_set *isl_basic_set_detect_equalities(
 						__isl_take isl_basic_set *bset)
 {
-	return (isl_basic_set *)
-		isl_basic_map_detect_equalities((isl_basic_map *)bset);
+	return bset_from_bmap(
+		isl_basic_map_detect_equalities(bset_to_bmap(bset)));
 }
 
 __isl_give isl_map *isl_map_detect_equalities(__isl_take isl_map *map)
@@ -1183,7 +932,7 @@ __isl_give isl_map *isl_map_detect_equalities(__isl_take isl_map *map)
 
 __isl_give isl_set *isl_set_detect_equalities(__isl_take isl_set *set)
 {
-	return (isl_set *)isl_map_detect_equalities((isl_map *)set);
+	return set_from_map(isl_map_detect_equalities(set_to_map(set)));
 }
 
 /* Return the superset of "bmap" described by the equalities
@@ -1212,7 +961,8 @@ __isl_give isl_basic_set *isl_basic_set_plain_affine_hull(
  * equalities), we compute the additional equalities satisfied by
  * the integer points (if any) and add the original equalities back in.
  */
-struct isl_basic_map *isl_basic_map_affine_hull(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_affine_hull(
+	__isl_take isl_basic_map *bmap)
 {
 	bmap = isl_basic_map_detect_equalities(bmap);
 	bmap = isl_basic_map_plain_affine_hull(bmap);
@@ -1221,8 +971,7 @@ struct isl_basic_map *isl_basic_map_affine_hull(struct isl_basic_map *bmap)
 
 struct isl_basic_set *isl_basic_set_affine_hull(struct isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_affine_hull((struct isl_basic_map *)bset);
+	return bset_from_bmap(isl_basic_map_affine_hull(bset_to_bmap(bset)));
 }
 
 /* Given a rational affine matrix "M", add stride constraints to "bmap"
@@ -1436,7 +1185,7 @@ __isl_give isl_basic_map *isl_map_affine_hull(__isl_take isl_map *map)
 	map = isl_map_local_affine_hull(map);
 	map = isl_map_remove_empty_parts(map);
 	map = isl_map_remove_unknown_divs(map);
-	map = isl_map_align_divs(map);
+	map = isl_map_align_divs_internal(map);
 
 	if (!map)
 		return NULL;
@@ -1467,6 +1216,5 @@ error:
 
 struct isl_basic_set *isl_set_affine_hull(struct isl_set *set)
 {
-	return (struct isl_basic_set *)
-		isl_map_affine_hull((struct isl_map *)set);
+	return bset_from_bmap(isl_map_affine_hull(set_to_map(set)));
 }
diff --git a/lib/Analysis/isl/isl_ast.c b/lib/Analysis/isl/isl_ast.c
index c9a70da..f13f8a6 100644
--- a/lib/Analysis/isl/isl_ast.c
+++ b/lib/Analysis/isl/isl_ast.c
@@ -1403,7 +1403,7 @@ isl_stat isl_ast_node_foreach_descendant_top_down(
 
 /* Textual C representation of the various operators.
  */
-static char *op_str[] = {
+static char *op_str_c[] = {
 	[isl_ast_op_and] = "&&",
 	[isl_ast_op_and_then] = "&&",
 	[isl_ast_op_or] = "||",
@@ -1514,6 +1514,9 @@ static int is_div_mod(enum isl_ast_op_type op)
 	       op == isl_ast_op_zdiv_r;
 }
 
+static __isl_give isl_printer *print_ast_expr_c(__isl_take isl_printer *p,
+	__isl_keep isl_ast_expr *expr);
+
 /* Do we need/want parentheses around "expr" as a subexpression of
  * an "op" operation?  If "left" is set, then "expr" is the left-most
  * operand.
@@ -1554,10 +1557,10 @@ static int sub_expr_need_parens(enum isl_ast_op_type op,
 	return 0;
 }
 
-/* Print "expr" as a subexpression of an "op" operation.
+/* Print "expr" as a subexpression of an "op" operation in C format.
  * If "left" is set, then "expr" is the left-most operand.
  */
-static __isl_give isl_printer *print_sub_expr(__isl_take isl_printer *p,
+static __isl_give isl_printer *print_sub_expr_c(__isl_take isl_printer *p,
 	enum isl_ast_op_type op, __isl_keep isl_ast_expr *expr, int left)
 {
 	int need_parens;
@@ -1566,7 +1569,7 @@ static __isl_give isl_printer *print_sub_expr(__isl_take isl_printer *p,
 
 	if (need_parens)
 		p = isl_printer_print_str(p, "(");
-	p = isl_printer_print_ast_expr(p, expr);
+	p = print_ast_expr_c(p, expr);
 	if (need_parens)
 		p = isl_printer_print_str(p, ")");
 	return p;
@@ -1575,7 +1578,7 @@ static __isl_give isl_printer *print_sub_expr(__isl_take isl_printer *p,
 #define isl_ast_op_last	isl_ast_op_address_of
 
 /* Data structure that holds the user-specified textual
- * representations for the operators.
+ * representations for the operators in C format.
  * The entries are either NULL or copies of strings.
  * A NULL entry means that the default name should be used.
  */
@@ -1700,13 +1703,13 @@ __isl_give isl_printer *isl_ast_op_type_set_print_name(
 	return p;
 }
 
-/* Return the textual representation of "type".
+/* Return the textual representation of "type" in C format.
  *
  * If there is a user-specified name in an isl_ast_op_names note
  * associated to "p", then return that.
  * Otherwise, return the default name in op_str.
  */
-static const char *get_op_str(__isl_keep isl_printer *p,
+static const char *get_op_str_c(__isl_keep isl_printer *p,
 	enum isl_ast_op_type type)
 {
 	isl_id *id;
@@ -1720,76 +1723,73 @@ static const char *get_op_str(__isl_keep isl_printer *p,
 	isl_id_free(id);
 	if (names && names->op_str[type])
 		return names->op_str[type];
-	return op_str[type];
+	return op_str_c[type];
 }
 
-/* Print a min or max reduction "expr".
+/* Print a min or max reduction "expr" in C format.
  */
-static __isl_give isl_printer *print_min_max(__isl_take isl_printer *p,
+static __isl_give isl_printer *print_min_max_c(__isl_take isl_printer *p,
 	__isl_keep isl_ast_expr *expr)
 {
 	int i = 0;
 
 	for (i = 1; i < expr->u.op.n_arg; ++i) {
-		p = isl_printer_print_str(p, get_op_str(p, expr->u.op.op));
+		p = isl_printer_print_str(p, get_op_str_c(p, expr->u.op.op));
 		p = isl_printer_print_str(p, "(");
 	}
 	p = isl_printer_print_ast_expr(p, expr->u.op.args[0]);
 	for (i = 1; i < expr->u.op.n_arg; ++i) {
 		p = isl_printer_print_str(p, ", ");
-		p = isl_printer_print_ast_expr(p, expr->u.op.args[i]);
+		p = print_ast_expr_c(p, expr->u.op.args[i]);
 		p = isl_printer_print_str(p, ")");
 	}
 
 	return p;
 }
 
-/* Print a function call "expr".
+/* Print a function call "expr" in C format.
  *
  * The first argument represents the function to be called.
  */
-static __isl_give isl_printer *print_call(__isl_take isl_printer *p,
+static __isl_give isl_printer *print_call_c(__isl_take isl_printer *p,
 	__isl_keep isl_ast_expr *expr)
 {
 	int i = 0;
 
-	p = isl_printer_print_ast_expr(p, expr->u.op.args[0]);
+	p = print_ast_expr_c(p, expr->u.op.args[0]);
 	p = isl_printer_print_str(p, "(");
 	for (i = 1; i < expr->u.op.n_arg; ++i) {
 		if (i != 1)
 			p = isl_printer_print_str(p, ", ");
-		p = isl_printer_print_ast_expr(p, expr->u.op.args[i]);
+		p = print_ast_expr_c(p, expr->u.op.args[i]);
 	}
 	p = isl_printer_print_str(p, ")");
 
 	return p;
 }
 
-/* Print an array access "expr".
+/* Print an array access "expr" in C format.
  *
  * The first argument represents the array being accessed.
  */
-static __isl_give isl_printer *print_access(__isl_take isl_printer *p,
+static __isl_give isl_printer *print_access_c(__isl_take isl_printer *p,
 	__isl_keep isl_ast_expr *expr)
 {
 	int i = 0;
 
-	p = isl_printer_print_ast_expr(p, expr->u.op.args[0]);
+	p = print_ast_expr_c(p, expr->u.op.args[0]);
 	for (i = 1; i < expr->u.op.n_arg; ++i) {
 		p = isl_printer_print_str(p, "[");
-		p = isl_printer_print_ast_expr(p, expr->u.op.args[i]);
+		p = print_ast_expr_c(p, expr->u.op.args[i]);
 		p = isl_printer_print_str(p, "]");
 	}
 
 	return p;
 }
 
-/* Print "expr" to "p".
- *
- * If we are printing in isl format, then we also print an indication
- * of the size of the expression (if it was computed).
+/* Print "expr" to "p" in C format.
  */
-__isl_give isl_printer *isl_printer_print_ast_expr(__isl_take isl_printer *p,
+static __isl_give isl_printer *print_ast_expr_c(__isl_take isl_printer *p,
 	__isl_keep isl_ast_expr *expr)
 {
 	if (!p)
@@ -1800,55 +1800,55 @@ __isl_give isl_printer *isl_printer_print_ast_expr(__isl_take isl_printer *p,
 	switch (expr->type) {
 	case isl_ast_expr_op:
 		if (expr->u.op.op == isl_ast_op_call) {
-			p = print_call(p, expr);
+			p = print_call_c(p, expr);
 			break;
 		}
 		if (expr->u.op.op == isl_ast_op_access) {
-			p = print_access(p, expr);
+			p = print_access_c(p, expr);
 			break;
 		}
 		if (expr->u.op.n_arg == 1) {
 			p = isl_printer_print_str(p,
-						get_op_str(p, expr->u.op.op));
-			p = print_sub_expr(p, expr->u.op.op,
+						get_op_str_c(p, expr->u.op.op));
+			p = print_sub_expr_c(p, expr->u.op.op,
 						expr->u.op.args[0], 0);
 			break;
 		}
 		if (expr->u.op.op == isl_ast_op_fdiv_q) {
-			const char *name = get_op_str(p, isl_ast_op_fdiv_q);
+			const char *name = get_op_str_c(p, isl_ast_op_fdiv_q);
 			p = isl_printer_print_str(p, name);
 			p = isl_printer_print_str(p, "(");
-			p = isl_printer_print_ast_expr(p, expr->u.op.args[0]);
+			p = print_ast_expr_c(p, expr->u.op.args[0]);
 			p = isl_printer_print_str(p, ", ");
-			p = isl_printer_print_ast_expr(p, expr->u.op.args[1]);
+			p = print_ast_expr_c(p, expr->u.op.args[1]);
 			p = isl_printer_print_str(p, ")");
 			break;
 		}
 		if (expr->u.op.op == isl_ast_op_max ||
 		    expr->u.op.op == isl_ast_op_min) {
-			p = print_min_max(p, expr);
+			p = print_min_max_c(p, expr);
 			break;
 		}
 		if (expr->u.op.op == isl_ast_op_cond ||
 		    expr->u.op.op == isl_ast_op_select) {
-			p = isl_printer_print_ast_expr(p, expr->u.op.args[0]);
+			p = print_ast_expr_c(p, expr->u.op.args[0]);
 			p = isl_printer_print_str(p, " ? ");
-			p = isl_printer_print_ast_expr(p, expr->u.op.args[1]);
+			p = print_ast_expr_c(p, expr->u.op.args[1]);
 			p = isl_printer_print_str(p, " : ");
-			p = isl_printer_print_ast_expr(p, expr->u.op.args[2]);
+			p = print_ast_expr_c(p, expr->u.op.args[2]);
 			break;
 		}
 		if (expr->u.op.n_arg != 2)
 			isl_die(isl_printer_get_ctx(p), isl_error_internal,
 				"operation should have two arguments",
-				goto error);
-		p = print_sub_expr(p, expr->u.op.op, expr->u.op.args[0], 1);
+				return isl_printer_free(p));
+		p = print_sub_expr_c(p, expr->u.op.op, expr->u.op.args[0], 1);
 		if (expr->u.op.op != isl_ast_op_member)
 			p = isl_printer_print_str(p, " ");
-		p = isl_printer_print_str(p, get_op_str(p, expr->u.op.op));
+		p = isl_printer_print_str(p, get_op_str_c(p, expr->u.op.op));
 		if (expr->u.op.op != isl_ast_op_member)
 			p = isl_printer_print_str(p, " ");
-		p = print_sub_expr(p, expr->u.op.op, expr->u.op.args[1], 0);
+		p = print_sub_expr_c(p, expr->u.op.op, expr->u.op.args[1], 0);
 		break;
 	case isl_ast_expr_id:
 		p = isl_printer_print_str(p, isl_id_get_name(expr->u.id));
@@ -1861,67 +1861,267 @@ __isl_give isl_printer *isl_printer_print_ast_expr(__isl_take isl_printer *p,
 	}
 
 	return p;
-error:
-	isl_printer_free(p);
-	return NULL;
+}
+
+/* Textual representation of the isl_ast_op_type elements
+ * for use in a YAML representation of an isl_ast_expr.
+ */
+static char *op_str[] = {
+	[isl_ast_op_and] = "and",
+	[isl_ast_op_and_then] = "and_then",
+	[isl_ast_op_or] = "or",
+	[isl_ast_op_or_else] = "or_else",
+	[isl_ast_op_max] = "max",
+	[isl_ast_op_min] = "min",
+	[isl_ast_op_minus] = "minus",
+	[isl_ast_op_add] = "add",
+	[isl_ast_op_sub] = "sub",
+	[isl_ast_op_mul] = "mul",
+	[isl_ast_op_div] = "div",
+	[isl_ast_op_fdiv_q] = "fdiv_q",
+	[isl_ast_op_pdiv_q] = "pdiv_q",
+	[isl_ast_op_pdiv_r] = "pdiv_r",
+	[isl_ast_op_zdiv_r] = "zdiv_r",
+	[isl_ast_op_cond] = "cond",
+	[isl_ast_op_select] = "select",
+	[isl_ast_op_eq] = "eq",
+	[isl_ast_op_le] = "le",
+	[isl_ast_op_lt] = "lt",
+	[isl_ast_op_ge] = "ge",
+	[isl_ast_op_gt] = "gt",
+	[isl_ast_op_call] = "call",
+	[isl_ast_op_access] = "access",
+	[isl_ast_op_member] = "member",
+	[isl_ast_op_address_of] = "address_of"
+};
+
+static __isl_give isl_printer *print_ast_expr_isl(__isl_take isl_printer *p,
+	__isl_keep isl_ast_expr *expr);
+
+/* Print the arguments of "expr" to "p" in isl format.
+ *
+ * If there are no arguments, then nothing needs to be printed.
+ * Otherwise add an "args" key to the current mapping with as value
+ * the list of arguments of "expr".
+ */
+static __isl_give isl_printer *print_arguments(__isl_take isl_printer *p,
+	__isl_keep isl_ast_expr *expr)
+{
+	int i, n;
+
+	n = isl_ast_expr_get_op_n_arg(expr);
+	if (n < 0)
+		return isl_printer_free(p);
+	if (n == 0)
+		return p;
+
+	p = isl_printer_print_str(p, "args");
+	p = isl_printer_yaml_next(p);
+	p = isl_printer_yaml_start_sequence(p);
+	for (i = 0; i < n; ++i) {
+		isl_ast_expr *arg;
+
+		arg = isl_ast_expr_get_op_arg(expr, i);
+		p = print_ast_expr_isl(p, arg);
+		isl_ast_expr_free(arg);
+		p = isl_printer_yaml_next(p);
+	}
+	p = isl_printer_yaml_end_sequence(p);
+
+	return p;
+}
+
+/* Print "expr" to "p" in isl format.
+ *
+ * In particular, print the isl_ast_expr as a YAML document.
+ */
+static __isl_give isl_printer *print_ast_expr_isl(__isl_take isl_printer *p,
+	__isl_keep isl_ast_expr *expr)
+{
+	enum isl_ast_expr_type type;
+	enum isl_ast_op_type op;
+	isl_id *id;
+	isl_val *v;
+
+	if (!expr)
+		return isl_printer_free(p);
+
+	p = isl_printer_yaml_start_mapping(p);
+	type = isl_ast_expr_get_type(expr);
+	switch (type) {
+	case isl_ast_expr_error:
+		return isl_printer_free(p);
+	case isl_ast_expr_op:
+		op = isl_ast_expr_get_op_type(expr);
+		if (op == isl_ast_op_error)
+			return isl_printer_free(p);
+		p = isl_printer_print_str(p, "op");
+		p = isl_printer_yaml_next(p);
+		p = isl_printer_print_str(p, op_str[op]);
+		p = isl_printer_yaml_next(p);
+		p = print_arguments(p, expr);
+		break;
+	case isl_ast_expr_id:
+		p = isl_printer_print_str(p, "id");
+		p = isl_printer_yaml_next(p);
+		id = isl_ast_expr_get_id(expr);
+		p = isl_printer_print_id(p, id);
+		isl_id_free(id);
+		break;
+	case isl_ast_expr_int:
+		p = isl_printer_print_str(p, "val");
+		p = isl_printer_yaml_next(p);
+		v = isl_ast_expr_get_val(expr);
+		p = isl_printer_print_val(p, v);
+		isl_val_free(v);
+		break;
+	}
+	p = isl_printer_yaml_end_mapping(p);
+
+	return p;
+}
+
+/* Print "expr" to "p".
+ *
+ * Only an isl and a C format are supported.
+ */
+__isl_give isl_printer *isl_printer_print_ast_expr(__isl_take isl_printer *p,
+	__isl_keep isl_ast_expr *expr)
+{
+	int format;
+
+	if (!p)
+		return NULL;
+
+	format = isl_printer_get_output_format(p);
+	switch (format) {
+	case ISL_FORMAT_ISL:
+		p = print_ast_expr_isl(p, expr);
+		break;
+	case ISL_FORMAT_C:
+		p = print_ast_expr_c(p, expr);
+		break;
+	default:
+		isl_die(isl_printer_get_ctx(p), isl_error_unsupported,
+			"output format not supported for ast_expr",
+			return isl_printer_free(p));
+	}
+
+	return p;
+}
+
+static __isl_give isl_printer *print_ast_node_isl(__isl_take isl_printer *p,
+	__isl_keep isl_ast_node *node);
+
+/* Print a YAML sequence containing the entries in "list" to "p".
+ */
+static __isl_give isl_printer *print_ast_node_list(__isl_take isl_printer *p,
+	__isl_keep isl_ast_node_list *list)
+{
+	int i, n;
+
+	n = isl_ast_node_list_n_ast_node(list);
+	if (n < 0)
+		return isl_printer_free(p);
+
+	p = isl_printer_yaml_start_sequence(p);
+	for (i = 0; i < n; ++i) {
+		isl_ast_node *node;
+
+		node = isl_ast_node_list_get_ast_node(list, i);
+		p = print_ast_node_isl(p, node);
+		isl_ast_node_free(node);
+		p = isl_printer_yaml_next(p);
+	}
+	p = isl_printer_yaml_end_sequence(p);
+
+	return p;
 }
 
 /* Print "node" to "p" in "isl format".
+ *
+ * In particular, print the isl_ast_node as a YAML document.
  */
 static __isl_give isl_printer *print_ast_node_isl(__isl_take isl_printer *p,
 	__isl_keep isl_ast_node *node)
 {
-	p = isl_printer_print_str(p, "(");
 	switch (node->type) {
 	case isl_ast_node_for:
+		p = isl_printer_yaml_start_mapping(p);
+		p = isl_printer_print_str(p, "iterator");
+		p = isl_printer_yaml_next(p);
+		p = isl_printer_print_ast_expr(p, node->u.f.iterator);
+		p = isl_printer_yaml_next(p);
 		if (node->u.f.degenerate) {
+			p = isl_printer_print_str(p, "value");
+			p = isl_printer_yaml_next(p);
 			p = isl_printer_print_ast_expr(p, node->u.f.init);
+			p = isl_printer_yaml_next(p);
 		} else {
-			p = isl_printer_print_str(p, "init: ");
+			p = isl_printer_print_str(p, "init");
+			p = isl_printer_yaml_next(p);
 			p = isl_printer_print_ast_expr(p, node->u.f.init);
-			p = isl_printer_print_str(p, ", ");
-			p = isl_printer_print_str(p, "cond: ");
+			p = isl_printer_yaml_next(p);
+			p = isl_printer_print_str(p, "cond");
+			p = isl_printer_yaml_next(p);
 			p = isl_printer_print_ast_expr(p, node->u.f.cond);
-			p = isl_printer_print_str(p, ", ");
-			p = isl_printer_print_str(p, "inc: ");
+			p = isl_printer_yaml_next(p);
+			p = isl_printer_print_str(p, "inc");
+			p = isl_printer_yaml_next(p);
 			p = isl_printer_print_ast_expr(p, node->u.f.inc);
+			p = isl_printer_yaml_next(p);
 		}
 		if (node->u.f.body) {
-			p = isl_printer_print_str(p, ", ");
-			p = isl_printer_print_str(p, "body: ");
+			p = isl_printer_print_str(p, "body");
+			p = isl_printer_yaml_next(p);
 			p = isl_printer_print_ast_node(p, node->u.f.body);
+			p = isl_printer_yaml_next(p);
 		}
+		p = isl_printer_yaml_end_mapping(p);
 		break;
 	case isl_ast_node_mark:
-		p = isl_printer_print_str(p, "mark: ");
+		p = isl_printer_yaml_start_mapping(p);
+		p = isl_printer_print_str(p, "mark");
+		p = isl_printer_yaml_next(p);
 		p = isl_printer_print_id(p, node->u.m.mark);
-		p = isl_printer_print_str(p, ", ");
-		p = isl_printer_print_str(p, "node: ");
+		p = isl_printer_yaml_next(p);
+		p = isl_printer_print_str(p, "node");
+		p = isl_printer_yaml_next(p);
 		p = isl_printer_print_ast_node(p, node->u.m.node);
+		p = isl_printer_yaml_end_mapping(p);
+		break;
 	case isl_ast_node_user:
+		p = isl_printer_yaml_start_mapping(p);
+		p = isl_printer_print_str(p, "user");
+		p = isl_printer_yaml_next(p);
 		p = isl_printer_print_ast_expr(p, node->u.e.expr);
+		p = isl_printer_yaml_end_mapping(p);
 		break;
 	case isl_ast_node_if:
-		p = isl_printer_print_str(p, "guard: ");
+		p = isl_printer_yaml_start_mapping(p);
+		p = isl_printer_print_str(p, "guard");
+		p = isl_printer_yaml_next(p);
 		p = isl_printer_print_ast_expr(p, node->u.i.guard);
+		p = isl_printer_yaml_next(p);
 		if (node->u.i.then) {
-			p = isl_printer_print_str(p, ", ");
-			p = isl_printer_print_str(p, "then: ");
+			p = isl_printer_print_str(p, "then");
+			p = isl_printer_yaml_next(p);
 			p = isl_printer_print_ast_node(p, node->u.i.then);
+			p = isl_printer_yaml_next(p);
 		}
 		if (node->u.i.else_node) {
-			p = isl_printer_print_str(p, ", ");
-			p = isl_printer_print_str(p, "else: ");
+			p = isl_printer_print_str(p, "else");
+			p = isl_printer_yaml_next(p);
 			p = isl_printer_print_ast_node(p, node->u.i.else_node);
 		}
+		p = isl_printer_yaml_end_mapping(p);
 		break;
 	case isl_ast_node_block:
-		p = isl_printer_print_ast_node_list(p, node->u.b.children);
+		p = print_ast_node_list(p, node->u.b.children);
 		break;
 	case isl_ast_node_error:
 		break;
 	}
-	p = isl_printer_print_str(p, ")");
 	return p;
 }
 
@@ -2480,7 +2680,7 @@ __isl_give isl_printer *isl_ast_op_type_print_macro(
 	case isl_ast_op_min:
 		p = isl_printer_start_line(p);
 		p = isl_printer_print_str(p, "#define ");
-		p = isl_printer_print_str(p, get_op_str(p, type));
+		p = isl_printer_print_str(p, get_op_str_c(p, type));
 		p = isl_printer_print_str(p,
 			"(x,y)    ((x) < (y) ? (x) : (y))");
 		p = isl_printer_end_line(p);
@@ -2488,7 +2688,7 @@ __isl_give isl_printer *isl_ast_op_type_print_macro(
 	case isl_ast_op_max:
 		p = isl_printer_start_line(p);
 		p = isl_printer_print_str(p, "#define ");
-		p = isl_printer_print_str(p, get_op_str(p, type));
+		p = isl_printer_print_str(p, get_op_str_c(p, type));
 		p = isl_printer_print_str(p,
 			"(x,y)    ((x) > (y) ? (x) : (y))");
 		p = isl_printer_end_line(p);
@@ -2496,7 +2696,7 @@ __isl_give isl_printer *isl_ast_op_type_print_macro(
 	case isl_ast_op_fdiv_q:
 		p = isl_printer_start_line(p);
 		p = isl_printer_print_str(p, "#define ");
-		p = isl_printer_print_str(p, get_op_str(p, type));
+		p = isl_printer_print_str(p, get_op_str_c(p, type));
 		p = isl_printer_print_str(p,
 			"(n,d) "
 			"(((n)<0) ? -((-(n)+(d)-1)/(d)) : (n)/(d))");
@@ -2587,3 +2787,45 @@ __isl_give isl_printer *isl_ast_node_print_macros(
 		return isl_printer_free(p);
 	return p;
 }
+
+/* Return a string containing C code representing this isl_ast_expr.
+ */
+__isl_give char *isl_ast_expr_to_C_str(__isl_keep isl_ast_expr *expr)
+{
+	isl_printer *p;
+	char *str;
+
+	if (!expr)
+		return NULL;
+
+	p = isl_printer_to_str(isl_ast_expr_get_ctx(expr));
+	p = isl_printer_set_output_format(p, ISL_FORMAT_C);
+	p = isl_printer_print_ast_expr(p, expr);
+
+	str = isl_printer_get_str(p);
+
+	isl_printer_free(p);
+
+	return str;
+}
+
+/* Return a string containing C code representing this isl_ast_node.
+ */
+__isl_give char *isl_ast_node_to_C_str(__isl_keep isl_ast_node *node)
+{
+	isl_printer *p;
+	char *str;
+
+	if (!node)
+		return NULL;
+
+	p = isl_printer_to_str(isl_ast_node_get_ctx(node));
+	p = isl_printer_set_output_format(p, ISL_FORMAT_C);
+	p = isl_printer_print_ast_node(p, node);
+
+	str = isl_printer_get_str(p);
+
+	isl_printer_free(p);
+
+	return str;
+}
diff --git a/lib/Analysis/isl/isl_ast_build.c b/lib/Analysis/isl/isl_ast_build.c
index bc208e1..65ab6d5 100644
--- a/lib/Analysis/isl/isl_ast_build.c
+++ b/lib/Analysis/isl/isl_ast_build.c
@@ -842,7 +842,7 @@ __isl_give isl_ast_build *isl_ast_build_set_loop_bounds(
 	build = update_values(build, isl_basic_set_copy(bounds));
 	if (!build)
 		goto error;
-	set = isl_set_from_basic_set(bounds);
+	set = isl_set_from_basic_set(isl_basic_set_copy(bounds));
 	if (isl_ast_build_has_affine_value(build, build->depth)) {
 		set = isl_set_eliminate(set, isl_dim_set, build->depth, 1);
 		set = isl_set_compute_divs(set);
@@ -855,6 +855,7 @@ __isl_give isl_ast_build *isl_ast_build_set_loop_bounds(
 		if (!build)
 			goto error;
 	}
+	isl_basic_set_free(bounds);
 
 	if (!build->domain || !build->pending || !build->generated)
 		return isl_ast_build_free(build);
diff --git a/lib/Analysis/isl/isl_ast_build_expr.c b/lib/Analysis/isl/isl_ast_build_expr.c
index b2c6b24..3213886 100644
--- a/lib/Analysis/isl/isl_ast_build_expr.c
+++ b/lib/Analysis/isl/isl_ast_build_expr.c
@@ -540,7 +540,7 @@ static int extract_term_and_mod(struct isl_extract_mod_data *data,
 						isl_dim_div, data->i, 0);
 	if (s < 0)
 		data->v = isl_val_neg(data->v);
-	term = isl_aff_scale_val(data->div, isl_val_copy(data->v));
+	term = isl_aff_scale_val(term, isl_val_copy(data->v));
 
 	if (!data->add)
 		data->add = term;
@@ -1961,6 +1961,37 @@ static isl_bool single_is_subset(struct isl_from_pw_aff_data *data,
 	return subset;
 }
 
+/* Is "aff" a rational expression, i.e., does it have a denominator
+ * different from one?
+ */
+static isl_bool aff_is_rational(__isl_keep isl_aff *aff)
+{
+	isl_bool rational;
+	isl_val *den;
+
+	den = isl_aff_get_denominator_val(aff);
+	rational = isl_bool_not(isl_val_is_one(den));
+	isl_val_free(den);
+
+	return rational;
+}
+
+/* Does "list" consist of a single rational affine expression?
+ */
+static isl_bool is_single_rational_aff(__isl_keep isl_aff_list *list)
+{
+	isl_bool rational;
+	isl_aff *aff;
+
+	if (isl_aff_list_n_aff(list) != 1)
+		return isl_bool_false;
+	aff = isl_aff_list_get_aff(list, 0);
+	rational = aff_is_rational(aff);
+	isl_aff_free(aff);
+
+	return rational;
+}
+
 /* Can the list of subpieces in the last piece of "data" be extended with
  * "set" and "aff" based on "test"?
  * In particular, is it the case for each entry (set_i, aff_i) that
@@ -1974,6 +2005,11 @@ static isl_bool single_is_subset(struct isl_from_pw_aff_data *data,
  * This function is used to detect min/max expressions.
  * If the ast_build_detect_min_max option is turned off, then
  * do not even try and perform any detection and return false instead.
+ *
+ * Rational affine expressions are not considered for min/max expressions
+ * since the combined expression will be defined on the union of the domains,
+ * while a rational expression may only yield integer values
+ * on its own definition domain.
  */
 static isl_bool extends(struct isl_from_pw_aff_data *data,
 	__isl_keep isl_set *set, __isl_keep isl_aff *aff,
@@ -1981,9 +2017,16 @@ static isl_bool extends(struct isl_from_pw_aff_data *data,
 		__isl_take isl_aff *aff2))
 {
 	int i, n;
+	isl_bool is_rational;
 	isl_ctx *ctx;
 	isl_set *dom;
 
+	is_rational = aff_is_rational(aff);
+	if (is_rational >= 0 && !is_rational)
+		is_rational = is_single_rational_aff(data->p[data->n].aff_list);
+	if (is_rational < 0 || is_rational)
+		return isl_bool_not(is_rational);
+
 	ctx = isl_ast_build_get_ctx(data->build);
 	if (!isl_options_get_ast_build_detect_min_max(ctx))
 		return isl_bool_false;
diff --git a/lib/Analysis/isl/isl_bernstein.c b/lib/Analysis/isl/isl_bernstein.c
index a34a0d5..3036e8f 100644
--- a/lib/Analysis/isl/isl_bernstein.c
+++ b/lib/Analysis/isl/isl_bernstein.c
@@ -242,7 +242,8 @@ error:
  * and the constant "1 = \sum_i \alpha_i" for the homogeneous dimension.
  * Next, we extract the coefficients of the Bernstein base polynomials.
  */
-static int bernstein_coefficients_cell(__isl_take isl_cell *cell, void *user)
+static isl_stat bernstein_coefficients_cell(__isl_take isl_cell *cell,
+	void *user)
 {
 	int i, j;
 	struct bernstein_data *data = (struct bernstein_data *)user;
@@ -319,10 +320,10 @@ static int bernstein_coefficients_cell(__isl_take isl_cell *cell, void *user)
 	for (i = 0; i < 1 + nvar; ++i)
 		isl_qpolynomial_free(subs[i]);
 	free(subs);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_cell_free(cell);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Base case of applying bernstein expansion.
@@ -373,8 +374,9 @@ static __isl_give isl_pw_qpolynomial_fold *bernstein_coefficients_base(
 	data->pwf_tight = isl_pw_qpolynomial_fold_zero(dim, data->type);
 	data->poly = isl_qpolynomial_homogenize(isl_qpolynomial_copy(poly));
 	vertices = isl_basic_set_compute_vertices(bset);
-	isl_vertices_foreach_disjoint_cell(vertices,
-		&bernstein_coefficients_cell, data);
+	if (isl_vertices_foreach_disjoint_cell(vertices,
+					&bernstein_coefficients_cell, data) < 0)
+		data->pwf = isl_pw_qpolynomial_fold_free(data->pwf);
 	isl_vertices_free(vertices);
 	isl_qpolynomial_free(data->poly);
 
@@ -517,8 +519,9 @@ error:
  * bernstein expansion recursively on each dimension.
  * Otherwise, we apply bernstein expansion on the entire polytope.
  */
-int isl_qpolynomial_bound_on_domain_bernstein(__isl_take isl_basic_set *bset,
-	__isl_take isl_qpolynomial *poly, struct isl_bound *bound)
+isl_stat isl_qpolynomial_bound_on_domain_bernstein(
+	__isl_take isl_basic_set *bset, __isl_take isl_qpolynomial *poly,
+	struct isl_bound *bound)
 {
 	struct bernstein_data data;
 	isl_pw_qpolynomial_fold *pwf;
@@ -547,9 +550,9 @@ int isl_qpolynomial_bound_on_domain_bernstein(__isl_take isl_basic_set *bset,
 	else
 		bound->pwf = isl_pw_qpolynomial_fold_fold(bound->pwf, pwf);
 
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_basic_set_free(bset);
 	isl_qpolynomial_free(poly);
-	return -1;
+	return isl_stat_error;
 }
diff --git a/lib/Analysis/isl/isl_bernstein.h b/lib/Analysis/isl/isl_bernstein.h
index 7694b04..ca11df4 100644
--- a/lib/Analysis/isl/isl_bernstein.h
+++ b/lib/Analysis/isl/isl_bernstein.h
@@ -1,4 +1,5 @@
 #include <isl_bound.h>
 
-int isl_qpolynomial_bound_on_domain_bernstein(__isl_take isl_basic_set *bset,
-	__isl_take isl_qpolynomial *poly, struct isl_bound *bound);
+isl_stat isl_qpolynomial_bound_on_domain_bernstein(
+	__isl_take isl_basic_set *bset, __isl_take isl_qpolynomial *poly,
+	struct isl_bound *bound);
diff --git a/lib/Analysis/isl/isl_bound.c b/lib/Analysis/isl/isl_bound.c
index 0774d9a..d4177f4 100644
--- a/lib/Analysis/isl/isl_bound.c
+++ b/lib/Analysis/isl/isl_bound.c
@@ -23,7 +23,7 @@
  * range propagation on unbounded domains.  Otherwise, we respect the choice
  * of the user.
  */
-static int compressed_guarded_poly_bound(__isl_take isl_basic_set *bset,
+static isl_stat compressed_guarded_poly_bound(__isl_take isl_basic_set *bset,
 	__isl_take isl_qpolynomial *poly, void *user)
 {
 	struct isl_bound *bound = (struct isl_bound *)user;
@@ -48,7 +48,7 @@ error:
 	return -1;
 }
 
-static int unwrapped_guarded_poly_bound(__isl_take isl_basic_set *bset,
+static isl_stat unwrapped_guarded_poly_bound(__isl_take isl_basic_set *bset,
 	__isl_take isl_qpolynomial *poly, void *user)
 {
 	struct isl_bound *bound = (struct isl_bound *)user;
@@ -56,7 +56,7 @@ static int unwrapped_guarded_poly_bound(__isl_take isl_basic_set *bset,
 	isl_pw_qpolynomial_fold *top_pwf_tight;
 	isl_space *dim;
 	isl_morph *morph;
-	int r;
+	isl_stat r;
 
 	bset = isl_basic_set_detect_equalities(bset);
 
@@ -102,10 +102,10 @@ static int unwrapped_guarded_poly_bound(__isl_take isl_basic_set *bset,
 error:
 	isl_basic_set_free(bset);
 	isl_qpolynomial_free(poly);
-	return -1;
+	return isl_stat_error;
 }
 
-static int guarded_poly_bound(__isl_take isl_basic_set *bset,
+static isl_stat guarded_poly_bound(__isl_take isl_basic_set *bset,
 	__isl_take isl_qpolynomial *poly, void *user)
 {
 	struct isl_bound *bound = (struct isl_bound *)user;
@@ -114,7 +114,7 @@ static int guarded_poly_bound(__isl_take isl_basic_set *bset,
 	isl_pw_qpolynomial_fold *top_pwf_tight;
 	int nparam;
 	int n_in;
-	int r;
+	isl_stat r;
 
 	if (!bound->wrapping)
 		return unwrapped_guarded_poly_bound(bset, poly, user);
diff --git a/lib/Analysis/isl/isl_coalesce.c b/lib/Analysis/isl/isl_coalesce.c
index b7f2f90..476f815 100644
--- a/lib/Analysis/isl/isl_coalesce.c
+++ b/lib/Analysis/isl/isl_coalesce.c
@@ -3,7 +3,7 @@
  * Copyright 2010      INRIA Saclay
  * Copyright 2012-2013 Ecole Normale Superieure
  * Copyright 2014      INRIA Rocquencourt
- * Copyright 2016      Sven Verdoolaege
+ * Copyright 2016      INRIA Paris
  *
  * Use of this software is governed by the MIT license
  *
@@ -14,6 +14,8 @@
  * and Ecole Normale Superieure, 45 rue dUlm, 75230 Paris, France
  * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
  * B.P. 105 - 78153 Le Chesnay, France
+ * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
+ * CS 42112, 75589 Paris Cedex 12, France
  */
 
 #include <isl_ctx_private.h>
@@ -23,9 +25,14 @@
 #include "isl_tab.h"
 #include <isl_mat_private.h>
 #include <isl_local_space_private.h>
+#include <isl_val_private.h>
 #include <isl_vec_private.h>
 #include <isl_aff_private.h>
 #include <isl_equalities.h>
+#include <isl_constraint_private.h>
+
+#include <set_to_map.c>
+#include <set_from_map.c>
 
 #define STATUS_ERROR		-1
 #define STATUS_REDUNDANT	 1
@@ -52,7 +59,7 @@ static int status_in(isl_int *ineq, struct isl_tab *tab)
 /* Compute the position of the equalities of basic map "bmap_i"
  * with respect to the basic map represented by "tab_j".
  * The resulting array has twice as many entries as the number
- * of equalities corresponding to the two inequalties to which
+ * of equalities corresponding to the two inequalities to which
  * each equality corresponds.
  */
 static int *eq_status_in(__isl_keep isl_basic_map *bmap_i,
@@ -73,9 +80,6 @@ static int *eq_status_in(__isl_keep isl_basic_map *bmap_i,
 			if (eq[2 * k + l] == STATUS_ERROR)
 				goto error;
 		}
-		if (eq[2 * k] == STATUS_SEPARATE ||
-		    eq[2 * k + 1] == STATUS_SEPARATE)
-			break;
 	}
 
 	return eq;
@@ -126,6 +130,19 @@ static int any(int *con, unsigned len, int status)
 	return 0;
 }
 
+/* Return the first position of "status" in the list "con" of length "len".
+ * Return -1 if there is no such entry.
+ */
+static int find(int *con, unsigned len, int status)
+{
+	int i;
+
+	for (i = 0; i < len ; ++i)
+		if (con[i] == status)
+			return i;
+	return -1;
+}
+
 static int count(int *con, unsigned len, int status)
 {
 	int i;
@@ -414,6 +431,9 @@ static enum isl_change fuse(int i, int j, struct isl_coalesce_info *info,
 	fused = add_valid_constraints(fused, &info[j], 1 + total);
 	if (!fused)
 		goto error;
+	if (ISL_F_ISSET(info[i].bmap, ISL_BASIC_MAP_RATIONAL) &&
+	    ISL_F_ISSET(info[j].bmap, ISL_BASIC_MAP_RATIONAL))
+		ISL_F_SET(fused, ISL_BASIC_MAP_RATIONAL);
 
 	for (k = 0; k < info[i].bmap->n_div; ++k) {
 		int l = isl_basic_map_alloc_div(fused);
@@ -444,9 +464,6 @@ static enum isl_change fuse(int i, int j, struct isl_coalesce_info *info,
 		info[i].simplify = 0;
 	}
 	fused = isl_basic_map_finalize(fused);
-	if (ISL_F_ISSET(info[i].bmap, ISL_BASIC_MAP_RATIONAL) &&
-	    ISL_F_ISSET(info[j].bmap, ISL_BASIC_MAP_RATIONAL))
-		ISL_F_SET(fused, ISL_BASIC_MAP_RATIONAL);
 
 	fused_tab = isl_tab_from_basic_map(fused, 0);
 	if (isl_tab_detect_redundant(fused_tab) < 0)
@@ -548,7 +565,7 @@ static enum isl_change check_facets(int i, int j,
  * (as an inequality) and its negation.  Make sure the
  * equality is returned to its original state before returning.
  */
-static int contains(struct isl_coalesce_info *info, struct isl_tab *tab)
+static isl_bool contains(struct isl_coalesce_info *info, struct isl_tab *tab)
 {
 	int k;
 	unsigned dim;
@@ -561,14 +578,14 @@ static int contains(struct isl_coalesce_info *info, struct isl_tab *tab)
 		stat = status_in(bmap->eq[k], tab);
 		isl_seq_neg(bmap->eq[k], bmap->eq[k], 1 + dim);
 		if (stat < 0)
-			return -1;
+			return isl_bool_error;
 		if (stat != STATUS_VALID)
-			return 0;
+			return isl_bool_false;
 		stat = status_in(bmap->eq[k], tab);
 		if (stat < 0)
-			return -1;
+			return isl_bool_error;
 		if (stat != STATUS_VALID)
-			return 0;
+			return isl_bool_false;
 	}
 
 	for (k = 0; k < bmap->n_ineq; ++k) {
@@ -577,11 +594,11 @@ static int contains(struct isl_coalesce_info *info, struct isl_tab *tab)
 			continue;
 		stat = status_in(bmap->ineq[k], tab);
 		if (stat < 0)
-			return -1;
+			return isl_bool_error;
 		if (stat != STATUS_VALID)
-			return 0;
+			return isl_bool_false;
 	}
-	return 1;
+	return isl_bool_true;
 }
 
 /* Basic map "i" has an inequality (say "k") that is adjacent
@@ -597,8 +614,11 @@ static int contains(struct isl_coalesce_info *info, struct isl_tab *tab)
  * In particular, we replace constraint k, say f >= 0, by constraint
  * f <= -1, add the inequalities of "j" that are valid for "i"
  * and check if the result is a subset of basic map "j".
- * If so, then we know that this result is exactly equal to basic map "j"
- * since all its constraints are valid for basic map "j".
+ * To improve the chances of the subset relation being detected,
+ * any variable that only attains a single integer value
+ * in the tableau of "i" is first fixed to that value.
+ * If the result is a subset, then we know that this result is exactly equal
+ * to basic map "j" since all its constraints are valid for basic map "j".
  * By combining the valid constraints of "i" (all equalities and all
  * inequalities except "k") and the valid constraints of "j" we therefore
  * obtain a basic map that is equal to their union.
@@ -628,16 +648,14 @@ static enum isl_change is_adj_ineq_extension(int i, int j,
 	struct isl_tab_undo *snap;
 	unsigned n_eq = info[i].bmap->n_eq;
 	unsigned total = isl_basic_map_total_dim(info[i].bmap);
-	int r;
-	int super;
+	isl_stat r;
+	isl_bool super;
 
 	if (isl_tab_extend_cons(info[i].tab, 1 + info[j].bmap->n_ineq) < 0)
 		return isl_change_error;
 
-	for (k = 0; k < info[i].bmap->n_ineq; ++k)
-		if (info[i].ineq[k] == STATUS_ADJ_INEQ)
-			break;
-	if (k >= info[i].bmap->n_ineq)
+	k = find(info[i].ineq, info[i].bmap->n_ineq, STATUS_ADJ_INEQ);
+	if (k < 0)
 		isl_die(isl_basic_map_get_ctx(info[i].bmap), isl_error_internal,
 			"info[i].ineq should have exactly one STATUS_ADJ_INEQ",
 			return isl_change_error);
@@ -661,6 +679,8 @@ static enum isl_change is_adj_ineq_extension(int i, int j,
 		if (isl_tab_add_ineq(info[i].tab, info[j].bmap->ineq[k]) < 0)
 			return isl_change_error;
 	}
+	if (isl_tab_detect_constants(info[i].tab) < 0)
+		return isl_change_error;
 
 	super = contains(&info[j], info[i].tab);
 	if (super < 0)
@@ -774,8 +794,8 @@ static int not_unique_unit_row(__isl_keep isl_mat *T, int row)
  * "total" is the total number of variables, i.e., the number
  * of entries in "affected".
  */
-static int is_affected(__isl_keep isl_basic_map *bmap, int ineq, int *affected,
-	int total)
+static isl_bool is_affected(__isl_keep isl_basic_map *bmap, int ineq,
+	int *affected, int total)
 {
 	int i;
 
@@ -783,10 +803,10 @@ static int is_affected(__isl_keep isl_basic_map *bmap, int ineq, int *affected,
 		if (!affected[i])
 			continue;
 		if (!isl_int_is_zero(bmap->ineq[ineq][1 + i]))
-			return 1;
+			return isl_bool_true;
 	}
 
-	return 0;
+	return isl_bool_false;
 }
 
 /* Given the compressed version of inequality constraint "ineq"
@@ -813,7 +833,7 @@ static __isl_give isl_vec *try_tightening(struct isl_coalesce_info *info,
 	int ineq, __isl_take isl_vec *v)
 {
 	isl_ctx *ctx;
-	int r;
+	isl_stat r;
 
 	if (!v)
 		return NULL;
@@ -848,13 +868,17 @@ static __isl_give isl_vec *try_tightening(struct isl_coalesce_info *info,
 	return v;
 }
 
-/* Tighten the constraints on the facet represented by info->tab.
+/* Tighten the (non-redundant) constraints on the facet represented
+ * by info->tab.
  * In particular, on input, info->tab represents the result
- * of replacing constraint k of info->bmap, i.e., f_k >= 0,
- * by the adjacent equality, i.e., f_k + 1 = 0.
+ * of relaxing the "n" inequality constraints of info->bmap in "relaxed"
+ * by one, i.e., replacing f_i >= 0 by f_i + 1 >= 0, and then
+ * replacing the one at index "l" by the corresponding equality,
+ * i.e., f_k + 1 = 0, with k = relaxed[l].
  *
  * Compute a variable compression from the equality constraint f_k + 1 = 0
- * and use it to tighten the other constraints of info->bmap,
+ * and use it to tighten the other constraints of info->bmap
+ * (that is, all constraints that have not been relaxed),
  * updating info->tab (and leaving info->bmap untouched).
  * The compression handles essentially two cases, one where a variable
  * is assigned a fixed value and can therefore be eliminated, and one
@@ -873,17 +897,26 @@ static __isl_give isl_vec *try_tightening(struct isl_coalesce_info *info,
  * considered.  In particular, if the constraint only involves variables
  * that are directly mapped to a distinct set of other variables, then
  * no common divisor can be introduced and no tightening can occur.
+ *
+ * It is important to only consider the non-redundant constraints
+ * since the facet constraint has been relaxed prior to the call
+ * to this function, meaning that the constraints that were redundant
+ * prior to the relaxation may no longer be redundant.
+ * These constraints will be ignored in the fused result, so
+ * the fusion detection should not exploit them.
  */
 static isl_stat tighten_on_relaxed_facet(struct isl_coalesce_info *info,
-	int k)
+	int n, int *relaxed, int l)
 {
 	unsigned total;
 	isl_ctx *ctx;
 	isl_vec *v = NULL;
 	isl_mat *T;
 	int i;
+	int k;
 	int *affected;
 
+	k = relaxed[l];
 	ctx = isl_basic_map_get_ctx(info->bmap);
 	total = isl_basic_map_total_dim(info->bmap);
 	isl_int_add_ui(info->bmap->ineq[k][0], info->bmap->ineq[k][0], 1);
@@ -905,9 +938,15 @@ static isl_stat tighten_on_relaxed_facet(struct isl_coalesce_info *info,
 		affected[i] = not_unique_unit_row(T, 1 + i);
 
 	for (i = 0; i < info->bmap->n_ineq; ++i) {
-		if (i == k)
+		isl_bool handle;
+		if (any(relaxed, n, i))
+			continue;
+		if (info->ineq[i] == STATUS_REDUNDANT)
 			continue;
-		if (!is_affected(info->bmap, i, affected, total))
+		handle = is_affected(info->bmap, i, affected, total);
+		if (handle < 0)
+			goto error;
+		if (!handle)
 			continue;
 		v = isl_vec_alloc(ctx, 1 + total);
 		if (!v)
@@ -929,81 +968,131 @@ error:
 	return isl_stat_error;
 }
 
-/* Basic map "i" has an inequality "k" that is adjacent to some equality
- * of basic map "j".  All the other inequalities are valid for "j".
+/* Replace the basic maps "i" and "j" by an extension of "i"
+ * along the "n" inequality constraints in "relax" by one.
+ * The tableau info[i].tab has already been extended.
+ * Extend info[i].bmap accordingly by relaxing all constraints in "relax"
+ * by one.
+ * Each integer division that does not have exactly the same
+ * definition in "i" and "j" is marked unknown and the basic map
+ * is scheduled to be simplified in an attempt to recover
+ * the integer division definition.
+ * Place the extension in the position that is the smallest of i and j.
+ */
+static enum isl_change extend(int i, int j, int n, int *relax,
+	struct isl_coalesce_info *info)
+{
+	int l;
+	unsigned total;
+
+	info[i].bmap = isl_basic_map_cow(info[i].bmap);
+	if (!info[i].bmap)
+		return isl_change_error;
+	total = isl_basic_map_total_dim(info[i].bmap);
+	for (l = 0; l < info[i].bmap->n_div; ++l)
+		if (!isl_seq_eq(info[i].bmap->div[l],
+				info[j].bmap->div[l], 1 + 1 + total)) {
+			isl_int_set_si(info[i].bmap->div[l][0], 0);
+			info[i].simplify = 1;
+		}
+	for (l = 0; l < n; ++l)
+		isl_int_add_ui(info[i].bmap->ineq[relax[l]][0],
+				info[i].bmap->ineq[relax[l]][0], 1);
+	ISL_F_SET(info[i].bmap, ISL_BASIC_MAP_FINAL);
+	drop(&info[j]);
+	if (j < i)
+		exchange(&info[i], &info[j]);
+	return isl_change_fuse;
+}
+
+/* Basic map "i" has "n" inequality constraints (collected in "relax")
+ * that are such that they include basic map "j" if they are relaxed
+ * by one.  All the other inequalities are valid for "j".
  * Check if basic map "j" forms an extension of basic map "i".
  *
- * In particular, we relax constraint "k", compute the corresponding
- * facet and check whether it is included in the other basic map.
- * Before testing for inclusion, the constraints on the facet
+ * In particular, relax the constraints in "relax", compute the corresponding
+ * facets one by one and check whether each of these is included
+ * in the other basic map.
+ * Before testing for inclusion, the constraints on each facet
  * are tightened to increase the chance of an inclusion being detected.
- * If the facet is included, we know that relaxing the constraint extends
+ * (Adding the valid constraints of "j" to the tableau of "i", as is done
+ * in is_adj_ineq_extension, may further increase those chances, but this
+ * is not currently done.)
+ * If each facet is included, we know that relaxing the constraints extends
  * the basic map with exactly the other basic map (we already know that this
- * other basic map is included in the extension, because there
- * were no "cut" inequalities in "i") and we can replace the
+ * other basic map is included in the extension, because all other
+ * inequality constraints are valid of "j") and we can replace the
  * two basic maps by this extension.
- * Each integer division that does not have exactly the same
- * definition in "i" and "j" is marked unknown and the basic map
- * is scheduled to be simplified in an attempt to recover
- * the integer division definition.
- * Place this extension in the position that is the smallest of i and j.
+ *
+ * If any of the relaxed constraints turn out to be redundant, then bail out.
+ * isl_tab_select_facet refuses to handle such constraints.  It may be
+ * possible to handle them anyway by making a distinction between
+ * redundant constraints with a corresponding facet that still intersects
+ * the set (allowing isl_tab_select_facet to handle them) and
+ * those where the facet does not intersect the set (which can be ignored
+ * because the empty facet is trivially included in the other disjunct).
+ * However, relaxed constraints that turn out to be redundant should
+ * be fairly rare and no such instance has been reported where
+ * coalescing would be successful.
  *        ____			  _____
  *       /    || 		 /     |
  *      /     ||  		/      |
  *      \     ||   	=>	\      |
  *       \    ||		 \     |
  *        \___||		  \____|
+ *
+ *
+ *	 \			|\
+ *	|\\			| \
+ *	| \\			|  \
+ *	|  |		=>	|  /
+ *	| /			| /
+ *	|/			|/
  */
-static enum isl_change is_adj_eq_extension(int i, int j, int k,
+static enum isl_change is_relaxed_extension(int i, int j, int n, int *relax,
 	struct isl_coalesce_info *info)
 {
-	int change = isl_change_none;
-	int super;
+	int l;
+	isl_bool super;
 	struct isl_tab_undo *snap, *snap2;
 	unsigned n_eq = info[i].bmap->n_eq;
 
-	if (isl_tab_is_equality(info[i].tab, n_eq + k))
-		return isl_change_none;
+	for (l = 0; l < n; ++l)
+		if (isl_tab_is_equality(info[i].tab, n_eq + relax[l]))
+			return isl_change_none;
 
 	snap = isl_tab_snap(info[i].tab);
-	if (isl_tab_relax(info[i].tab, n_eq + k) < 0)
-		return isl_change_error;
+	for (l = 0; l < n; ++l)
+		if (isl_tab_relax(info[i].tab, n_eq + relax[l]) < 0)
+			return isl_change_error;
+	for (l = 0; l < n; ++l) {
+		if (!isl_tab_is_redundant(info[i].tab, n_eq + relax[l]))
+			continue;
+		if (isl_tab_rollback(info[i].tab, snap) < 0)
+			return isl_change_error;
+		return isl_change_none;
+	}
 	snap2 = isl_tab_snap(info[i].tab);
-	if (isl_tab_select_facet(info[i].tab, n_eq + k) < 0)
-		return isl_change_error;
-	if (tighten_on_relaxed_facet(&info[i], k) < 0)
-		return isl_change_error;
-	super = contains(&info[j], info[i].tab);
-	if (super < 0)
-		return isl_change_error;
-	if (super) {
-		int l;
-		unsigned total;
-
+	for (l = 0; l < n; ++l) {
 		if (isl_tab_rollback(info[i].tab, snap2) < 0)
 			return isl_change_error;
-		info[i].bmap = isl_basic_map_cow(info[i].bmap);
-		if (!info[i].bmap)
+		if (isl_tab_select_facet(info[i].tab, n_eq + relax[l]) < 0)
 			return isl_change_error;
-		total = isl_basic_map_total_dim(info[i].bmap);
-		for (l = 0; l < info[i].bmap->n_div; ++l)
-			if (!isl_seq_eq(info[i].bmap->div[l],
-					info[j].bmap->div[l], 1 + 1 + total)) {
-				isl_int_set_si(info[i].bmap->div[l][0], 0);
-				info[i].simplify = 1;
-			}
-		isl_int_add_ui(info[i].bmap->ineq[k][0],
-				info[i].bmap->ineq[k][0], 1);
-		ISL_F_SET(info[i].bmap, ISL_BASIC_MAP_FINAL);
-		drop(&info[j]);
-		if (j < i)
-			exchange(&info[i], &info[j]);
-		change = isl_change_fuse;
-	} else
+		if (tighten_on_relaxed_facet(&info[i], n, relax, l) < 0)
+			return isl_change_error;
+		super = contains(&info[j], info[i].tab);
+		if (super < 0)
+			return isl_change_error;
+		if (super)
+			continue;
 		if (isl_tab_rollback(info[i].tab, snap) < 0)
 			return isl_change_error;
+		return isl_change_none;
+	}
 
-	return change;
+	if (isl_tab_rollback(info[i].tab, snap2) < 0)
+		return isl_change_error;
+	return extend(i, j, n, relax, info);
 }
 
 /* Data structure that keeps track of the wrapping constraints
@@ -1023,7 +1112,7 @@ struct isl_wraps {
  * in the equalities and inequalities of info->bmap that can be removed
  * if we end up applying wrapping.
  */
-static void wraps_update_max(struct isl_wraps *wraps,
+static isl_stat wraps_update_max(struct isl_wraps *wraps,
 	struct isl_coalesce_info *info)
 {
 	int k;
@@ -1051,6 +1140,8 @@ static void wraps_update_max(struct isl_wraps *wraps,
 	}
 
 	isl_int_clear(max_k);
+
+	return isl_stat_ok;
 }
 
 /* Initialize the isl_wraps data structure.
@@ -1059,7 +1150,7 @@ static void wraps_update_max(struct isl_wraps *wraps,
  * in the equalities and inequalities that can be removed if we end up
  * applying wrapping.
  */
-static void wraps_init(struct isl_wraps *wraps, __isl_take isl_mat *mat,
+static isl_stat wraps_init(struct isl_wraps *wraps, __isl_take isl_mat *mat,
 	struct isl_coalesce_info *info, int i, int j)
 {
 	isl_ctx *ctx;
@@ -1067,15 +1158,19 @@ static void wraps_init(struct isl_wraps *wraps, __isl_take isl_mat *mat,
 	wraps->bound = 0;
 	wraps->mat = mat;
 	if (!mat)
-		return;
+		return isl_stat_error;
 	ctx = isl_mat_get_ctx(mat);
 	wraps->bound = isl_options_get_coalesce_bounded_wrapping(ctx);
 	if (!wraps->bound)
-		return;
+		return isl_stat_ok;
 	isl_int_init(wraps->max);
 	isl_int_set_si(wraps->max, 0);
-	wraps_update_max(wraps, &info[i]);
-	wraps_update_max(wraps, &info[j]);
+	if (wraps_update_max(wraps, &info[i]) < 0)
+		return isl_stat_error;
+	if (wraps_update_max(wraps, &info[j]) < 0)
+		return isl_stat_error;
+
+	return isl_stat_ok;
 }
 
 /* Free the contents of the isl_wraps data structure.
@@ -1151,8 +1246,8 @@ static int add_wrap(struct isl_wraps *wraps, int w, isl_int *bound,
  * constraints and a newly added wrapping constraint does not
  * satisfy the bound, then wraps->n_row is also reset to zero.
  */
-static int add_wraps(struct isl_wraps *wraps, struct isl_coalesce_info *info,
-	isl_int *bound, __isl_keep isl_set *set)
+static isl_stat add_wraps(struct isl_wraps *wraps,
+	struct isl_coalesce_info *info, isl_int *bound, __isl_keep isl_set *set)
 {
 	int l, m;
 	int w;
@@ -1175,7 +1270,7 @@ static int add_wraps(struct isl_wraps *wraps, struct isl_coalesce_info *info,
 
 		added = add_wrap(wraps, w, bound, bmap->ineq[l], len, set, 0);
 		if (added < 0)
-			return -1;
+			return isl_stat_error;
 		if (!added)
 			goto unbounded;
 		++w;
@@ -1192,7 +1287,7 @@ static int add_wraps(struct isl_wraps *wraps, struct isl_coalesce_info *info,
 			added = add_wrap(wraps, w, bound, bmap->eq[l], len,
 					set, !m);
 			if (added < 0)
-				return -1;
+				return isl_stat_error;
 			if (!added)
 				goto unbounded;
 			++w;
@@ -1200,10 +1295,10 @@ static int add_wraps(struct isl_wraps *wraps, struct isl_coalesce_info *info,
 	}
 
 	wraps->mat->n_row = w;
-	return 0;
+	return isl_stat_ok;
 unbounded:
 	wraps->mat->n_row = 0;
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Check if the constraints in "wraps" from "first" until the last
@@ -1265,7 +1360,7 @@ static __isl_give isl_set *set_from_updated_bmap(__isl_keep isl_basic_map *bmap,
  * If any of the wrapped constraints turn out to be invalid, then
  * check_wraps will reset wrap->n_row to zero.
  */
-static int add_wraps_around_facet(struct isl_wraps *wraps,
+static isl_stat add_wraps_around_facet(struct isl_wraps *wraps,
 	struct isl_coalesce_info *info, int k, isl_int *bound,
 	__isl_keep isl_set *set)
 {
@@ -1276,22 +1371,22 @@ static int add_wraps_around_facet(struct isl_wraps *wraps,
 	snap = isl_tab_snap(info->tab);
 
 	if (isl_tab_select_facet(info->tab, info->bmap->n_eq + k) < 0)
-		return -1;
+		return isl_stat_error;
 	if (isl_tab_detect_redundant(info->tab) < 0)
-		return -1;
+		return isl_stat_error;
 
 	isl_seq_neg(bound, info->bmap->ineq[k], 1 + total);
 
 	n = wraps->mat->n_row;
 	if (add_wraps(wraps, info, bound, set) < 0)
-		return -1;
+		return isl_stat_error;
 
 	if (isl_tab_rollback(info->tab, snap) < 0)
-		return -1;
+		return isl_stat_error;
 	if (check_wraps(wraps->mat, n, info->tab) < 0)
-		return -1;
+		return isl_stat_error;
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Given a basic set i with a constraint k that is adjacent to
@@ -1333,9 +1428,10 @@ static enum isl_change can_wrap_in_facet(int i, int j, int k,
 	mat = isl_mat_alloc(ctx, 2 * (info[i].bmap->n_eq + info[j].bmap->n_eq) +
 				    info[i].bmap->n_ineq + info[j].bmap->n_ineq,
 				    1 + total);
-	wraps_init(&wraps, mat, info, i, j);
+	if (wraps_init(&wraps, mat, info, i, j) < 0)
+		goto error;
 	bound = isl_vec_alloc(ctx, 1 + total);
-	if (!set_i || !set_j || !wraps.mat || !bound)
+	if (!set_i || !set_j || !bound)
 		goto error;
 
 	isl_seq_cpy(bound->el, info[i].bmap->ineq[k], 1 + total);
@@ -1515,8 +1611,9 @@ static enum isl_change wrap_in_facets(int i, int j, int n,
 	set_i = set_from_updated_bmap(info[i].bmap, info[i].tab);
 	ctx = isl_basic_map_get_ctx(info[i].bmap);
 	mat = isl_mat_alloc(ctx, max_wrap, 1 + total);
-	wraps_init(&wraps, mat, info, i, j);
-	if (!set_i || !wraps.mat)
+	if (wraps_init(&wraps, mat, info, i, j) < 0)
+		goto error;
+	if (!set_i)
 		goto error;
 
 	change = try_wrap_in_facets(i, j, info, &wraps, set_i);
@@ -1675,6 +1772,88 @@ static enum isl_change check_wrap(int i, int j, struct isl_coalesce_info *info)
 	return change;
 }
 
+/* Check if all inequality constraints of "i" that cut "j" cease
+ * to be cut constraints if they are relaxed by one.
+ * If so, collect the cut constraints in "list".
+ * The caller is responsible for allocating "list".
+ */
+static isl_bool all_cut_by_one(int i, int j, struct isl_coalesce_info *info,
+	int *list)
+{
+	int l, n;
+
+	n = 0;
+	for (l = 0; l < info[i].bmap->n_ineq; ++l) {
+		enum isl_ineq_type type;
+
+		if (info[i].ineq[l] != STATUS_CUT)
+			continue;
+		type = type_of_relaxed(info[j].tab, info[i].bmap->ineq[l]);
+		if (type == isl_ineq_error)
+			return isl_bool_error;
+		if (type != isl_ineq_redundant)
+			return isl_bool_false;
+		list[n++] = l;
+	}
+
+	return isl_bool_true;
+}
+
+/* Given two basic maps such that "j" has at least one equality constraint
+ * that is adjacent to an inequality constraint of "i" and such that "i" has
+ * exactly one inequality constraint that is adjacent to an equality
+ * constraint of "j", check whether "i" can be extended to include "j" or
+ * whether "j" can be wrapped into "i".
+ * All remaining constraints of "i" and "j" are assumed to be valid
+ * or cut constraints of the other basic map.
+ * However, none of the equality constraints of "i" are cut constraints.
+ *
+ * If "i" has any "cut" inequality constraints, then check if relaxing
+ * each of them by one is sufficient for them to become valid.
+ * If so, check if the inequality constraint adjacent to an equality
+ * constraint of "j" along with all these cut constraints
+ * can be relaxed by one to contain exactly "j".
+ * Otherwise, or if this fails, check if "j" can be wrapped into "i".
+ */
+static enum isl_change check_single_adj_eq(int i, int j,
+	struct isl_coalesce_info *info)
+{
+	enum isl_change change = isl_change_none;
+	int k;
+	int n_cut;
+	int *relax;
+	isl_ctx *ctx;
+	isl_bool try_relax;
+
+	n_cut = count(info[i].ineq, info[i].bmap->n_ineq, STATUS_CUT);
+
+	k = find(info[i].ineq, info[i].bmap->n_ineq, STATUS_ADJ_EQ);
+
+	if (n_cut > 0) {
+		ctx = isl_basic_map_get_ctx(info[i].bmap);
+		relax = isl_calloc_array(ctx, int, 1 + n_cut);
+		if (!relax)
+			return isl_change_error;
+		relax[0] = k;
+		try_relax = all_cut_by_one(i, j, info, relax + 1);
+		if (try_relax < 0)
+			change = isl_change_error;
+	} else {
+		try_relax = isl_bool_true;
+		relax = &k;
+	}
+	if (try_relax && change == isl_change_none)
+		change = is_relaxed_extension(i, j, 1 + n_cut, relax, info);
+	if (n_cut > 0)
+		free(relax);
+	if (change != isl_change_none)
+		return change;
+
+	change = can_wrap_in_facet(i, j, k, info, n_cut > 0);
+
+	return change;
+}
+
 /* At least one of the basic maps has an equality that is adjacent
  * to inequality.  Make sure that only one of the basic maps has
  * such an equality and that the other basic map has exactly one
@@ -1682,21 +1861,12 @@ static enum isl_change check_wrap(int i, int j, struct isl_coalesce_info *info)
  * If the other basic map does not have such an inequality, then
  * check if all its constraints are either valid or cut constraints
  * and, if so, try wrapping in the first map into the second.
- *
- * We call the basic map that has the inequality "i" and the basic
- * map that has the equality "j".
- * If "i" has any "cut" (in)equality, then relaxing the inequality
- * by one would not result in a basic map that contains the other
- * basic map.  However, it may still be possible to wrap in the other
- * basic map.
+ * Otherwise, try to extend one basic map with the other or
+ * wrap one basic map in the other.
  */
 static enum isl_change check_adj_eq(int i, int j,
 	struct isl_coalesce_info *info)
 {
-	enum isl_change change = isl_change_none;
-	int k;
-	int any_cut;
-
 	if (any(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_ADJ_INEQ) &&
 	    any(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_ADJ_INEQ))
 		/* ADJ EQ TOO MANY */
@@ -1714,26 +1884,13 @@ static enum isl_change check_adj_eq(int i, int j,
 	}
 	if (any(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_CUT))
 		return isl_change_none;
-	any_cut = any(info[i].ineq, info[i].bmap->n_ineq, STATUS_CUT);
 	if (any(info[j].ineq, info[j].bmap->n_ineq, STATUS_ADJ_EQ) ||
 	    any(info[i].ineq, info[i].bmap->n_ineq, STATUS_ADJ_INEQ) ||
 	    any(info[j].ineq, info[j].bmap->n_ineq, STATUS_ADJ_INEQ))
 		/* ADJ EQ TOO MANY */
 		return isl_change_none;
 
-	for (k = 0; k < info[i].bmap->n_ineq; ++k)
-		if (info[i].ineq[k] == STATUS_ADJ_EQ)
-			break;
-
-	if (!any_cut) {
-		change = is_adj_eq_extension(i, j, k, info);
-		if (change != isl_change_none)
-			return change;
-	}
-
-	change = can_wrap_in_facet(i, j, k, info, any_cut);
-
-	return change;
+	return check_single_adj_eq(i, j, info);
 }
 
 /* The two basic maps lie on adjacent hyperplanes.  In particular,
@@ -1771,9 +1928,7 @@ static enum isl_change check_eq_adj_eq(int i, int j,
 	if (count(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_ADJ_EQ) != 1)
 		detect_equalities = 1;
 
-	for (k = 0; k < 2 * info[i].bmap->n_eq ; ++k)
-		if (info[i].eq[k] == STATUS_ADJ_EQ)
-			break;
+	k = find(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_ADJ_EQ);
 
 	set_i = set_from_updated_bmap(info[i].bmap, info[i].tab);
 	set_j = set_from_updated_bmap(info[j].bmap, info[j].tab);
@@ -1781,9 +1936,10 @@ static enum isl_change check_eq_adj_eq(int i, int j,
 	mat = isl_mat_alloc(ctx, 2 * (info[i].bmap->n_eq + info[j].bmap->n_eq) +
 				    info[i].bmap->n_ineq + info[j].bmap->n_ineq,
 				    1 + total);
-	wraps_init(&wraps, mat, info, i, j);
+	if (wraps_init(&wraps, mat, info, i, j) < 0)
+		goto error;
 	bound = isl_vec_alloc(ctx, 1 + total);
-	if (!set_i || !set_j || !wraps.mat || !bound)
+	if (!set_i || !set_j || !bound)
 		goto error;
 
 	if (k % 2 == 0)
@@ -1868,6 +2024,56 @@ static void clear_status(struct isl_coalesce_info *info)
 	free(info->ineq);
 }
 
+/* Are all inequality constraints of the basic map represented by "info"
+ * valid for the other basic map, except for a single constraint
+ * that is adjacent to an inequality constraint of the other basic map?
+ */
+static int all_ineq_valid_or_single_adj_ineq(struct isl_coalesce_info *info)
+{
+	int i;
+	int k = -1;
+
+	for (i = 0; i < info->bmap->n_ineq; ++i) {
+		if (info->ineq[i] == STATUS_REDUNDANT)
+			continue;
+		if (info->ineq[i] == STATUS_VALID)
+			continue;
+		if (info->ineq[i] != STATUS_ADJ_INEQ)
+			return 0;
+		if (k != -1)
+			return 0;
+		k = i;
+	}
+
+	return k != -1;
+}
+
+/* Basic map "i" has one or more equality constraints that separate it
+ * from basic map "j".  Check if it happens to be an extension
+ * of basic map "j".
+ * In particular, check that all constraints of "j" are valid for "i",
+ * except for one inequality constraint that is adjacent
+ * to an inequality constraints of "i".
+ * If so, check for "i" being an extension of "j" by calling
+ * is_adj_ineq_extension.
+ *
+ * Clean up the memory allocated for keeping track of the status
+ * of the constraints before returning.
+ */
+static enum isl_change separating_equality(int i, int j,
+	struct isl_coalesce_info *info)
+{
+	enum isl_change change = isl_change_none;
+
+	if (all(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_VALID) &&
+	    all_ineq_valid_or_single_adj_ineq(&info[j]))
+		change = is_adj_ineq_extension(j, i, info);
+
+	clear_status(&info[i]);
+	clear_status(&info[j]);
+	return change;
+}
+
 /* Check if the union of the given pair of basic maps
  * can be represented by a single basic map.
  * If so, replace the pair by the single basic map and return
@@ -1959,22 +2165,6 @@ static enum isl_change coalesce_local_pair_reuse(int i, int j,
 {
 	enum isl_change change = isl_change_none;
 
-	set_eq_status_in(&info[i], info[j].tab);
-	if (info[i].bmap->n_eq && !info[i].eq)
-		goto error;
-	if (any(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_ERROR))
-		goto error;
-	if (any(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_SEPARATE))
-		goto done;
-
-	set_eq_status_in(&info[j], info[i].tab);
-	if (info[j].bmap->n_eq && !info[j].eq)
-		goto error;
-	if (any(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_ERROR))
-		goto error;
-	if (any(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_SEPARATE))
-		goto done;
-
 	set_ineq_status_in(&info[i], info[j].tab);
 	if (info[i].bmap->n_ineq && !info[i].ineq)
 		goto error;
@@ -1991,6 +2181,23 @@ static enum isl_change coalesce_local_pair_reuse(int i, int j,
 	if (any(info[j].ineq, info[j].bmap->n_ineq, STATUS_SEPARATE))
 		goto done;
 
+	set_eq_status_in(&info[i], info[j].tab);
+	if (info[i].bmap->n_eq && !info[i].eq)
+		goto error;
+	if (any(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_ERROR))
+		goto error;
+
+	set_eq_status_in(&info[j], info[i].tab);
+	if (info[j].bmap->n_eq && !info[j].eq)
+		goto error;
+	if (any(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_ERROR))
+		goto error;
+
+	if (any(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_SEPARATE))
+		return separating_equality(i, j, info);
+	if (any(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_SEPARATE))
+		return separating_equality(j, i, info);
+
 	if (all(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_VALID) &&
 	    all(info[i].ineq, info[i].bmap->n_ineq, STATUS_VALID)) {
 		drop(&info[j]);
@@ -2057,36 +2264,190 @@ static enum isl_change coalesce_local_pair(int i, int j,
  *
  *	floor((f(x) + shift * d)/d) - shift
  */
-static int shift_div(struct isl_coalesce_info *info, int div, isl_int shift)
+static isl_stat shift_div(struct isl_coalesce_info *info, int div,
+	isl_int shift)
 {
 	unsigned total;
 
 	info->bmap = isl_basic_map_shift_div(info->bmap, div, 0, shift);
 	if (!info->bmap)
-		return -1;
+		return isl_stat_error;
 
 	total = isl_basic_map_dim(info->bmap, isl_dim_all);
 	total -= isl_basic_map_dim(info->bmap, isl_dim_div);
 	if (isl_tab_shift_var(info->tab, total + div, shift) < 0)
-		return -1;
+		return isl_stat_error;
 
-	return 0;
+	return isl_stat_ok;
+}
+
+/* If the integer division at position "div" is defined by an equality,
+ * i.e., a stride constraint, then change the integer division expression
+ * to have a constant term equal to zero.
+ *
+ * Let the equality constraint be
+ *
+ *	c + f + m a = 0
+ *
+ * The integer division expression is then of the form
+ *
+ *	a = floor((-f - c')/m)
+ *
+ * The integer division is first shifted by t = floor(c/m),
+ * turning the equality constraint into
+ *
+ *	c - m floor(c/m) + f + m a' = 0
+ *
+ * i.e.,
+ *
+ *	(c mod m) + f + m a' = 0
+ *
+ * That is,
+ *
+ *	a' = (-f - (c mod m))/m = floor((-f)/m)
+ *
+ * because a' is an integer and 0 <= (c mod m) < m.
+ * The constant term of a' can therefore be zeroed out.
+ */
+static isl_stat normalize_stride_div(struct isl_coalesce_info *info, int div)
+{
+	isl_bool defined;
+	isl_stat r;
+	isl_constraint *c;
+	isl_int shift, stride;
+
+	defined = isl_basic_map_has_defining_equality(info->bmap, isl_dim_div,
+							div, &c);
+	if (defined < 0)
+		return isl_stat_error;
+	if (!defined)
+		return isl_stat_ok;
+	if (!c)
+		return isl_stat_error;
+	isl_int_init(shift);
+	isl_int_init(stride);
+	isl_constraint_get_constant(c, &shift);
+	isl_constraint_get_coefficient(c, isl_dim_div, div, &stride);
+	isl_int_fdiv_q(shift, shift, stride);
+	r = shift_div(info, div, shift);
+	isl_int_clear(stride);
+	isl_int_clear(shift);
+	isl_constraint_free(c);
+	if (r < 0)
+		return isl_stat_error;
+	info->bmap = isl_basic_map_set_div_expr_constant_num_si_inplace(
+							    info->bmap, div, 0);
+	if (!info->bmap)
+		return isl_stat_error;
+	return isl_stat_ok;
+}
+
+/* The basic maps represented by "info1" and "info2" are known
+ * to have the same number of integer divisions.
+ * Check if pairs of integer divisions are equal to each other
+ * despite the fact that they differ by a rational constant.
+ *
+ * In particular, look for any pair of integer divisions that
+ * only differ in their constant terms.
+ * If either of these integer divisions is defined
+ * by stride constraints, then modify it to have a zero constant term.
+ * If both are defined by stride constraints then in the end they will have
+ * the same (zero) constant term.
+ */
+static isl_stat harmonize_stride_divs(struct isl_coalesce_info *info1,
+	struct isl_coalesce_info *info2)
+{
+	int i, n;
+
+	n = isl_basic_map_dim(info1->bmap, isl_dim_div);
+	for (i = 0; i < n; ++i) {
+		isl_bool known, harmonize;
+
+		known = isl_basic_map_div_is_known(info1->bmap, i);
+		if (known >= 0 && known)
+			known = isl_basic_map_div_is_known(info2->bmap, i);
+		if (known < 0)
+			return isl_stat_error;
+		if (!known)
+			continue;
+		harmonize = isl_basic_map_equal_div_expr_except_constant(
+					    info1->bmap, i, info2->bmap, i);
+		if (harmonize < 0)
+			return isl_stat_error;
+		if (!harmonize)
+			continue;
+		if (normalize_stride_div(info1, i) < 0)
+			return isl_stat_error;
+		if (normalize_stride_div(info2, i) < 0)
+			return isl_stat_error;
+	}
+
+	return isl_stat_ok;
+}
+
+/* If "shift" is an integer constant, then shift the integer division
+ * at position "div" of the basic map represented by "info" by "shift".
+ * If "shift" is not an integer constant, then do nothing.
+ * If "shift" is equal to zero, then no shift needs to be performed either.
+ *
+ * That is, if the integer division has the form
+ *
+ *	floor(f(x)/d)
+ *
+ * then replace it by
+ *
+ *	floor((f(x) + shift * d)/d) - shift
+ */
+static isl_stat shift_if_cst_int(struct isl_coalesce_info *info, int div,
+	__isl_keep isl_aff *shift)
+{
+	isl_bool cst;
+	isl_stat r;
+	isl_int d;
+	isl_val *c;
+
+	cst = isl_aff_is_cst(shift);
+	if (cst < 0 || !cst)
+		return cst < 0 ? isl_stat_error : isl_stat_ok;
+
+	c = isl_aff_get_constant_val(shift);
+	cst = isl_val_is_int(c);
+	if (cst >= 0 && cst)
+		cst = isl_bool_not(isl_val_is_zero(c));
+	if (cst < 0 || !cst) {
+		isl_val_free(c);
+		return cst < 0 ? isl_stat_error : isl_stat_ok;
+	}
+
+	isl_int_init(d);
+	r = isl_val_get_num_isl_int(c, &d);
+	if (r >= 0)
+		r = shift_div(info, div, d);
+	isl_int_clear(d);
+
+	isl_val_free(c);
+
+	return r;
 }
 
 /* Check if some of the divs in the basic map represented by "info1"
  * are shifts of the corresponding divs in the basic map represented
- * by "info2".  If so, align them with those of "info2".
- * Only do this if "info1" and "info2" have the same number
+ * by "info2", taking into account the equality constraints "eq1" of "info1"
+ * and "eq2" of "info2".  If so, align them with those of "info2".
+ * "info1" and "info2" are assumed to have the same number
  * of integer divisions.
  *
  * An integer division is considered to be a shift of another integer
- * division if one is equal to the other plus a constant.
+ * division if, after simplification with respect to the equality
+ * constraints of the other basic map, one is equal to the other
+ * plus a constant.
  *
  * In particular, for each pair of integer divisions, if both are known,
- * have identical coefficients (apart from the constant term) and
- * if the difference between the constant terms (taking into account
- * the denominator) is an integer, then move the difference outside.
- * That is, if one integer division is of the form
+ * have the same denominator and are not already equal to each other,
+ * simplify each with respect to the equality constraints
+ * of the other basic map.  If the difference is an integer constant,
+ * then move this difference outside.
+ * That is, if, after simplification, one integer division is of the form
  *
  *	floor((f(x) + c_1)/d)
  *
@@ -2097,49 +2458,111 @@ static int shift_div(struct isl_coalesce_info *info, int div, isl_int shift)
  * and n = (c_2 - c_1)/d is an integer, then replace the first
  * integer division by
  *
- *	floor((f(x) + c_1 + n * d)/d) - n = floor((f(x) + c_2)/d) - n
+ *	floor((f_1(x) + c_1 + n * d)/d) - n,
+ *
+ * where floor((f_1(x) + c_1 + n * d)/d) = floor((f2(x) + c_2)/d)
+ * after simplification with respect to the equality constraints.
  */
-static int harmonize_divs(struct isl_coalesce_info *info1,
-	struct isl_coalesce_info *info2)
+static isl_stat harmonize_divs_with_hulls(struct isl_coalesce_info *info1,
+	struct isl_coalesce_info *info2, __isl_keep isl_basic_set *eq1,
+	__isl_keep isl_basic_set *eq2)
 {
 	int i;
 	int total;
-
-	if (!info1->bmap || !info2->bmap)
-		return -1;
-
-	if (info1->bmap->n_div != info2->bmap->n_div)
-		return 0;
-	if (info1->bmap->n_div == 0)
-		return 0;
+	isl_local_space *ls1, *ls2;
 
 	total = isl_basic_map_total_dim(info1->bmap);
+	ls1 = isl_local_space_wrap(isl_basic_map_get_local_space(info1->bmap));
+	ls2 = isl_local_space_wrap(isl_basic_map_get_local_space(info2->bmap));
 	for (i = 0; i < info1->bmap->n_div; ++i) {
-		isl_int d;
-		int r = 0;
+		isl_stat r;
+		isl_aff *div1, *div2;
 
-		if (isl_int_is_zero(info1->bmap->div[i][0]) ||
-		    isl_int_is_zero(info2->bmap->div[i][0]))
+		if (!isl_local_space_div_is_known(ls1, i) ||
+		    !isl_local_space_div_is_known(ls2, i))
 			continue;
 		if (isl_int_ne(info1->bmap->div[i][0], info2->bmap->div[i][0]))
 			continue;
-		if (isl_int_eq(info1->bmap->div[i][1], info2->bmap->div[i][1]))
+		if (isl_seq_eq(info1->bmap->div[i] + 1,
+				info2->bmap->div[i] + 1, 1 + total))
 			continue;
-		if (!isl_seq_eq(info1->bmap->div[i] + 2,
-				info2->bmap->div[i] + 2, total))
-			continue;
-		isl_int_init(d);
-		isl_int_sub(d, info2->bmap->div[i][1], info1->bmap->div[i][1]);
-		if (isl_int_is_divisible_by(d, info1->bmap->div[i][0])) {
-			isl_int_divexact(d, d, info1->bmap->div[i][0]);
-			r = shift_div(info1, i, d);
-		}
-		isl_int_clear(d);
+		div1 = isl_local_space_get_div(ls1, i);
+		div2 = isl_local_space_get_div(ls2, i);
+		div1 = isl_aff_substitute_equalities(div1,
+						    isl_basic_set_copy(eq2));
+		div2 = isl_aff_substitute_equalities(div2,
+						    isl_basic_set_copy(eq1));
+		div2 = isl_aff_sub(div2, div1);
+		r = shift_if_cst_int(info1, i, div2);
+		isl_aff_free(div2);
 		if (r < 0)
-			return -1;
+			break;
 	}
+	isl_local_space_free(ls1);
+	isl_local_space_free(ls2);
 
-	return 0;
+	if (i < info1->bmap->n_div)
+		return isl_stat_error;
+	return isl_stat_ok;
+}
+
+/* Check if some of the divs in the basic map represented by "info1"
+ * are shifts of the corresponding divs in the basic map represented
+ * by "info2".  If so, align them with those of "info2".
+ * Only do this if "info1" and "info2" have the same number
+ * of integer divisions.
+ *
+ * An integer division is considered to be a shift of another integer
+ * division if, after simplification with respect to the equality
+ * constraints of the other basic map, one is equal to the other
+ * plus a constant.
+ *
+ * First check if pairs of integer divisions are equal to each other
+ * despite the fact that they differ by a rational constant.
+ * If so, try and arrange for them to have the same constant term.
+ *
+ * Then, extract the equality constraints and continue with
+ * harmonize_divs_with_hulls.
+ *
+ * If the equality constraints of both basic maps are the same,
+ * then there is no need to perform any shifting since
+ * the coefficients of the integer divisions should have been
+ * reduced in the same way.
+ */
+static isl_stat harmonize_divs(struct isl_coalesce_info *info1,
+	struct isl_coalesce_info *info2)
+{
+	isl_bool equal;
+	isl_basic_map *bmap1, *bmap2;
+	isl_basic_set *eq1, *eq2;
+	isl_stat r;
+
+	if (!info1->bmap || !info2->bmap)
+		return isl_stat_error;
+
+	if (info1->bmap->n_div != info2->bmap->n_div)
+		return isl_stat_ok;
+	if (info1->bmap->n_div == 0)
+		return isl_stat_ok;
+
+	if (harmonize_stride_divs(info1, info2) < 0)
+		return isl_stat_error;
+
+	bmap1 = isl_basic_map_copy(info1->bmap);
+	bmap2 = isl_basic_map_copy(info2->bmap);
+	eq1 = isl_basic_map_wrap(isl_basic_map_plain_affine_hull(bmap1));
+	eq2 = isl_basic_map_wrap(isl_basic_map_plain_affine_hull(bmap2));
+	equal = isl_basic_set_plain_is_equal(eq1, eq2);
+	if (equal < 0)
+		r = isl_stat_error;
+	else if (equal)
+		r = isl_stat_ok;
+	else
+		r = harmonize_divs_with_hulls(info1, info2, eq1, eq2);
+	isl_basic_set_free(eq1);
+	isl_basic_set_free(eq2);
+
+	return r;
 }
 
 /* Do the two basic maps live in the same local space, i.e.,
@@ -2147,20 +2570,20 @@ static int harmonize_divs(struct isl_coalesce_info *info1,
  * If either basic map has any unknown divs, then we can only assume
  * that they do not live in the same local space.
  */
-static int same_divs(__isl_keep isl_basic_map *bmap1,
+static isl_bool same_divs(__isl_keep isl_basic_map *bmap1,
 	__isl_keep isl_basic_map *bmap2)
 {
 	int i;
-	int known;
+	isl_bool known;
 	int total;
 
 	if (!bmap1 || !bmap2)
-		return -1;
+		return isl_bool_error;
 	if (bmap1->n_div != bmap2->n_div)
-		return 0;
+		return isl_bool_false;
 
 	if (bmap1->n_div == 0)
-		return 1;
+		return isl_bool_true;
 
 	known = isl_basic_map_divs_known(bmap1);
 	if (known < 0 || !known)
@@ -2177,58 +2600,263 @@ static int same_divs(__isl_keep isl_basic_map *bmap1,
 	return 1;
 }
 
-/* Expand info->tab in the same way info->bmap was expanded in
- * isl_basic_map_expand_divs using the expansion "exp" and
+/* Assuming that "tab" contains the equality constraints and
+ * the initial inequality constraints of "bmap", copy the remaining
+ * inequality constraints of "bmap" to "Tab".
+ */
+static isl_stat copy_ineq(struct isl_tab *tab, __isl_keep isl_basic_map *bmap)
+{
+	int i, n_ineq;
+
+	if (!bmap)
+		return isl_stat_error;
+
+	n_ineq = tab->n_con - tab->n_eq;
+	for (i = n_ineq; i < bmap->n_ineq; ++i)
+		if (isl_tab_add_ineq(tab, bmap->ineq[i]) < 0)
+			return isl_stat_error;
+
+	return isl_stat_ok;
+}
+
+/* Description of an integer division that is added
+ * during an expansion.
+ * "pos" is the position of the corresponding variable.
+ * "cst" indicates whether this integer division has a fixed value.
+ * "val" contains the fixed value, if the value is fixed.
+ */
+struct isl_expanded {
+	int pos;
+	isl_bool cst;
+	isl_int val;
+};
+
+/* For each of the "n" integer division variables "expanded",
+ * if the variable has a fixed value, then add two inequality
+ * constraints expressing the fixed value.
+ * Otherwise, add the corresponding div constraints.
+ * The caller is responsible for removing the div constraints
+ * that it added for all these "n" integer divisions.
+ *
+ * The div constraints and the pair of inequality constraints
+ * forcing the fixed value cannot both be added for a given variable
+ * as the combination may render some of the original constraints redundant.
+ * These would then be ignored during the coalescing detection,
+ * while they could remain in the fused result.
+ *
+ * The two added inequality constraints are
+ *
+ *	-a + v >= 0
+ *	a - v >= 0
+ *
+ * with "a" the variable and "v" its fixed value.
+ * The facet corresponding to one of these two constraints is selected
+ * in the tableau to ensure that the pair of inequality constraints
+ * is treated as an equality constraint.
+ *
+ * The information in info->ineq is thrown away because it was
+ * computed in terms of div constraints, while some of those
+ * have now been replaced by these pairs of inequality constraints.
+ */
+static isl_stat fix_constant_divs(struct isl_coalesce_info *info,
+	int n, struct isl_expanded *expanded)
+{
+	unsigned o_div;
+	int i;
+	isl_vec *ineq;
+
+	o_div = isl_basic_map_offset(info->bmap, isl_dim_div) - 1;
+	ineq = isl_vec_alloc(isl_tab_get_ctx(info->tab), 1 + info->tab->n_var);
+	if (!ineq)
+		return isl_stat_error;
+	isl_seq_clr(ineq->el + 1, info->tab->n_var);
+
+	for (i = 0; i < n; ++i) {
+		if (!expanded[i].cst) {
+			info->bmap = isl_basic_map_extend_constraints(
+						info->bmap, 0, 2);
+			if (isl_basic_map_add_div_constraints(info->bmap,
+						expanded[i].pos - o_div) < 0)
+				break;
+		} else {
+			isl_int_set_si(ineq->el[1 + expanded[i].pos], -1);
+			isl_int_set(ineq->el[0], expanded[i].val);
+			info->bmap = isl_basic_map_add_ineq(info->bmap,
+								ineq->el);
+			isl_int_set_si(ineq->el[1 + expanded[i].pos], 1);
+			isl_int_neg(ineq->el[0], expanded[i].val);
+			info->bmap = isl_basic_map_add_ineq(info->bmap,
+								ineq->el);
+			isl_int_set_si(ineq->el[1 + expanded[i].pos], 0);
+		}
+		if (copy_ineq(info->tab, info->bmap) < 0)
+			break;
+		if (expanded[i].cst &&
+		    isl_tab_select_facet(info->tab, info->tab->n_con - 1) < 0)
+			break;
+	}
+
+	isl_vec_free(ineq);
+
+	clear_status(info);
+	init_status(info);
+
+	return i < n ? isl_stat_error : isl_stat_ok;
+}
+
+/* Insert the "n" integer division variables "expanded"
+ * into info->tab and info->bmap and
  * update info->ineq with respect to the redundant constraints
  * in the resulting tableau.
+ * "bmap" contains the result of this insertion in info->bmap,
+ * while info->bmap is the original version
+ * of "bmap", i.e., the one that corresponds to the current
+ * state of info->tab.  The number of constraints in info->bmap
+ * is assumed to be the same as the number of constraints
+ * in info->tab.  This is required to be able to detect
+ * the extra constraints in "bmap".
+ *
  * In particular, introduce extra variables corresponding
  * to the extra integer divisions and add the div constraints
- * that were added to info->bmap after info->tab was created
- * from the original info->bmap.
+ * that were added to "bmap" after info->tab was created
+ * from info->bmap.
+ * Furthermore, check if these extra integer divisions happen
+ * to attain a fixed integer value in info->tab.
+ * If so, replace the corresponding div constraints by pairs
+ * of inequality constraints that fix these
+ * integer divisions to their single integer values.
+ * Replace info->bmap by "bmap" to match the changes to info->tab.
  * info->ineq was computed without a tableau and therefore
  * does not take into account the redundant constraints
  * in the tableau.  Mark them here.
+ * There is no need to check the newly added div constraints
+ * since they cannot be redundant.
+ * The redundancy check is not performed when constants have been discovered
+ * since info->ineq is completely thrown away in this case.
  */
-static isl_stat expand_tab(struct isl_coalesce_info *info, int *exp)
+static isl_stat tab_insert_divs(struct isl_coalesce_info *info,
+	int n, struct isl_expanded *expanded, __isl_take isl_basic_map *bmap)
 {
-	unsigned total, pos, n_div;
-	int extra_var;
-	int i, n, j, n_ineq;
+	int i, n_ineq;
 	unsigned n_eq;
+	struct isl_tab_undo *snap;
+	int any;
 
-	total = isl_basic_map_dim(info->bmap, isl_dim_all);
-	n_div = isl_basic_map_dim(info->bmap, isl_dim_div);
+	if (!bmap)
+		return isl_stat_error;
+	if (info->bmap->n_eq + info->bmap->n_ineq != info->tab->n_con)
+		isl_die(isl_basic_map_get_ctx(bmap), isl_error_internal,
+			"original tableau does not correspond "
+			"to original basic map", goto error);
+
+	if (isl_tab_extend_vars(info->tab, n) < 0)
+		goto error;
+	if (isl_tab_extend_cons(info->tab, 2 * n) < 0)
+		goto error;
+
+	for (i = 0; i < n; ++i) {
+		if (isl_tab_insert_var(info->tab, expanded[i].pos) < 0)
+			goto error;
+	}
+
+	snap = isl_tab_snap(info->tab);
+
+	n_ineq = info->tab->n_con - info->tab->n_eq;
+	if (copy_ineq(info->tab, bmap) < 0)
+		goto error;
+
+	isl_basic_map_free(info->bmap);
+	info->bmap = bmap;
+
+	any = 0;
+	for (i = 0; i < n; ++i) {
+		expanded[i].cst = isl_tab_is_constant(info->tab,
+					    expanded[i].pos, &expanded[i].val);
+		if (expanded[i].cst < 0)
+			return isl_stat_error;
+		if (expanded[i].cst)
+			any = 1;
+	}
+
+	if (any) {
+		if (isl_tab_rollback(info->tab, snap) < 0)
+			return isl_stat_error;
+		info->bmap = isl_basic_map_cow(info->bmap);
+		if (isl_basic_map_free_inequality(info->bmap, 2 * n) < 0)
+			return isl_stat_error;
+
+		return fix_constant_divs(info, n, expanded);
+	}
+
+	n_eq = info->bmap->n_eq;
+	for (i = 0; i < n_ineq; ++i) {
+		if (isl_tab_is_redundant(info->tab, n_eq + i))
+			info->ineq[i] = STATUS_REDUNDANT;
+	}
+
+	return isl_stat_ok;
+error:
+	isl_basic_map_free(bmap);
+	return isl_stat_error;
+}
+
+/* Expand info->tab and info->bmap in the same way "bmap" was expanded
+ * in isl_basic_map_expand_divs using the expansion "exp" and
+ * update info->ineq with respect to the redundant constraints
+ * in the resulting tableau. info->bmap is the original version
+ * of "bmap", i.e., the one that corresponds to the current
+ * state of info->tab.  The number of constraints in info->bmap
+ * is assumed to be the same as the number of constraints
+ * in info->tab.  This is required to be able to detect
+ * the extra constraints in "bmap".
+ *
+ * Extract the positions where extra local variables are introduced
+ * from "exp" and call tab_insert_divs.
+ */
+static isl_stat expand_tab(struct isl_coalesce_info *info, int *exp,
+	__isl_take isl_basic_map *bmap)
+{
+	isl_ctx *ctx;
+	struct isl_expanded *expanded;
+	int i, j, k, n;
+	int extra_var;
+	unsigned total, pos, n_div;
+	isl_stat r;
+
+	total = isl_basic_map_dim(bmap, isl_dim_all);
+	n_div = isl_basic_map_dim(bmap, isl_dim_div);
 	pos = total - n_div;
 	extra_var = total - info->tab->n_var;
 	n = n_div - extra_var;
 
-	if (isl_tab_extend_vars(info->tab, extra_var) < 0)
-		return isl_stat_error;
-	if (isl_tab_extend_cons(info->tab, 2 * extra_var) < 0)
-		return isl_stat_error;
+	ctx = isl_basic_map_get_ctx(bmap);
+	expanded = isl_calloc_array(ctx, struct isl_expanded, extra_var);
+	if (extra_var && !expanded)
+		goto error;
 
 	i = 0;
+	k = 0;
 	for (j = 0; j < n_div; ++j) {
 		if (i < n && exp[i] == j) {
 			++i;
 			continue;
 		}
-		if (isl_tab_insert_var(info->tab, pos + j) < 0)
-			return isl_stat_error;
+		expanded[k++].pos = pos + j;
 	}
 
-	n_ineq = info->tab->n_con - info->tab->n_eq;
-	for (i = n_ineq; i < info->bmap->n_ineq; ++i)
-		if (isl_tab_add_ineq(info->tab, info->bmap->ineq[i]) < 0)
-			return isl_stat_error;
+	for (k = 0; k < extra_var; ++k)
+		isl_int_init(expanded[k].val);
 
-	n_eq = info->bmap->n_eq;
-	for (i = 0; i < info->bmap->n_ineq; ++i) {
-		if (isl_tab_is_redundant(info->tab, n_eq + i))
-			info->ineq[i] = STATUS_REDUNDANT;
-	}
+	r = tab_insert_divs(info, extra_var, expanded, bmap);
 
-	return isl_stat_ok;
+	for (k = 0; k < extra_var; ++k)
+		isl_int_clear(expanded[k].val);
+	free(expanded);
+
+	return r;
+error:
+	isl_basic_map_free(bmap);
+	return isl_stat_error;
 }
 
 /* Check if the union of the basic maps represented by info[i] and info[j]
@@ -2277,10 +2905,9 @@ static enum isl_change coalesce_expand_tab_divs(__isl_take isl_basic_map *bmap,
 		return known < 0 ? isl_change_error : isl_change_none;
 	}
 
-	bmap_i = info[i].bmap;
-	info[i].bmap = isl_basic_map_copy(bmap);
+	bmap_i = isl_basic_map_copy(info[i].bmap);
 	snap = isl_tab_snap(info[i].tab);
-	if (!info[i].bmap || expand_tab(&info[i], exp) < 0)
+	if (expand_tab(&info[i], exp, bmap) < 0)
 		change = isl_change_error;
 
 	init_status(&info[j]);
@@ -2298,7 +2925,6 @@ static enum isl_change coalesce_expand_tab_divs(__isl_take isl_basic_map *bmap,
 			change = isl_change_error;
 	}
 
-	isl_basic_map_free(bmap);
 	return change;
 }
 
@@ -2337,6 +2963,7 @@ static enum isl_change coalesce_with_expanded_divs(
 	init_status(info_i);
 	bmap = isl_basic_map_copy(bmap);
 	bmap = isl_basic_map_expand_divs(bmap, isl_mat_copy(div), exp);
+	bmap = isl_basic_map_mark_final(bmap);
 
 	if (!bmap)
 		goto error;
@@ -2555,7 +3182,7 @@ static enum isl_change coalesce_divs(int i, int j,
 
 /* Does "bmap" involve any divs that themselves refer to divs?
  */
-static int has_nested_div(__isl_keep isl_basic_map *bmap)
+static isl_bool has_nested_div(__isl_keep isl_basic_map *bmap)
 {
 	int i;
 	unsigned total;
@@ -2568,9 +3195,9 @@ static int has_nested_div(__isl_keep isl_basic_map *bmap)
 	for (i = 0; i < n_div; ++i)
 		if (isl_seq_first_non_zero(bmap->div[i] + 2 + total,
 					    n_div) != -1)
-			return 1;
+			return isl_bool_true;
 
-	return 0;
+	return isl_bool_false;
 }
 
 /* Return a list of affine expressions, one for each integer division
@@ -2617,7 +3244,8 @@ static __isl_give isl_aff_list *set_up_substitutions(
 		isl_aff *aff;
 
 		if (j < n_div_j &&
-		    isl_seq_eq(bmap_i->div[i], bmap_j->div[j], 2 + total)) {
+		    isl_basic_map_equal_div_expr_part(bmap_i, i, bmap_j, j,
+						    0, 2 + total)) {
 			++j;
 			list = isl_aff_list_add(list, isl_aff_copy(aff_nan));
 			continue;
@@ -2668,7 +3296,7 @@ error:
  * that is added later to result in constraints that do not hold
  * in the original input.
  */
-static int add_sub_vars(struct isl_coalesce_info *info,
+static isl_stat add_sub_vars(struct isl_coalesce_info *info,
 	__isl_keep isl_aff_list *list, int dim, int extra_var)
 {
 	int i, j, n, d;
@@ -2679,7 +3307,7 @@ static int add_sub_vars(struct isl_coalesce_info *info,
 	info->bmap = isl_basic_map_extend_space(info->bmap, space,
 						extra_var, 0, 0);
 	if (!info->bmap)
-		return -1;
+		return isl_stat_error;
 	n = isl_aff_list_n_aff(list);
 	for (i = 0; i < n; ++i) {
 		int is_nan;
@@ -2689,23 +3317,23 @@ static int add_sub_vars(struct isl_coalesce_info *info,
 		is_nan = isl_aff_is_nan(aff);
 		isl_aff_free(aff);
 		if (is_nan < 0)
-			return -1;
+			return isl_stat_error;
 		if (is_nan)
 			continue;
 
 		if (isl_tab_insert_var(info->tab, dim + i) < 0)
-			return -1;
+			return isl_stat_error;
 		d = isl_basic_map_alloc_div(info->bmap);
 		if (d < 0)
-			return -1;
+			return isl_stat_error;
 		info->bmap = isl_basic_map_mark_div_unknown(info->bmap, d);
 		if (!info->bmap)
-			return -1;
+			return isl_stat_error;
 		for (j = d; j > i; --j)
 			isl_basic_map_swap_div(info->bmap, j - 1, j);
 	}
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* For each element in "list" that is not set to NaN, fix the corresponding
@@ -2905,7 +3533,7 @@ error:
 static enum isl_change check_coalesce_eq(int i, int j,
 	struct isl_coalesce_info *info)
 {
-	int known, nested;
+	isl_bool known, nested;
 	enum isl_change change;
 
 	known = isl_basic_map_divs_known(info[i].bmap);
@@ -2948,7 +3576,7 @@ static enum isl_change check_coalesce_eq(int i, int j,
 static enum isl_change coalesce_pair(int i, int j,
 	struct isl_coalesce_info *info)
 {
-	int same;
+	isl_bool same;
 	enum isl_change change;
 
 	if (harmonize_divs(&info[i], &info[j]) < 0)
@@ -3118,7 +3746,7 @@ static __isl_give isl_map *update_basic_maps(__isl_take isl_map *map,
  * For each basic map, we also compute the hash of the apparent affine hull
  * for use in coalesce.
  */
-struct isl_map *isl_map_coalesce(struct isl_map *map)
+__isl_give isl_map *isl_map_coalesce(__isl_take isl_map *map)
 {
 	int i;
 	unsigned n;
@@ -3190,5 +3818,5 @@ error:
  */
 struct isl_set *isl_set_coalesce(struct isl_set *set)
 {
-	return (struct isl_set *)isl_map_coalesce((struct isl_map *)set);
+	return set_from_map(isl_map_coalesce(set_to_map(set)));
 }
diff --git a/lib/Analysis/isl/isl_config.h.in b/lib/Analysis/isl/isl_config.h.in
index cd98b73..27b6f94 100644
--- a/lib/Analysis/isl/isl_config.h.in
+++ b/lib/Analysis/isl/isl_config.h.in
@@ -34,6 +34,9 @@
 /* Define if clang/Basic/DiagnosticOptions.h exists */
 #undef HAVE_BASIC_DIAGNOSTICOPTIONS_H
 
+/* define if the compiler supports basic C++11 syntax */
+#undef HAVE_CXX11
+
 /* Define if Driver constructor takes CXXIsProduction argument */
 #undef HAVE_CXXISPRODUCTION
 
@@ -85,6 +88,9 @@
 /* Define if Driver constructor takes IsProduction argument */
 #undef HAVE_ISPRODUCTION
 
+/* Define if clang/Lex/PreprocessorOptions.h exists */
+#undef HAVE_LEX_PREPROCESSOROPTIONS_H
+
 /* Define to 1 if you have the `gmp' library (-lgmp). */
 #undef HAVE_LIBGMP
 
@@ -124,8 +130,10 @@
 /* Return type of HandleTopLevelDeclReturn */
 #undef HandleTopLevelDeclReturn
 
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
+/* Define to InputKind::C for newer versions of clang */
+#undef IK_C
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
 #undef LT_OBJDIR
 
 /* Name of package */
@@ -149,6 +157,12 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
+/* Defined if CompilerInstance::setInvocation takes a shared_ptr */
+#undef SETINVOCATION_TAKES_SHARED_PTR
+
+/* Define if CompilerInvocation::setLangDefaults takes 5 arguments */
+#undef SETLANGDEFAULTS_TAKES_5_ARGUMENTS
+
 /* The size of `char', as computed by sizeof. */
 #undef SIZEOF_CHAR
 
diff --git a/lib/Analysis/isl/isl_constraint.c b/lib/Analysis/isl/isl_constraint.c
index 9411fd1..92a6bb8 100644
--- a/lib/Analysis/isl/isl_constraint.c
+++ b/lib/Analysis/isl/isl_constraint.c
@@ -20,6 +20,9 @@
 #include <isl_vec_private.h>
 #include <isl/deprecated/constraint_int.h>
 
+#include <bset_to_bmap.c>
+#include <bset_from_bmap.c>
+
 #undef BASE
 #define BASE constraint
 
@@ -132,7 +135,7 @@ error:
 struct isl_constraint *isl_basic_set_constraint(struct isl_basic_set *bset,
 	isl_int **line)
 {
-	return isl_basic_map_constraint((struct isl_basic_map *)bset, line);
+	return isl_basic_map_constraint(bset_to_bmap(bset), line);
 }
 
 __isl_give isl_constraint *isl_constraint_alloc_equality(
@@ -248,7 +251,7 @@ isl_stat isl_basic_map_foreach_constraint(__isl_keep isl_basic_map *bmap,
 isl_stat isl_basic_set_foreach_constraint(__isl_keep isl_basic_set *bset,
 	isl_stat (*fn)(__isl_take isl_constraint *c, void *user), void *user)
 {
-	return isl_basic_map_foreach_constraint((isl_basic_map *)bset, fn, user);
+	return isl_basic_map_foreach_constraint(bset_to_bmap(bset), fn, user);
 }
 
 /* Add the constraint to the list that "user" points to, if it is not
@@ -350,9 +353,8 @@ error:
 struct isl_basic_set *isl_basic_set_add_constraint(
 	struct isl_basic_set *bset, struct isl_constraint *constraint)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_add_constraint((struct isl_basic_map *)bset,
-						constraint);
+	return bset_from_bmap(isl_basic_map_add_constraint(bset_to_bmap(bset),
+							    constraint));
 }
 
 __isl_give isl_map *isl_map_add_constraint(__isl_take isl_map *map,
@@ -471,7 +473,8 @@ const char *isl_constraint_get_dim_name(__isl_keep isl_constraint *constraint,
 	    isl_local_space_get_dim_name(constraint->ls, type, pos) : NULL;
 }
 
-void isl_constraint_get_constant(struct isl_constraint *constraint, isl_int *v)
+void isl_constraint_get_constant(__isl_keep isl_constraint *constraint,
+	isl_int *v)
 {
 	if (!constraint)
 		return;
@@ -667,71 +670,6 @@ __isl_give isl_constraint *isl_constraint_set_coefficient_si(
 	return constraint;
 }
 
-/* Drop any constraint from "bset" that is identical to "constraint".
- * In particular, this means that the local spaces of "bset" and
- * "constraint" need to be the same.
- *
- * We manually set ISL_BASIC_SET_FINAL instead of calling
- * isl_basic_set_finalize because this function is called by CLooG,
- * which does not expect any variables to disappear.
- */
-__isl_give isl_basic_set *isl_basic_set_drop_constraint(
-	__isl_take isl_basic_set *bset, __isl_take isl_constraint *constraint)
-{
-	int i;
-	unsigned n;
-	isl_int **row;
-	unsigned total;
-	isl_local_space *ls1;
-	int equal;
-	int equality;
-
-	if (!bset || !constraint)
-		goto error;
-
-	ls1 = isl_basic_set_get_local_space(bset);
-	equal = isl_local_space_is_equal(ls1, constraint->ls);
-	isl_local_space_free(ls1);
-	if (equal < 0)
-		goto error;
-	if (!equal) {
-		isl_constraint_free(constraint);
-		return bset;
-	}
-
-	bset = isl_basic_set_cow(bset);
-	if (!bset)
-		goto error;
-
-	equality = isl_constraint_is_equality(constraint);
-	if (equality) {
-		n = bset->n_eq;
-		row = bset->eq;
-	} else {
-		n = bset->n_ineq;
-		row = bset->ineq;
-	}
-
-	total = isl_constraint_dim(constraint, isl_dim_all);
-	for (i = 0; i < n; ++i) {
-		if (!isl_seq_eq(row[i], constraint->v->el, 1 + total))
-			continue;
-		if (equality && isl_basic_set_drop_equality(bset, i) < 0)
-			goto error;
-		if (!equality && isl_basic_set_drop_inequality(bset, i) < 0)
-			goto error;
-		break;
-	}
-			
-	isl_constraint_free(constraint);
-	ISL_F_SET(bset, ISL_BASIC_SET_FINAL);
-	return bset;
-error:
-	isl_constraint_free(constraint);
-	isl_basic_set_free(bset);
-	return NULL;
-}
-
 struct isl_constraint *isl_constraint_negate(struct isl_constraint *constraint)
 {
 	isl_ctx *ctx;
@@ -770,9 +708,11 @@ int isl_constraint_is_div_constraint(__isl_keep isl_constraint *constraint)
 		return 0;
 	n_div = isl_constraint_dim(constraint, isl_dim_div);
 	for (i = 0; i < n_div; ++i) {
-		if (isl_local_space_is_div_constraint(constraint->ls,
-							constraint->v->el, i))
-			return 1;
+		isl_bool is_div;
+		is_div = isl_local_space_is_div_constraint(constraint->ls,
+							constraint->v->el, i);
+		if (is_div < 0 || is_div)
+			return is_div;
 	}
 
 	return 0;
@@ -822,8 +762,8 @@ error:
 	return NULL;
 }
 
-struct isl_basic_set *isl_basic_set_from_constraint(
-	struct isl_constraint *constraint)
+__isl_give isl_basic_set *isl_basic_set_from_constraint(
+	__isl_take isl_constraint *constraint)
 {
 	if (!constraint)
 		return NULL;
@@ -831,7 +771,7 @@ struct isl_basic_set *isl_basic_set_from_constraint(
 	if (isl_constraint_dim(constraint, isl_dim_in) != 0)
 		isl_die(isl_constraint_get_ctx(constraint), isl_error_invalid,
 			"not a set constraint", goto error);
-	return (isl_basic_set *)isl_basic_map_from_constraint(constraint);
+	return bset_from_bmap(isl_basic_map_from_constraint(constraint));
 error:
 	isl_constraint_free(constraint);
 	return NULL;
@@ -842,7 +782,7 @@ error:
  *
  * If so, and if c is not NULL, then return a copy of this equality in *c.
  */
-int isl_basic_map_has_defining_equality(
+isl_bool isl_basic_map_has_defining_equality(
 	__isl_keep isl_basic_map *bmap, enum isl_dim_type type, int pos,
 	__isl_give isl_constraint **c)
 {
@@ -851,10 +791,12 @@ int isl_basic_map_has_defining_equality(
 	unsigned total;
 
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	offset = basic_map_offset(bmap, type);
 	total = isl_basic_map_total_dim(bmap);
-	isl_assert(bmap->ctx, pos < isl_basic_map_dim(bmap, type), return -1);
+	if (pos >= isl_basic_map_dim(bmap, type))
+		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
+			"invalid position", return isl_bool_error);
 	for (i = 0; i < bmap->n_eq; ++i) {
 		if (isl_int_is_zero(bmap->eq[i][offset + pos]) ||
 		    isl_seq_first_non_zero(bmap->eq[i]+offset+pos+1,
@@ -863,9 +805,9 @@ int isl_basic_map_has_defining_equality(
 		if (c)
 			*c = isl_basic_map_constraint(isl_basic_map_copy(bmap),
 								&bmap->eq[i]);
-		return 1;
+		return isl_bool_true;
 	}
-	return 0;
+	return isl_bool_false;
 }
 
 /* Is the variable of "type" at position "pos" of "bset" defined
@@ -873,15 +815,15 @@ int isl_basic_map_has_defining_equality(
  *
  * If so, and if c is not NULL, then return a copy of this equality in *c.
  */
-int isl_basic_set_has_defining_equality(
+isl_bool isl_basic_set_has_defining_equality(
 	__isl_keep isl_basic_set *bset, enum isl_dim_type type, int pos,
 	__isl_give isl_constraint **c)
 {
-	return isl_basic_map_has_defining_equality((isl_basic_map *)bset,
+	return isl_basic_map_has_defining_equality(bset_to_bmap(bset),
 						    type, pos, c);
 }
 
-int isl_basic_set_has_defining_inequalities(
+isl_bool isl_basic_set_has_defining_inequalities(
 	struct isl_basic_set *bset, enum isl_dim_type type, int pos,
 	struct isl_constraint **lower,
 	struct isl_constraint **upper)
@@ -893,10 +835,12 @@ int isl_basic_set_has_defining_inequalities(
 	isl_int **lower_line, **upper_line;
 
 	if (!bset)
-		return -1;
+		return isl_bool_error;
 	offset = basic_set_offset(bset, type);
 	total = isl_basic_set_total_dim(bset);
-	isl_assert(bset->ctx, pos < isl_basic_set_dim(bset, type), return -1);
+	if (pos >= isl_basic_set_dim(bset, type))
+		isl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,
+			"invalid position", return isl_bool_error);
 	isl_int_init(m);
 	for (i = 0; i < bset->n_ineq; ++i) {
 		if (isl_int_is_zero(bset->ineq[i][offset + pos]))
@@ -928,13 +872,13 @@ int isl_basic_set_has_defining_inequalities(
 			*upper = isl_basic_set_constraint(
 					isl_basic_set_copy(bset), upper_line);
 			isl_int_clear(m);
-			return 1;
+			return isl_bool_true;
 		}
 	}
 	*lower = NULL;
 	*upper = NULL;
 	isl_int_clear(m);
-	return 0;
+	return isl_bool_false;
 }
 
 /* Given two constraints "a" and "b" on the variable at position "abs_pos"
diff --git a/lib/Analysis/isl/isl_constraint_private.h b/lib/Analysis/isl/isl_constraint_private.h
index 5cef017..26a8630 100644
--- a/lib/Analysis/isl/isl_constraint_private.h
+++ b/lib/Analysis/isl/isl_constraint_private.h
@@ -21,6 +21,8 @@ struct isl_constraint {
 struct isl_constraint *isl_basic_set_constraint(struct isl_basic_set *bset,
 	isl_int **line);
 
+void isl_constraint_get_constant(__isl_keep isl_constraint *constraint,
+	isl_int *v);
 void isl_constraint_get_coefficient(__isl_keep isl_constraint *constraint,
 	enum isl_dim_type type, int pos, isl_int *v);
 __isl_give isl_constraint *isl_constraint_set_constant(
diff --git a/lib/Analysis/isl/isl_convex_hull.c b/lib/Analysis/isl/isl_convex_hull.c
index 1c732b3..bedee1b 100644
--- a/lib/Analysis/isl/isl_convex_hull.c
+++ b/lib/Analysis/isl/isl_convex_hull.c
@@ -23,57 +23,12 @@
 #include "isl_tab.h"
 #include <isl_sort.h>
 
-static struct isl_basic_set *uset_convex_hull_wrap_bounded(struct isl_set *set);
+#include <bset_to_bmap.c>
+#include <bset_from_bmap.c>
+#include <set_to_map.c>
 
-/* Return 1 if constraint c is redundant with respect to the constraints
- * in bmap.  If c is a lower [upper] bound in some variable and bmap
- * does not have a lower [upper] bound in that variable, then c cannot
- * be redundant and we do not need solve any lp.
- */
-int isl_basic_map_constraint_is_redundant(struct isl_basic_map **bmap,
-	isl_int *c, isl_int *opt_n, isl_int *opt_d)
-{
-	enum isl_lp_result res;
-	unsigned total;
-	int i, j;
-
-	if (!bmap)
-		return -1;
-
-	total = isl_basic_map_total_dim(*bmap);
-	for (i = 0; i < total; ++i) {
-		int sign;
-		if (isl_int_is_zero(c[1+i]))
-			continue;
-		sign = isl_int_sgn(c[1+i]);
-		for (j = 0; j < (*bmap)->n_ineq; ++j)
-			if (sign == isl_int_sgn((*bmap)->ineq[j][1+i]))
-				break;
-		if (j == (*bmap)->n_ineq)
-			break;
-	}
-	if (i < total)
-		return 0;
-
-	res = isl_basic_map_solve_lp(*bmap, 0, c, (*bmap)->ctx->one,
-					opt_n, opt_d, NULL);
-	if (res == isl_lp_unbounded)
-		return 0;
-	if (res == isl_lp_error)
-		return -1;
-	if (res == isl_lp_empty) {
-		*bmap = isl_basic_map_set_to_empty(*bmap);
-		return 0;
-	}
-	return !isl_int_is_neg(*opt_n);
-}
-
-int isl_basic_set_constraint_is_redundant(struct isl_basic_set **bset,
-	isl_int *c, isl_int *opt_n, isl_int *opt_d)
-{
-	return isl_basic_map_constraint_is_redundant(
-			(struct isl_basic_map **)bset, c, opt_n, opt_d);
-}
+static __isl_give isl_basic_set *uset_convex_hull_wrap_bounded(
+	__isl_take isl_set *set);
 
 /* Remove redundant
  * constraints.  If the minimal value along the normal of a constraint
@@ -82,7 +37,12 @@ int isl_basic_set_constraint_is_redundant(struct isl_basic_set **bset,
  * Since some constraints may be mutually redundant, sort the constraints
  * first such that constraints that involve existentially quantified
  * variables are considered for removal before those that do not.
- * The sorting is also need for the use in map_simple_hull.
+ * The sorting is also needed for the use in map_simple_hull.
+ *
+ * Note that isl_tab_detect_implicit_equalities may also end up
+ * marking some constraints as redundant.  Make sure the constraints
+ * are preserved and undo those marking such that isl_tab_detect_redundant
+ * can consider the constraints in the sorted order.
  *
  * Alternatively, we could have intersected the basic map with the
  * corresponding equality and then checked if the dimension was that
@@ -106,8 +66,14 @@ __isl_give isl_basic_map *isl_basic_map_remove_redundancies(
 
 	bmap = isl_basic_map_sort_constraints(bmap);
 	tab = isl_tab_from_basic_map(bmap, 0);
+	if (!tab)
+		goto error;
+	tab->preserve = 1;
 	if (isl_tab_detect_implicit_equalities(tab) < 0)
 		goto error;
+	if (isl_tab_restore_redundant(tab) < 0)
+		goto error;
+	tab->preserve = 0;
 	if (isl_tab_detect_redundant(tab) < 0)
 		goto error;
 	bmap = isl_basic_map_update_from_tab(bmap, tab);
@@ -126,8 +92,8 @@ error:
 __isl_give isl_basic_set *isl_basic_set_remove_redundancies(
 	__isl_take isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_remove_redundancies((struct isl_basic_map *)bset);
+	return bset_from_bmap(
+		isl_basic_map_remove_redundancies(bset_to_bmap(bset)));
 }
 
 /* Remove redundant constraints in each of the basic maps.
@@ -147,7 +113,7 @@ __isl_give isl_set *isl_set_remove_redundancies(__isl_take isl_set *set)
  * constraint c and if so, set the constant term such that the
  * resulting constraint is a bounding constraint for the set.
  */
-static int uset_is_bound(struct isl_set *set, isl_int *c, unsigned len)
+static int uset_is_bound(__isl_keep isl_set *set, isl_int *c, unsigned len)
 {
 	int first;
 	int j;
@@ -191,53 +157,6 @@ error:
 	return -1;
 }
 
-__isl_give isl_basic_map *isl_basic_map_set_rational(
-	__isl_take isl_basic_set *bmap)
-{
-	if (!bmap)
-		return NULL;
-
-	if (ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL))
-		return bmap;
-
-	bmap = isl_basic_map_cow(bmap);
-	if (!bmap)
-		return NULL;
-
-	ISL_F_SET(bmap, ISL_BASIC_MAP_RATIONAL);
-
-	return isl_basic_map_finalize(bmap);
-}
-
-__isl_give isl_basic_set *isl_basic_set_set_rational(
-	__isl_take isl_basic_set *bset)
-{
-	return isl_basic_map_set_rational(bset);
-}
-
-__isl_give isl_map *isl_map_set_rational(__isl_take isl_map *map)
-{
-	int i;
-
-	map = isl_map_cow(map);
-	if (!map)
-		return NULL;
-	for (i = 0; i < map->n; ++i) {
-		map->p[i] = isl_basic_map_set_rational(map->p[i]);
-		if (!map->p[i])
-			goto error;
-	}
-	return map;
-error:
-	isl_map_free(map);
-	return NULL;
-}
-
-__isl_give isl_set *isl_set_set_rational(__isl_take isl_set *set)
-{
-	return isl_map_set_rational(set);
-}
-
 static struct isl_basic_set *isl_basic_set_add_equality(
 	struct isl_basic_set *bset, isl_int *c)
 {
@@ -265,7 +184,8 @@ error:
 	return NULL;
 }
 
-static struct isl_set *isl_set_add_basic_set_equality(struct isl_set *set, isl_int *c)
+static __isl_give isl_set *isl_set_add_basic_set_equality(
+	__isl_take isl_set *set, isl_int *c)
 {
 	int i;
 
@@ -300,7 +220,7 @@ error:
  *
  *			\sum_i x_{i,1} = 1
  */
-static struct isl_basic_set *wrap_constraints(struct isl_set *set)
+static __isl_give isl_basic_set *wrap_constraints(__isl_keep isl_set *set)
 {
 	struct isl_basic_set *lp;
 	unsigned n_eq;
@@ -580,7 +500,8 @@ error:
  * After computing the facets of the facet in the z' space,
  * we convert them back to the x space through Q.
  */
-static struct isl_basic_set *compute_facet(struct isl_set *set, isl_int *c)
+static __isl_give isl_basic_set *compute_facet(__isl_keep isl_set *set,
+	isl_int *c)
 {
 	struct isl_mat *m, *U, *Q;
 	struct isl_basic_set *facet = NULL;
@@ -634,8 +555,8 @@ error:
  * using the technique in section "3.1 Ridge Generation" of
  * "Extended Convex Hull" by Fukuda et al.
  */
-static struct isl_basic_set *extend(struct isl_basic_set *hull,
-	struct isl_set *set)
+static __isl_give isl_basic_set *extend(__isl_take isl_basic_set *hull,
+	__isl_keep isl_set *set)
 {
 	int i, j, f;
 	int k;
@@ -697,7 +618,7 @@ error:
  * We simply collect the lower and upper bounds of each basic set
  * and the biggest of those.
  */
-static struct isl_basic_set *convex_hull_1d(struct isl_set *set)
+static __isl_give isl_basic_set *convex_hull_1d(__isl_take isl_set *set)
 {
 	struct isl_mat *c = NULL;
 	isl_int *lower = NULL;
@@ -817,7 +738,7 @@ error:
 	return NULL;
 }
 
-static struct isl_basic_set *convex_hull_0d(struct isl_set *set)
+static __isl_give isl_basic_set *convex_hull_0d(__isl_take isl_set *set)
 {
 	struct isl_basic_set *convex_hull;
 
@@ -841,8 +762,8 @@ static struct isl_basic_set *convex_hull_0d(struct isl_set *set)
  * to the two original basic sets, retaining only those corresponding
  * to the convex hull.
  */
-static struct isl_basic_set *convex_hull_pair_elim(struct isl_basic_set *bset1,
-	struct isl_basic_set *bset2)
+static __isl_give isl_basic_set *convex_hull_pair_elim(
+	__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)
 {
 	int i, j, k;
 	struct isl_basic_set *bset[2];
@@ -907,15 +828,15 @@ error:
 
 /* Is the set bounded for each value of the parameters?
  */
-int isl_basic_set_is_bounded(__isl_keep isl_basic_set *bset)
+isl_bool isl_basic_set_is_bounded(__isl_keep isl_basic_set *bset)
 {
 	struct isl_tab *tab;
-	int bounded;
+	isl_bool bounded;
 
 	if (!bset)
-		return -1;
+		return isl_bool_error;
 	if (isl_basic_set_plain_is_empty(bset))
-		return 1;
+		return isl_bool_true;
 
 	tab = isl_tab_from_recession_cone(bset, 1);
 	bounded = isl_tab_cone_is_bounded(tab);
@@ -926,17 +847,17 @@ int isl_basic_set_is_bounded(__isl_keep isl_basic_set *bset)
 /* Is the image bounded for each value of the parameters and
  * the domain variables?
  */
-int isl_basic_map_image_is_bounded(__isl_keep isl_basic_map *bmap)
+isl_bool isl_basic_map_image_is_bounded(__isl_keep isl_basic_map *bmap)
 {
 	unsigned nparam = isl_basic_map_dim(bmap, isl_dim_param);
 	unsigned n_in = isl_basic_map_dim(bmap, isl_dim_in);
-	int bounded;
+	isl_bool bounded;
 
 	bmap = isl_basic_map_copy(bmap);
 	bmap = isl_basic_map_cow(bmap);
 	bmap = isl_basic_map_move_dims(bmap, isl_dim_param, nparam,
 					isl_dim_in, 0, n_in);
-	bounded = isl_basic_set_is_bounded((isl_basic_set *)bmap);
+	bounded = isl_basic_set_is_bounded(bset_from_bmap(bmap));
 	isl_basic_map_free(bmap);
 
 	return bounded;
@@ -944,19 +865,19 @@ int isl_basic_map_image_is_bounded(__isl_keep isl_basic_map *bmap)
 
 /* Is the set bounded for each value of the parameters?
  */
-int isl_set_is_bounded(__isl_keep isl_set *set)
+isl_bool isl_set_is_bounded(__isl_keep isl_set *set)
 {
 	int i;
 
 	if (!set)
-		return -1;
+		return isl_bool_error;
 
 	for (i = 0; i < set->n; ++i) {
-		int bounded = isl_basic_set_is_bounded(set->p[i]);
+		isl_bool bounded = isl_basic_set_is_bounded(set->p[i]);
 		if (!bounded || bounded < 0)
 			return bounded;
 	}
-	return 1;
+	return isl_bool_true;
 }
 
 /* Compute the lineality space of the convex hull of bset1 and bset2.
@@ -965,8 +886,8 @@ int isl_set_is_bounded(__isl_keep isl_set *set)
  * with the negative of the recession cone of bset2 and then compute
  * the linear hull of the resulting cone.
  */
-static struct isl_basic_set *induced_lineality_space(
-	struct isl_basic_set *bset1, struct isl_basic_set *bset2)
+static __isl_give isl_basic_set *induced_lineality_space(
+	__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)
 {
 	int i, k;
 	struct isl_basic_set *lin = NULL;
@@ -1021,7 +942,7 @@ error:
 	return NULL;
 }
 
-static struct isl_basic_set *uset_convex_hull(struct isl_set *set);
+static __isl_give isl_basic_set *uset_convex_hull(__isl_take isl_set *set);
 
 /* Given a set and a linear space "lin" of dimension n > 0,
  * project the linear space from the set, compute the convex hull
@@ -1043,8 +964,8 @@ static struct isl_basic_set *uset_convex_hull(struct isl_set *set);
  * we transform the hull back to the original space as A' Q_1 x >= b',
  * with Q_1 all but the last n rows of Q.
  */
-static struct isl_basic_set *modulo_lineality(struct isl_set *set,
-	struct isl_basic_set *lin)
+static __isl_give isl_basic_set *modulo_lineality(__isl_take isl_set *set,
+	__isl_take isl_basic_set *lin)
 {
 	unsigned total = isl_basic_set_total_dim(lin);
 	unsigned lin_dim;
@@ -1087,8 +1008,8 @@ error:
  * The next \alpha{ij} correspond to the equalities and come in pairs.
  * The final \alpha{ij} correspond to the inequalities.
  */
-static struct isl_basic_set *valid_direction_lp(
-	struct isl_basic_set *bset1, struct isl_basic_set *bset2)
+static __isl_give isl_basic_set *valid_direction_lp(
+	__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)
 {
 	isl_space *dim;
 	struct isl_basic_set *lp;
@@ -1168,8 +1089,8 @@ error:
  * Note that we simply pick any valid direction and make no attempt
  * to pick a "good" or even the "best" valid direction.
  */
-static struct isl_vec *valid_direction(
-	struct isl_basic_set *bset1, struct isl_basic_set *bset2)
+static __isl_give isl_vec *valid_direction(
+	__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)
 {
 	struct isl_basic_set *lp;
 	struct isl_tab *tab;
@@ -1231,8 +1152,8 @@ error:
  * In particular, add the "positivity constraint" and then perform
  * the mapping.
  */
-static struct isl_basic_set *homogeneous_map(struct isl_basic_set *bset,
-	struct isl_mat *T)
+static __isl_give isl_basic_set *homogeneous_map(__isl_take isl_basic_set *bset,
+	__isl_take isl_mat *T)
 {
 	int k;
 
@@ -1311,8 +1232,8 @@ error:
  *
  * The polyhedron b + A x >= 0 is then the convex hull of the input polyhedra.
  */
-static struct isl_basic_set *convex_hull_pair_pointed(
-	struct isl_basic_set *bset1, struct isl_basic_set *bset2)
+static __isl_give isl_basic_set *convex_hull_pair_pointed(
+	__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)
 {
 	struct isl_ctx *ctx = NULL;
 	struct isl_vec *dir = NULL;
@@ -1353,9 +1274,9 @@ error:
 	return NULL;
 }
 
-static struct isl_basic_set *uset_convex_hull_wrap(struct isl_set *set);
-static struct isl_basic_set *modulo_affine_hull(
-	struct isl_set *set, struct isl_basic_set *affine_hull);
+static __isl_give isl_basic_set *uset_convex_hull_wrap(__isl_take isl_set *set);
+static __isl_give isl_basic_set *modulo_affine_hull(
+	__isl_take isl_set *set, __isl_take isl_basic_set *affine_hull);
 
 /* Compute the convex hull of a pair of basic sets without any parameters or
  * integer divisions.
@@ -1370,8 +1291,8 @@ static struct isl_basic_set *modulo_affine_hull(
  * If the convex hull of the two basic sets would have a non-trivial
  * lineality space, we first project out this lineality space.
  */
-static struct isl_basic_set *convex_hull_pair(struct isl_basic_set *bset1,
-	struct isl_basic_set *bset2)
+static __isl_give isl_basic_set *convex_hull_pair(
+	__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)
 {
 	isl_basic_set *lin, *aff;
 	int bounded1, bounded2;
@@ -1425,22 +1346,29 @@ error:
 }
 
 /* Compute the lineality space of a basic set.
- * We currently do not allow the basic set to have any divs.
  * We basically just drop the constants and turn every inequality
  * into an equality.
+ * Any explicit representations of local variables are removed
+ * because they may no longer be valid representations
+ * in the lineality space.
  */
-struct isl_basic_set *isl_basic_set_lineality_space(struct isl_basic_set *bset)
+__isl_give isl_basic_set *isl_basic_set_lineality_space(
+	__isl_take isl_basic_set *bset)
 {
 	int i, k;
 	struct isl_basic_set *lin = NULL;
-	unsigned dim;
+	unsigned n_div, dim;
 
 	if (!bset)
 		goto error;
-	isl_assert(bset->ctx, bset->n_div == 0, goto error);
+	n_div = isl_basic_set_dim(bset, isl_dim_div);
 	dim = isl_basic_set_total_dim(bset);
 
-	lin = isl_basic_set_alloc_space(isl_basic_set_get_space(bset), 0, dim, 0);
+	lin = isl_basic_set_alloc_space(isl_basic_set_get_space(bset),
+					n_div, dim, 0);
+	for (i = 0; i < n_div; ++i)
+		if (isl_basic_set_alloc_div(lin) < 0)
+			goto error;
 	if (!lin)
 		goto error;
 	for (i = 0; i < bset->n_eq; ++i) {
@@ -1472,9 +1400,10 @@ error:
 }
 
 /* Compute the (linear) hull of the lineality spaces of the basic sets in the
- * "underlying" set "set".
+ * set "set".
  */
-static struct isl_basic_set *uset_combined_lineality_space(struct isl_set *set)
+__isl_give isl_basic_set *isl_set_combined_lineality_space(
+	__isl_take isl_set *set)
 {
 	int i;
 	struct isl_set *lin = NULL;
@@ -1482,9 +1411,9 @@ static struct isl_basic_set *uset_combined_lineality_space(struct isl_set *set)
 	if (!set)
 		return NULL;
 	if (set->n == 0) {
-		isl_space *dim = isl_set_get_space(set);
+		isl_space *space = isl_set_get_space(set);
 		isl_set_free(set);
-		return isl_basic_set_empty(dim);
+		return isl_basic_set_empty(space);
 	}
 
 	lin = isl_set_alloc_space(isl_set_get_space(set), set->n, 0);
@@ -1503,44 +1432,53 @@ static struct isl_basic_set *uset_combined_lineality_space(struct isl_set *set)
  * lineality space.  If any of the intermediate results has
  * a non-trivial lineality space, it is projected out.
  */
-static struct isl_basic_set *uset_convex_hull_unbounded(struct isl_set *set)
+static __isl_give isl_basic_set *uset_convex_hull_unbounded(
+	__isl_take isl_set *set)
 {
-	struct isl_basic_set *convex_hull = NULL;
+	isl_basic_set_list *list;
 
-	convex_hull = isl_set_copy_basic_set(set);
-	set = isl_set_drop_basic_set(set, convex_hull);
-	if (!set)
-		goto error;
-	while (set->n > 0) {
+	list = isl_set_get_basic_set_list(set);
+	isl_set_free(set);
+
+	while (list) {
+		int n;
 		struct isl_basic_set *t;
-		t = isl_set_copy_basic_set(set);
-		if (!t)
-			goto error;
-		set = isl_set_drop_basic_set(set, t);
-		if (!set)
-			goto error;
-		convex_hull = convex_hull_pair(convex_hull, t);
-		if (set->n == 0)
-			break;
-		t = isl_basic_set_lineality_space(isl_basic_set_copy(convex_hull));
+		isl_basic_set *bset1, *bset2;
+
+		n = isl_basic_set_list_n_basic_set(list);
+		if (n < 2)
+			isl_die(isl_basic_set_list_get_ctx(list),
+				isl_error_internal,
+				"expecting at least two elements", goto error);
+		bset1 = isl_basic_set_list_get_basic_set(list, n - 1);
+		bset2 = isl_basic_set_list_get_basic_set(list, n - 2);
+		bset1 = convex_hull_pair(bset1, bset2);
+		if (n == 2) {
+			isl_basic_set_list_free(list);
+			return bset1;
+		}
+		bset1 = isl_basic_set_underlying_set(bset1);
+		list = isl_basic_set_list_drop(list, n - 2, 2);
+		list = isl_basic_set_list_add(list, bset1);
+
+		t = isl_basic_set_list_get_basic_set(list, n - 2);
+		t = isl_basic_set_lineality_space(t);
 		if (!t)
 			goto error;
 		if (isl_basic_set_plain_is_universe(t)) {
-			isl_basic_set_free(convex_hull);
-			convex_hull = t;
-			break;
+			isl_basic_set_list_free(list);
+			return t;
 		}
 		if (t->n_eq < isl_basic_set_total_dim(t)) {
-			set = isl_set_add_basic_set(set, convex_hull);
+			set = isl_basic_set_list_union(list);
 			return modulo_lineality(set, t);
 		}
 		isl_basic_set_free(t);
 	}
-	isl_set_free(set);
-	return convex_hull;
+
+	return NULL;
 error:
-	isl_set_free(set);
-	isl_basic_set_free(convex_hull);
+	isl_basic_set_list_free(list);
 	return NULL;
 }
 
@@ -1548,8 +1486,8 @@ error:
  * facet.
  * This function assumes that the given set is bounded.
  */
-static struct isl_basic_set *initial_hull(struct isl_basic_set *hull,
-	struct isl_set *set)
+static __isl_give isl_basic_set *initial_hull(__isl_take isl_basic_set *hull,
+	__isl_keep isl_set *set)
 {
 	struct isl_mat *bounds = NULL;
 	unsigned dim;
@@ -1650,8 +1588,8 @@ static int has_constraint(struct isl_ctx *ctx, struct isl_hash_table *table,
  * all other basic sets and is therefore the convex hull of set.
  * In this case we set *is_hull to 1.
  */
-static struct isl_basic_set *common_constraints(struct isl_basic_set *hull,
-	struct isl_set *set, int *is_hull)
+static __isl_give isl_basic_set *common_constraints(
+	__isl_take isl_basic_set *hull, __isl_keep isl_set *set, int *is_hull)
 {
 	int i, j, s, n;
 	int min_constraints;
@@ -1771,7 +1709,8 @@ error:
  * obvious facet constraints, if any.  If the result happens to
  * be the convex hull of "set" then *is_hull is set to 1.
  */
-static struct isl_basic_set *proto_hull(struct isl_set *set, int *is_hull)
+static __isl_give isl_basic_set *proto_hull(__isl_keep isl_set *set,
+	int *is_hull)
 {
 	struct isl_basic_set *hull;
 	unsigned n_ineq;
@@ -1789,7 +1728,7 @@ static struct isl_basic_set *proto_hull(struct isl_set *set, int *is_hull)
 	return common_constraints(hull, set, is_hull);
 }
 
-static struct isl_basic_set *uset_convex_hull_wrap(struct isl_set *set)
+static __isl_give isl_basic_set *uset_convex_hull_wrap(__isl_take isl_set *set)
 {
 	struct isl_basic_set *hull;
 	int is_hull;
@@ -1811,8 +1750,9 @@ static struct isl_basic_set *uset_convex_hull_wrap(struct isl_set *set)
  * the Fourier-Motzkin elimination based convex hull.
  * We also handle a few special cases before checking the boundedness.
  */
-static struct isl_basic_set *uset_convex_hull(struct isl_set *set)
+static __isl_give isl_basic_set *uset_convex_hull(__isl_take isl_set *set)
 {
+	isl_bool bounded;
 	struct isl_basic_set *convex_hull = NULL;
 	struct isl_basic_set *lin;
 
@@ -1823,8 +1763,6 @@ static struct isl_basic_set *uset_convex_hull(struct isl_set *set)
 	set = isl_set_set_rational(set);
 
 	if (!set)
-		goto error;
-	if (!set)
 		return NULL;
 	if (set->n == 1) {
 		convex_hull = isl_basic_set_copy(set->p[0]);
@@ -1834,11 +1772,13 @@ static struct isl_basic_set *uset_convex_hull(struct isl_set *set)
 	if (isl_set_n_dim(set) == 1)
 		return convex_hull_1d(set);
 
-	if (isl_set_is_bounded(set) &&
-	    set->ctx->opt->convex == ISL_CONVEX_HULL_WRAP)
+	bounded = isl_set_is_bounded(set);
+	if (bounded < 0)
+		goto error;
+	if (bounded && set->ctx->opt->convex == ISL_CONVEX_HULL_WRAP)
 		return uset_convex_hull_wrap(set);
 
-	lin = uset_combined_lineality_space(isl_set_copy(set));
+	lin = isl_set_combined_lineality_space(isl_set_copy(set));
 	if (!lin)
 		goto error;
 	if (isl_basic_set_plain_is_universe(lin)) {
@@ -1860,7 +1800,8 @@ error:
  * without parameters or divs and where the convex hull of set is
  * known to be full-dimensional.
  */
-static struct isl_basic_set *uset_convex_hull_wrap_bounded(struct isl_set *set)
+static __isl_give isl_basic_set *uset_convex_hull_wrap_bounded(
+	__isl_take isl_set *set)
 {
 	struct isl_basic_set *convex_hull = NULL;
 
@@ -1898,8 +1839,8 @@ error:
  * convex hull of the transformed set and then add the equalities back
  * (after performing the inverse transformation.
  */
-static struct isl_basic_set *modulo_affine_hull(
-	struct isl_set *set, struct isl_basic_set *affine_hull)
+static __isl_give isl_basic_set *modulo_affine_hull(
+	__isl_take isl_set *set, __isl_take isl_basic_set *affine_hull)
 {
 	struct isl_mat *T;
 	struct isl_mat *T2;
@@ -1917,6 +1858,8 @@ static struct isl_basic_set *modulo_affine_hull(
 	convex_hull = isl_basic_set_intersect(convex_hull, affine_hull);
 	return convex_hull;
 error:
+	isl_mat_free(T);
+	isl_mat_free(T2);
 	isl_basic_set_free(affine_hull);
 	isl_set_free(set);
 	return NULL;
@@ -1939,7 +1882,7 @@ static __isl_give isl_basic_map *replace_map_by_empty_basic_map(
  * The implementation was inspired by "Extended Convex Hull" by Fukuda et al.,
  * specifically, the wrapping of facets to obtain new facets.
  */
-struct isl_basic_map *isl_map_convex_hull(struct isl_map *map)
+__isl_give isl_basic_map *isl_map_convex_hull(__isl_take isl_map *map)
 {
 	struct isl_basic_set *bset;
 	struct isl_basic_map *model = NULL;
@@ -1948,7 +1891,7 @@ struct isl_basic_map *isl_map_convex_hull(struct isl_map *map)
 	struct isl_set *set = NULL;
 
 	map = isl_map_detect_equalities(map);
-	map = isl_map_align_divs(map);
+	map = isl_map_align_divs_internal(map);
 	if (!map)
 		goto error;
 
@@ -1986,8 +1929,7 @@ error:
 
 struct isl_basic_set *isl_set_convex_hull(struct isl_set *set)
 {
-	return (struct isl_basic_set *)
-		isl_map_convex_hull((struct isl_map *)set);
+	return bset_from_bmap(isl_map_convex_hull(set_to_map(set)));
 }
 
 __isl_give isl_basic_map *isl_map_polyhedral_hull(__isl_take isl_map *map)
@@ -2000,7 +1942,7 @@ __isl_give isl_basic_map *isl_map_polyhedral_hull(__isl_take isl_map *map)
 
 __isl_give isl_basic_set *isl_set_polyhedral_hull(__isl_take isl_set *set)
 {
-	return (isl_basic_set *)isl_map_polyhedral_hull((isl_map *)set);
+	return bset_from_bmap(isl_map_polyhedral_hull(set_to_map(set)));
 }
 
 struct sh_data_entry {
@@ -2074,7 +2016,7 @@ static int hash_ineq(struct isl_ctx *ctx, struct isl_hash_table *table,
  * The value in the hash table is a pointer to the (in)equality of "bset".
  */
 static int hash_basic_set(struct isl_hash_table *table,
-				struct isl_basic_set *bset)
+	__isl_keep isl_basic_set *bset)
 {
 	int i, j;
 	unsigned dim = isl_basic_set_total_dim(bset);
@@ -2093,7 +2035,7 @@ static int hash_basic_set(struct isl_hash_table *table,
 	return 0;
 }
 
-static struct sh_data *sh_data_alloc(struct isl_set *set, unsigned n_ineq)
+static struct sh_data *sh_data_alloc(__isl_keep isl_set *set, unsigned n_ineq)
 {
 	struct sh_data *data;
 	int i;
@@ -2132,7 +2074,7 @@ error:
  *	  0 if "ineq" may attain arbitrarily small values on basic set "j"
  *	 -1 if some error occurred
  */
-static int is_bound(struct sh_data *data, struct isl_set *set, int j,
+static int is_bound(struct sh_data *data, __isl_keep isl_set *set, int j,
 	isl_int *ineq, int shift)
 {
 	enum isl_lp_result res;
@@ -2223,8 +2165,8 @@ static void set_max_constant_term(struct sh_data *data, __isl_keep isl_set *set,
  * translate and the inequality is therefore known to be a bound
  * of this basic set.
  */
-static struct isl_basic_set *add_bound(struct isl_basic_set *hull,
-	struct sh_data *data, struct isl_set *set, int i, isl_int *ineq,
+static __isl_give isl_basic_set *add_bound(__isl_take isl_basic_set *hull,
+	struct sh_data *data, __isl_keep isl_set *set, int i, isl_int *ineq,
 	int shift)
 {
 	uint32_t c_hash;
@@ -2305,8 +2247,8 @@ error:
  * become a bound on the whole set.  If so, add the (relaxed) inequality
  * to "hull".  Relaxation is only allowed if "shift" is set.
  */
-static struct isl_basic_set *add_bounds(struct isl_basic_set *bset,
-	struct sh_data *data, struct isl_set *set, int i, int shift)
+static __isl_give isl_basic_set *add_bounds(__isl_take isl_basic_set *bset,
+	struct sh_data *data, __isl_keep isl_set *set, int i, int shift)
 {
 	int j, k;
 	unsigned dim = isl_basic_set_total_dim(bset);
@@ -2441,7 +2383,7 @@ static __isl_give isl_basic_map *map_simple_hull(__isl_take isl_map *map,
 		return map_simple_hull_trivial(map);
 	affine_hull = isl_map_affine_hull(isl_map_copy(map));
 	input = isl_map_copy(map);
-	map = isl_map_align_divs(map);
+	map = isl_map_align_divs_internal(map);
 	model = map ? isl_basic_map_copy(map->p[0]) : NULL;
 
 	set = isl_map_underlying_set(map);
@@ -2476,8 +2418,7 @@ __isl_give isl_basic_map *isl_map_simple_hull(__isl_take isl_map *map)
 
 struct isl_basic_set *isl_set_simple_hull(struct isl_set *set)
 {
-	return (struct isl_basic_set *)
-		isl_map_simple_hull((struct isl_map *)set);
+	return bset_from_bmap(isl_map_simple_hull(set_to_map(set)));
 }
 
 /* Compute a superset of the convex hull of map that is described
@@ -2976,7 +2917,7 @@ error:
 
 /* Return a sequence of the basic maps that make up the maps in "list".
  */
-static __isl_give isl_basic_set_list *collect_basic_maps(
+static __isl_give isl_basic_map_list *collect_basic_maps(
 	__isl_take isl_map_list *list)
 {
 	int i, n;
@@ -3055,7 +2996,7 @@ static struct isl_basic_set *set_bounds(struct isl_set *set, int dim)
  * resulting hull is bounded by a symbolic constant.  If not, the
  * hull is intersected with the corresponding bounds on the whole set.
  */
-struct isl_basic_set *isl_set_bounded_simple_hull(struct isl_set *set)
+__isl_give isl_basic_set *isl_set_bounded_simple_hull(__isl_take isl_set *set)
 {
 	int i, j;
 	struct isl_basic_set *hull;
@@ -3117,5 +3058,6 @@ struct isl_basic_set *isl_set_bounded_simple_hull(struct isl_set *set)
 	return hull;
 error:
 	isl_set_free(set);
+	isl_basic_set_free(hull);
 	return NULL;
 }
diff --git a/lib/Analysis/isl/isl_dim_map.c b/lib/Analysis/isl/isl_dim_map.c
index 102b8e8..cc104c6 100644
--- a/lib/Analysis/isl/isl_dim_map.c
+++ b/lib/Analysis/isl/isl_dim_map.c
@@ -43,8 +43,7 @@ __isl_give isl_dim_map *isl_dim_map_alloc(isl_ctx *ctx, unsigned len)
 }
 
 void isl_dim_map_range(__isl_keep isl_dim_map *dim_map,
-	unsigned dst_pos, unsigned dst_stride,
-	unsigned src_pos, unsigned src_stride,
+	unsigned dst_pos, int dst_stride, unsigned src_pos, int src_stride,
 	unsigned n, int sign)
 {
 	int i;
@@ -189,6 +188,9 @@ __isl_give isl_dim_map *isl_dim_map_extend(__isl_keep isl_dim_map *dim_map,
 	struct isl_dim_map *res;
 	int offset;
 
+	if (!dim_map)
+		return NULL;
+
 	offset = isl_basic_map_offset(bmap, isl_dim_div);
 
 	res = isl_dim_map_alloc(bmap->ctx, dim_map->len - 1 + bmap->n_div);
diff --git a/lib/Analysis/isl/isl_dim_map.h b/lib/Analysis/isl/isl_dim_map.h
index 0f988c3..0c39b49 100644
--- a/lib/Analysis/isl/isl_dim_map.h
+++ b/lib/Analysis/isl/isl_dim_map.h
@@ -4,14 +4,14 @@
 #include <isl/ctx.h>
 #include <isl/space.h>
 #include <isl/map.h>
+#include <isl_reordering.h>
 
 struct isl_dim_map;
 typedef struct isl_dim_map isl_dim_map;
 
 __isl_give isl_dim_map *isl_dim_map_alloc(isl_ctx *ctx, unsigned len);
 void isl_dim_map_range(__isl_keep isl_dim_map *dim_map,
-	unsigned dst_pos, unsigned dst_stride,
-	unsigned src_pos, unsigned src_stride,
+	unsigned dst_pos, int dst_stride, unsigned src_pos, int src_stride,
 	unsigned n, int sign);
 void isl_dim_map_dim_range(__isl_keep isl_dim_map *dim_map,
 	isl_space *dim, enum isl_dim_type type,
diff --git a/lib/Analysis/isl/isl_equalities.c b/lib/Analysis/isl/isl_equalities.c
index a43aa42..0501cd9 100644
--- a/lib/Analysis/isl/isl_equalities.c
+++ b/lib/Analysis/isl/isl_equalities.c
@@ -305,8 +305,8 @@ error:
  * as any y = y_0 + G y' with y' integer is a solution to the original
  * modulo constraints.
  */
-struct isl_mat *isl_mat_parameter_compression(
-			struct isl_mat *B, struct isl_vec *d)
+__isl_give isl_mat *isl_mat_parameter_compression(__isl_take isl_mat *B,
+	__isl_take isl_vec *d)
 {
 	int i;
 	struct isl_mat *cst = NULL;
@@ -493,7 +493,7 @@ static __isl_give isl_mat *insert_parameter_rows(__isl_take isl_mat *mat,
  * The number of equality constraints in B is assumed to be smaller than
  * or equal to the number of variables x.
  * "first" is the position of the first x variable.
- * The preceding variables are considered to by y-variables.
+ * The preceding variables are considered to be y-variables.
  * If T2 is not NULL, then *T2 is set to a matrix mapping [1 x] to [1 x'].
  *
  * First compute the (left) Hermite normal form of M,
@@ -689,7 +689,8 @@ static struct isl_basic_set *compress_variables(
 			isl_mat_free(*T2);
 			*T2 = NULL;
 		}
-		return isl_basic_set_set_to_empty(bset);
+		bset = isl_basic_set_set_to_empty(bset);
+		return return_with_identity(bset, T, T2);
 	}
 
 	bset = isl_basic_set_preimage(bset, T ? isl_mat_copy(TC) : TC);
@@ -731,20 +732,24 @@ error:
  * If i_dim does not belong to such a residue class, then *modulo
  * is set to 1 and *residue is set to 0.
  */
-int isl_basic_set_dim_residue_class(struct isl_basic_set *bset,
+isl_stat isl_basic_set_dim_residue_class(__isl_keep isl_basic_set *bset,
 	int pos, isl_int *modulo, isl_int *residue)
 {
+	isl_bool fixed;
 	struct isl_ctx *ctx;
 	struct isl_mat *H = NULL, *U = NULL, *C, *H1, *U1;
 	unsigned total;
 	unsigned nparam;
 
 	if (!bset || !modulo || !residue)
-		return -1;
+		return isl_stat_error;
 
-	if (isl_basic_set_plain_dim_is_fixed(bset, pos, residue)) {
+	fixed = isl_basic_set_plain_dim_is_fixed(bset, pos, residue);
+	if (fixed < 0)
+		return isl_stat_error;
+	if (fixed) {
 		isl_int_set_si(*modulo, 0);
-		return 0;
+		return isl_stat_ok;
 	}
 
 	ctx = isl_basic_set_get_ctx(bset);
@@ -753,7 +758,7 @@ int isl_basic_set_dim_residue_class(struct isl_basic_set *bset,
 	H = isl_mat_sub_alloc6(ctx, bset->eq, 0, bset->n_eq, 1, total);
 	H = isl_mat_left_hermite(H, 0, &U, NULL);
 	if (!H)
-		return -1;
+		return isl_stat_error;
 
 	isl_seq_gcd(U->row[nparam + pos]+bset->n_eq,
 			total-bset->n_eq, modulo);
@@ -763,7 +768,7 @@ int isl_basic_set_dim_residue_class(struct isl_basic_set *bset,
 		isl_int_set_si(*residue, 0);
 		isl_mat_free(H);
 		isl_mat_free(U);
-		return 0;
+		return isl_stat_ok;
 	}
 
 	C = isl_mat_alloc(ctx, 1 + bset->n_eq, 1);
@@ -780,23 +785,23 @@ int isl_basic_set_dim_residue_class(struct isl_basic_set *bset,
 	isl_mat_free(U);
 	C = isl_mat_product(U1, C);
 	if (!C)
-		return -1;
+		return isl_stat_error;
 	if (!isl_int_is_divisible_by(C->row[1][0], C->row[0][0])) {
 		bset = isl_basic_set_copy(bset);
 		bset = isl_basic_set_set_to_empty(bset);
 		isl_basic_set_free(bset);
 		isl_int_set_si(*modulo, 1);
 		isl_int_set_si(*residue, 0);
-		return 0;
+		return isl_stat_ok;
 	}
 	isl_int_divexact(*residue, C->row[1][0], C->row[0][0]);
 	isl_int_fdiv_r(*residue, *residue, *modulo);
 	isl_mat_free(C);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_mat_free(H);
 	isl_mat_free(U);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Check if dimension dim belongs to a residue class
@@ -808,7 +813,7 @@ error:
  * If i_dim does not belong to such a residue class, then *modulo
  * is set to 1 and *residue is set to 0.
  */
-int isl_set_dim_residue_class(struct isl_set *set,
+isl_stat isl_set_dim_residue_class(__isl_keep isl_set *set,
 	int pos, isl_int *modulo, isl_int *residue)
 {
 	isl_int m;
@@ -816,22 +821,22 @@ int isl_set_dim_residue_class(struct isl_set *set,
 	int i;
 
 	if (!set || !modulo || !residue)
-		return -1;
+		return isl_stat_error;
 
 	if (set->n == 0) {
 		isl_int_set_si(*modulo, 0);
 		isl_int_set_si(*residue, 0);
-		return 0;
+		return isl_stat_ok;
 	}
 
 	if (isl_basic_set_dim_residue_class(set->p[0], pos, modulo, residue)<0)
-		return -1;
+		return isl_stat_error;
 
 	if (set->n == 1)
-		return 0;
+		return isl_stat_ok;
 
 	if (isl_int_is_one(*modulo))
-		return 0;
+		return isl_stat_ok;
 
 	isl_int_init(m);
 	isl_int_init(r);
@@ -851,11 +856,11 @@ int isl_set_dim_residue_class(struct isl_set *set,
 	isl_int_clear(m);
 	isl_int_clear(r);
 
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_int_clear(m);
 	isl_int_clear(r);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Check if dimension "dim" belongs to a residue class
diff --git a/lib/Analysis/isl/isl_equalities.h b/lib/Analysis/isl/isl_equalities.h
index a64d123..0de8347 100644
--- a/lib/Analysis/isl/isl_equalities.h
+++ b/lib/Analysis/isl/isl_equalities.h
@@ -21,8 +21,8 @@ __isl_give isl_mat *isl_mat_final_variable_compression(__isl_take isl_mat *B,
 	int first, __isl_give isl_mat **T2);
 __isl_give isl_mat *isl_mat_variable_compression(__isl_take isl_mat *B,
 	__isl_give isl_mat **T2);
-struct isl_mat *isl_mat_parameter_compression(
-			struct isl_mat *B, struct isl_vec *d);
+__isl_give isl_mat *isl_mat_parameter_compression(__isl_take isl_mat *B,
+	__isl_take isl_vec *d);
 __isl_give isl_mat *isl_mat_parameter_compression_ext(__isl_take isl_mat *B,
 	__isl_take isl_mat *A);
 struct isl_basic_set *isl_basic_set_remove_equalities(
diff --git a/lib/Analysis/isl/isl_factorization.h b/lib/Analysis/isl/isl_factorization.h
index 4687b9c..4d769d9 100644
--- a/lib/Analysis/isl/isl_factorization.h
+++ b/lib/Analysis/isl/isl_factorization.h
@@ -1,3 +1,6 @@
+#ifndef ISL_FACTORIZATION_H
+#define ISL_FACTORIZATION_H
+
 #include <isl/set.h>
 #include <isl_morph.h>
 
@@ -27,3 +30,5 @@ void isl_factorizer_dump(__isl_take isl_factorizer *f);
 #if defined(__cplusplus)
 }
 #endif
+
+#endif
diff --git a/lib/Analysis/isl/isl_farkas.c b/lib/Analysis/isl/isl_farkas.c
index dddb49a..cb45a63 100644
--- a/lib/Analysis/isl/isl_farkas.c
+++ b/lib/Analysis/isl/isl_farkas.c
@@ -281,8 +281,8 @@ static __isl_give isl_basic_set *farkas(__isl_take isl_space *space,
 	}
 
 	dual = isl_basic_set_remove_divs(dual);
-	isl_basic_set_simplify(dual);
-	isl_basic_set_finalize(dual);
+	dual = isl_basic_set_simplify(dual);
+	dual = isl_basic_set_finalize(dual);
 
 	isl_basic_set_free(bset);
 	return dual;
@@ -371,6 +371,24 @@ __isl_give isl_basic_set *isl_set_coefficients(__isl_take isl_set *set)
 	return coeff;
 }
 
+/* Wrapper around isl_basic_set_coefficients for use
+ * as a isl_basic_set_list_map callback.
+ */
+static __isl_give isl_basic_set *coefficients_wrap(
+	__isl_take isl_basic_set *bset, void *user)
+{
+	return isl_basic_set_coefficients(bset);
+}
+
+/* Replace the elements of "list" by the result of applying
+ * isl_basic_set_coefficients to them.
+ */
+__isl_give isl_basic_set_list *isl_basic_set_list_coefficients(
+	__isl_take isl_basic_set_list *list)
+{
+	return isl_basic_set_list_map(list, &coefficients_wrap, NULL);
+}
+
 /* Construct a basic set containing the elements that satisfy all
  * affine constraints whose coefficient tuples are
  * contained in the given set.
diff --git a/lib/Analysis/isl/isl_flow.c b/lib/Analysis/isl/isl_flow.c
index b5ae691..37a29b0 100644
--- a/lib/Analysis/isl/isl_flow.c
+++ b/lib/Analysis/isl/isl_flow.c
@@ -23,6 +23,7 @@
 #include <isl/flow.h>
 #include <isl/schedule_node.h>
 #include <isl_sort.h>
+#include <isl/stream.h>
 
 enum isl_restriction_type {
 	isl_restriction_type_empty,
@@ -159,10 +160,15 @@ struct isl_labeled_map {
 	int		must;
 };
 
+typedef int (*isl_access_coscheduled)(void *first, void *second);
+
 /* A structure containing the input for dependence analysis:
  * - a sink
  * - n_must + n_may (<= max_source) sources
  * - a function for determining the relative order of sources and sink
+ * - an optional function "coscheduled" for determining whether sources
+ *   may be coscheduled.  If "coscheduled" is NULL, then the sources
+ *   are assumed not to be coscheduled.
  * The must sources are placed before the may sources.
  *
  * domain_map is an auxiliary map that maps the sink access relation
@@ -177,6 +183,7 @@ struct isl_access_info {
 	isl_map				*domain_map;
 	struct isl_labeled_map		sink;
 	isl_access_level_before		level_before;
+	isl_access_coscheduled		coscheduled;
 
 	isl_access_restrict		restrict_fn;
 	void				*restrict_user;
@@ -304,6 +311,13 @@ error:
 	return NULL;
 }
 
+/* A helper struct carrying the isl_access_info and an error condition.
+ */
+struct access_sort_info {
+	isl_access_info *access_info;
+	int error;
+};
+
 /* Return -n, 0 or n (with n a positive value), depending on whether
  * the source access identified by p1 should be sorted before, together
  * or after that identified by p2.
@@ -316,10 +330,18 @@ error:
  * If not, we try to order the two statements based on the description
  * of the iteration domains.  This results in an arbitrary, but fairly
  * stable ordering.
+ *
+ * In case of an error, sort_info.error is set to true and all elements are
+ * reported to be equal.
  */
 static int access_sort_cmp(const void *p1, const void *p2, void *user)
 {
-	isl_access_info *acc = user;
+	struct access_sort_info *sort_info = user;
+	isl_access_info *acc = sort_info->access_info;
+
+	if (sort_info->error)
+		return 0;
+
 	const struct isl_labeled_map *i1, *i2;
 	int level1, level2;
 	uint32_t h1, h2;
@@ -327,16 +349,23 @@ static int access_sort_cmp(const void *p1, const void *p2, void *user)
 	i2 = (const struct isl_labeled_map *) p2;
 
 	level1 = acc->level_before(i1->data, i2->data);
+	if (level1 < 0)
+		goto error;
 	if (level1 % 2)
 		return -1;
 
 	level2 = acc->level_before(i2->data, i1->data);
+	if (level2 < 0)
+		goto error;
 	if (level2 % 2)
 		return 1;
 
 	h1 = isl_map_get_hash(i1->map);
 	h2 = isl_map_get_hash(i2->map);
 	return h1 > h2 ? 1 : h1 < h2 ? -1 : 0;
+error:
+	sort_info->error = 1;
+	return 0;
 }
 
 /* Sort the must source accesses in their textual order.
@@ -344,13 +373,20 @@ static int access_sort_cmp(const void *p1, const void *p2, void *user)
 static __isl_give isl_access_info *isl_access_info_sort_sources(
 	__isl_take isl_access_info *acc)
 {
+	struct access_sort_info sort_info;
+
+	sort_info.access_info = acc;
+	sort_info.error = 0;
+
 	if (!acc)
 		return NULL;
 	if (acc->n_must <= 1)
 		return acc;
 
 	if (isl_sort(acc->source, acc->n_must, sizeof(struct isl_labeled_map),
-		    access_sort_cmp, acc) < 0)
+		    access_sort_cmp, &sort_info) < 0)
+		return isl_access_info_free(acc);
+	if (sort_info.error)
 		return isl_access_info_free(acc);
 
 	return acc;
@@ -362,12 +398,21 @@ static __isl_give isl_access_info *isl_access_info_sort_sources(
 static __isl_give isl_space *space_align_and_join(__isl_take isl_space *left,
 	__isl_take isl_space *right)
 {
-	if (isl_space_match(left, isl_dim_param, right, isl_dim_param))
+	isl_bool equal_params;
+
+	equal_params = isl_space_has_equal_params(left, right);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return isl_space_join(left, right);
 
 	left = isl_space_align_params(left, isl_space_copy(right));
 	right = isl_space_align_params(right, isl_space_copy(left));
 	return isl_space_join(left, right);
+error:
+	isl_space_free(left);
+	isl_space_free(right);
+	return NULL;
 }
 
 /* Initialize an empty isl_flow structure corresponding to a given
@@ -674,24 +719,31 @@ static int can_precede_at_level(int shared_level, int target_level)
  *
  * If temp_rel[j] is empty, then there can be no improvement and
  * we return immediately.
+ *
+ * This function returns isl_stat_ok in case it was executed successfully and
+ * isl_stat_error in case of errors during the execution of this function.
  */
-static int intermediate_sources(__isl_keep isl_access_info *acc,
+static isl_stat intermediate_sources(__isl_keep isl_access_info *acc,
 	struct isl_map **temp_rel, int j, int sink_level)
 {
 	int k, level;
 	int depth = 2 * isl_map_dim(acc->source[j].map, isl_dim_in) + 1;
 
 	if (isl_map_plain_is_empty(temp_rel[j]))
-		return 0;
+		return isl_stat_ok;
 
 	for (k = j - 1; k >= 0; --k) {
 		int plevel, plevel2;
 		plevel = acc->level_before(acc->source[k].data, acc->sink.data);
+		if (plevel < 0)
+			return isl_stat_error;
 		if (!can_precede_at_level(plevel, sink_level))
 			continue;
 
 		plevel2 = acc->level_before(acc->source[j].data,
 						acc->source[k].data);
+		if (plevel2 < 0)
+			return isl_stat_error;
 
 		for (level = sink_level; level <= depth; ++level) {
 			struct isl_map *T;
@@ -714,7 +766,7 @@ static int intermediate_sources(__isl_keep isl_access_info *acc,
 		}
 	}
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Compute all iterations of may source j that precedes the sink at the given
@@ -740,7 +792,7 @@ static __isl_give isl_map *all_sources(__isl_keep isl_access_info *acc,
 }
 
 /* For a given mapping between iterations of must source k and iterations
- * of the sink, compute the all iteration of may source j preceding
+ * of the sink, compute all iterations of may source j preceding
  * the sink at level before_level for any of the sink iterations,
  * but following the corresponding iteration of must source k at level
  * after_level.
@@ -800,6 +852,8 @@ static __isl_give isl_map *all_intermediate_sources(
 
 		plevel = acc->level_before(acc->source[k].data,
 					acc->source[acc->n_must + j].data);
+		if (plevel < 0)
+			return isl_map_free(map);
 
 		for (level = sink_level; level <= depth; ++level) {
 			isl_map *T;
@@ -831,6 +885,145 @@ static __isl_give isl_map *all_intermediate_sources(
 	return map;
 }
 
+/* Given a dependence relation "old_map" between a must-source and the sink,
+ * return a subset of the dependences, augmented with instances
+ * of the source at position "pos" in "acc" that are coscheduled
+ * with the must-source and that access the same element.
+ * That is, if the input lives in a space T -> K, then the output
+ * lives in the space [T -> S] -> K, with S the space of source "pos", and
+ * the domain factor of the domain product is a subset of the input.
+ * The sources are considered to be coscheduled if they have the same values
+ * for the initial "depth" coordinates.
+ *
+ * First construct a dependence relation S -> K and a mapping
+ * between coscheduled sources T -> S.
+ * The second is combined with the original dependence relation T -> K
+ * to form a relation in T -> [S -> K], which is subsequently
+ * uncurried to [T -> S] -> K.
+ * This result is then intersected with the dependence relation S -> K
+ * to form the output.
+ *
+ * In case a negative depth is given, NULL is returned to indicate an error.
+ */
+static __isl_give isl_map *coscheduled_source(__isl_keep isl_access_info *acc,
+	__isl_keep isl_map *old_map, int pos, int depth)
+{
+	isl_space *space;
+	isl_set *set_C;
+	isl_map *read_map;
+	isl_map *write_map;
+	isl_map *dep_map;
+	isl_map *equal;
+	isl_map *map;
+
+	if (depth < 0)
+		return NULL;
+
+	set_C = isl_map_range(isl_map_copy(old_map));
+	read_map = isl_map_copy(acc->sink.map);
+	read_map = isl_map_intersect_domain(read_map, set_C);
+	write_map = isl_map_copy(acc->source[pos].map);
+	dep_map = isl_map_domain_product(write_map, read_map);
+	dep_map = isl_set_unwrap(isl_map_domain(dep_map));
+	space = isl_space_join(isl_map_get_space(old_map),
+				isl_space_reverse(isl_map_get_space(dep_map)));
+	equal = isl_map_from_basic_map(isl_basic_map_equal(space, depth));
+	map = isl_map_range_product(equal, isl_map_copy(old_map));
+	map = isl_map_uncurry(map);
+	map = isl_map_intersect_domain_factor_range(map, dep_map);
+
+	return map;
+}
+
+/* After the dependences derived from a must-source have been computed
+ * at a certain level, check if any of the sources of the must-dependences
+ * may be coscheduled with other sources.
+ * If they are any such sources, then there is no way of determining
+ * which of the sources actually comes last and the must-dependences
+ * need to be turned into may-dependences, while dependences from
+ * the other sources need to be added to the may-dependences as well.
+ * "acc" describes the sources and a callback for checking whether
+ * two sources may be coscheduled.  If acc->coscheduled is NULL then
+ * the sources are assumed not to be coscheduled.
+ * "must_rel" and "may_rel" describe the must and may-dependence relations
+ * computed at the current level for the must-sources.  Some of the dependences
+ * may be moved from "must_rel" to "may_rel".
+ * "flow" contains all dependences computed so far (apart from those
+ * in "must_rel" and "may_rel") and may be updated with additional
+ * dependences derived from may-sources.
+ *
+ * In particular, consider all the must-sources with a non-empty
+ * dependence relation in "must_rel".  They are considered in reverse
+ * order because that is the order in which they are considered in the caller.
+ * If any of the must-sources are coscheduled, then the last one
+ * is the one that will have a corresponding dependence relation.
+ * For each must-source i, consider both all the previous must-sources
+ * and all the may-sources.  If any of those may be coscheduled with
+ * must-source i, then compute the coscheduled instances that access
+ * the same memory elements.  The result is a relation [T -> S] -> K.
+ * The projection onto T -> K is a subset of the must-dependence relation
+ * that needs to be turned into may-dependences.
+ * The projection onto S -> K needs to be added to the may-dependences
+ * of source S.
+ * Since a given must-source instance may be coscheduled with several
+ * other source instances, the dependences that need to be turned
+ * into may-dependences are first collected and only actually removed
+ * from the must-dependences after all other sources have been considered.
+ */
+static __isl_give isl_flow *handle_coscheduled(__isl_keep isl_access_info *acc,
+	__isl_keep isl_map **must_rel, __isl_keep isl_map **may_rel,
+	__isl_take isl_flow *flow)
+{
+	int i, j;
+
+	if (!acc->coscheduled)
+		return flow;
+	for (i = acc->n_must - 1; i >= 0; --i) {
+		isl_map *move;
+
+		if (isl_map_plain_is_empty(must_rel[i]))
+			continue;
+		move = isl_map_empty(isl_map_get_space(must_rel[i]));
+		for (j = i - 1; j >= 0; --j) {
+			int depth;
+			isl_map *map, *factor;
+
+			if (!acc->coscheduled(acc->source[i].data,
+						acc->source[j].data))
+				continue;
+			depth = acc->level_before(acc->source[i].data,
+						acc->source[j].data) / 2;
+			map = coscheduled_source(acc, must_rel[i], j, depth);
+			factor = isl_map_domain_factor_range(isl_map_copy(map));
+			may_rel[j] = isl_map_union(may_rel[j], factor);
+			map = isl_map_domain_factor_domain(map);
+			move = isl_map_union(move, map);
+		}
+		for (j = 0; j < acc->n_may; ++j) {
+			int depth, pos;
+			isl_map *map, *factor;
+
+			pos = acc->n_must + j;
+			if (!acc->coscheduled(acc->source[i].data,
+						acc->source[pos].data))
+				continue;
+			depth = acc->level_before(acc->source[i].data,
+						acc->source[pos].data) / 2;
+			map = coscheduled_source(acc, must_rel[i], pos, depth);
+			factor = isl_map_domain_factor_range(isl_map_copy(map));
+			pos = 2 * acc->n_must + j;
+			flow->dep[pos].map = isl_map_union(flow->dep[pos].map,
+							    factor);
+			map = isl_map_domain_factor_domain(map);
+			move = isl_map_union(move, map);
+		}
+		must_rel[i] = isl_map_subtract(must_rel[i], isl_map_copy(move));
+		may_rel[i] = isl_map_union(may_rel[i], move);
+	}
+
+	return flow;
+}
+
 /* Compute dependences for the case where all accesses are "may"
  * accesses, which boils down to computing memory based dependences.
  * The generic algorithm would also work in this case, but it would
@@ -859,6 +1052,9 @@ static __isl_give isl_flow *compute_mem_based_dependences(
 		isl_map *dep;
 
 		plevel = acc->level_before(acc->source[i].data, acc->sink.data);
+		if (plevel < 0)
+			goto error;
+
 		is_before = plevel & 1;
 		plevel >>= 1;
 
@@ -879,6 +1075,11 @@ static __isl_give isl_flow *compute_mem_based_dependences(
 	res->must_no_source = mustdo;
 
 	return res;
+error:
+	isl_set_free(mustdo);
+	isl_set_free(maydo);
+	isl_flow_free(res);
+	return NULL;
 }
 
 /* Compute dependences for the case where there is at least one
@@ -908,7 +1109,12 @@ static __isl_give isl_flow *compute_mem_based_dependences(
  * need to be considered.  These iterations are split into those that
  * haven't been matched to any source access (mustdo) and those that have only
  * been matched to may accesses (maydo).
- * At the end of each level, we also consider the may accesses.
+ * At the end of each level, must-sources and may-sources that are coscheduled
+ * with the sources of the must-dependences at that level are considered.
+ * If any coscheduled instances are found, then corresponding may-dependences
+ * are added and the original must-dependences are turned into may-dependences.
+ * Afterwards, the may accesses that occur after must-dependence sources
+ * are considered.
  * In particular, we consider may accesses that precede the remaining
  * sink iterations, moving elements from mustdo to maydo when appropriate,
  * and may accesses that occur between a must source and a sink of any 
@@ -944,8 +1150,8 @@ static __isl_give isl_flow *compute_val_based_dependences(
 	if (isl_set_plain_is_empty(mustdo))
 		goto done;
 
-	must_rel = isl_alloc_array(ctx, struct isl_map *, acc->n_must);
-	may_rel = isl_alloc_array(ctx, struct isl_map *, acc->n_must);
+	must_rel = isl_calloc_array(ctx, struct isl_map *, acc->n_must);
+	may_rel = isl_calloc_array(ctx, struct isl_map *, acc->n_must);
 	if (!must_rel || !may_rel)
 		goto error;
 
@@ -964,6 +1170,8 @@ static __isl_give isl_flow *compute_val_based_dependences(
 
 			plevel = acc->level_before(acc->source[j].data,
 						     acc->sink.data);
+			if (plevel < 0)
+				goto error;
 			if (!can_precede_at_level(plevel, level))
 				continue;
 
@@ -971,13 +1179,15 @@ static __isl_give isl_flow *compute_val_based_dependences(
 			must_rel[j] = isl_map_union_disjoint(must_rel[j], T);
 			mustdo = rest;
 
-			intermediate_sources(acc, must_rel, j, level);
+			if (intermediate_sources(acc, must_rel, j, level) < 0)
+				goto error;
 
 			T = last_source(acc, maydo, j, level, &rest);
 			may_rel[j] = isl_map_union_disjoint(may_rel[j], T);
 			maydo = rest;
 
-			intermediate_sources(acc, may_rel, j, level);
+			if (intermediate_sources(acc, may_rel, j, level) < 0)
+				goto error;
 
 			if (isl_set_plain_is_empty(mustdo) &&
 			    isl_set_plain_is_empty(maydo))
@@ -988,13 +1198,19 @@ static __isl_give isl_flow *compute_val_based_dependences(
 
 			plevel = acc->level_before(acc->source[j].data,
 						     acc->sink.data);
+			if (plevel < 0)
+				goto error;
 			if (!can_precede_at_level(plevel, level))
 				continue;
 
-			intermediate_sources(acc, must_rel, j, level);
-			intermediate_sources(acc, may_rel, j, level);
+			if (intermediate_sources(acc, must_rel, j, level) < 0)
+				goto error;
+			if (intermediate_sources(acc, may_rel, j, level) < 0)
+				goto error;
 		}
 
+		handle_coscheduled(acc, must_rel, may_rel, res);
+
 		for (j = 0; j < acc->n_may; ++j) {
 			int plevel;
 			isl_map *T;
@@ -1002,6 +1218,8 @@ static __isl_give isl_flow *compute_val_based_dependences(
 
 			plevel = acc->level_before(acc->source[acc->n_must + j].data,
 						     acc->sink.data);
+			if (plevel < 0)
+				goto error;
 			if (!can_precede_at_level(plevel, level))
 				continue;
 
@@ -1042,6 +1260,12 @@ done:
 	res->may_no_source = maydo;
 	return res;
 error:
+	if (must_rel)
+		for (j = 0; j < acc->n_must; ++j)
+			isl_map_free(must_rel[j]);
+	if (may_rel)
+		for (j = 0; j < acc->n_must; ++j)
+			isl_map_free(may_rel[j]);
 	isl_flow_free(res);
 	isl_set_free(mustdo);
 	isl_set_free(maydo);
@@ -1210,11 +1434,28 @@ error:
 	return NULL;
 }
 
+/* The different types of access relations that isl_union_access_info
+ * keeps track of.
+
+ * "isl_access_sink" represents the sink accesses.
+ * "isl_access_must_source" represents the definite source accesses.
+ * "isl_access_may_source" represents the possible source accesses.
+ * "isl_access_kill" represents the kills.
+ *
+ * isl_access_sink is sometimes treated differently and
+ * should therefore appear first.
+ */
+enum isl_access_type {
+	isl_access_sink,
+	isl_access_must_source,
+	isl_access_may_source,
+	isl_access_kill,
+	isl_access_end
+};
+
 /* This structure represents the input for a dependence analysis computation.
  *
- * "sink" represents the sink accesses.
- * "must_source" represents the definite source accesses.
- * "may_source" represents the possible source accesses.
+ * "access" contains the access relations.
  *
  * "schedule" or "schedule_map" represents the execution order.
  * Exactly one of these fields should be NULL.  The other field
@@ -1227,9 +1468,7 @@ error:
  * the "schedule_map" field no longer contains useful information.
  */
 struct isl_union_access_info {
-	isl_union_map *sink;
-	isl_union_map *must_source;
-	isl_union_map *may_source;
+	isl_union_map *access[isl_access_end];
 
 	isl_schedule *schedule;
 	isl_union_map *schedule_map;
@@ -1240,12 +1479,13 @@ struct isl_union_access_info {
 __isl_null isl_union_access_info *isl_union_access_info_free(
 	__isl_take isl_union_access_info *access)
 {
+	enum isl_access_type i;
+
 	if (!access)
 		return NULL;
 
-	isl_union_map_free(access->sink);
-	isl_union_map_free(access->must_source);
-	isl_union_map_free(access->may_source);
+	for (i = isl_access_sink; i < isl_access_end; ++i)
+		isl_union_map_free(access->access[i]);
 	isl_schedule_free(access->schedule);
 	isl_union_map_free(access->schedule_map);
 	free(access);
@@ -1257,85 +1497,174 @@ __isl_null isl_union_access_info *isl_union_access_info_free(
  */
 isl_ctx *isl_union_access_info_get_ctx(__isl_keep isl_union_access_info *access)
 {
-	return access ? isl_union_map_get_ctx(access->sink) : NULL;
+	if (!access)
+		return NULL;
+	return isl_union_map_get_ctx(access->access[isl_access_sink]);
 }
 
-/* Create a new isl_union_access_info with the given sink accesses and
- * and no source accesses or schedule information.
+/* Construct an empty (invalid) isl_union_access_info object.
+ * The caller is responsible for setting the sink access relation and
+ * initializing all the other fields, e.g., by calling
+ * isl_union_access_info_init.
+ */
+static __isl_give isl_union_access_info *isl_union_access_info_alloc(
+	isl_ctx *ctx)
+{
+	return isl_calloc_type(ctx, isl_union_access_info);
+}
+
+/* Initialize all the fields of "info", except the sink access relation,
+ * which is assumed to have been set by the caller.
  *
  * By default, we use the schedule field of the isl_union_access_info,
  * but this may be overridden by a call
  * to isl_union_access_info_set_schedule_map.
  */
+static __isl_give isl_union_access_info *isl_union_access_info_init(
+	__isl_take isl_union_access_info *info)
+{
+	isl_space *space;
+	isl_union_map *empty;
+	enum isl_access_type i;
+
+	if (!info)
+		return NULL;
+	if (!info->access[isl_access_sink])
+		return isl_union_access_info_free(info);
+
+	space = isl_union_map_get_space(info->access[isl_access_sink]);
+	empty = isl_union_map_empty(isl_space_copy(space));
+	for (i = isl_access_sink + 1; i < isl_access_end; ++i)
+		if (!info->access[i])
+			info->access[i] = isl_union_map_copy(empty);
+	isl_union_map_free(empty);
+	if (!info->schedule && !info->schedule_map)
+		info->schedule = isl_schedule_empty(isl_space_copy(space));
+	isl_space_free(space);
+
+	for (i = isl_access_sink + 1; i < isl_access_end; ++i)
+		if (!info->access[i])
+			return isl_union_access_info_free(info);
+	if (!info->schedule && !info->schedule_map)
+		return isl_union_access_info_free(info);
+
+	return info;
+}
+
+/* Create a new isl_union_access_info with the given sink accesses and
+ * and no other accesses or schedule information.
+ */
 __isl_give isl_union_access_info *isl_union_access_info_from_sink(
 	__isl_take isl_union_map *sink)
 {
 	isl_ctx *ctx;
-	isl_space *space;
-	isl_union_map *empty;
 	isl_union_access_info *access;
 
 	if (!sink)
 		return NULL;
 	ctx = isl_union_map_get_ctx(sink);
-	access = isl_alloc_type(ctx, isl_union_access_info);
+	access = isl_union_access_info_alloc(ctx);
 	if (!access)
 		goto error;
-
-	space = isl_union_map_get_space(sink);
-	empty = isl_union_map_empty(isl_space_copy(space));
-	access->sink = sink;
-	access->must_source = isl_union_map_copy(empty);
-	access->may_source = empty;
-	access->schedule = isl_schedule_empty(space);
-	access->schedule_map = NULL;
-
-	if (!access->sink || !access->must_source ||
-	    !access->may_source || !access->schedule)
-		return isl_union_access_info_free(access);
-
-	return access;
+	access->access[isl_access_sink] = sink;
+	return isl_union_access_info_init(access);
 error:
 	isl_union_map_free(sink);
 	return NULL;
 }
 
-/* Replace the definite source accesses of "access" by "must_source".
+/* Replace the access relation of type "type" of "info" by "access".
  */
-__isl_give isl_union_access_info *isl_union_access_info_set_must_source(
-	__isl_take isl_union_access_info *access,
-	__isl_take isl_union_map *must_source)
+static __isl_give isl_union_access_info *isl_union_access_info_set(
+	__isl_take isl_union_access_info *info,
+	enum isl_access_type type, __isl_take isl_union_map *access)
 {
-	if (!access || !must_source)
+	if (!info || !access)
 		goto error;
 
-	isl_union_map_free(access->must_source);
-	access->must_source = must_source;
+	isl_union_map_free(info->access[type]);
+	info->access[type] = access;
 
-	return access;
+	return info;
 error:
-	isl_union_access_info_free(access);
-	isl_union_map_free(must_source);
+	isl_union_access_info_free(info);
+	isl_union_map_free(access);
 	return NULL;
 }
 
+/* Replace the definite source accesses of "access" by "must_source".
+ */
+__isl_give isl_union_access_info *isl_union_access_info_set_must_source(
+	__isl_take isl_union_access_info *access,
+	__isl_take isl_union_map *must_source)
+{
+	return isl_union_access_info_set(access, isl_access_must_source,
+					must_source);
+}
+
 /* Replace the possible source accesses of "access" by "may_source".
  */
 __isl_give isl_union_access_info *isl_union_access_info_set_may_source(
 	__isl_take isl_union_access_info *access,
 	__isl_take isl_union_map *may_source)
 {
-	if (!access || !may_source)
-		goto error;
+	return isl_union_access_info_set(access, isl_access_may_source,
+					may_source);
+}
+
+/* Replace the kills of "info" by "kill".
+ */
+__isl_give isl_union_access_info *isl_union_access_info_set_kill(
+	__isl_take isl_union_access_info *info, __isl_take isl_union_map *kill)
+{
+	return isl_union_access_info_set(info, isl_access_kill, kill);
+}
 
-	isl_union_map_free(access->may_source);
-	access->may_source = may_source;
+/* Return the access relation of type "type" of "info".
+ */
+static __isl_give isl_union_map *isl_union_access_info_get(
+	__isl_keep isl_union_access_info *info, enum isl_access_type type)
+{
+	if (!info)
+		return NULL;
+	return isl_union_map_copy(info->access[type]);
+}
 
-	return access;
-error:
-	isl_union_access_info_free(access);
-	isl_union_map_free(may_source);
-	return NULL;
+/* Return the definite source accesses of "info".
+ */
+__isl_give isl_union_map *isl_union_access_info_get_must_source(
+	__isl_keep isl_union_access_info *info)
+{
+	return isl_union_access_info_get(info, isl_access_must_source);
+}
+
+/* Return the possible source accesses of "info".
+ */
+__isl_give isl_union_map *isl_union_access_info_get_may_source(
+	__isl_keep isl_union_access_info *info)
+{
+	return isl_union_access_info_get(info, isl_access_may_source);
+}
+
+/* Return the kills of "info".
+ */
+__isl_give isl_union_map *isl_union_access_info_get_kill(
+	__isl_keep isl_union_access_info *info)
+{
+	return isl_union_access_info_get(info, isl_access_kill);
+}
+
+/* Does "info" specify any kills?
+ */
+static isl_bool isl_union_access_has_kill(
+	__isl_keep isl_union_access_info *info)
+{
+	isl_bool empty;
+
+	if (!info)
+		return isl_bool_error;
+	empty = isl_union_map_is_empty(info->access[isl_access_kill]);
+	return isl_bool_not(empty);
 }
 
 /* Replace the schedule of "access" by "schedule".
@@ -1384,15 +1713,15 @@ __isl_give isl_union_access_info *isl_union_access_info_copy(
 	__isl_keep isl_union_access_info *access)
 {
 	isl_union_access_info *copy;
+	enum isl_access_type i;
 
 	if (!access)
 		return NULL;
 	copy = isl_union_access_info_from_sink(
-				isl_union_map_copy(access->sink));
-	copy = isl_union_access_info_set_must_source(copy,
-				isl_union_map_copy(access->must_source));
-	copy = isl_union_access_info_set_may_source(copy,
-				isl_union_map_copy(access->may_source));
+		    isl_union_map_copy(access->access[isl_access_sink]));
+	for (i = isl_access_sink + 1; i < isl_access_end; ++i)
+		copy = isl_union_access_info_set(copy, i,
+					isl_union_map_copy(access->access[i]));
 	if (access->schedule)
 		copy = isl_union_access_info_set_schedule(copy,
 				isl_schedule_copy(access->schedule));
@@ -1419,26 +1748,76 @@ static __isl_give isl_printer *print_union_map_field(__isl_take isl_printer *p,
 	return p;
 }
 
+/* An enumeration of the various keys that may appear in a YAML mapping
+ * of an isl_union_access_info object.
+ * The keys for the access relation types are assumed to have the same values
+ * as the access relation types in isl_access_type.
+ */
+enum isl_ai_key {
+	isl_ai_key_error = -1,
+	isl_ai_key_sink = isl_access_sink,
+	isl_ai_key_must_source = isl_access_must_source,
+	isl_ai_key_may_source = isl_access_may_source,
+	isl_ai_key_kill = isl_access_kill,
+	isl_ai_key_schedule_map,
+	isl_ai_key_schedule,
+	isl_ai_key_end
+};
+
+/* Textual representations of the YAML keys for an isl_union_access_info
+ * object.
+ */
+static char *key_str[] = {
+	[isl_ai_key_sink] = "sink",
+	[isl_ai_key_must_source] = "must_source",
+	[isl_ai_key_may_source] = "may_source",
+	[isl_ai_key_kill] = "kill",
+	[isl_ai_key_schedule_map] = "schedule_map",
+	[isl_ai_key_schedule] = "schedule",
+};
+
+/* Print a key-value pair corresponding to the access relation of type "type"
+ * of a YAML mapping of "info" to "p".
+ *
+ * The sink access relation is always printed, but any other access relation
+ * is only printed if it is non-empty.
+ */
+static __isl_give isl_printer *print_access_field(__isl_take isl_printer *p,
+	__isl_keep isl_union_access_info *info, enum isl_access_type type)
+{
+	if (type != isl_access_sink) {
+		isl_bool empty;
+
+		empty = isl_union_map_is_empty(info->access[type]);
+		if (empty < 0)
+			return isl_printer_free(p);
+		if (empty)
+			return p;
+	}
+	return print_union_map_field(p, key_str[type], info->access[type]);
+}
+
 /* Print the information contained in "access" to "p".
  * The information is printed as a YAML document.
  */
 __isl_give isl_printer *isl_printer_print_union_access_info(
 	__isl_take isl_printer *p, __isl_keep isl_union_access_info *access)
 {
+	enum isl_access_type i;
+
 	if (!access)
 		return isl_printer_free(p);
 
 	p = isl_printer_yaml_start_mapping(p);
-	p = print_union_map_field(p, "sink", access->sink);
-	p = print_union_map_field(p, "must_source", access->must_source);
-	p = print_union_map_field(p, "may_source", access->may_source);
+	for (i = isl_access_sink; i < isl_access_end; ++i)
+		p = print_access_field(p, access, i);
 	if (access->schedule) {
-		p = isl_printer_print_str(p, "schedule");
+		p = isl_printer_print_str(p, key_str[isl_ai_key_schedule]);
 		p = isl_printer_yaml_next(p);
 		p = isl_printer_print_schedule(p, access->schedule);
 		p = isl_printer_yaml_next(p);
 	} else {
-		p = print_union_map_field(p, "schedule_map",
+		p = print_union_map_field(p, key_str[isl_ai_key_schedule_map],
 						access->schedule_map);
 	}
 	p = isl_printer_yaml_end_mapping(p);
@@ -1467,6 +1846,119 @@ __isl_give char *isl_union_access_info_to_str(
 	return s;
 }
 
+#undef KEY
+#define KEY enum isl_ai_key
+#undef KEY_ERROR
+#define KEY_ERROR isl_ai_key_error
+#undef KEY_END
+#define KEY_END isl_ai_key_end
+#include "extract_key.c"
+
+#undef BASE
+#define BASE union_map
+#include "read_in_string_templ.c"
+
+/* Read an isl_union_access_info object from "s".
+ *
+ * Start off with an empty (invalid) isl_union_access_info object and
+ * then fill up the fields based on the input.
+ * The input needs to contain at least a description of the sink
+ * access relation as well as some form of schedule.
+ * The other access relations are set to empty relations
+ * by isl_union_access_info_init if they are not specified in the input.
+ */
+__isl_give isl_union_access_info *isl_stream_read_union_access_info(
+	isl_stream *s)
+{
+	isl_ctx *ctx;
+	isl_union_access_info *info;
+	int more;
+	int sink_set = 0;
+	int schedule_set = 0;
+
+	if (isl_stream_yaml_read_start_mapping(s))
+		return NULL;
+
+	ctx = isl_stream_get_ctx(s);
+	info = isl_union_access_info_alloc(ctx);
+	while ((more = isl_stream_yaml_next(s)) > 0) {
+		enum isl_ai_key key;
+		isl_union_map *access, *schedule_map;
+		isl_schedule *schedule;
+
+		key = get_key(s);
+		if (isl_stream_yaml_next(s) < 0)
+			return isl_union_access_info_free(info);
+		switch (key) {
+		case isl_ai_key_end:
+		case isl_ai_key_error:
+			return isl_union_access_info_free(info);
+		case isl_ai_key_sink:
+			sink_set = 1;
+		case isl_ai_key_must_source:
+		case isl_ai_key_may_source:
+		case isl_ai_key_kill:
+			access = read_union_map(s);
+			info = isl_union_access_info_set(info, key, access);
+			if (!info)
+				return NULL;
+			break;
+		case isl_ai_key_schedule_map:
+			schedule_set = 1;
+			schedule_map = read_union_map(s);
+			info = isl_union_access_info_set_schedule_map(info,
+								schedule_map);
+			if (!info)
+				return NULL;
+			break;
+		case isl_ai_key_schedule:
+			schedule_set = 1;
+			schedule = isl_stream_read_schedule(s);
+			info = isl_union_access_info_set_schedule(info,
+								schedule);
+			if (!info)
+				return NULL;
+			break;
+		}
+	}
+	if (more < 0)
+		return isl_union_access_info_free(info);
+
+	if (isl_stream_yaml_read_end_mapping(s) < 0) {
+		isl_stream_error(s, NULL, "unexpected extra elements");
+		return isl_union_access_info_free(info);
+	}
+
+	if (!sink_set) {
+		isl_stream_error(s, NULL, "no sink specified");
+		return isl_union_access_info_free(info);
+	}
+
+	if (!schedule_set) {
+		isl_stream_error(s, NULL, "no schedule specified");
+		return isl_union_access_info_free(info);
+	}
+
+	return isl_union_access_info_init(info);
+}
+
+/* Read an isl_union_access_info object from the file "input".
+ */
+__isl_give isl_union_access_info *isl_union_access_info_read_from_file(
+	isl_ctx *ctx, FILE *input)
+{
+	isl_stream *s;
+	isl_union_access_info *access;
+
+	s = isl_stream_new_file(ctx, input);
+	if (!s)
+		return NULL;
+	access = isl_stream_read_union_access_info(s);
+	isl_stream_free(s);
+
+	return access;
+}
+
 /* Update the fields of "access" such that they all have the same parameters,
  * keeping in mind that the schedule_map field may be NULL and ignoring
  * the schedule field.
@@ -1475,23 +1967,21 @@ static __isl_give isl_union_access_info *isl_union_access_info_align_params(
 	__isl_take isl_union_access_info *access)
 {
 	isl_space *space;
+	enum isl_access_type i;
 
 	if (!access)
 		return NULL;
 
-	space = isl_union_map_get_space(access->sink);
-	space = isl_space_align_params(space,
-				isl_union_map_get_space(access->must_source));
-	space = isl_space_align_params(space,
-				isl_union_map_get_space(access->may_source));
+	space = isl_union_map_get_space(access->access[isl_access_sink]);
+	for (i = isl_access_sink + 1; i < isl_access_end; ++i)
+		space = isl_space_align_params(space,
+				isl_union_map_get_space(access->access[i]));
 	if (access->schedule_map)
 		space = isl_space_align_params(space,
 				isl_union_map_get_space(access->schedule_map));
-	access->sink = isl_union_map_align_params(access->sink,
-							isl_space_copy(space));
-	access->must_source = isl_union_map_align_params(access->must_source,
-							isl_space_copy(space));
-	access->may_source = isl_union_map_align_params(access->may_source,
+	for (i = isl_access_sink; i < isl_access_end; ++i)
+		access->access[i] =
+			isl_union_map_align_params(access->access[i],
 							isl_space_copy(space));
 	if (!access->schedule_map) {
 		isl_space_free(space);
@@ -1502,8 +1992,9 @@ static __isl_give isl_union_access_info *isl_union_access_info_align_params(
 			return isl_union_access_info_free(access);
 	}
 
-	if (!access->sink || !access->must_source || !access->may_source)
-		return isl_union_access_info_free(access);
+	for (i = isl_access_sink; i < isl_access_end; ++i)
+		if (!access->access[i])
+			return isl_union_access_info_free(access);
 
 	return access;
 }
@@ -1535,22 +2026,23 @@ isl_union_access_info_introduce_schedule(
 	__isl_take isl_union_access_info *access)
 {
 	isl_union_map *sm;
+	enum isl_access_type i;
 
 	if (!access)
 		return NULL;
 
 	sm = isl_union_map_reverse(access->schedule_map);
 	sm = isl_union_map_range_map(sm);
-	access->sink = isl_union_map_apply_range(isl_union_map_copy(sm),
-						access->sink);
-	access->may_source = isl_union_map_apply_range(isl_union_map_copy(sm),
-						access->may_source);
-	access->must_source = isl_union_map_apply_range(isl_union_map_copy(sm),
-						access->must_source);
+	for (i = isl_access_sink; i < isl_access_end; ++i)
+		access->access[i] =
+			isl_union_map_apply_range(isl_union_map_copy(sm),
+						access->access[i]);
 	access->schedule_map = sm;
 
-	if (!access->sink || !access->must_source ||
-	    !access->may_source || !access->schedule_map)
+	for (i = isl_access_sink; i < isl_access_end; ++i)
+		if (!access->access[i])
+			return isl_union_access_info_free(access);
+	if (!access->schedule_map)
 		return isl_union_access_info_free(access);
 
 	return access;
@@ -1741,6 +2233,36 @@ error:
 	return NULL;
 }
 
+/* Copy this isl_union_flow object.
+ */
+__isl_give isl_union_flow *isl_union_flow_copy(__isl_keep isl_union_flow *flow)
+{
+	isl_union_flow *copy;
+
+	if (!flow)
+		return NULL;
+
+	copy = isl_union_flow_alloc(isl_union_map_get_space(flow->must_dep));
+
+	if (!copy)
+		return NULL;
+
+	copy->must_dep = isl_union_map_union(copy->must_dep,
+		isl_union_map_copy(flow->must_dep));
+	copy->may_dep = isl_union_map_union(copy->may_dep,
+		isl_union_map_copy(flow->may_dep));
+	copy->must_no_source = isl_union_map_union(copy->must_no_source,
+		isl_union_map_copy(flow->must_no_source));
+	copy->may_no_source = isl_union_map_union(copy->may_no_source,
+		isl_union_map_copy(flow->may_no_source));
+
+	if (!copy->must_dep || !copy->may_dep ||
+	    !copy->must_no_source || !copy->may_no_source)
+		return isl_union_flow_free(copy);
+
+	return copy;
+}
+
 /* Drop the schedule dimensions from the iteration domains in "flow".
  * In particular, the schedule dimensions have been prepended
  * to the iteration domains prior to the dependence analysis by
@@ -1900,6 +2422,40 @@ static int before(void *first, void *second)
 	return 2 * n1;
 }
 
+/* Check if the given two accesses may be coscheduled.
+ * If so, return 1.  Otherwise return 0.
+ *
+ * Two accesses may only be coscheduled if the fixed schedule
+ * coordinates have the same values.
+ */
+static int coscheduled(void *first, void *second)
+{
+	struct isl_sched_info *info1 = first;
+	struct isl_sched_info *info2 = second;
+	int n1, n2;
+	int i;
+
+	n1 = isl_vec_size(info1->cst);
+	n2 = isl_vec_size(info2->cst);
+
+	if (n2 < n1)
+		n1 = n2;
+
+	for (i = 0; i < n1; ++i) {
+		int cmp;
+
+		if (!info1->is_cst[i])
+			continue;
+		if (!info2->is_cst[i])
+			continue;
+		cmp = isl_vec_cmp_element(info1->cst, info2->cst, i);
+		if (cmp != 0)
+			return 0;
+	}
+
+	return 1;
+}
+
 /* Given a sink access, look for all the source accesses that access
  * the same array and perform dataflow analysis on them using
  * isl_access_info_compute_flow_core.
@@ -1939,6 +2495,7 @@ static isl_stat compute_flow(__isl_take isl_map *map, void *user)
 	if (!data->sink_info || (data->count && !data->source_info) ||
 	    !data->accesses)
 		goto error;
+	data->accesses->coscheduled = &coscheduled;
 	data->count = 0;
 	data->must = 1;
 	if (isl_union_map_foreach_map(data->must_source,
@@ -1995,6 +2552,69 @@ error:
 	return isl_stat_error;
 }
 
+/* Add the kills of "info" to the must-sources.
+ */
+static __isl_give isl_union_access_info *
+isl_union_access_info_add_kill_to_must_source(
+	__isl_take isl_union_access_info *info)
+{
+	isl_union_map *must, *kill;
+
+	must = isl_union_access_info_get_must_source(info);
+	kill = isl_union_access_info_get_kill(info);
+	must = isl_union_map_union(must, kill);
+	return isl_union_access_info_set_must_source(info, must);
+}
+
+/* Drop dependences from "flow" that purely originate from kills.
+ * That is, only keep those dependences that originate from
+ * the original must-sources "must" and/or the original may-sources "may".
+ * In particular, "must" contains the must-sources from before
+ * the kills were added and "may" contains the may-source from before
+ * the kills were removed.
+ *
+ * The dependences are of the form
+ *
+ *	Source -> [Sink -> Data]
+ *
+ * Only those dependences are kept where the Source -> Data part
+ * is a subset of the original may-sources or must-sources.
+ * Of those, only the must-dependences that intersect with the must-sources
+ * remain must-dependences.
+ * If there is some overlap between the may-sources and the must-sources,
+ * then the may-dependences and must-dependences may also overlap.
+ * This should be fine since the may-dependences are only kept
+ * disjoint from the must-dependences for the isl_union_map_compute_flow
+ * interface.  This interface does not support kills, so it will
+ * not end up calling this function.
+ */
+static __isl_give isl_union_flow *isl_union_flow_drop_kill_source(
+	__isl_take isl_union_flow *flow, __isl_take isl_union_map *must,
+	__isl_take isl_union_map *may)
+{
+	isl_union_map *move;
+
+	if (!flow)
+		goto error;
+	move = isl_union_map_copy(flow->must_dep);
+	move = isl_union_map_intersect_range_factor_range(move,
+				isl_union_map_copy(may));
+	may = isl_union_map_union(may, isl_union_map_copy(must));
+	flow->may_dep = isl_union_map_intersect_range_factor_range(
+				flow->may_dep, may);
+	flow->must_dep = isl_union_map_intersect_range_factor_range(
+				flow->must_dep, must);
+	flow->may_dep = isl_union_map_union(flow->may_dep, move);
+	if (!flow->must_dep || !flow->may_dep)
+		return isl_union_flow_free(flow);
+
+	return flow;
+error:
+	isl_union_map_free(must);
+	isl_union_map_free(may);
+	return NULL;
+}
+
 /* Remove the must accesses from the may accesses.
  *
  * A must access always trumps a may access, so there is no need
@@ -2007,9 +2627,10 @@ static __isl_give isl_union_access_info *isl_union_access_info_normalize(
 {
 	if (!access)
 		return NULL;
-	access->may_source = isl_union_map_subtract(access->may_source,
-				    isl_union_map_copy(access->must_source));
-	if (!access->may_source)
+	access->access[isl_access_may_source] =
+		isl_union_map_subtract(access->access[isl_access_may_source],
+		    isl_union_map_copy(access->access[isl_access_must_source]));
+	if (!access->access[isl_access_may_source])
 		return isl_union_access_info_free(access);
 
 	return access;
@@ -2038,18 +2659,20 @@ static __isl_give isl_union_flow *compute_flow_union_map(
 	__isl_take isl_union_access_info *access)
 {
 	struct isl_compute_flow_data data;
+	isl_union_map *sink;
 
 	access = isl_union_access_info_align_params(access);
 	access = isl_union_access_info_introduce_schedule(access);
 	if (!access)
 		return NULL;
 
-	data.must_source = access->must_source;
-	data.may_source = access->may_source;
+	data.must_source = access->access[isl_access_must_source];
+	data.may_source = access->access[isl_access_may_source];
 
-	data.flow = isl_union_flow_alloc(isl_union_map_get_space(access->sink));
+	sink = access->access[isl_access_sink];
+	data.flow = isl_union_flow_alloc(isl_union_map_get_space(sink));
 
-	if (isl_union_map_foreach_map(access->sink, &compute_flow, &data) < 0)
+	if (isl_union_map_foreach_map(sink, &compute_flow, &data) < 0)
 		goto error;
 
 	data.flow = isl_union_flow_drop_schedule(data.flow);
@@ -2179,21 +2802,21 @@ static isl_bool count_sink_source(__isl_keep isl_schedule_node *node,
 
 	domain = isl_schedule_node_get_universe_domain(node);
 
-	umap = isl_union_map_copy(data->access->sink);
+	umap = isl_union_map_copy(data->access->access[isl_access_sink]);
 	umap = isl_union_map_intersect_domain(umap, isl_union_set_copy(domain));
 	data->n_sink += isl_union_map_n_map(umap);
 	isl_union_map_free(umap);
 	if (!umap)
 		r = isl_bool_error;
 
-	umap = isl_union_map_copy(data->access->must_source);
+	umap = isl_union_map_copy(data->access->access[isl_access_must_source]);
 	umap = isl_union_map_intersect_domain(umap, isl_union_set_copy(domain));
 	data->n_source += isl_union_map_n_map(umap);
 	isl_union_map_free(umap);
 	if (!umap)
 		r = isl_bool_error;
 
-	umap = isl_union_map_copy(data->access->may_source);
+	umap = isl_union_map_copy(data->access->access[isl_access_may_source]);
 	umap = isl_union_map_intersect_domain(umap, isl_union_set_copy(domain));
 	data->n_source += isl_union_map_n_map(umap);
 	isl_union_map_free(umap);
@@ -2268,7 +2891,7 @@ static isl_bool collect_sink_source(__isl_keep isl_schedule_node *node,
 	prefix = isl_union_map_range_map(prefix);
 
 	data->set_sink = 1;
-	umap = isl_union_map_copy(data->access->sink);
+	umap = isl_union_map_copy(data->access->access[isl_access_sink]);
 	umap = isl_union_map_apply_range(isl_union_map_copy(prefix), umap);
 	if (isl_union_map_foreach_map(umap, &extract_sink_source, data) < 0)
 		r = isl_bool_error;
@@ -2276,7 +2899,7 @@ static isl_bool collect_sink_source(__isl_keep isl_schedule_node *node,
 
 	data->set_sink = 0;
 	data->must = 1;
-	umap = isl_union_map_copy(data->access->must_source);
+	umap = isl_union_map_copy(data->access->access[isl_access_must_source]);
 	umap = isl_union_map_apply_range(isl_union_map_copy(prefix), umap);
 	if (isl_union_map_foreach_map(umap, &extract_sink_source, data) < 0)
 		r = isl_bool_error;
@@ -2284,7 +2907,7 @@ static isl_bool collect_sink_source(__isl_keep isl_schedule_node *node,
 
 	data->set_sink = 0;
 	data->must = 0;
-	umap = isl_union_map_copy(data->access->may_source);
+	umap = isl_union_map_copy(data->access->access[isl_access_may_source]);
 	umap = isl_union_map_apply_range(isl_union_map_copy(prefix), umap);
 	if (isl_union_map_foreach_map(umap, &extract_sink_source, data) < 0)
 		r = isl_bool_error;
@@ -2339,6 +2962,19 @@ static int before_node(void *first, void *second)
 	return 2 * depth + before;
 }
 
+/* Check if the given two accesses may be coscheduled.
+ * If so, return 1.  Otherwise return 0.
+ *
+ * Two accesses may only be coscheduled if they appear in the same leaf.
+ */
+static int coscheduled_node(void *first, void *second)
+{
+	isl_schedule_node *node1 = first;
+	isl_schedule_node *node2 = second;
+
+	return node1 == node2;
+}
+
 /* Add the scheduled sources from "data" that access
  * the same data space as "sink" to "access".
  */
@@ -2409,6 +3045,8 @@ static __isl_give isl_union_flow *compute_single_flow(
 
 	access = isl_access_info_alloc(isl_map_copy(sink->access), sink->node,
 					&before_node, data->n_source);
+	if (access)
+		access->coscheduled = &coscheduled_node;
 	access = add_matching_sources(access, sink, data);
 
 	flow = access_info_compute_flow_core(access);
@@ -2466,6 +3104,7 @@ static __isl_give isl_union_flow *compute_flow_schedule(
 	struct isl_compute_flow_schedule_data data = { access };
 	int i, n;
 	isl_ctx *ctx;
+	isl_space *space;
 	isl_union_flow *flow;
 
 	ctx = isl_union_access_info_get_ctx(access);
@@ -2488,7 +3127,8 @@ static __isl_give isl_union_flow *compute_flow_schedule(
 					    &collect_sink_source, &data) < 0)
 		goto error;
 
-	flow = isl_union_flow_alloc(isl_union_map_get_space(access->sink));
+	space = isl_union_map_get_space(access->access[isl_access_sink]);
+	flow = isl_union_flow_alloc(space);
 
 	isl_compute_flow_schedule_data_align_params(&data);
 
@@ -2517,20 +3157,44 @@ error:
  * map domain elements of access->{may,must)_source to
  * domain elements of access->sink.
  *
+ * If any kills have been specified, then they are treated as
+ * must-sources internally.  Any dependence that purely derives
+ * from an original kill is removed from the output.
+ *
  * We check whether the schedule is available as a schedule tree
- * or a schedule map and call the correpsonding function to perform
+ * or a schedule map and call the corresponding function to perform
  * the analysis.
  */
 __isl_give isl_union_flow *isl_union_access_info_compute_flow(
 	__isl_take isl_union_access_info *access)
 {
+	isl_bool has_kill;
+	isl_union_map *must = NULL, *may = NULL;
+	isl_union_flow *flow;
+
+	has_kill = isl_union_access_has_kill(access);
+	if (has_kill < 0)
+		goto error;
+	if (has_kill) {
+		must = isl_union_access_info_get_must_source(access);
+		may = isl_union_access_info_get_may_source(access);
+	}
+	access = isl_union_access_info_add_kill_to_must_source(access);
 	access = isl_union_access_info_normalize(access);
 	if (!access)
-		return NULL;
+		goto error;
 	if (access->schedule)
-		return compute_flow_schedule(access);
+		flow = compute_flow_schedule(access);
 	else
-		return compute_flow_union_map(access);
+		flow = compute_flow_union_map(access);
+	if (has_kill)
+		flow = isl_union_flow_drop_kill_source(flow, must, may);
+	return flow;
+error:
+	isl_union_access_info_free(access);
+	isl_union_map_free(must);
+	isl_union_map_free(may);
+	return NULL;
 }
 
 /* Print the information contained in "flow" to "p".
@@ -2545,8 +3209,10 @@ __isl_give isl_printer *isl_printer_print_union_flow(
 		return isl_printer_free(p);
 
 	p = isl_printer_yaml_start_mapping(p);
-	p = print_union_map_field(p, "must_dependence", flow->must_dep);
-	umap = isl_union_flow_get_may_dependence(flow);
+	umap = isl_union_flow_get_full_must_dependence(flow);
+	p = print_union_map_field(p, "must_dependence", umap);
+	isl_union_map_free(umap);
+	umap = isl_union_flow_get_full_may_dependence(flow);
 	p = print_union_map_field(p, "may_dependence", umap);
 	isl_union_map_free(umap);
 	p = print_union_map_field(p, "must_no_source", flow->must_no_source);
diff --git a/lib/Analysis/isl/isl_fold.c b/lib/Analysis/isl/isl_fold.c
index e05ee10..1ba8815 100644
--- a/lib/Analysis/isl/isl_fold.c
+++ b/lib/Analysis/isl/isl_fold.c
@@ -169,6 +169,16 @@ error:
 	return NULL;
 }
 
+/* Given a dimension type for an isl_qpolynomial_fold,
+ * return the corresponding type for the domain.
+ */
+static enum isl_dim_type domain_type(enum isl_dim_type type)
+{
+	if (type == isl_dim_in)
+		return isl_dim_set;
+	return type;
+}
+
 __isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_drop_dims(
 	__isl_take isl_qpolynomial_fold *fold,
 	enum isl_dim_type type, unsigned first, unsigned n)
@@ -181,7 +191,7 @@ __isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_drop_dims(
 	if (n == 0)
 		return fold;
 
-	set_type = type == isl_dim_in ? isl_dim_set : type;
+	set_type = domain_type(type);
 
 	fold = isl_qpolynomial_fold_cow(fold);
 	if (!fold)
@@ -652,6 +662,8 @@ __isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_gist_params(
 	return isl_qpolynomial_fold_gist(fold, dom_context);
 }
 
+#define isl_qpolynomial_fold_involves_nan isl_qpolynomial_fold_is_nan
+
 #define HAS_TYPE
 
 #undef PW
@@ -934,10 +946,8 @@ __isl_give isl_union_pw_qpolynomial_fold *isl_union_pw_qpolynomial_fold_fold_pw_
 
 	if (!part || !u)
 		goto error;
-
-	isl_assert(u->space->ctx,
-	    isl_space_match(part->dim, isl_dim_param, u->space, isl_dim_param),
-	    goto error);
+	if (isl_space_check_equal_params(part->dim, u->space) < 0)
+		goto error;
 
 	entry = isl_union_pw_qpolynomial_fold_find_part_entry(u, part->dim, 1);
 	if (!entry)
@@ -1366,6 +1376,7 @@ __isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_move_dims(
 	enum isl_dim_type src_type, unsigned src_pos, unsigned n)
 {
 	int i;
+	enum isl_dim_type set_src_type, set_dst_type;
 
 	if (n == 0)
 		return fold;
@@ -1374,8 +1385,11 @@ __isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_move_dims(
 	if (!fold)
 		return NULL;
 
-	fold->dim = isl_space_move_dims(fold->dim, dst_type, dst_pos,
-						src_type, src_pos, n);
+	set_src_type = domain_type(src_type);
+	set_dst_type = domain_type(dst_type);
+
+	fold->dim = isl_space_move_dims(fold->dim, set_dst_type, dst_pos,
+						set_src_type, src_pos, n);
 	if (!fold->dim)
 		goto error;
 
@@ -1424,14 +1438,12 @@ error:
 
 static isl_stat add_pwqp(__isl_take isl_pw_qpolynomial *pwqp, void *user)
 {
-	isl_ctx *ctx;
 	isl_pw_qpolynomial_fold *pwf;
 	isl_union_pw_qpolynomial_fold **upwf;
 	struct isl_hash_table_entry *entry;
 
 	upwf = (isl_union_pw_qpolynomial_fold **)user;
 
-	ctx = pwqp->dim->ctx;
 	entry = isl_union_pw_qpolynomial_fold_find_part_entry(*upwf,
 			 pwqp->dim, 1);
 	if (!entry)
@@ -1481,13 +1493,15 @@ error:
 	return NULL;
 }
 
-static int join_compatible(__isl_keep isl_space *dim1, __isl_keep isl_space *dim2)
+static isl_bool join_compatible(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2)
 {
-	int m;
-	m = isl_space_match(dim1, isl_dim_param, dim2, isl_dim_param);
+	isl_bool m;
+	m = isl_space_has_equal_params(space1, space2);
 	if (m < 0 || !m)
 		return m;
-	return isl_space_tuple_is_equal(dim1, isl_dim_out, dim2, isl_dim_in);
+	return isl_space_tuple_is_equal(space1, isl_dim_out,
+					space2, isl_dim_in);
 }
 
 /* Compute the intersection of the range of the map and the domain
@@ -1508,7 +1522,7 @@ __isl_give isl_pw_qpolynomial_fold *isl_map_apply_pw_qpolynomial_fold(
 	isl_space *map_dim;
 	isl_space *pwf_dim;
 	unsigned n_in;
-	int ok;
+	isl_bool ok;
 
 	ctx = isl_map_get_ctx(map);
 	if (!ctx)
@@ -1519,6 +1533,8 @@ __isl_give isl_pw_qpolynomial_fold *isl_map_apply_pw_qpolynomial_fold(
 	ok = join_compatible(map_dim, pwf_dim);
 	isl_space_free(map_dim);
 	isl_space_free(pwf_dim);
+	if (ok < 0)
+		goto error;
 	if (!ok)
 		isl_die(ctx, isl_error_invalid, "incompatible dimensions",
 			goto error);
@@ -1560,7 +1576,7 @@ static isl_stat pw_qpolynomial_fold_apply(
 	isl_space *map_dim;
 	isl_space *pwf_dim;
 	struct isl_apply_fold_data *data = user;
-	int ok;
+	isl_bool ok;
 
 	map_dim = isl_map_get_space(data->map);
 	pwf_dim = isl_pw_qpolynomial_fold_get_space(pwf);
@@ -1568,6 +1584,8 @@ static isl_stat pw_qpolynomial_fold_apply(
 	isl_space_free(map_dim);
 	isl_space_free(pwf_dim);
 
+	if (ok < 0)
+		return isl_stat_error;
 	if (ok) {
 		pwf = isl_map_apply_pw_qpolynomial_fold(isl_map_copy(data->map),
 				    pwf, data->tight ? &data->tight : NULL);
diff --git a/lib/Analysis/isl/isl_ilp.c b/lib/Analysis/isl/isl_ilp.c
index 1897035..eee294e 100644
--- a/lib/Analysis/isl/isl_ilp.c
+++ b/lib/Analysis/isl/isl_ilp.c
@@ -32,7 +32,8 @@
  * term.  This ensures that if x satisfies the resulting constraints,
  * then x plus any sum of unit vectors satisfies the original constraints.
  */
-static struct isl_basic_set *unit_box_base_points(struct isl_basic_set *bset)
+static __isl_give isl_basic_set *unit_box_base_points(
+	__isl_take isl_basic_set *bset)
 {
 	int i, j, k;
 	struct isl_basic_set *unit_box = NULL;
@@ -80,7 +81,8 @@ error:
  * and round it up to the nearest integer.
  * If not, we simply pick any integer point in "bset".
  */
-static struct isl_vec *initial_solution(struct isl_basic_set *bset, isl_int *f)
+static __isl_give isl_vec *initial_solution(__isl_keep isl_basic_set *bset,
+	isl_int *f)
 {
 	enum isl_lp_result res;
 	struct isl_basic_set *unit_box;
@@ -102,7 +104,7 @@ static struct isl_vec *initial_solution(struct isl_basic_set *bset, isl_int *f)
 
 /* Restrict "bset" to those points with values for f in the interval [l, u].
  */
-static struct isl_basic_set *add_bounds(struct isl_basic_set *bset,
+static __isl_give isl_basic_set *add_bounds(__isl_take isl_basic_set *bset,
 	isl_int *f, isl_int l, isl_int u)
 {
 	int k;
@@ -145,8 +147,8 @@ error:
  * If no point can be found, we update l to the upper bound of the interval
  * we checked (u or l+floor(u-l-1/2)) plus 1.
  */
-static struct isl_vec *solve_ilp_search(struct isl_basic_set *bset,
-	isl_int *f, isl_int *opt, struct isl_vec *sol, isl_int l, isl_int u)
+static __isl_give isl_vec *solve_ilp_search(__isl_keep isl_basic_set *bset,
+	isl_int *f, isl_int *opt, __isl_take isl_vec *sol, isl_int l, isl_int u)
 {
 	isl_int tmp;
 	int divide = 1;
@@ -204,9 +206,8 @@ static struct isl_vec *solve_ilp_search(struct isl_basic_set *bset,
  *
  * We then call solve_ilp_search to perform a binary search on the interval.
  */
-static enum isl_lp_result solve_ilp(struct isl_basic_set *bset,
-				      isl_int *f, isl_int *opt,
-				      struct isl_vec **sol_p)
+static enum isl_lp_result solve_ilp(__isl_keep isl_basic_set *bset,
+	isl_int *f, isl_int *opt, __isl_give isl_vec **sol_p)
 {
 	enum isl_lp_result res;
 	isl_int l, u;
@@ -260,9 +261,8 @@ static enum isl_lp_result solve_ilp(struct isl_basic_set *bset,
 	return res;
 }
 
-static enum isl_lp_result solve_ilp_with_eq(struct isl_basic_set *bset, int max,
-				      isl_int *f, isl_int *opt,
-				      struct isl_vec **sol_p)
+static enum isl_lp_result solve_ilp_with_eq(__isl_keep isl_basic_set *bset,
+	int max, isl_int *f, isl_int *opt, __isl_give isl_vec **sol_p)
 {
 	unsigned dim;
 	enum isl_lp_result res;
@@ -303,9 +303,8 @@ error:
  * If there is any equality among the points in "bset", then we first
  * project it out.  Otherwise, we continue with solve_ilp above.
  */
-enum isl_lp_result isl_basic_set_solve_ilp(struct isl_basic_set *bset, int max,
-				      isl_int *f, isl_int *opt,
-				      struct isl_vec **sol_p)
+enum isl_lp_result isl_basic_set_solve_ilp(__isl_keep isl_basic_set *bset,
+	int max, isl_int *f, isl_int *opt, __isl_give isl_vec **sol_p)
 {
 	unsigned dim;
 	enum isl_lp_result res;
@@ -315,7 +314,8 @@ enum isl_lp_result isl_basic_set_solve_ilp(struct isl_basic_set *bset, int max,
 	if (sol_p)
 		*sol_p = NULL;
 
-	isl_assert(bset->ctx, isl_basic_set_n_param(bset) == 0, goto error);
+	isl_assert(bset->ctx, isl_basic_set_n_param(bset) == 0,
+		return isl_lp_error);
 
 	if (isl_basic_set_plain_is_empty(bset))
 		return isl_lp_empty;
@@ -336,9 +336,6 @@ enum isl_lp_result isl_basic_set_solve_ilp(struct isl_basic_set *bset, int max,
 	}
 
 	return res;
-error:
-	isl_basic_set_free(bset);
-	return isl_lp_error;
 }
 
 static enum isl_lp_result basic_set_opt(__isl_keep isl_basic_set *bset, int max,
@@ -467,8 +464,9 @@ static enum isl_lp_result isl_set_opt_aligned(__isl_keep isl_set *set, int max,
 			isl_int_clear(opt_i);
 			return res;
 		}
-		if (res == isl_lp_ok)
-			empty = 0;
+		if (res == isl_lp_empty)
+			continue;
+		empty = 0;
 		if (max ? isl_int_gt(opt_i, *opt) : isl_int_lt(opt_i, *opt))
 			isl_int_set(*opt, opt_i);
 	}
@@ -484,12 +482,15 @@ enum isl_lp_result isl_set_opt(__isl_keep isl_set *set, int max,
 	__isl_keep isl_aff *obj, isl_int *opt)
 {
 	enum isl_lp_result res;
+	isl_bool aligned;
 
 	if (!set || !obj)
 		return isl_lp_error;
 
-	if (isl_space_match(set->dim, isl_dim_param,
-			    obj->ls->dim, isl_dim_param))
+	aligned = isl_set_space_has_equal_params(set, obj->ls->dim);
+	if (aligned < 0)
+		return isl_lp_error;
+	if (aligned)
 		return isl_set_opt_aligned(set, max, obj, opt);
 
 	set = isl_set_copy(set);
diff --git a/lib/Analysis/isl/isl_imath.c b/lib/Analysis/isl/isl_imath.c
index cffd79a..d870f14 100644
--- a/lib/Analysis/isl/isl_imath.c
+++ b/lib/Analysis/isl/isl_imath.c
@@ -53,3 +53,31 @@ void isl_imath_submul_ui(mp_int rop, mp_int op1, unsigned long op2)
 
 	mp_int_clear(&temp);
 }
+
+/* Compute the division of lhs by a rhs of type unsigned long, rounding towards
+ * positive infinity (Ceil).
+ */
+void isl_imath_cdiv_q_ui(mp_int rop, mp_int lhs, unsigned long rhs)
+{
+	mpz_t temp;
+	mp_int_init(&temp);
+
+	mp_int_set_uvalue(&temp, rhs);
+	impz_cdiv_q(rop, lhs, &temp);
+
+	mp_int_clear(&temp);
+}
+
+/* Compute the division of lhs by a rhs of type unsigned long, rounding towards
+ * negative infinity (Floor).
+ */
+void isl_imath_fdiv_q_ui(mp_int rop, mp_int lhs, unsigned long rhs)
+{
+	mpz_t temp;
+	mp_int_init(&temp);
+
+	mp_int_set_uvalue(&temp, rhs);
+	impz_fdiv_q(rop, lhs, &temp);
+
+	mp_int_clear(&temp);
+}
diff --git a/lib/Analysis/isl/isl_imath.h b/lib/Analysis/isl/isl_imath.h
index d51e03c..9efbe31 100644
--- a/lib/Analysis/isl/isl_imath.h
+++ b/lib/Analysis/isl/isl_imath.h
@@ -6,3 +6,5 @@ int isl_imath_fits_ulong_p(mp_int op);
 int isl_imath_fits_slong_p(mp_int op);
 void isl_imath_addmul_ui(mp_int rop, mp_int op1, unsigned long op2);
 void isl_imath_submul_ui(mp_int rop, mp_int op1, unsigned long op2);
+void isl_imath_cdiv_q_ui(mp_int rop, mp_int op1, unsigned long op2);
+void isl_imath_fdiv_q_ui(mp_int rop, mp_int op1, unsigned long op2);
diff --git a/lib/Analysis/isl/isl_input.c b/lib/Analysis/isl/isl_input.c
index 7238127..e122053 100644
--- a/lib/Analysis/isl/isl_input.c
+++ b/lib/Analysis/isl/isl_input.c
@@ -412,7 +412,7 @@ static __isl_give isl_pw_aff *accept_div(__isl_keep isl_stream *s,
 			isl_stream_push_token(s, tok);
 			goto error;
 		}
-		isl_pw_aff_scale_down(pwaff,  tok->u.v);
+		pwaff = isl_pw_aff_scale_down(pwaff,  tok->u.v);
 		isl_token_free(tok);
 	}
 
@@ -1202,7 +1202,7 @@ static __isl_give isl_space *read_tuple_space(__isl_keep isl_stream *s,
 			goto error;
 		out = read_tuple_space(s, v, isl_space_copy(space),
 					rational, comma, read_el, user);
-		res = isl_space_range_product(res, out);
+		res = isl_space_product(res, out);
 	} else
 		res = read_tuple_list(s, v, isl_space_copy(space),
 					rational, comma, read_el, user);
@@ -1805,11 +1805,8 @@ static struct isl_map *read_disjuncts(__isl_keep isl_stream *s,
 {
 	isl_map *res;
 
-	if (isl_stream_next_token_is(s, '}')) {
-		isl_space *dim = isl_map_get_space(map);
-		isl_map_free(map);
-		return isl_map_universe(dim);
-	}
+	if (isl_stream_next_token_is(s, '}'))
+		return map;
 
 	res = read_conjuncts(s, v, isl_map_copy(map), rational);
 	while (isl_stream_eat_if_available(s, ISL_TOKEN_OR)) {
@@ -3112,12 +3109,15 @@ static int next_is_fresh_ident(__isl_keep isl_stream *s, struct vars *v)
  * If the tuple we are reading is named, we assume it's the domain.
  * Also, if inside the tuple, the first thing we find is a nested tuple
  * or a new identifier, we again assume it's the domain.
+ * Finally, if the tuple is empty, then it must be the domain
+ * since it does not contain an affine expression.
  * Otherwise, we assume we are reading an affine expression.
  */
 static __isl_give isl_set *read_aff_domain(__isl_keep isl_stream *s,
 	__isl_take isl_set *dom, struct vars *v)
 {
-	struct isl_token *tok;
+	struct isl_token *tok, *tok2;
+	int is_empty;
 
 	tok = isl_stream_next_token(s);
 	if (tok && (tok->type == ISL_TOKEN_IDENT || tok->is_keyword)) {
@@ -3128,7 +3128,11 @@ static __isl_give isl_set *read_aff_domain(__isl_keep isl_stream *s,
 		isl_stream_error(s, tok, "expecting '['");
 		goto error;
 	}
-	if (next_is_tuple(s) || next_is_fresh_ident(s, v)) {
+	tok2 = isl_stream_next_token(s);
+	is_empty = tok2 && tok2->type == ']';
+	if (tok2)
+		isl_stream_push_token(s, tok2);
+	if (is_empty || next_is_tuple(s) || next_is_fresh_ident(s, v)) {
 		isl_stream_push_token(s, tok);
 		dom = read_map_tuple(s, dom, isl_dim_set, v, 1, 0);
 	} else
@@ -3265,29 +3269,154 @@ __isl_give isl_pw_aff *isl_pw_aff_read_from_str(isl_ctx *ctx, const char *str)
 	return pa;
 }
 
+/* Extract an isl_multi_pw_aff with domain space "dom_space"
+ * from a tuple "tuple" read by read_tuple.
+ *
+ * Note that the function read_tuple accepts tuples where some output or
+ * set dimensions are defined in terms of other output or set dimensions
+ * since this function is also used to read maps.  As a special case,
+ * read_tuple also accept dimensions that are defined in terms of themselves
+ * (i.e., that are not defined).
+ * These cases are not allowed when extracting an isl_multi_pw_aff so check
+ * that the definitions of the output/set dimensions do not involve any
+ * output/set dimensions.
+ * Finally, drop the output dimensions from the domain of the result
+ * of read_tuple (which is of the form [input, output] -> [output],
+ * with anonymous domain) and reset the space.
+ */
+static __isl_give isl_multi_pw_aff *extract_mpa_from_tuple(
+	__isl_take isl_space *dom_space, __isl_keep isl_multi_pw_aff *tuple)
+{
+	int dim, i, n;
+	isl_space *space;
+	isl_multi_pw_aff *mpa;
+
+	n = isl_multi_pw_aff_dim(tuple, isl_dim_out);
+	dim = isl_space_dim(dom_space, isl_dim_all);
+	space = isl_space_range(isl_multi_pw_aff_get_space(tuple));
+	space = isl_space_align_params(space, isl_space_copy(dom_space));
+	if (!isl_space_is_params(dom_space))
+		space = isl_space_map_from_domain_and_range(
+				isl_space_copy(dom_space), space);
+	isl_space_free(dom_space);
+	mpa = isl_multi_pw_aff_alloc(space);
+
+	for (i = 0; i < n; ++i) {
+		isl_pw_aff *pa;
+		pa = isl_multi_pw_aff_get_pw_aff(tuple, i);
+		if (!pa)
+			return isl_multi_pw_aff_free(mpa);
+		if (isl_pw_aff_involves_dims(pa, isl_dim_in, dim, i + 1)) {
+			isl_ctx *ctx = isl_pw_aff_get_ctx(pa);
+			isl_pw_aff_free(pa);
+			isl_die(ctx, isl_error_invalid,
+				"not an affine expression",
+				return isl_multi_pw_aff_free(mpa));
+		}
+		pa = isl_pw_aff_drop_dims(pa, isl_dim_in, dim, n);
+		space = isl_multi_pw_aff_get_domain_space(mpa);
+		pa = isl_pw_aff_reset_domain_space(pa, space);
+		mpa = isl_multi_pw_aff_set_pw_aff(mpa, i, pa);
+	}
+
+	return mpa;
+}
+
+/* Read a tuple of affine expressions, together with optional constraints
+ * on the domain from "s".  "dom" represents the initial constraints
+ * on the domain.
+ *
+ * The isl_multi_aff may live in either a set or a map space.
+ * First read the first tuple and check if it is followed by a "->".
+ * If so, convert the tuple into the domain of the isl_multi_pw_aff and
+ * read in the next tuple.  This tuple (or the first tuple if it was
+ * not followed by a "->") is then converted into an isl_multi_pw_aff
+ * through a call to extract_mpa_from_tuple.
+ * The result is converted to an isl_pw_multi_aff and
+ * its domain is intersected with the domain.
+ */
+static __isl_give isl_pw_multi_aff *read_conditional_multi_aff(
+	__isl_keep isl_stream *s, __isl_take isl_set *dom, struct vars *v)
+{
+	isl_multi_pw_aff *tuple;
+	isl_multi_pw_aff *mpa;
+	isl_pw_multi_aff *pma;
+	int n = v->n;
+
+	tuple = read_tuple(s, v, 0, 0);
+	if (!tuple)
+		goto error;
+	if (isl_stream_eat_if_available(s, ISL_TOKEN_TO)) {
+		isl_map *map = map_from_tuple(tuple, dom, isl_dim_in, v, 0);
+		dom = isl_map_domain(map);
+		tuple = read_tuple(s, v, 0, 0);
+		if (!tuple)
+			goto error;
+	}
+
+	dom = read_optional_formula(s, dom, v, 0);
+
+	vars_drop(v, v->n - n);
+
+	mpa = extract_mpa_from_tuple(isl_set_get_space(dom), tuple);
+	isl_multi_pw_aff_free(tuple);
+	pma = isl_pw_multi_aff_from_multi_pw_aff(mpa);
+	pma = isl_pw_multi_aff_intersect_domain(pma, dom);
+
+	return pma;
+error:
+	isl_set_free(dom);
+	return NULL;
+}
+
 /* Read an isl_pw_multi_aff from "s".
- * We currently read a generic object and if it turns out to be a set or
- * a map, we convert that to an isl_pw_multi_aff.
- * It would be more efficient if we were to construct the isl_pw_multi_aff
- * directly.
+ *
+ * In particular, first read the parameters and then read a sequence
+ * of one or more tuples of affine expressions with optional conditions and
+ * add them up.
  */
 __isl_give isl_pw_multi_aff *isl_stream_read_pw_multi_aff(
 	__isl_keep isl_stream *s)
 {
-	struct isl_obj obj;
+	struct vars *v;
+	isl_set *dom;
+	isl_pw_multi_aff *pma = NULL;
 
-	obj = obj_read(s);
-	if (!obj.v)
+	v = vars_new(s->ctx);
+	if (!v)
 		return NULL;
 
-	if (obj.type == isl_obj_map)
-		return isl_pw_multi_aff_from_map(obj.v);
-	if (obj.type == isl_obj_set)
-		return isl_pw_multi_aff_from_set(obj.v);
+	dom = isl_set_universe(isl_space_params_alloc(s->ctx, 0));
+	if (next_is_tuple(s)) {
+		dom = read_map_tuple(s, dom, isl_dim_param, v, 1, 0);
+		if (isl_stream_eat(s, ISL_TOKEN_TO))
+			goto error;
+	}
+	if (isl_stream_eat(s, '{'))
+		goto error;
 
-	obj.type->free(obj.v);
-	isl_die(s->ctx, isl_error_invalid, "unexpected object type",
-		return NULL);
+	pma = read_conditional_multi_aff(s, isl_set_copy(dom), v);
+
+	while (isl_stream_eat_if_available(s, ';')) {
+		isl_pw_multi_aff *pma2;
+
+		pma2 = read_conditional_multi_aff(s, isl_set_copy(dom), v);
+		pma = isl_pw_multi_aff_union_add(pma, pma2);
+		if (!pma)
+			goto error;
+	}
+
+	if (isl_stream_eat(s, '}'))
+		goto error;
+
+	isl_set_free(dom);
+	vars_free(v);
+	return pma;
+error:
+	isl_pw_multi_aff_free(pma);
+	isl_set_free(dom);
+	vars_free(v);
+	return NULL;
 }
 
 __isl_give isl_pw_multi_aff *isl_pw_multi_aff_read_from_str(isl_ctx *ctx,
@@ -3572,19 +3701,9 @@ __isl_give isl_multi_aff *isl_multi_aff_read_from_str(isl_ctx *ctx,
  * if it is followed by a "->".  If so, we convert the tuple into
  * the domain of the isl_multi_pw_aff and read in the next tuple.
  * This tuple (or the first tuple if it was not followed by a "->")
- * is then converted into the isl_multi_pw_aff.
- *
- * Note that the function read_tuple accepts tuples where some output or
- * set dimensions are defined in terms of other output or set dimensions
- * since this function is also used to read maps.  As a special case,
- * read_tuple also accept dimensions that are defined in terms of themselves
- * (i.e., that are not defined).
- * These cases are not allowed when reading am isl_multi_pw_aff so we check
- * that the definition of the output/set dimensions does not involve any
- * output/set dimensions.
- * We then drop the output dimensions from the domain of the result
- * of read_tuple (which is of the form [input, output] -> [output],
- * with anonymous domain) and reset the space.
+ * is then converted into the isl_multi_pw_aff through a call
+ * to extract_mpa_from_tuple and the domain of the result
+ * is intersected with the domain.
  */
 __isl_give isl_multi_pw_aff *isl_stream_read_multi_pw_aff(
 	__isl_keep isl_stream *s)
@@ -3592,8 +3711,6 @@ __isl_give isl_multi_pw_aff *isl_stream_read_multi_pw_aff(
 	struct vars *v;
 	isl_set *dom = NULL;
 	isl_multi_pw_aff *tuple = NULL;
-	int dim, i, n;
-	isl_space *space, *dom_space;
 	isl_multi_pw_aff *mpa = NULL;
 
 	v = vars_new(s->ctx);
@@ -3623,32 +3740,7 @@ __isl_give isl_multi_pw_aff *isl_stream_read_multi_pw_aff(
 	if (isl_stream_eat(s, '}'))
 		goto error;
 
-	n = isl_multi_pw_aff_dim(tuple, isl_dim_out);
-	dim = isl_set_dim(dom, isl_dim_all);
-	dom_space = isl_set_get_space(dom);
-	space = isl_space_range(isl_multi_pw_aff_get_space(tuple));
-	space = isl_space_align_params(space, isl_space_copy(dom_space));
-	if (!isl_space_is_params(dom_space))
-		space = isl_space_map_from_domain_and_range(
-				isl_space_copy(dom_space), space);
-	isl_space_free(dom_space);
-	mpa = isl_multi_pw_aff_alloc(space);
-
-	for (i = 0; i < n; ++i) {
-		isl_pw_aff *pa;
-		pa = isl_multi_pw_aff_get_pw_aff(tuple, i);
-		if (!pa)
-			goto error;
-		if (isl_pw_aff_involves_dims(pa, isl_dim_in, dim, i + 1)) {
-			isl_pw_aff_free(pa);
-			isl_die(s->ctx, isl_error_invalid,
-				"not an affine expression", goto error);
-		}
-		pa = isl_pw_aff_drop_dims(pa, isl_dim_in, dim, n);
-		space = isl_multi_pw_aff_get_domain_space(mpa);
-		pa = isl_pw_aff_reset_domain_space(pa, space);
-		mpa = isl_multi_pw_aff_set_pw_aff(mpa, i, pa);
-	}
+	mpa = extract_mpa_from_tuple(isl_set_get_space(dom), tuple);
 
 	isl_multi_pw_aff_free(tuple);
 	vars_free(v);
diff --git a/lib/Analysis/isl/isl_int_gmp.h b/lib/Analysis/isl/isl_int_gmp.h
index 08f2857..3a35e26 100644
--- a/lib/Analysis/isl/isl_int_gmp.h
+++ b/lib/Analysis/isl/isl_int_gmp.h
@@ -45,6 +45,7 @@ typedef mpz_t	isl_int;
 #define isl_int_divexact_ui(r,i,j)	mpz_divexact_ui(r,i,j)
 #define isl_int_tdiv_q(r,i,j)	mpz_tdiv_q(r,i,j)
 #define isl_int_cdiv_q(r,i,j)	mpz_cdiv_q(r,i,j)
+#define isl_int_cdiv_q_ui(r,i,j)	mpz_cdiv_q_ui(r,i,j)
 #define isl_int_fdiv_q(r,i,j)	mpz_fdiv_q(r,i,j)
 #define isl_int_fdiv_r(r,i,j)	mpz_fdiv_r(r,i,j)
 #define isl_int_fdiv_q_ui(r,i,j)	mpz_fdiv_q_ui(r,i,j)
diff --git a/lib/Analysis/isl/isl_int_imath.h b/lib/Analysis/isl/isl_int_imath.h
index e5b7186..73d6379 100644
--- a/lib/Analysis/isl/isl_int_imath.h
+++ b/lib/Analysis/isl/isl_int_imath.h
@@ -45,9 +45,10 @@ typedef mp_int isl_int;
 #define isl_int_divexact_ui(r,i,j)	impz_divexact_ui(r,i,j)
 #define isl_int_tdiv_q(r,i,j)	impz_tdiv_q(r,i,j)
 #define isl_int_cdiv_q(r,i,j)	impz_cdiv_q(r,i,j)
+#define isl_int_cdiv_q_ui(r,i,j)	isl_imath_cdiv_q_ui(r,i,j)
 #define isl_int_fdiv_q(r,i,j)	impz_fdiv_q(r,i,j)
 #define isl_int_fdiv_r(r,i,j)	impz_fdiv_r(r,i,j)
-#define isl_int_fdiv_q_ui(r,i,j)	impz_fdiv_q_ui(r,i,j)
+#define isl_int_fdiv_q_ui(r,i,j)	isl_imath_fdiv_q_ui(r,i,j)
 
 #define isl_int_read(r,s)	impz_set_str(r,s,10)
 #define isl_int_sgn(i)		impz_sgn(i)
diff --git a/lib/Analysis/isl/isl_int_sioimath.c b/lib/Analysis/isl/isl_int_sioimath.c
index 50c159f..1702862 100644
--- a/lib/Analysis/isl/isl_int_sioimath.c
+++ b/lib/Analysis/isl/isl_int_sioimath.c
@@ -154,6 +154,8 @@ extern void isl_sioimath_tdiv_q_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,
 	unsigned long rhs);
 extern void isl_sioimath_cdiv_q(isl_sioimath_ptr dst, isl_sioimath_src lhs,
 	isl_sioimath_src rhs);
+extern void isl_sioimath_cdiv_q_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,
+	unsigned long rhs);
 extern void isl_sioimath_fdiv_q(isl_sioimath_ptr dst, isl_sioimath_src lhs,
 	isl_sioimath_src rhs);
 extern void isl_sioimath_fdiv_q_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,
diff --git a/lib/Analysis/isl/isl_int_sioimath.h b/lib/Analysis/isl/isl_int_sioimath.h
index 0b6eb0e..a2112cd 100644
--- a/lib/Analysis/isl/isl_int_sioimath.h
+++ b/lib/Analysis/isl/isl_int_sioimath.h
@@ -927,6 +927,31 @@ inline void isl_sioimath_cdiv_q(isl_sioimath_ptr dst, isl_sioimath_src lhs,
 	isl_sioimath_try_demote(dst);
 }
 
+/* Compute the division of lhs by a rhs of type unsigned long, rounding towards
+ * positive infinity (Ceil).
+ */
+inline void isl_sioimath_cdiv_q_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,
+	unsigned long rhs)
+{
+	isl_sioimath_scratchspace_t lhsscratch, rhsscratch;
+	int32_t lhssmall, q;
+
+	if (isl_sioimath_decode_small(lhs, &lhssmall) && (rhs <= INT32_MAX)) {
+		if (lhssmall >= 0)
+			q = ((int64_t) lhssmall + ((int64_t) rhs - 1)) /
+			    (int64_t) rhs;
+		else
+			q = lhssmall / (int32_t) rhs;
+		isl_sioimath_set_small(dst, q);
+		return;
+	}
+
+	impz_cdiv_q(isl_sioimath_reinit_big(dst),
+	    isl_sioimath_bigarg_src(lhs, &lhsscratch),
+	    isl_sioimath_uiarg_src(rhs, &rhsscratch));
+	isl_sioimath_try_demote(dst);
+}
+
 /* Divide lhs by rhs, rounding to negative infinity (Floor).
  */
 inline void isl_sioimath_fdiv_q(isl_sioimath_ptr dst, isl_sioimath_src lhs,
@@ -1083,6 +1108,8 @@ inline int isl_sioimath_abs_cmp(isl_sioimath_src lhs, isl_sioimath_src rhs)
 }
 
 /* Return whether lhs is divisible by rhs.
+ * In particular, can rhs be multiplied by some integer to result in lhs?
+ * If rhs is zero, then this means lhs has to be zero too.
  */
 inline int isl_sioimath_is_divisible_by(isl_sioimath_src lhs,
 					isl_sioimath_src rhs)
@@ -1092,6 +1119,9 @@ inline int isl_sioimath_is_divisible_by(isl_sioimath_src lhs,
 	mpz_t rem;
 	int cmp;
 
+	if (isl_sioimath_sgn(rhs) == 0)
+		return isl_sioimath_sgn(lhs) == 0;
+
 	if (isl_sioimath_decode_small(lhs, &lhssmall) &&
 	    isl_sioimath_decode_small(rhs, &rhssmall))
 		return lhssmall % rhssmall == 0;
@@ -1194,6 +1224,7 @@ typedef isl_sioimath isl_int[1];
 #define isl_int_divexact_ui(r, i, j)	isl_sioimath_tdiv_q_ui((r), *(i), j)
 #define isl_int_tdiv_q(r, i, j)		isl_sioimath_tdiv_q((r), *(i), *(j))
 #define isl_int_cdiv_q(r, i, j)		isl_sioimath_cdiv_q((r), *(i), *(j))
+#define isl_int_cdiv_q_ui(r, i, j)	isl_sioimath_cdiv_q_ui((r), *(i), j)
 #define isl_int_fdiv_q(r, i, j)		isl_sioimath_fdiv_q((r), *(i), *(j))
 #define isl_int_fdiv_r(r, i, j)		isl_sioimath_fdiv_r((r), *(i), *(j))
 #define isl_int_fdiv_q_ui(r, i, j)	isl_sioimath_fdiv_q_ui((r), *(i), j)
diff --git a/lib/Analysis/isl/isl_list_templ.c b/lib/Analysis/isl/isl_list_templ.c
index aa900b9..7d0c544 100644
--- a/lib/Analysis/isl/isl_list_templ.c
+++ b/lib/Analysis/isl/isl_list_templ.c
@@ -2,6 +2,7 @@
  * Copyright 2008-2009 Katholieke Universiteit Leuven
  * Copyright 2011      INRIA Saclay
  * Copyright 2012-2013 Ecole Normale Superieure
+ * Copyright 2017      Sven Verdoolaege
  *
  * Use of this software is governed by the MIT license
  *
@@ -130,6 +131,18 @@ static __isl_give LIST(EL) *FN(LIST(EL),grow)(__isl_take LIST(EL) *list, int n)
 	return res;
 }
 
+/* Check that "index" is a valid position in "list".
+ */
+static isl_stat FN(LIST(EL),check_index)(__isl_keep LIST(EL) *list, int index)
+{
+	if (!list)
+		return isl_stat_error;
+	if (index < 0 || index >= list->n)
+		isl_die(FN(LIST(EL),get_ctx)(list), isl_error_invalid,
+			"index out of bounds", return isl_stat_error);
+	return isl_stat_ok;
+}
+
 __isl_give LIST(EL) *FN(LIST(EL),add)(__isl_take LIST(EL) *list,
 	__isl_take struct EL *el)
 {
@@ -192,8 +205,8 @@ __isl_give LIST(EL) *FN(LIST(EL),insert)(__isl_take LIST(EL) *list,
 			"index out of bounds", goto error);
 
 	if (list->ref == 1 && list->size > list->n) {
-		for (i = list->n - 1; i >= pos; --i)
-			list->p[i + 1] = list->p[i];
+		for (i = list->n; i > pos; --i)
+			list->p[i] = list->p[i - 1];
 		list->n++;
 		list->p[pos] = el;
 		return list;
@@ -239,11 +252,8 @@ int FN(FN(LIST(EL),n),BASE)(__isl_keep LIST(EL) *list)
 
 __isl_give EL *FN(FN(LIST(EL),get),BASE)(__isl_keep LIST(EL) *list, int index)
 {
-	if (!list)
+	if (FN(LIST(EL),check_index)(list, index) < 0)
 		return NULL;
-	if (index < 0 || index >= list->n)
-		isl_die(list->ctx, isl_error_invalid,
-			"index out of bounds", return NULL);
 	return FN(EL,copy)(list->p[index]);
 }
 
@@ -254,9 +264,8 @@ __isl_give LIST(EL) *FN(FN(LIST(EL),set),BASE)(__isl_take LIST(EL) *list,
 {
 	if (!list || !el)
 		goto error;
-	if (index < 0 || index >= list->n)
-		isl_die(list->ctx, isl_error_invalid,
-			"index out of bounds", goto error);
+	if (FN(LIST(EL),check_index)(list, index) < 0)
+		goto error;
 	if (list->p[index] == el) {
 		FN(EL,free)(el);
 		return list;
@@ -273,6 +282,40 @@ error:
 	return NULL;
 }
 
+/* Return the element at position "index" of "list".
+ * This may be either a copy or the element itself
+ * if there is only one reference to "list".
+ * This allows the element to be modified inplace
+ * if both the list and the element have only a single reference.
+ * The caller is not allowed to modify "list" between
+ * this call to isl_list_*_take_* and a subsequent call
+ * to isl_list_*_restore_*.
+ * The only exception is that isl_list_*_free can be called instead.
+ */
+static __isl_give EL *FN(FN(LIST(EL),take),BASE)(__isl_keep LIST(EL) *list,
+	int index)
+{
+	EL *el;
+
+	if (FN(LIST(EL),check_index)(list, index) < 0)
+		return NULL;
+	if (list->ref != 1)
+		return FN(FN(LIST(EL),get),BASE)(list, index);
+	el = list->p[index];
+	list->p[index] = NULL;
+	return el;
+}
+
+/* Set the element at position "index" of "list" to "el",
+ * where the position may be empty due to a previous call
+ * to isl_list_*_take_*.
+ */
+static __isl_give LIST(EL) *FN(FN(LIST(EL),restore),BASE)(
+	__isl_take LIST(EL) *list, int index, __isl_take EL *el)
+{
+	return FN(FN(LIST(EL),set),BASE)(list, index, el);
+}
+
 isl_stat FN(LIST(EL),foreach)(__isl_keep LIST(EL) *list,
 	isl_stat (*fn)(__isl_take EL *el, void *user), void *user)
 {
@@ -282,7 +325,7 @@ isl_stat FN(LIST(EL),foreach)(__isl_keep LIST(EL) *list,
 		return isl_stat_error;
 
 	for (i = 0; i < list->n; ++i) {
-		EL *el = FN(EL,copy(list->p[i]));
+		EL *el = FN(EL,copy)(list->p[i]);
 		if (!el)
 			return isl_stat_error;
 		if (fn(el, user) < 0)
@@ -292,6 +335,29 @@ isl_stat FN(LIST(EL),foreach)(__isl_keep LIST(EL) *list,
 	return isl_stat_ok;
 }
 
+/* Replace each element in "list" by the result of calling "fn"
+ * on the element.
+ */
+__isl_give LIST(EL) *FN(LIST(EL),map)(__isl_keep LIST(EL) *list,
+	__isl_give EL *(*fn)(__isl_take EL *el, void *user), void *user)
+{
+	int i, n;
+
+	if (!list)
+		return NULL;
+
+	n = list->n;
+	for (i = 0; i < n; ++i) {
+		EL *el = FN(FN(LIST(EL),take),BASE)(list, i);
+		if (!el)
+			return FN(LIST(EL),free)(list);
+		el = fn(el, user);
+		list = FN(FN(LIST(EL),restore),BASE)(list, i, el);
+	}
+
+	return list;
+}
+
 /* Internal data structure for isl_*_list_sort.
  *
  * "cmp" is the original comparison function.
@@ -461,6 +527,26 @@ error:
 	return NULL;
 }
 
+/* Append the elements of "list2" to "list1", where "list1" is known
+ * to have only a single reference and enough room to hold
+ * the extra elements.
+ */
+static __isl_give LIST(EL) *FN(LIST(EL),concat_inplace)(
+	__isl_take LIST(EL) *list1, __isl_take LIST(EL) *list2)
+{
+	int i;
+
+	for (i = 0; i < list2->n; ++i)
+		list1 = FN(LIST(EL),add)(list1, FN(EL,copy)(list2->p[i]));
+	FN(LIST(EL),free)(list2);
+	return list1;
+}
+
+/* Concatenate "list1" and "list2".
+ * If "list1" has only one reference and has enough room
+ * for the elements of "list2", the add the elements to "list1" itself.
+ * Otherwise, create a new list to store the result.
+ */
 __isl_give LIST(EL) *FN(LIST(EL),concat)(__isl_take LIST(EL) *list1,
 	__isl_take LIST(EL) *list2)
 {
@@ -471,6 +557,9 @@ __isl_give LIST(EL) *FN(LIST(EL),concat)(__isl_take LIST(EL) *list1,
 	if (!list1 || !list2)
 		goto error;
 
+	if (list1->ref == 1 && list1->n + list2->n <= list1->size)
+		return FN(LIST(EL),concat_inplace)(list1, list2);
+
 	ctx = FN(LIST(EL),get_ctx)(list1);
 	res = FN(LIST(EL),alloc)(ctx, list1->n + list2->n);
 	for (i = 0; i < list1->n; ++i)
diff --git a/lib/Analysis/isl/isl_local.c b/lib/Analysis/isl/isl_local.c
index 7725af9..c8240b9 100644
--- a/lib/Analysis/isl/isl_local.c
+++ b/lib/Analysis/isl/isl_local.c
@@ -11,16 +11,59 @@
 #include <isl_seq.h>
 
 /* Given a matrix "div" representing local variables,
- * does the variable at position "pos" have an explicit representation?
+ * is the variable at position "pos" marked as not having
+ * an explicit representation?
+ * Note that even if this variable is not marked in this way and therefore
+ * does have an explicit representation, this representation may still
+ * depend (indirectly) on other local variables that do not
+ * have an explicit representation.
+ */
+isl_bool isl_local_div_is_marked_unknown(__isl_keep isl_mat *div, int pos)
+{
+	if (!div)
+		return isl_bool_error;
+	if (pos < 0 || pos >= div->n_row)
+		isl_die(isl_mat_get_ctx(div), isl_error_invalid,
+			"position out of bounds", return isl_bool_error);
+	return isl_int_is_zero(div->row[pos][0]);
+}
+
+/* Given a matrix "div" representing local variables,
+ * does the variable at position "pos" have a complete explicit representation?
+ * Having a complete explicit representation requires not only
+ * an explicit representation, but also that all local variables
+ * that appear in this explicit representation in turn have
+ * a complete explicit representation.
  */
 isl_bool isl_local_div_is_known(__isl_keep isl_mat *div, int pos)
 {
+	isl_bool marked;
+	int i, n, off;
+
 	if (!div)
 		return isl_bool_error;
 	if (pos < 0 || pos >= div->n_row)
 		isl_die(isl_mat_get_ctx(div), isl_error_invalid,
 			"position out of bounds", return isl_bool_error);
-	return !isl_int_is_zero(div->row[pos][0]);
+
+	marked = isl_local_div_is_marked_unknown(div, pos);
+	if (marked < 0 || marked)
+		return isl_bool_not(marked);
+
+	n = isl_mat_rows(div);
+	off = isl_mat_cols(div) - n;
+
+	for (i = n - 1; i >= 0; --i) {
+		isl_bool known;
+
+		if (isl_int_is_zero(div->row[pos][off + i]))
+			continue;
+		known = isl_local_div_is_known(div, i);
+		if (known < 0 || !known)
+			return known;
+	}
+
+	return isl_bool_true;
 }
 
 /* Compare two matrices representing local variables, defined over
@@ -37,7 +80,7 @@ int isl_local_cmp(__isl_keep isl_mat *div1, __isl_keep isl_mat *div2)
 {
 	int i;
 	int cmp;
-	int known1, known2;
+	isl_bool unknown1, unknown2;
 	int last1, last2;
 	int n_col;
 
@@ -53,13 +96,13 @@ int isl_local_cmp(__isl_keep isl_mat *div1, __isl_keep isl_mat *div2)
 
 	n_col = isl_mat_cols(div1);
 	for (i = 0; i < div1->n_row; ++i) {
-		known1 = isl_local_div_is_known(div1, i);
-		known2 = isl_local_div_is_known(div2, i);
-		if (!known1 && !known2)
+		unknown1 = isl_local_div_is_marked_unknown(div1, i);
+		unknown2 = isl_local_div_is_marked_unknown(div2, i);
+		if (unknown1 && unknown2)
 			continue;
-		if (!known1)
+		if (unknown1)
 			return 1;
-		if (!known2)
+		if (unknown2)
 			return -1;
 		last1 = isl_seq_last_non_zero(div1->row[i] + 1, n_col - 1);
 		last2 = isl_seq_last_non_zero(div2->row[i] + 1, n_col - 1);
diff --git a/lib/Analysis/isl/isl_local.h b/lib/Analysis/isl/isl_local.h
index f989fcb..0970509 100644
--- a/lib/Analysis/isl/isl_local.h
+++ b/lib/Analysis/isl/isl_local.h
@@ -3,6 +3,7 @@
 
 #include <isl/mat.h>
 
+isl_bool isl_local_div_is_marked_unknown(__isl_keep isl_mat *div, int pos);
 isl_bool isl_local_div_is_known(__isl_keep isl_mat *div, int pos);
 int isl_local_cmp(__isl_keep isl_mat *div1, __isl_keep isl_mat *div2);
 
diff --git a/lib/Analysis/isl/isl_local_space.c b/lib/Analysis/isl/isl_local_space.c
index 9bc8c8d..58ce847 100644
--- a/lib/Analysis/isl/isl_local_space.c
+++ b/lib/Analysis/isl/isl_local_space.c
@@ -280,10 +280,62 @@ __isl_give isl_id *isl_local_space_get_dim_id(__isl_keep isl_local_space *ls,
 	return ls ? isl_space_get_dim_id(ls->dim, type, pos) : NULL;
 }
 
+/* Return the argument of the integer division at position "pos" in "ls".
+ * All local variables in "ls" are known to have a (complete) explicit
+ * representation.
+ */
+static __isl_give isl_aff *extract_div(__isl_keep isl_local_space *ls, int pos)
+{
+	isl_aff *aff;
+
+	aff = isl_aff_alloc(isl_local_space_copy(ls));
+	if (!aff)
+		return NULL;
+	isl_seq_cpy(aff->v->el, ls->div->row[pos], aff->v->size);
+	return aff;
+}
+
+/* Return the argument of the integer division at position "pos" in "ls".
+ * The integer division at that position is known to have a complete
+ * explicit representation, but some of the others do not.
+ * Remove them first because the domain of an isl_aff
+ * is not allowed to have unknown local variables.
+ */
+static __isl_give isl_aff *drop_unknown_divs_and_extract_div(
+	__isl_keep isl_local_space *ls, int pos)
+{
+	int i, n;
+	isl_bool unknown;
+	isl_aff *aff;
+
+	ls = isl_local_space_copy(ls);
+	n = isl_local_space_dim(ls, isl_dim_div);
+	for (i = n - 1; i >= 0; --i) {
+		unknown = isl_local_space_div_is_marked_unknown(ls, i);
+		if (unknown < 0)
+			ls = isl_local_space_free(ls);
+		else if (!unknown)
+			continue;
+		ls = isl_local_space_drop_dims(ls, isl_dim_div, i, 1);
+		if (pos > i)
+			--pos;
+	}
+	aff = extract_div(ls, pos);
+	isl_local_space_free(ls);
+	return aff;
+}
+
+/* Return the argument of the integer division at position "pos" in "ls".
+ * The integer division is assumed to have a complete explicit
+ * representation.  If some of the other integer divisions
+ * do not have an explicit representation, then they need
+ * to be removed first because the domain of an isl_aff
+ * is not allowed to have unknown local variables.
+ */
 __isl_give isl_aff *isl_local_space_get_div(__isl_keep isl_local_space *ls,
 	int pos)
 {
-	isl_aff *aff;
+	isl_bool known;
 
 	if (!ls)
 		return NULL;
@@ -292,18 +344,23 @@ __isl_give isl_aff *isl_local_space_get_div(__isl_keep isl_local_space *ls,
 		isl_die(isl_local_space_get_ctx(ls), isl_error_invalid,
 			"index out of bounds", return NULL);
 
-	if (isl_int_is_zero(ls->div->row[pos][0]))
+	known = isl_local_space_div_is_known(ls, pos);
+	if (known < 0)
+		return NULL;
+	if (!known)
 		isl_die(isl_local_space_get_ctx(ls), isl_error_invalid,
 			"expression of div unknown", return NULL);
 	if (!isl_local_space_is_set(ls))
 		isl_die(isl_local_space_get_ctx(ls), isl_error_invalid,
 			"cannot represent divs of map spaces", return NULL);
 
-	aff = isl_aff_alloc(isl_local_space_copy(ls));
-	if (!aff)
+	known = isl_local_space_divs_known(ls);
+	if (known < 0)
 		return NULL;
-	isl_seq_cpy(aff->v->el, ls->div->row[pos], aff->v->size);
-	return aff;
+	if (known)
+		return extract_div(ls, pos);
+	else
+		return drop_unknown_divs_and_extract_div(ls, pos);
 }
 
 __isl_give isl_space *isl_local_space_get_space(__isl_keep isl_local_space *ls)
@@ -672,8 +729,8 @@ __isl_give isl_local_space *isl_local_space_intersect(
 	isl_ctx *ctx;
 	int *exp1 = NULL;
 	int *exp2 = NULL;
-	isl_mat *div;
-	int equal;
+	isl_mat *div = NULL;
+	isl_bool equal;
 
 	if (!ls1 || !ls2)
 		goto error;
@@ -720,12 +777,28 @@ __isl_give isl_local_space *isl_local_space_intersect(
 error:
 	free(exp1);
 	free(exp2);
+	isl_mat_free(div);
 	isl_local_space_free(ls1);
 	isl_local_space_free(ls2);
 	return NULL;
 }
 
-/* Does "ls" have an explicit representation for div "div"?
+/* Is the local variable "div" of "ls" marked as not having
+ * an explicit representation?
+ * Note that even if this variable is not marked in this way and therefore
+ * does have an explicit representation, this representation may still
+ * depend (indirectly) on other local variables that do not
+ * have an explicit representation.
+ */
+isl_bool isl_local_space_div_is_marked_unknown(__isl_keep isl_local_space *ls,
+	int div)
+{
+	if (!ls)
+		return isl_bool_error;
+	return isl_local_div_is_marked_unknown(ls->div, div);
+}
+
+/* Does "ls" have a complete explicit representation for div "div"?
  */
 isl_bool isl_local_space_div_is_known(__isl_keep isl_local_space *ls, int div)
 {
@@ -744,9 +817,9 @@ isl_bool isl_local_space_divs_known(__isl_keep isl_local_space *ls)
 		return isl_bool_error;
 
 	for (i = 0; i < ls->div->n_row; ++i) {
-		isl_bool known = isl_local_space_div_is_known(ls, i);
-		if (known < 0 || !known)
-			return known;
+		isl_bool unknown = isl_local_space_div_is_marked_unknown(ls, i);
+		if (unknown < 0 || unknown)
+			return isl_bool_not(unknown);
 	}
 
 	return isl_bool_true;
@@ -964,11 +1037,11 @@ __isl_give isl_local_space *isl_local_space_substitute(
 					    subs->v->size, 0, ls->div->n_row);
 }
 
-int isl_local_space_is_named_or_nested(__isl_keep isl_local_space *ls,
+isl_bool isl_local_space_is_named_or_nested(__isl_keep isl_local_space *ls,
 	enum isl_dim_type type)
 {
 	if (!ls)
-		return -1;
+		return isl_bool_error;
 	return isl_space_is_named_or_nested(ls->dim, type);
 }
 
@@ -1053,16 +1126,16 @@ __isl_give isl_local_space *isl_local_space_insert_dims(
  * or
  *		-(f-(m-1)) + m d >= 0
  */
-int isl_local_space_is_div_constraint(__isl_keep isl_local_space *ls,
+isl_bool isl_local_space_is_div_constraint(__isl_keep isl_local_space *ls,
 	isl_int *constraint, unsigned div)
 {
 	unsigned pos;
 
 	if (!ls)
-		return -1;
+		return isl_bool_error;
 
 	if (isl_int_is_zero(ls->div->row[div][0]))
-		return 0;
+		return isl_bool_false;
 
 	pos = isl_local_space_offset(ls, isl_dim_div) + div;
 
@@ -1076,20 +1149,20 @@ int isl_local_space_is_div_constraint(__isl_keep isl_local_space *ls,
 		isl_int_add(ls->div->row[div][1],
 				ls->div->row[div][1], ls->div->row[div][0]);
 		if (!neg)
-			return 0;
+			return isl_bool_false;
 		if (isl_seq_first_non_zero(constraint+pos+1,
 					    ls->div->n_row-div-1) != -1)
-			return 0;
+			return isl_bool_false;
 	} else if (isl_int_abs_eq(constraint[pos], ls->div->row[div][0])) {
 		if (!isl_seq_eq(constraint, ls->div->row[div]+1, pos))
-			return 0;
+			return isl_bool_false;
 		if (isl_seq_first_non_zero(constraint+pos+1,
 					    ls->div->n_row-div-1) != -1)
-			return 0;
+			return isl_bool_false;
 	} else
-		return 0;
+		return isl_bool_false;
 
-	return 1;
+	return isl_bool_true;
 }
 
 /*
diff --git a/lib/Analysis/isl/isl_local_space_private.h b/lib/Analysis/isl/isl_local_space_private.h
index 50626d5..a1bdb1b 100644
--- a/lib/Analysis/isl/isl_local_space_private.h
+++ b/lib/Analysis/isl/isl_local_space_private.h
@@ -33,13 +33,15 @@ unsigned isl_local_space_offset(__isl_keep isl_local_space *ls,
 
 __isl_give isl_local_space *isl_local_space_replace_divs(
 	__isl_take isl_local_space *ls, __isl_take isl_mat *div);
+isl_bool isl_local_space_div_is_marked_unknown(__isl_keep isl_local_space *ls,
+	int div);
 isl_bool isl_local_space_div_is_known(__isl_keep isl_local_space *ls, int div);
 isl_bool isl_local_space_divs_known(__isl_keep isl_local_space *ls);
 
 __isl_give isl_local_space *isl_local_space_substitute_equalities(
 	__isl_take isl_local_space *ls, __isl_take isl_basic_set *eq);
 
-int isl_local_space_is_named_or_nested(__isl_keep isl_local_space *ls,
+isl_bool isl_local_space_is_named_or_nested(__isl_keep isl_local_space *ls,
 	enum isl_dim_type type);
 
 isl_bool isl_local_space_has_equal_space(__isl_keep isl_local_space *ls1,
@@ -50,7 +52,7 @@ __isl_give isl_local_space *isl_local_space_reset_space(
 __isl_give isl_local_space *isl_local_space_realign(
 	__isl_take isl_local_space *ls, __isl_take isl_reordering *r);
 
-int isl_local_space_is_div_constraint(__isl_keep isl_local_space *ls,
+isl_bool isl_local_space_is_div_constraint(__isl_keep isl_local_space *ls,
 	isl_int *constraint, unsigned div);
 
 int *isl_local_space_get_active(__isl_keep isl_local_space *ls, isl_int *l);
diff --git a/lib/Analysis/isl/isl_lp.c b/lib/Analysis/isl/isl_lp.c
index 1d5ae6e..0c2f5ff 100644
--- a/lib/Analysis/isl/isl_lp.c
+++ b/lib/Analysis/isl/isl_lp.c
@@ -19,10 +19,12 @@
 #include <isl_val_private.h>
 #include <isl_vec_private.h>
 
-enum isl_lp_result isl_tab_solve_lp(struct isl_basic_map *bmap, int maximize,
-				      isl_int *f, isl_int denom, isl_int *opt,
-				      isl_int *opt_denom,
-				      struct isl_vec **sol)
+#include <bset_to_bmap.c>
+#include <set_to_map.c>
+
+enum isl_lp_result isl_tab_solve_lp(__isl_keep isl_basic_map *bmap,
+	int maximize, isl_int *f, isl_int denom, isl_int *opt,
+	isl_int *opt_denom, __isl_give isl_vec **sol)
 {
 	struct isl_tab *tab;
 	enum isl_lp_result res;
@@ -57,12 +59,11 @@ enum isl_lp_result isl_tab_solve_lp(struct isl_basic_map *bmap, int maximize,
  * If opt_denom is NULL, then *opt is rounded up (or down)
  * to the nearest integer.
  * The return value reflects the nature of the result (empty, unbounded,
- * minmimal or maximal value returned in *opt).
+ * minimal or maximal value returned in *opt).
  */
-enum isl_lp_result isl_basic_map_solve_lp(struct isl_basic_map *bmap, int max,
-				      isl_int *f, isl_int d, isl_int *opt,
-				      isl_int *opt_denom,
-				      struct isl_vec **sol)
+enum isl_lp_result isl_basic_map_solve_lp(__isl_keep isl_basic_map *bmap,
+	int max, isl_int *f, isl_int d, isl_int *opt, isl_int *opt_denom,
+	__isl_give isl_vec **sol)
 {
 	if (sol)
 		*sol = NULL;
@@ -78,7 +79,7 @@ enum isl_lp_result isl_basic_set_solve_lp(struct isl_basic_set *bset, int max,
 				      isl_int *opt_denom,
 				      struct isl_vec **sol)
 {
-	return isl_basic_map_solve_lp((struct isl_basic_map *)bset, max,
+	return isl_basic_map_solve_lp(bset_to_bmap(bset), max,
 					f, d, opt, opt_denom, sol);
 }
 
@@ -196,7 +197,7 @@ enum isl_lp_result isl_set_solve_lp(__isl_keep isl_set *set, int max,
 				      isl_int *opt_denom,
 				      struct isl_vec **sol)
 {
-	return isl_map_solve_lp((struct isl_map *)set, max,
+	return isl_map_solve_lp(set_to_map(set), max,
 					f, d, opt, opt_denom, sol);
 }
 
@@ -317,13 +318,16 @@ error:
 static __isl_give isl_val *isl_basic_set_opt_lp_val(
 	__isl_keep isl_basic_set *bset, int max, __isl_keep isl_aff *obj)
 {
+	isl_bool equal;
 	isl_val *res;
 
 	if (!bset || !obj)
 		return NULL;
 
-	if (isl_space_match(bset->dim, isl_dim_param,
-			    obj->ls->dim, isl_dim_param))
+	equal = isl_basic_set_space_has_equal_params(bset, obj->ls->dim);
+	if (equal < 0)
+		return NULL;
+	if (equal)
 		return isl_basic_set_opt_lp_val_aligned(bset, max, obj);
 
 	bset = isl_basic_set_copy(bset);
diff --git a/lib/Analysis/isl/isl_map.c b/lib/Analysis/isl/isl_map.c
index 71e0fd6..cb3b376 100644
--- a/lib/Analysis/isl/isl_map.c
+++ b/lib/Analysis/isl/isl_map.c
@@ -3,6 +3,7 @@
  * Copyright 2010      INRIA Saclay
  * Copyright 2012-2014 Ecole Normale Superieure
  * Copyright 2014      INRIA Rocquencourt
+ * Copyright 2016      INRIA Paris
  * Copyright 2016      Sven Verdoolaege
  *
  * Use of this software is governed by the MIT license
@@ -14,6 +15,8 @@
  * and Ecole Normale Superieure, 45 rue dUlm, 75230 Paris, France
  * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
  * B.P. 105 - 78153 Le Chesnay, France
+ * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
+ * CS 42112, 75589 Paris Cedex 12, France
  */
 
 #include <string.h>
@@ -43,6 +46,11 @@
 #include <isl/deprecated/map_int.h>
 #include <isl/deprecated/set_int.h>
 
+#include <bset_to_bmap.c>
+#include <bset_from_bmap.c>
+#include <set_to_map.c>
+#include <set_from_map.c>
+
 static unsigned n(__isl_keep isl_space *dim, enum isl_dim_type type)
 {
 	switch (type) {
@@ -80,6 +88,13 @@ unsigned isl_basic_map_dim(__isl_keep isl_basic_map *bmap,
 	}
 }
 
+/* Return the space of "map".
+ */
+__isl_keep isl_space *isl_map_peek_space(__isl_keep const isl_map *map)
+{
+	return map ? map->dim : NULL;
+}
+
 unsigned isl_map_dim(__isl_keep isl_map *map, enum isl_dim_type type)
 {
 	return map ? n(map->dim, type) : 0;
@@ -93,24 +108,30 @@ unsigned isl_set_dim(__isl_keep isl_set *set, enum isl_dim_type type)
 unsigned isl_basic_map_offset(struct isl_basic_map *bmap,
 					enum isl_dim_type type)
 {
-	isl_space *dim = bmap->dim;
+	isl_space *space;
+
+	if (!bmap)
+		return 0;
+
+	space = bmap->dim;
 	switch (type) {
 	case isl_dim_cst:	return 0;
 	case isl_dim_param:	return 1;
-	case isl_dim_in:	return 1 + dim->nparam;
-	case isl_dim_out:	return 1 + dim->nparam + dim->n_in;
-	case isl_dim_div:	return 1 + dim->nparam + dim->n_in + dim->n_out;
+	case isl_dim_in:	return 1 + space->nparam;
+	case isl_dim_out:	return 1 + space->nparam + space->n_in;
+	case isl_dim_div:	return 1 + space->nparam + space->n_in +
+								space->n_out;
 	default:		return 0;
 	}
 }
 
-unsigned isl_basic_set_offset(struct isl_basic_set *bset,
+unsigned isl_basic_set_offset(__isl_keep isl_basic_set *bset,
 					enum isl_dim_type type)
 {
 	return isl_basic_map_offset(bset, type);
 }
 
-static unsigned map_offset(struct isl_map *map, enum isl_dim_type type)
+static unsigned map_offset(__isl_keep isl_map *map, enum isl_dim_type type)
 {
 	return pos(map->dim, type);
 }
@@ -131,7 +152,7 @@ unsigned isl_basic_set_n_param(__isl_keep isl_basic_set *bset)
 	return isl_basic_set_dim(bset, isl_dim_param);
 }
 
-unsigned isl_basic_set_total_dim(const struct isl_basic_set *bset)
+unsigned isl_basic_set_total_dim(__isl_keep const isl_basic_set *bset)
 {
 	if (!bset)
 		return 0;
@@ -148,90 +169,160 @@ unsigned isl_set_n_param(__isl_keep isl_set *set)
 	return isl_set_dim(set, isl_dim_param);
 }
 
-unsigned isl_basic_map_n_in(const struct isl_basic_map *bmap)
+unsigned isl_basic_map_n_in(__isl_keep const isl_basic_map *bmap)
 {
 	return bmap ? bmap->dim->n_in : 0;
 }
 
-unsigned isl_basic_map_n_out(const struct isl_basic_map *bmap)
+unsigned isl_basic_map_n_out(__isl_keep const isl_basic_map *bmap)
 {
 	return bmap ? bmap->dim->n_out : 0;
 }
 
-unsigned isl_basic_map_n_param(const struct isl_basic_map *bmap)
+unsigned isl_basic_map_n_param(__isl_keep const isl_basic_map *bmap)
 {
 	return bmap ? bmap->dim->nparam : 0;
 }
 
-unsigned isl_basic_map_n_div(const struct isl_basic_map *bmap)
+unsigned isl_basic_map_n_div(__isl_keep const isl_basic_map *bmap)
 {
 	return bmap ? bmap->n_div : 0;
 }
 
-unsigned isl_basic_map_total_dim(const struct isl_basic_map *bmap)
+unsigned isl_basic_map_total_dim(__isl_keep const isl_basic_map *bmap)
 {
 	return bmap ? isl_space_dim(bmap->dim, isl_dim_all) + bmap->n_div : 0;
 }
 
-unsigned isl_map_n_in(const struct isl_map *map)
+unsigned isl_map_n_in(__isl_keep const isl_map *map)
 {
 	return map ? map->dim->n_in : 0;
 }
 
-unsigned isl_map_n_out(const struct isl_map *map)
+unsigned isl_map_n_out(__isl_keep const isl_map *map)
 {
 	return map ? map->dim->n_out : 0;
 }
 
-unsigned isl_map_n_param(const struct isl_map *map)
+unsigned isl_map_n_param(__isl_keep const isl_map *map)
 {
 	return map ? map->dim->nparam : 0;
 }
 
-int isl_map_compatible_domain(struct isl_map *map, struct isl_set *set)
+/* Return the number of equality constraints in the description of "bmap".
+ * Return -1 on error.
+ */
+int isl_basic_map_n_equality(__isl_keep isl_basic_map *bmap)
 {
-	int m;
-	if (!map || !set)
+	if (!bmap)
 		return -1;
-	m = isl_space_match(map->dim, isl_dim_param, set->dim, isl_dim_param);
+	return bmap->n_eq;
+}
+
+/* Return the number of equality constraints in the description of "bset".
+ * Return -1 on error.
+ */
+int isl_basic_set_n_equality(__isl_keep isl_basic_set *bset)
+{
+	return isl_basic_map_n_equality(bset_to_bmap(bset));
+}
+
+/* Return the number of inequality constraints in the description of "bmap".
+ * Return -1 on error.
+ */
+int isl_basic_map_n_inequality(__isl_keep isl_basic_map *bmap)
+{
+	if (!bmap)
+		return -1;
+	return bmap->n_ineq;
+}
+
+/* Return the number of inequality constraints in the description of "bset".
+ * Return -1 on error.
+ */
+int isl_basic_set_n_inequality(__isl_keep isl_basic_set *bset)
+{
+	return isl_basic_map_n_inequality(bset_to_bmap(bset));
+}
+
+/* Do "bmap1" and "bmap2" have the same parameters?
+ */
+static isl_bool isl_basic_map_has_equal_params(__isl_keep isl_basic_map *bmap1,
+	__isl_keep isl_basic_map *bmap2)
+{
+	isl_space *space1, *space2;
+
+	space1 = isl_basic_map_peek_space(bmap1);
+	space2 = isl_basic_map_peek_space(bmap2);
+	return isl_space_has_equal_params(space1, space2);
+}
+
+/* Do "map1" and "map2" have the same parameters?
+ */
+isl_bool isl_map_has_equal_params(__isl_keep isl_map *map1,
+	__isl_keep isl_map *map2)
+{
+	isl_space *space1, *space2;
+
+	space1 = isl_map_peek_space(map1);
+	space2 = isl_map_peek_space(map2);
+	return isl_space_has_equal_params(space1, space2);
+}
+
+/* Do "map" and "set" have the same parameters?
+ */
+static isl_bool isl_map_set_has_equal_params(__isl_keep isl_map *map,
+	__isl_keep isl_set *set)
+{
+	return isl_map_has_equal_params(map, set_to_map(set));
+}
+
+isl_bool isl_map_compatible_domain(__isl_keep isl_map *map,
+	__isl_keep isl_set *set)
+{
+	isl_bool m;
+	if (!map || !set)
+		return isl_bool_error;
+	m = isl_map_has_equal_params(map, set_to_map(set));
 	if (m < 0 || !m)
 		return m;
 	return isl_space_tuple_is_equal(map->dim, isl_dim_in,
 					set->dim, isl_dim_set);
 }
 
-int isl_basic_map_compatible_domain(struct isl_basic_map *bmap,
-		struct isl_basic_set *bset)
+isl_bool isl_basic_map_compatible_domain(__isl_keep isl_basic_map *bmap,
+	__isl_keep isl_basic_set *bset)
 {
-	int m;
+	isl_bool m;
 	if (!bmap || !bset)
-		return -1;
-	m = isl_space_match(bmap->dim, isl_dim_param, bset->dim, isl_dim_param);
+		return isl_bool_error;
+	m = isl_basic_map_has_equal_params(bmap, bset_to_bmap(bset));
 	if (m < 0 || !m)
 		return m;
 	return isl_space_tuple_is_equal(bmap->dim, isl_dim_in,
 					bset->dim, isl_dim_set);
 }
 
-int isl_map_compatible_range(__isl_keep isl_map *map, __isl_keep isl_set *set)
+isl_bool isl_map_compatible_range(__isl_keep isl_map *map,
+	__isl_keep isl_set *set)
 {
-	int m;
+	isl_bool m;
 	if (!map || !set)
-		return -1;
-	m = isl_space_match(map->dim, isl_dim_param, set->dim, isl_dim_param);
+		return isl_bool_error;
+	m = isl_map_has_equal_params(map, set_to_map(set));
 	if (m < 0 || !m)
 		return m;
 	return isl_space_tuple_is_equal(map->dim, isl_dim_out,
 					set->dim, isl_dim_set);
 }
 
-int isl_basic_map_compatible_range(struct isl_basic_map *bmap,
-		struct isl_basic_set *bset)
+isl_bool isl_basic_map_compatible_range(__isl_keep isl_basic_map *bmap,
+	__isl_keep isl_basic_set *bset)
 {
-	int m;
+	isl_bool m;
 	if (!bmap || !bset)
-		return -1;
-	m = isl_space_match(bmap->dim, isl_dim_param, bset->dim, isl_dim_param);
+		return isl_bool_error;
+	m = isl_basic_map_has_equal_params(bmap, bset_to_bmap(bset));
 	if (m < 0 || !m)
 		return m;
 	return isl_space_tuple_is_equal(bmap->dim, isl_dim_out,
@@ -258,18 +349,29 @@ isl_ctx *isl_set_get_ctx(__isl_keep isl_set *set)
 	return set ? set->ctx : NULL;
 }
 
+/* Return the space of "bmap".
+ */
+__isl_keep isl_space *isl_basic_map_peek_space(
+	__isl_keep const isl_basic_map *bmap)
+{
+	return bmap ? bmap->dim : NULL;
+}
+
+/* Return the space of "bset".
+ */
+__isl_keep isl_space *isl_basic_set_peek_space(__isl_keep isl_basic_set *bset)
+{
+	return isl_basic_map_peek_space(bset_to_bmap(bset));
+}
+
 __isl_give isl_space *isl_basic_map_get_space(__isl_keep isl_basic_map *bmap)
 {
-	if (!bmap)
-		return NULL;
-	return isl_space_copy(bmap->dim);
+	return isl_space_copy(isl_basic_map_peek_space(bmap));
 }
 
 __isl_give isl_space *isl_basic_set_get_space(__isl_keep isl_basic_set *bset)
 {
-	if (!bset)
-		return NULL;
-	return isl_space_copy(bset->dim);
+	return isl_basic_map_get_space(bset_to_bmap(bset));
 }
 
 /* Extract the divs in "bmap" as a matrix.
@@ -393,9 +495,7 @@ __isl_give isl_basic_set *isl_basic_set_from_local_space(
 
 __isl_give isl_space *isl_map_get_space(__isl_keep isl_map *map)
 {
-	if (!map)
-		return NULL;
-	return isl_space_copy(map->dim);
+	return isl_space_copy(isl_map_peek_space(map));
 }
 
 __isl_give isl_space *isl_set_get_space(__isl_keep isl_set *set)
@@ -501,7 +601,8 @@ const char *isl_map_get_tuple_name(__isl_keep isl_map *map,
 __isl_give isl_set *isl_set_set_tuple_name(__isl_take isl_set *set,
 	const char *s)
 {
-	return (isl_set *)isl_map_set_tuple_name((isl_map *)set, isl_dim_set, s);
+	return set_from_map(isl_map_set_tuple_name(set_to_map(set),
+						isl_dim_set, s));
 }
 
 __isl_give isl_map *isl_map_set_tuple_id(__isl_take isl_map *map,
@@ -672,14 +773,15 @@ __isl_give isl_basic_set *isl_basic_set_set_dim_name(
 	__isl_take isl_basic_set *bset,
 	enum isl_dim_type type, unsigned pos, const char *s)
 {
-	return (isl_basic_set *)isl_basic_map_set_dim_name(
-		(isl_basic_map *)bset, type, pos, s);
+	return bset_from_bmap(isl_basic_map_set_dim_name(bset_to_bmap(bset),
+							type, pos, s));
 }
 
 __isl_give isl_set *isl_set_set_dim_name(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned pos, const char *s)
 {
-	return (isl_set *)isl_map_set_dim_name((isl_map *)set, type, pos, s);
+	return set_from_map(isl_map_set_dim_name(set_to_map(set),
+							type, pos, s));
 }
 
 isl_bool isl_basic_map_has_dim_id(__isl_keep isl_basic_map *bmap,
@@ -781,6 +883,53 @@ int isl_set_find_dim_by_name(__isl_keep isl_set *set, enum isl_dim_type type,
 	return isl_map_find_dim_by_name(set, type, name);
 }
 
+/* Check whether equality i of bset is a pure stride constraint
+ * on a single dimension, i.e., of the form
+ *
+ *	v = k e
+ *
+ * with k a constant and e an existentially quantified variable.
+ */
+isl_bool isl_basic_set_eq_is_stride(__isl_keep isl_basic_set *bset, int i)
+{
+	unsigned nparam;
+	unsigned d;
+	unsigned n_div;
+	int pos1;
+	int pos2;
+
+	if (!bset)
+		return isl_bool_error;
+
+	if (!isl_int_is_zero(bset->eq[i][0]))
+		return isl_bool_false;
+
+	nparam = isl_basic_set_dim(bset, isl_dim_param);
+	d = isl_basic_set_dim(bset, isl_dim_set);
+	n_div = isl_basic_set_dim(bset, isl_dim_div);
+
+	if (isl_seq_first_non_zero(bset->eq[i] + 1, nparam) != -1)
+		return isl_bool_false;
+	pos1 = isl_seq_first_non_zero(bset->eq[i] + 1 + nparam, d);
+	if (pos1 == -1)
+		return isl_bool_false;
+	if (isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + pos1 + 1,
+					d - pos1 - 1) != -1)
+		return isl_bool_false;
+
+	pos2 = isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + d, n_div);
+	if (pos2 == -1)
+		return isl_bool_false;
+	if (isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + d  + pos2 + 1,
+				   n_div - pos2 - 1) != -1)
+		return isl_bool_false;
+	if (!isl_int_is_one(bset->eq[i][1 + nparam + pos1]) &&
+	    !isl_int_is_negone(bset->eq[i][1 + nparam + pos1]))
+		return isl_bool_false;
+
+	return isl_bool_true;
+}
+
 /* Reset the user pointer on all identifiers of parameters and tuples
  * of the space of "map".
  */
@@ -803,13 +952,57 @@ __isl_give isl_set *isl_set_reset_user(__isl_take isl_set *set)
 	return isl_map_reset_user(set);
 }
 
-int isl_basic_map_is_rational(__isl_keep isl_basic_map *bmap)
+isl_bool isl_basic_map_is_rational(__isl_keep isl_basic_map *bmap)
 {
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	return ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);
 }
 
+/* Has "map" been marked as a rational map?
+ * In particular, have all basic maps in "map" been marked this way?
+ * An empty map is not considered to be rational.
+ * Maps where only some of the basic maps are marked rational
+ * are not allowed.
+ */
+isl_bool isl_map_is_rational(__isl_keep isl_map *map)
+{
+	int i;
+	isl_bool rational;
+
+	if (!map)
+		return isl_bool_error;
+	if (map->n == 0)
+		return isl_bool_false;
+	rational = isl_basic_map_is_rational(map->p[0]);
+	if (rational < 0)
+		return rational;
+	for (i = 1; i < map->n; ++i) {
+		isl_bool rational_i;
+
+		rational_i = isl_basic_map_is_rational(map->p[i]);
+		if (rational_i < 0)
+			return rational_i;
+		if (rational != rational_i)
+			isl_die(isl_map_get_ctx(map), isl_error_unsupported,
+				"mixed rational and integer basic maps "
+				"not supported", return isl_bool_error);
+	}
+
+	return rational;
+}
+
+/* Has "set" been marked as a rational set?
+ * In particular, have all basic set in "set" been marked this way?
+ * An empty set is not considered to be rational.
+ * Sets where only some of the basic sets are marked rational
+ * are not allowed.
+ */
+isl_bool isl_set_is_rational(__isl_keep isl_set *set)
+{
+	return isl_map_is_rational(set);
+}
+
 int isl_basic_set_is_rational(__isl_keep isl_basic_set *bset)
 {
 	return isl_basic_map_is_rational(bset);
@@ -821,21 +1014,21 @@ int isl_basic_set_is_rational(__isl_keep isl_basic_set *bset)
  * to an integer constant, then it has no rational points, even if it
  * is marked as rational.
  */
-int isl_basic_map_has_rational(__isl_keep isl_basic_map *bmap)
+isl_bool isl_basic_map_has_rational(__isl_keep isl_basic_map *bmap)
 {
-	int has_rational = 1;
+	isl_bool has_rational = isl_bool_true;
 	unsigned total;
 
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	if (isl_basic_map_plain_is_empty(bmap))
-		return 0;
+		return isl_bool_false;
 	if (!isl_basic_map_is_rational(bmap))
-		return 0;
+		return isl_bool_false;
 	bmap = isl_basic_map_copy(bmap);
 	bmap = isl_basic_map_implicit_equalities(bmap);
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	total = isl_basic_map_total_dim(bmap);
 	if (bmap->n_eq == total) {
 		int i, j;
@@ -852,7 +1045,7 @@ int isl_basic_map_has_rational(__isl_keep isl_basic_map *bmap)
 				break;
 		}
 		if (i == bmap->n_eq)
-			has_rational = 0;
+			has_rational = isl_bool_false;
 	}
 	isl_basic_map_free(bmap);
 
@@ -861,36 +1054,34 @@ int isl_basic_map_has_rational(__isl_keep isl_basic_map *bmap)
 
 /* Does "map" contain any rational points?
  */
-int isl_map_has_rational(__isl_keep isl_map *map)
+isl_bool isl_map_has_rational(__isl_keep isl_map *map)
 {
 	int i;
-	int has_rational;
+	isl_bool has_rational;
 
 	if (!map)
-		return -1;
+		return isl_bool_error;
 	for (i = 0; i < map->n; ++i) {
 		has_rational = isl_basic_map_has_rational(map->p[i]);
-		if (has_rational < 0)
-			return -1;
-		if (has_rational)
-			return 1;
+		if (has_rational < 0 || has_rational)
+			return has_rational;
 	}
-	return 0;
+	return isl_bool_false;
 }
 
 /* Does "set" contain any rational points?
  */
-int isl_set_has_rational(__isl_keep isl_set *set)
+isl_bool isl_set_has_rational(__isl_keep isl_set *set)
 {
 	return isl_map_has_rational(set);
 }
 
 /* Is this basic set a parameter domain?
  */
-int isl_basic_set_is_params(__isl_keep isl_basic_set *bset)
+isl_bool isl_basic_set_is_params(__isl_keep isl_basic_set *bset)
 {
 	if (!bset)
-		return -1;
+		return isl_bool_error;
 	return isl_space_is_params(bset->dim);
 }
 
@@ -907,10 +1098,10 @@ isl_bool isl_set_is_params(__isl_keep isl_set *set)
  * Users should never call this function.  Outside of isl,
  * a map can never be a parameter domain.
  */
-int isl_map_is_params(__isl_keep isl_map *map)
+isl_bool isl_map_is_params(__isl_keep isl_map *map)
 {
 	if (!map)
-		return -1;
+		return isl_bool_error;
 	return isl_space_is_params(map->dim);
 }
 
@@ -979,10 +1170,10 @@ struct isl_basic_set *isl_basic_set_alloc(struct isl_ctx *ctx,
 		return NULL;
 
 	bmap = isl_basic_map_alloc_space(space, extra, n_eq, n_ineq);
-	return (struct isl_basic_set *)bmap;
+	return bset_from_bmap(bmap);
 }
 
-struct isl_basic_set *isl_basic_set_alloc_space(__isl_take isl_space *dim,
+__isl_give isl_basic_set *isl_basic_set_alloc_space(__isl_take isl_space *dim,
 		unsigned extra, unsigned n_eq, unsigned n_ineq)
 {
 	struct isl_basic_map *bmap;
@@ -990,7 +1181,7 @@ struct isl_basic_set *isl_basic_set_alloc_space(__isl_take isl_space *dim,
 		return NULL;
 	isl_assert(dim->ctx, dim->n_in == 0, goto error);
 	bmap = isl_basic_map_alloc_space(dim, extra, n_eq, n_ineq);
-	return (struct isl_basic_set *)bmap;
+	return bset_from_bmap(bmap);
 error:
 	isl_space_free(dim);
 	return NULL;
@@ -1052,7 +1243,7 @@ static void dup_constraints(
 	ISL_F_SET(dst, ISL_BASIC_SET_FINAL);
 }
 
-struct isl_basic_map *isl_basic_map_dup(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_dup(__isl_keep isl_basic_map *bmap)
 {
 	struct isl_basic_map *dup;
 
@@ -1072,11 +1263,11 @@ struct isl_basic_set *isl_basic_set_dup(struct isl_basic_set *bset)
 {
 	struct isl_basic_map *dup;
 
-	dup = isl_basic_map_dup((struct isl_basic_map *)bset);
-	return (struct isl_basic_set *)dup;
+	dup = isl_basic_map_dup(bset_to_bmap(bset));
+	return bset_from_bmap(dup);
 }
 
-struct isl_basic_set *isl_basic_set_copy(struct isl_basic_set *bset)
+__isl_give isl_basic_set *isl_basic_set_copy(__isl_keep isl_basic_set *bset)
 {
 	if (!bset)
 		return NULL;
@@ -1088,7 +1279,7 @@ struct isl_basic_set *isl_basic_set_copy(struct isl_basic_set *bset)
 	return isl_basic_set_dup(bset);
 }
 
-struct isl_set *isl_set_copy(struct isl_set *set)
+__isl_give isl_set *isl_set_copy(__isl_keep isl_set *set)
 {
 	if (!set)
 		return NULL;
@@ -1097,7 +1288,7 @@ struct isl_set *isl_set_copy(struct isl_set *set)
 	return set;
 }
 
-struct isl_basic_map *isl_basic_map_copy(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_copy(__isl_keep isl_basic_map *bmap)
 {
 	if (!bmap)
 		return NULL;
@@ -1112,7 +1303,7 @@ struct isl_basic_map *isl_basic_map_copy(struct isl_basic_map *bmap)
 	return bmap;
 }
 
-struct isl_map *isl_map_copy(struct isl_map *map)
+__isl_give isl_map *isl_map_copy(__isl_keep isl_map *map)
 {
 	if (!map)
 		return NULL;
@@ -1143,7 +1334,7 @@ __isl_null isl_basic_map *isl_basic_map_free(__isl_take isl_basic_map *bmap)
 
 __isl_null isl_basic_set *isl_basic_set_free(__isl_take isl_basic_set *bset)
 {
-	return isl_basic_map_free((struct isl_basic_map *)bset);
+	return isl_basic_map_free(bset_to_bmap(bset));
 }
 
 static int room_for_con(struct isl_basic_map *bmap, unsigned n)
@@ -1151,6 +1342,31 @@ static int room_for_con(struct isl_basic_map *bmap, unsigned n)
 	return bmap->n_eq + bmap->n_ineq + n <= bmap->c_size;
 }
 
+/* Check that "map" has only named parameters, reporting an error
+ * if it does not.
+ */
+isl_stat isl_map_check_named_params(__isl_keep isl_map *map)
+{
+	return isl_space_check_named_params(isl_map_peek_space(map));
+}
+
+/* Check that "bmap1" and "bmap2" have the same parameters,
+ * reporting an error if they do not.
+ */
+static isl_stat isl_basic_map_check_equal_params(
+	__isl_keep isl_basic_map *bmap1, __isl_keep isl_basic_map *bmap2)
+{
+	isl_bool match;
+
+	match = isl_basic_map_has_equal_params(bmap1, bmap2);
+	if (match < 0)
+		return isl_stat_error;
+	if (!match)
+		isl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,
+			"parameters don't match", return isl_stat_error);
+	return isl_stat_ok;
+}
+
 __isl_give isl_map *isl_map_align_params_map_map_and(
 	__isl_take isl_map *map1, __isl_take isl_map *map2,
 	__isl_give isl_map *(*fn)(__isl_take isl_map *map1,
@@ -1158,12 +1374,12 @@ __isl_give isl_map *isl_map_align_params_map_map_and(
 {
 	if (!map1 || !map2)
 		goto error;
-	if (isl_space_match(map1->dim, isl_dim_param, map2->dim, isl_dim_param))
+	if (isl_map_has_equal_params(map1, map2))
 		return fn(map1, map2);
-	if (!isl_space_has_named_params(map1->dim) ||
-	    !isl_space_has_named_params(map2->dim))
-		isl_die(map1->ctx, isl_error_invalid,
-			"unaligned unnamed parameters", goto error);
+	if (isl_map_check_named_params(map1) < 0)
+		goto error;
+	if (isl_map_check_named_params(map2) < 0)
+		goto error;
 	map1 = isl_map_align_params(map1, isl_map_get_space(map2));
 	map2 = isl_map_align_params(map2, isl_map_get_space(map1));
 	return fn(map1, map2);
@@ -1181,12 +1397,12 @@ isl_bool isl_map_align_params_map_map_and_test(__isl_keep isl_map *map1,
 
 	if (!map1 || !map2)
 		return isl_bool_error;
-	if (isl_space_match(map1->dim, isl_dim_param, map2->dim, isl_dim_param))
+	if (isl_map_has_equal_params(map1, map2))
 		return fn(map1, map2);
-	if (!isl_space_has_named_params(map1->dim) ||
-	    !isl_space_has_named_params(map2->dim))
-		isl_die(map1->ctx, isl_error_invalid,
-			"unaligned unnamed parameters", return isl_bool_error);
+	if (isl_map_check_named_params(map1) < 0)
+		return isl_bool_error;
+	if (isl_map_check_named_params(map2) < 0)
+		return isl_bool_error;
 	map1 = isl_map_copy(map1);
 	map2 = isl_map_copy(map2);
 	map1 = isl_map_align_params(map1, isl_map_get_space(map2));
@@ -1232,7 +1448,7 @@ int isl_basic_map_alloc_equality(struct isl_basic_map *bmap)
 
 int isl_basic_set_alloc_equality(struct isl_basic_set *bset)
 {
-	return isl_basic_map_alloc_equality((struct isl_basic_map *)bset);
+	return isl_basic_map_alloc_equality(bset_to_bmap(bset));
 }
 
 int isl_basic_map_free_equality(struct isl_basic_map *bmap, unsigned n)
@@ -1246,7 +1462,7 @@ int isl_basic_map_free_equality(struct isl_basic_map *bmap, unsigned n)
 
 int isl_basic_set_free_equality(struct isl_basic_set *bset, unsigned n)
 {
-	return isl_basic_map_free_equality((struct isl_basic_map *)bset, n);
+	return isl_basic_map_free_equality(bset_to_bmap(bset), n);
 }
 
 int isl_basic_map_drop_equality(struct isl_basic_map *bmap, unsigned pos)
@@ -1265,11 +1481,6 @@ int isl_basic_map_drop_equality(struct isl_basic_map *bmap, unsigned pos)
 	return 0;
 }
 
-int isl_basic_set_drop_equality(struct isl_basic_set *bset, unsigned pos)
-{
-	return isl_basic_map_drop_equality((struct isl_basic_map *)bset, pos);
-}
-
 /* Turn inequality "pos" of "bmap" into an equality.
  *
  * In particular, we move the inequality in front of the equalities
@@ -1300,7 +1511,7 @@ static int room_for_ineq(struct isl_basic_map *bmap, unsigned n)
 	return bmap->n_ineq + n <= bmap->eq - bmap->ineq;
 }
 
-int isl_basic_map_alloc_inequality(struct isl_basic_map *bmap)
+int isl_basic_map_alloc_inequality(__isl_keep isl_basic_map *bmap)
 {
 	struct isl_ctx *ctx;
 	if (!bmap)
@@ -1317,9 +1528,9 @@ int isl_basic_map_alloc_inequality(struct isl_basic_map *bmap)
 	return bmap->n_ineq++;
 }
 
-int isl_basic_set_alloc_inequality(struct isl_basic_set *bset)
+int isl_basic_set_alloc_inequality(__isl_keep isl_basic_set *bset)
 {
-	return isl_basic_map_alloc_inequality((struct isl_basic_map *)bset);
+	return isl_basic_map_alloc_inequality(bset_to_bmap(bset));
 }
 
 int isl_basic_map_free_inequality(struct isl_basic_map *bmap, unsigned n)
@@ -1333,7 +1544,7 @@ int isl_basic_map_free_inequality(struct isl_basic_map *bmap, unsigned n)
 
 int isl_basic_set_free_inequality(struct isl_basic_set *bset, unsigned n)
 {
-	return isl_basic_map_free_inequality((struct isl_basic_map *)bset, n);
+	return isl_basic_map_free_inequality(bset_to_bmap(bset), n);
 }
 
 int isl_basic_map_drop_inequality(struct isl_basic_map *bmap, unsigned pos)
@@ -1355,7 +1566,7 @@ int isl_basic_map_drop_inequality(struct isl_basic_map *bmap, unsigned pos)
 
 int isl_basic_set_drop_inequality(struct isl_basic_set *bset, unsigned pos)
 {
-	return isl_basic_map_drop_inequality((struct isl_basic_map *)bset, pos);
+	return isl_basic_map_drop_inequality(bset_to_bmap(bset), pos);
 }
 
 __isl_give isl_basic_map *isl_basic_map_add_eq(__isl_take isl_basic_map *bmap,
@@ -1379,8 +1590,7 @@ error:
 __isl_give isl_basic_set *isl_basic_set_add_eq(__isl_take isl_basic_set *bset,
 	isl_int *eq)
 {
-	return (isl_basic_set *)
-		isl_basic_map_add_eq((isl_basic_map *)bset, eq);
+	return bset_from_bmap(isl_basic_map_add_eq(bset_to_bmap(bset), eq));
 }
 
 __isl_give isl_basic_map *isl_basic_map_add_ineq(__isl_take isl_basic_map *bmap,
@@ -1404,8 +1614,7 @@ error:
 __isl_give isl_basic_set *isl_basic_set_add_ineq(__isl_take isl_basic_set *bset,
 	isl_int *ineq)
 {
-	return (isl_basic_set *)
-		isl_basic_map_add_ineq((isl_basic_map *)bset, ineq);
+	return bset_from_bmap(isl_basic_map_add_ineq(bset_to_bmap(bset), ineq));
 }
 
 int isl_basic_map_alloc_div(struct isl_basic_map *bmap)
@@ -1422,21 +1631,69 @@ int isl_basic_map_alloc_div(struct isl_basic_map *bmap)
 
 int isl_basic_set_alloc_div(struct isl_basic_set *bset)
 {
-	return isl_basic_map_alloc_div((struct isl_basic_map *)bset);
+	return isl_basic_map_alloc_div(bset_to_bmap(bset));
 }
 
-int isl_basic_map_free_div(struct isl_basic_map *bmap, unsigned n)
+/* Check that there are "n" dimensions of type "type" starting at "first"
+ * in "bmap".
+ */
+static isl_stat isl_basic_map_check_range(__isl_keep isl_basic_map *bmap,
+	enum isl_dim_type type, unsigned first, unsigned n)
 {
+	unsigned dim;
+
 	if (!bmap)
-		return -1;
-	isl_assert(bmap->ctx, n <= bmap->n_div, return -1);
-	bmap->n_div -= n;
-	return 0;
+		return isl_stat_error;
+	dim = isl_basic_map_dim(bmap, type);
+	if (first + n > dim || first + n < first)
+		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
+			"position or range out of bounds",
+			return isl_stat_error);
+	return isl_stat_ok;
+}
+
+/* Insert an extra integer division, prescribed by "div", to "bmap"
+ * at (integer division) position "pos".
+ *
+ * The integer division is first added at the end and then moved
+ * into the right position.
+ */
+__isl_give isl_basic_map *isl_basic_map_insert_div(
+	__isl_take isl_basic_map *bmap, int pos, __isl_keep isl_vec *div)
+{
+	int i, k;
+
+	bmap = isl_basic_map_cow(bmap);
+	if (!bmap || !div)
+		return isl_basic_map_free(bmap);
+
+	if (div->size != 1 + 1 + isl_basic_map_dim(bmap, isl_dim_all))
+		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
+			"unexpected size", return isl_basic_map_free(bmap));
+	if (isl_basic_map_check_range(bmap, isl_dim_div, pos, 0) < 0)
+		return isl_basic_map_free(bmap);
+
+	bmap = isl_basic_map_extend_space(bmap,
+					isl_basic_map_get_space(bmap), 1, 0, 2);
+	k = isl_basic_map_alloc_div(bmap);
+	if (k < 0)
+		return isl_basic_map_free(bmap);
+	isl_seq_cpy(bmap->div[k], div->el, div->size);
+	isl_int_set_si(bmap->div[k][div->size], 0);
+
+	for (i = k; i > pos; --i)
+		isl_basic_map_swap_div(bmap, i, i - 1);
+
+	return bmap;
 }
 
-int isl_basic_set_free_div(struct isl_basic_set *bset, unsigned n)
+isl_stat isl_basic_map_free_div(struct isl_basic_map *bmap, unsigned n)
 {
-	return isl_basic_map_free_div((struct isl_basic_map *)bset, n);
+	if (!bmap)
+		return isl_stat_error;
+	isl_assert(bmap->ctx, n <= bmap->n_div, return isl_stat_error);
+	bmap->n_div -= n;
+	return isl_stat_ok;
 }
 
 /* Copy constraint from src to dst, putting the vars of src at offset
@@ -1448,12 +1705,12 @@ static void copy_constraint(struct isl_basic_map *dst_map, isl_int *dst,
 			    struct isl_basic_map *src_map, isl_int *src,
 			    unsigned in_off, unsigned out_off, unsigned div_off)
 {
-	unsigned src_nparam = isl_basic_map_n_param(src_map);
-	unsigned dst_nparam = isl_basic_map_n_param(dst_map);
-	unsigned src_in = isl_basic_map_n_in(src_map);
-	unsigned dst_in = isl_basic_map_n_in(dst_map);
-	unsigned src_out = isl_basic_map_n_out(src_map);
-	unsigned dst_out = isl_basic_map_n_out(dst_map);
+	unsigned src_nparam = isl_basic_map_dim(src_map, isl_dim_param);
+	unsigned dst_nparam = isl_basic_map_dim(dst_map, isl_dim_param);
+	unsigned src_in = isl_basic_map_dim(src_map, isl_dim_in);
+	unsigned dst_in = isl_basic_map_dim(dst_map, isl_dim_in);
+	unsigned src_out = isl_basic_map_dim(src_map, isl_dim_out);
+	unsigned dst_out = isl_basic_map_dim(dst_map, isl_dim_out);
 	isl_int_set(dst[0], src[0]);
 	isl_seq_cpy(dst+1, src+1, isl_min(dst_nparam, src_nparam));
 	if (dst_nparam > src_nparam)
@@ -1491,8 +1748,9 @@ static void copy_div(struct isl_basic_map *dst_map, isl_int *dst,
 	copy_constraint(dst_map, dst+1, src_map, src+1, in_off, out_off, div_off);
 }
 
-static struct isl_basic_map *add_constraints(struct isl_basic_map *bmap1,
-		struct isl_basic_map *bmap2, unsigned i_pos, unsigned o_pos)
+static __isl_give isl_basic_map *add_constraints(
+	__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2,
+	unsigned i_pos, unsigned o_pos)
 {
 	int i;
 	unsigned div_off;
@@ -1539,14 +1797,13 @@ error:
 struct isl_basic_set *isl_basic_set_add_constraints(struct isl_basic_set *bset1,
 		struct isl_basic_set *bset2, unsigned pos)
 {
-	return (struct isl_basic_set *)
-		add_constraints((struct isl_basic_map *)bset1,
-				(struct isl_basic_map *)bset2, 0, pos);
+	return bset_from_bmap(add_constraints(bset_to_bmap(bset1),
+						bset_to_bmap(bset2), 0, pos));
 }
 
-struct isl_basic_map *isl_basic_map_extend_space(struct isl_basic_map *base,
-		__isl_take isl_space *dim, unsigned extra,
-		unsigned n_eq, unsigned n_ineq)
+__isl_give isl_basic_map *isl_basic_map_extend_space(
+	__isl_take isl_basic_map *base, __isl_take isl_space *dim,
+	unsigned extra, unsigned n_eq, unsigned n_ineq)
 {
 	struct isl_basic_map *ext;
 	unsigned flags;
@@ -1596,13 +1853,13 @@ error:
 	return NULL;
 }
 
-struct isl_basic_set *isl_basic_set_extend_space(struct isl_basic_set *base,
+__isl_give isl_basic_set *isl_basic_set_extend_space(
+	__isl_take isl_basic_set *base,
 		__isl_take isl_space *dim, unsigned extra,
 		unsigned n_eq, unsigned n_ineq)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_extend_space((struct isl_basic_map *)base, dim,
-							extra, n_eq, n_ineq);
+	return bset_from_bmap(isl_basic_map_extend_space(bset_to_bmap(base),
+						    dim, extra, n_eq, n_ineq));
 }
 
 struct isl_basic_map *isl_basic_map_extend_constraints(
@@ -1638,26 +1895,24 @@ struct isl_basic_set *isl_basic_set_extend(struct isl_basic_set *base,
 		unsigned nparam, unsigned dim, unsigned extra,
 		unsigned n_eq, unsigned n_ineq)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_extend((struct isl_basic_map *)base,
-					nparam, 0, dim, extra, n_eq, n_ineq);
+	return bset_from_bmap(isl_basic_map_extend(bset_to_bmap(base),
+					nparam, 0, dim, extra, n_eq, n_ineq));
 }
 
 struct isl_basic_set *isl_basic_set_extend_constraints(
 		struct isl_basic_set *base, unsigned n_eq, unsigned n_ineq)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_extend_constraints((struct isl_basic_map *)base,
-						    n_eq, n_ineq);
+	isl_basic_map *bmap = bset_to_bmap(base);
+	bmap = isl_basic_map_extend_constraints(bmap, n_eq, n_ineq);
+	return bset_from_bmap(bmap);
 }
 
-struct isl_basic_set *isl_basic_set_cow(struct isl_basic_set *bset)
+__isl_give isl_basic_set *isl_basic_set_cow(__isl_take isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_cow((struct isl_basic_map *)bset);
+	return bset_from_bmap(isl_basic_map_cow(bset_to_bmap(bset)));
 }
 
-struct isl_basic_map *isl_basic_map_cow(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_cow(__isl_take isl_basic_map *bmap)
 {
 	if (!bmap)
 		return NULL;
@@ -1687,7 +1942,7 @@ static __isl_give isl_map *clear_caches(__isl_take isl_map *map)
 	return map;
 }
 
-struct isl_set *isl_set_cow(struct isl_set *set)
+__isl_give isl_set *isl_set_cow(__isl_take isl_set *set)
 {
 	return isl_map_cow(set);
 }
@@ -1702,7 +1957,7 @@ struct isl_set *isl_set_cow(struct isl_set *set)
  *
  * Otherwise, create a duplicate (without any cached information).
  */
-struct isl_map *isl_map_cow(struct isl_map *map)
+__isl_give isl_map *isl_map_cow(__isl_take isl_map *map)
 {
 	if (!map)
 		return NULL;
@@ -1766,14 +2021,16 @@ error:
 	return NULL;
 }
 
-struct isl_basic_map *isl_basic_map_set_to_empty(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_set_to_empty(
+	__isl_take isl_basic_map *bmap)
 {
 	int i = 0;
 	unsigned total;
 	if (!bmap)
 		goto error;
 	total = isl_basic_map_total_dim(bmap);
-	isl_basic_map_free_div(bmap, bmap->n_div);
+	if (isl_basic_map_free_div(bmap, bmap->n_div) < 0)
+		return isl_basic_map_free(bmap);
 	isl_basic_map_free_inequality(bmap, bmap->n_ineq);
 	if (bmap->n_eq > 0)
 		isl_basic_map_free_equality(bmap, bmap->n_eq-1);
@@ -1793,49 +2050,321 @@ error:
 	return NULL;
 }
 
-struct isl_basic_set *isl_basic_set_set_to_empty(struct isl_basic_set *bset)
+__isl_give isl_basic_set *isl_basic_set_set_to_empty(
+	__isl_take isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_set_to_empty((struct isl_basic_map *)bset);
+	return bset_from_bmap(isl_basic_map_set_to_empty(bset_to_bmap(bset)));
 }
 
-/* Swap divs "a" and "b" in "bmap" (without modifying any of the constraints
- * of "bmap").
- */
-static void swap_div(__isl_keep isl_basic_map *bmap, int a, int b)
+__isl_give isl_basic_map *isl_basic_map_set_rational(
+	__isl_take isl_basic_map *bmap)
 {
-	isl_int *t = bmap->div[a];
-	bmap->div[a] = bmap->div[b];
-	bmap->div[b] = t;
+	if (!bmap)
+		return NULL;
+
+	if (ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL))
+		return bmap;
+
+	bmap = isl_basic_map_cow(bmap);
+	if (!bmap)
+		return NULL;
+
+	ISL_F_SET(bmap, ISL_BASIC_MAP_RATIONAL);
+
+	return isl_basic_map_finalize(bmap);
 }
 
-/* Swap divs "a" and "b" in "bmap" and adjust the constraints and
- * div definitions accordingly.
- */
-void isl_basic_map_swap_div(struct isl_basic_map *bmap, int a, int b)
+__isl_give isl_basic_set *isl_basic_set_set_rational(
+	__isl_take isl_basic_set *bset)
 {
-	int i;
-	unsigned off = isl_space_dim(bmap->dim, isl_dim_all);
+	return isl_basic_map_set_rational(bset);
+}
 
-	swap_div(bmap, a, b);
+__isl_give isl_basic_set *isl_basic_set_set_integral(
+	__isl_take isl_basic_set *bset)
+{
+	if (!bset)
+		return NULL;
 
-	for (i = 0; i < bmap->n_eq; ++i)
-		isl_int_swap(bmap->eq[i][1+off+a], bmap->eq[i][1+off+b]);
+	if (!ISL_F_ISSET(bset, ISL_BASIC_MAP_RATIONAL))
+		return bset;
 
-	for (i = 0; i < bmap->n_ineq; ++i)
-		isl_int_swap(bmap->ineq[i][1+off+a], bmap->ineq[i][1+off+b]);
+	bset = isl_basic_set_cow(bset);
+	if (!bset)
+		return NULL;
 
-	for (i = 0; i < bmap->n_div; ++i)
-		isl_int_swap(bmap->div[i][1+1+off+a], bmap->div[i][1+1+off+b]);
-	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
+	ISL_F_CLR(bset, ISL_BASIC_MAP_RATIONAL);
+
+	return isl_basic_set_finalize(bset);
 }
 
-/* Eliminate the specified n dimensions starting at first from the
- * constraints, without removing the dimensions from the space.
- * If the set is rational, the dimensions are eliminated using Fourier-Motzkin.
- */
-__isl_give isl_map *isl_map_eliminate(__isl_take isl_map *map,
-	enum isl_dim_type type, unsigned first, unsigned n)
+__isl_give isl_map *isl_map_set_rational(__isl_take isl_map *map)
+{
+	int i;
+
+	map = isl_map_cow(map);
+	if (!map)
+		return NULL;
+	for (i = 0; i < map->n; ++i) {
+		map->p[i] = isl_basic_map_set_rational(map->p[i]);
+		if (!map->p[i])
+			goto error;
+	}
+	return map;
+error:
+	isl_map_free(map);
+	return NULL;
+}
+
+__isl_give isl_set *isl_set_set_rational(__isl_take isl_set *set)
+{
+	return isl_map_set_rational(set);
+}
+
+/* Swap divs "a" and "b" in "bmap" (without modifying any of the constraints
+ * of "bmap").
+ */
+static void swap_div(__isl_keep isl_basic_map *bmap, int a, int b)
+{
+	isl_int *t = bmap->div[a];
+	bmap->div[a] = bmap->div[b];
+	bmap->div[b] = t;
+}
+
+/* Swap divs "a" and "b" in "bmap" and adjust the constraints and
+ * div definitions accordingly.
+ */
+void isl_basic_map_swap_div(struct isl_basic_map *bmap, int a, int b)
+{
+	int i;
+	unsigned off = isl_space_dim(bmap->dim, isl_dim_all);
+
+	swap_div(bmap, a, b);
+
+	for (i = 0; i < bmap->n_eq; ++i)
+		isl_int_swap(bmap->eq[i][1+off+a], bmap->eq[i][1+off+b]);
+
+	for (i = 0; i < bmap->n_ineq; ++i)
+		isl_int_swap(bmap->ineq[i][1+off+a], bmap->ineq[i][1+off+b]);
+
+	for (i = 0; i < bmap->n_div; ++i)
+		isl_int_swap(bmap->div[i][1+1+off+a], bmap->div[i][1+1+off+b]);
+	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
+}
+
+/* Swap divs "a" and "b" in "bset" and adjust the constraints and
+ * div definitions accordingly.
+ */
+void isl_basic_set_swap_div(__isl_keep isl_basic_set *bset, int a, int b)
+{
+	isl_basic_map_swap_div(bset, a, b);
+}
+
+static void constraint_drop_vars(isl_int *c, unsigned n, unsigned rem)
+{
+	isl_seq_cpy(c, c + n, rem);
+	isl_seq_clr(c + rem, n);
+}
+
+/* Drop n dimensions starting at first.
+ *
+ * In principle, this frees up some extra variables as the number
+ * of columns remains constant, but we would have to extend
+ * the div array too as the number of rows in this array is assumed
+ * to be equal to extra.
+ */
+__isl_give isl_basic_set *isl_basic_set_drop_dims(
+	__isl_take isl_basic_set *bset, unsigned first, unsigned n)
+{
+	return isl_basic_map_drop(bset_to_bmap(bset), isl_dim_set, first, n);
+}
+
+/* Move "n" divs starting at "first" to the end of the list of divs.
+ */
+static struct isl_basic_map *move_divs_last(struct isl_basic_map *bmap,
+	unsigned first, unsigned n)
+{
+	isl_int **div;
+	int i;
+
+	if (first + n == bmap->n_div)
+		return bmap;
+
+	div = isl_alloc_array(bmap->ctx, isl_int *, n);
+	if (!div)
+		goto error;
+	for (i = 0; i < n; ++i)
+		div[i] = bmap->div[first + i];
+	for (i = 0; i < bmap->n_div - first - n; ++i)
+		bmap->div[first + i] = bmap->div[first + n + i];
+	for (i = 0; i < n; ++i)
+		bmap->div[bmap->n_div - n + i] = div[i];
+	free(div);
+	return bmap;
+error:
+	isl_basic_map_free(bmap);
+	return NULL;
+}
+
+/* Drop "n" dimensions of type "type" starting at "first".
+ *
+ * In principle, this frees up some extra variables as the number
+ * of columns remains constant, but we would have to extend
+ * the div array too as the number of rows in this array is assumed
+ * to be equal to extra.
+ */
+__isl_give isl_basic_map *isl_basic_map_drop(__isl_take isl_basic_map *bmap,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	int i;
+	unsigned dim;
+	unsigned offset;
+	unsigned left;
+
+	if (!bmap)
+		goto error;
+
+	dim = isl_basic_map_dim(bmap, type);
+	isl_assert(bmap->ctx, first + n <= dim, goto error);
+
+	if (n == 0 && !isl_space_is_named_or_nested(bmap->dim, type))
+		return bmap;
+
+	bmap = isl_basic_map_cow(bmap);
+	if (!bmap)
+		return NULL;
+
+	offset = isl_basic_map_offset(bmap, type) + first;
+	left = isl_basic_map_total_dim(bmap) - (offset - 1) - n;
+	for (i = 0; i < bmap->n_eq; ++i)
+		constraint_drop_vars(bmap->eq[i]+offset, n, left);
+
+	for (i = 0; i < bmap->n_ineq; ++i)
+		constraint_drop_vars(bmap->ineq[i]+offset, n, left);
+
+	for (i = 0; i < bmap->n_div; ++i)
+		constraint_drop_vars(bmap->div[i]+1+offset, n, left);
+
+	if (type == isl_dim_div) {
+		bmap = move_divs_last(bmap, first, n);
+		if (!bmap)
+			goto error;
+		if (isl_basic_map_free_div(bmap, n) < 0)
+			return isl_basic_map_free(bmap);
+	} else
+		bmap->dim = isl_space_drop_dims(bmap->dim, type, first, n);
+	if (!bmap->dim)
+		goto error;
+
+	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
+	bmap = isl_basic_map_simplify(bmap);
+	return isl_basic_map_finalize(bmap);
+error:
+	isl_basic_map_free(bmap);
+	return NULL;
+}
+
+__isl_give isl_basic_set *isl_basic_set_drop(__isl_take isl_basic_set *bset,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	return bset_from_bmap(isl_basic_map_drop(bset_to_bmap(bset),
+							type, first, n));
+}
+
+__isl_give isl_map *isl_map_drop(__isl_take isl_map *map,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	int i;
+
+	if (!map)
+		goto error;
+
+	isl_assert(map->ctx, first + n <= isl_map_dim(map, type), goto error);
+
+	if (n == 0 && !isl_space_is_named_or_nested(map->dim, type))
+		return map;
+	map = isl_map_cow(map);
+	if (!map)
+		goto error;
+	map->dim = isl_space_drop_dims(map->dim, type, first, n);
+	if (!map->dim)
+		goto error;
+
+	for (i = 0; i < map->n; ++i) {
+		map->p[i] = isl_basic_map_drop(map->p[i], type, first, n);
+		if (!map->p[i])
+			goto error;
+	}
+	ISL_F_CLR(map, ISL_MAP_NORMALIZED);
+
+	return map;
+error:
+	isl_map_free(map);
+	return NULL;
+}
+
+__isl_give isl_set *isl_set_drop(__isl_take isl_set *set,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	return set_from_map(isl_map_drop(set_to_map(set), type, first, n));
+}
+
+/*
+ * We don't cow, as the div is assumed to be redundant.
+ */
+__isl_give isl_basic_map *isl_basic_map_drop_div(
+	__isl_take isl_basic_map *bmap, unsigned div)
+{
+	int i;
+	unsigned pos;
+
+	if (!bmap)
+		goto error;
+
+	pos = 1 + isl_space_dim(bmap->dim, isl_dim_all) + div;
+
+	isl_assert(bmap->ctx, div < bmap->n_div, goto error);
+
+	for (i = 0; i < bmap->n_eq; ++i)
+		constraint_drop_vars(bmap->eq[i]+pos, 1, bmap->extra-div-1);
+
+	for (i = 0; i < bmap->n_ineq; ++i) {
+		if (!isl_int_is_zero(bmap->ineq[i][pos])) {
+			isl_basic_map_drop_inequality(bmap, i);
+			--i;
+			continue;
+		}
+		constraint_drop_vars(bmap->ineq[i]+pos, 1, bmap->extra-div-1);
+	}
+
+	for (i = 0; i < bmap->n_div; ++i)
+		constraint_drop_vars(bmap->div[i]+1+pos, 1, bmap->extra-div-1);
+
+	if (div != bmap->n_div - 1) {
+		int j;
+		isl_int *t = bmap->div[div];
+
+		for (j = div; j < bmap->n_div - 1; ++j)
+			bmap->div[j] = bmap->div[j+1];
+
+		bmap->div[bmap->n_div - 1] = t;
+	}
+	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
+	if (isl_basic_map_free_div(bmap, 1) < 0)
+		return isl_basic_map_free(bmap);
+
+	return bmap;
+error:
+	isl_basic_map_free(bmap);
+	return NULL;
+}
+
+/* Eliminate the specified n dimensions starting at first from the
+ * constraints, without removing the dimensions from the space.
+ * If the set is rational, the dimensions are eliminated using Fourier-Motzkin.
+ */
+__isl_give isl_map *isl_map_eliminate(__isl_take isl_map *map,
+	enum isl_dim_type type, unsigned first, unsigned n)
 {
 	int i;
 
@@ -1870,7 +2399,7 @@ error:
 __isl_give isl_set *isl_set_eliminate(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return (isl_set *)isl_map_eliminate((isl_map *)set, type, first, n);
+	return set_from_map(isl_map_eliminate(set_to_map(set), type, first, n));
 }
 
 /* Eliminate the specified n dimensions starting at first from the
@@ -1899,8 +2428,7 @@ __isl_give isl_basic_map *isl_basic_map_remove_divs(
 __isl_give isl_basic_set *isl_basic_set_remove_divs(
 	__isl_take isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)isl_basic_map_remove_divs(
-			(struct isl_basic_map *)bset);
+	return bset_from_bmap(isl_basic_map_remove_divs(bset_to_bmap(bset)));
 }
 
 __isl_give isl_map *isl_map_remove_divs(__isl_take isl_map *map)
@@ -1932,13 +2460,12 @@ __isl_give isl_set *isl_set_remove_divs(__isl_take isl_set *set)
 	return isl_map_remove_divs(set);
 }
 
-struct isl_basic_map *isl_basic_map_remove_dims(struct isl_basic_map *bmap,
-	enum isl_dim_type type, unsigned first, unsigned n)
+__isl_give isl_basic_map *isl_basic_map_remove_dims(
+	__isl_take isl_basic_map *bmap, enum isl_dim_type type,
+	unsigned first, unsigned n)
 {
-	if (!bmap)
-		return NULL;
-	isl_assert(bmap->ctx, first + n <= isl_basic_map_dim(bmap, type),
-			goto error);
+	if (isl_basic_map_check_range(bmap, type, first, n) < 0)
+		return isl_basic_map_free(bmap);
 	if (n == 0 && !isl_space_is_named_or_nested(bmap->dim, type))
 		return bmap;
 	bmap = isl_basic_map_eliminate_vars(bmap,
@@ -1949,33 +2476,33 @@ struct isl_basic_map *isl_basic_map_remove_dims(struct isl_basic_map *bmap,
 		return bmap;
 	bmap = isl_basic_map_drop(bmap, type, first, n);
 	return bmap;
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
 }
 
 /* Return true if the definition of the given div (recursively) involves
  * any of the given variables.
  */
-static int div_involves_vars(__isl_keep isl_basic_map *bmap, int div,
+static isl_bool div_involves_vars(__isl_keep isl_basic_map *bmap, int div,
 	unsigned first, unsigned n)
 {
 	int i;
 	unsigned div_offset = isl_basic_map_offset(bmap, isl_dim_div);
 
 	if (isl_int_is_zero(bmap->div[div][0]))
-		return 0;
+		return isl_bool_false;
 	if (isl_seq_first_non_zero(bmap->div[div] + 1 + first, n) >= 0)
-		return 1;
+		return isl_bool_true;
 
 	for (i = bmap->n_div - 1; i >= 0; --i) {
+		isl_bool involves;
+
 		if (isl_int_is_zero(bmap->div[div][1 + div_offset + i]))
 			continue;
-		if (div_involves_vars(bmap, i, first, n))
-			return 1;
+		involves = div_involves_vars(bmap, i, first, n);
+		if (involves < 0 || involves)
+			return involves;
 	}
 
-	return 0;
+	return isl_bool_false;
 }
 
 /* Try and add a lower and/or upper bound on "div" to "bmap"
@@ -2152,183 +2679,392 @@ static __isl_give isl_basic_map *insert_bounds_on_div(
 			check_lb = 1;
 	}
 
-	if (!check_lb && !check_ub)
-		return bmap;
+	if (!check_lb && !check_ub)
+		return bmap;
+
+	isl_int_init(v);
+
+	for (i = 0; bmap && i < bmap->n_ineq; ++i) {
+		if (!isl_int_is_zero(bmap->ineq[i][1 + total + div]))
+			continue;
+
+		bmap = insert_bounds_on_div_from_ineq(bmap, div, i, total, v,
+							check_lb, check_ub);
+	}
+
+	isl_int_clear(v);
+
+	return bmap;
+}
+
+/* Remove all divs (recursively) involving any of the given dimensions
+ * in their definitions.
+ */
+__isl_give isl_basic_map *isl_basic_map_remove_divs_involving_dims(
+	__isl_take isl_basic_map *bmap,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	int i;
+
+	if (isl_basic_map_check_range(bmap, type, first, n) < 0)
+		return isl_basic_map_free(bmap);
+	first += isl_basic_map_offset(bmap, type);
+
+	for (i = bmap->n_div - 1; i >= 0; --i) {
+		isl_bool involves;
+
+		involves = div_involves_vars(bmap, i, first, n);
+		if (involves < 0)
+			return isl_basic_map_free(bmap);
+		if (!involves)
+			continue;
+		bmap = insert_bounds_on_div(bmap, i);
+		bmap = isl_basic_map_remove_dims(bmap, isl_dim_div, i, 1);
+		if (!bmap)
+			return NULL;
+		i = bmap->n_div;
+	}
+
+	return bmap;
+}
+
+__isl_give isl_basic_set *isl_basic_set_remove_divs_involving_dims(
+	__isl_take isl_basic_set *bset,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	return isl_basic_map_remove_divs_involving_dims(bset, type, first, n);
+}
+
+__isl_give isl_map *isl_map_remove_divs_involving_dims(__isl_take isl_map *map,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	int i;
+
+	if (!map)
+		return NULL;
+	if (map->n == 0)
+		return map;
+
+	map = isl_map_cow(map);
+	if (!map)
+		return NULL;
+
+	for (i = 0; i < map->n; ++i) {
+		map->p[i] = isl_basic_map_remove_divs_involving_dims(map->p[i],
+								type, first, n);
+		if (!map->p[i])
+			goto error;
+	}
+	return map;
+error:
+	isl_map_free(map);
+	return NULL;
+}
+
+__isl_give isl_set *isl_set_remove_divs_involving_dims(__isl_take isl_set *set,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	return set_from_map(isl_map_remove_divs_involving_dims(set_to_map(set),
+							      type, first, n));
+}
+
+/* Does the description of "bmap" depend on the specified dimensions?
+ * We also check whether the dimensions appear in any of the div definitions.
+ * In principle there is no need for this check.  If the dimensions appear
+ * in a div definition, they also appear in the defining constraints of that
+ * div.
+ */
+isl_bool isl_basic_map_involves_dims(__isl_keep isl_basic_map *bmap,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	int i;
+
+	if (isl_basic_map_check_range(bmap, type, first, n) < 0)
+		return isl_bool_error;
+
+	first += isl_basic_map_offset(bmap, type);
+	for (i = 0; i < bmap->n_eq; ++i)
+		if (isl_seq_first_non_zero(bmap->eq[i] + first, n) >= 0)
+			return isl_bool_true;
+	for (i = 0; i < bmap->n_ineq; ++i)
+		if (isl_seq_first_non_zero(bmap->ineq[i] + first, n) >= 0)
+			return isl_bool_true;
+	for (i = 0; i < bmap->n_div; ++i) {
+		if (isl_int_is_zero(bmap->div[i][0]))
+			continue;
+		if (isl_seq_first_non_zero(bmap->div[i] + 1 + first, n) >= 0)
+			return isl_bool_true;
+	}
+
+	return isl_bool_false;
+}
+
+isl_bool isl_map_involves_dims(__isl_keep isl_map *map,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	int i;
+
+	if (!map)
+		return isl_bool_error;
+
+	if (first + n > isl_map_dim(map, type))
+		isl_die(map->ctx, isl_error_invalid,
+			"index out of bounds", return isl_bool_error);
+
+	for (i = 0; i < map->n; ++i) {
+		isl_bool involves = isl_basic_map_involves_dims(map->p[i],
+							    type, first, n);
+		if (involves < 0 || involves)
+			return involves;
+	}
+
+	return isl_bool_false;
+}
+
+isl_bool isl_basic_set_involves_dims(__isl_keep isl_basic_set *bset,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	return isl_basic_map_involves_dims(bset, type, first, n);
+}
+
+isl_bool isl_set_involves_dims(__isl_keep isl_set *set,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	return isl_map_involves_dims(set, type, first, n);
+}
+
+/* Drop all constraints in bmap that involve any of the dimensions
+ * first to first+n-1.
+ */
+static __isl_give isl_basic_map *isl_basic_map_drop_constraints_involving(
+	__isl_take isl_basic_map *bmap, unsigned first, unsigned n)
+{
+	int i;
+
+	if (n == 0)
+		return bmap;
+
+	bmap = isl_basic_map_cow(bmap);
+
+	if (!bmap)
+		return NULL;
+
+	for (i = bmap->n_eq - 1; i >= 0; --i) {
+		if (isl_seq_first_non_zero(bmap->eq[i] + 1 + first, n) == -1)
+			continue;
+		isl_basic_map_drop_equality(bmap, i);
+	}
+
+	for (i = bmap->n_ineq - 1; i >= 0; --i) {
+		if (isl_seq_first_non_zero(bmap->ineq[i] + 1 + first, n) == -1)
+			continue;
+		isl_basic_map_drop_inequality(bmap, i);
+	}
+
+	bmap = isl_basic_map_add_known_div_constraints(bmap);
+	return bmap;
+}
+
+/* Drop all constraints in bset that involve any of the dimensions
+ * first to first+n-1.
+ */
+__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving(
+	__isl_take isl_basic_set *bset, unsigned first, unsigned n)
+{
+	return isl_basic_map_drop_constraints_involving(bset, first, n);
+}
+
+/* Drop all constraints in bmap that do not involve any of the dimensions
+ * first to first + n - 1 of the given type.
+ */
+__isl_give isl_basic_map *isl_basic_map_drop_constraints_not_involving_dims(
+	__isl_take isl_basic_map *bmap,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
+	int i;
+
+	if (n == 0) {
+		isl_space *space = isl_basic_map_get_space(bmap);
+		isl_basic_map_free(bmap);
+		return isl_basic_map_universe(space);
+	}
+	bmap = isl_basic_map_cow(bmap);
+	if (!bmap)
+		return NULL;
+
+	if (isl_basic_map_check_range(bmap, type, first, n) < 0)
+		return isl_basic_map_free(bmap);
 
-	isl_int_init(v);
+	first += isl_basic_map_offset(bmap, type) - 1;
 
-	for (i = 0; bmap && i < bmap->n_ineq; ++i) {
-		if (!isl_int_is_zero(bmap->ineq[i][1 + total + div]))
+	for (i = bmap->n_eq - 1; i >= 0; --i) {
+		if (isl_seq_first_non_zero(bmap->eq[i] + 1 + first, n) != -1)
 			continue;
-
-		bmap = insert_bounds_on_div_from_ineq(bmap, div, i, total, v,
-							check_lb, check_ub);
+		isl_basic_map_drop_equality(bmap, i);
 	}
 
-	isl_int_clear(v);
+	for (i = bmap->n_ineq - 1; i >= 0; --i) {
+		if (isl_seq_first_non_zero(bmap->ineq[i] + 1 + first, n) != -1)
+			continue;
+		isl_basic_map_drop_inequality(bmap, i);
+	}
 
+	bmap = isl_basic_map_add_known_div_constraints(bmap);
 	return bmap;
 }
 
-/* Remove all divs (recursively) involving any of the given dimensions
- * in their definitions.
+/* Drop all constraints in bset that do not involve any of the dimensions
+ * first to first + n - 1 of the given type.
  */
-__isl_give isl_basic_map *isl_basic_map_remove_divs_involving_dims(
-	__isl_take isl_basic_map *bmap,
+__isl_give isl_basic_set *isl_basic_set_drop_constraints_not_involving_dims(
+	__isl_take isl_basic_set *bset,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	int i;
+	return isl_basic_map_drop_constraints_not_involving_dims(bset,
+							    type, first, n);
+}
 
+/* Drop all constraints in bmap that involve any of the dimensions
+ * first to first + n - 1 of the given type.
+ */
+__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving_dims(
+	__isl_take isl_basic_map *bmap,
+	enum isl_dim_type type, unsigned first, unsigned n)
+{
 	if (!bmap)
 		return NULL;
-	isl_assert(bmap->ctx, first + n <= isl_basic_map_dim(bmap, type),
-			goto error);
-	first += isl_basic_map_offset(bmap, type);
+	if (n == 0)
+		return bmap;
 
-	for (i = bmap->n_div - 1; i >= 0; --i) {
-		if (!div_involves_vars(bmap, i, first, n))
-			continue;
-		bmap = insert_bounds_on_div(bmap, i);
-		bmap = isl_basic_map_remove_dims(bmap, isl_dim_div, i, 1);
-		if (!bmap)
-			return NULL;
-		i = bmap->n_div;
-	}
+	if (isl_basic_map_check_range(bmap, type, first, n) < 0)
+		return isl_basic_map_free(bmap);
 
-	return bmap;
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
+	bmap = isl_basic_map_remove_divs_involving_dims(bmap, type, first, n);
+	first += isl_basic_map_offset(bmap, type) - 1;
+	return isl_basic_map_drop_constraints_involving(bmap, first, n);
 }
 
-__isl_give isl_basic_set *isl_basic_set_remove_divs_involving_dims(
+/* Drop all constraints in bset that involve any of the dimensions
+ * first to first + n - 1 of the given type.
+ */
+__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving_dims(
 	__isl_take isl_basic_set *bset,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return isl_basic_map_remove_divs_involving_dims(bset, type, first, n);
+	return isl_basic_map_drop_constraints_involving_dims(bset,
+							    type, first, n);
 }
 
-__isl_give isl_map *isl_map_remove_divs_involving_dims(__isl_take isl_map *map,
-	enum isl_dim_type type, unsigned first, unsigned n)
+/* Drop constraints from "map" by applying "drop" to each basic map.
+ */
+static __isl_give isl_map *drop_constraints(__isl_take isl_map *map,
+	enum isl_dim_type type, unsigned first, unsigned n,
+	__isl_give isl_basic_map *(*drop)(__isl_take isl_basic_map *bmap,
+		enum isl_dim_type type, unsigned first, unsigned n))
 {
 	int i;
+	unsigned dim;
 
 	if (!map)
 		return NULL;
-	if (map->n == 0)
-		return map;
+
+	dim = isl_map_dim(map, type);
+	if (first + n > dim || first + n < first)
+		isl_die(isl_map_get_ctx(map), isl_error_invalid,
+			"index out of bounds", return isl_map_free(map));
 
 	map = isl_map_cow(map);
 	if (!map)
 		return NULL;
 
 	for (i = 0; i < map->n; ++i) {
-		map->p[i] = isl_basic_map_remove_divs_involving_dims(map->p[i],
-								type, first, n);
+		map->p[i] = drop(map->p[i], type, first, n);
 		if (!map->p[i])
-			goto error;
+			return isl_map_free(map);
 	}
-	return map;
-error:
-	isl_map_free(map);
-	return NULL;
-}
 
-__isl_give isl_set *isl_set_remove_divs_involving_dims(__isl_take isl_set *set,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	return (isl_set *)isl_map_remove_divs_involving_dims((isl_map *)set,
-							      type, first, n);
+	if (map->n > 1)
+		ISL_F_CLR(map, ISL_MAP_DISJOINT);
+
+	return map;
 }
 
-/* Does the desciption of "bmap" depend on the specified dimensions?
- * We also check whether the dimensions appear in any of the div definitions.
- * In principle there is no need for this check.  If the dimensions appear
- * in a div definition, they also appear in the defining constraints of that
- * div.
+/* Drop all constraints in map that involve any of the dimensions
+ * first to first + n - 1 of the given type.
  */
-isl_bool isl_basic_map_involves_dims(__isl_keep isl_basic_map *bmap,
+__isl_give isl_map *isl_map_drop_constraints_involving_dims(
+	__isl_take isl_map *map,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	int i;
-
-	if (!bmap)
-		return isl_bool_error;
-
-	if (first + n > isl_basic_map_dim(bmap, type))
-		isl_die(bmap->ctx, isl_error_invalid,
-			"index out of bounds", return isl_bool_error);
-
-	first += isl_basic_map_offset(bmap, type);
-	for (i = 0; i < bmap->n_eq; ++i)
-		if (isl_seq_first_non_zero(bmap->eq[i] + first, n) >= 0)
-			return isl_bool_true;
-	for (i = 0; i < bmap->n_ineq; ++i)
-		if (isl_seq_first_non_zero(bmap->ineq[i] + first, n) >= 0)
-			return isl_bool_true;
-	for (i = 0; i < bmap->n_div; ++i) {
-		if (isl_int_is_zero(bmap->div[i][0]))
-			continue;
-		if (isl_seq_first_non_zero(bmap->div[i] + 1 + first, n) >= 0)
-			return isl_bool_true;
-	}
-
-	return isl_bool_false;
+	if (n == 0)
+		return map;
+	return drop_constraints(map, type, first, n,
+				&isl_basic_map_drop_constraints_involving_dims);
 }
 
-isl_bool isl_map_involves_dims(__isl_keep isl_map *map,
+/* Drop all constraints in "map" that do not involve any of the dimensions
+ * first to first + n - 1 of the given type.
+ */
+__isl_give isl_map *isl_map_drop_constraints_not_involving_dims(
+	__isl_take isl_map *map,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	int i;
-
-	if (!map)
-		return isl_bool_error;
-
-	if (first + n > isl_map_dim(map, type))
-		isl_die(map->ctx, isl_error_invalid,
-			"index out of bounds", return isl_bool_error);
-
-	for (i = 0; i < map->n; ++i) {
-		isl_bool involves = isl_basic_map_involves_dims(map->p[i],
-							    type, first, n);
-		if (involves < 0 || involves)
-			return involves;
+	if (n == 0) {
+		isl_space *space = isl_map_get_space(map);
+		isl_map_free(map);
+		return isl_map_universe(space);
 	}
-
-	return isl_bool_false;
+	return drop_constraints(map, type, first, n,
+			    &isl_basic_map_drop_constraints_not_involving_dims);
 }
 
-isl_bool isl_basic_set_involves_dims(__isl_keep isl_basic_set *bset,
+/* Drop all constraints in set that involve any of the dimensions
+ * first to first + n - 1 of the given type.
+ */
+__isl_give isl_set *isl_set_drop_constraints_involving_dims(
+	__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return isl_basic_map_involves_dims(bset, type, first, n);
+	return isl_map_drop_constraints_involving_dims(set, type, first, n);
 }
 
-isl_bool isl_set_involves_dims(__isl_keep isl_set *set,
+/* Drop all constraints in "set" that do not involve any of the dimensions
+ * first to first + n - 1 of the given type.
+ */
+__isl_give isl_set *isl_set_drop_constraints_not_involving_dims(
+	__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return isl_map_involves_dims(set, type, first, n);
+	return isl_map_drop_constraints_not_involving_dims(set, type, first, n);
 }
 
-/* Return true if the definition of the given div is unknown or depends
- * on unknown divs.
+/* Does local variable "div" of "bmap" have a complete explicit representation?
+ * Having a complete explicit representation requires not only
+ * an explicit representation, but also that all local variables
+ * that appear in this explicit representation in turn have
+ * a complete explicit representation.
  */
-static int div_is_unknown(__isl_keep isl_basic_map *bmap, int div)
+isl_bool isl_basic_map_div_is_known(__isl_keep isl_basic_map *bmap, int div)
 {
 	int i;
 	unsigned div_offset = isl_basic_map_offset(bmap, isl_dim_div);
+	isl_bool marked;
 
-	if (isl_int_is_zero(bmap->div[div][0]))
-		return 1;
+	marked = isl_basic_map_div_is_marked_unknown(bmap, div);
+	if (marked < 0 || marked)
+		return isl_bool_not(marked);
 
 	for (i = bmap->n_div - 1; i >= 0; --i) {
+		isl_bool known;
+
 		if (isl_int_is_zero(bmap->div[div][1 + div_offset + i]))
 			continue;
-		if (div_is_unknown(bmap, i))
-			return 1;
+		known = isl_basic_map_div_is_known(bmap, i);
+		if (known < 0 || !known)
+			return known;
 	}
 
-	return 0;
+	return isl_bool_true;
 }
 
 /* Remove all divs that are unknown or defined in terms of unknown divs.
@@ -2342,7 +3078,7 @@ __isl_give isl_basic_map *isl_basic_map_remove_unknown_divs(
 		return NULL;
 
 	for (i = bmap->n_div - 1; i >= 0; --i) {
-		if (!div_is_unknown(bmap, i))
+		if (isl_basic_map_div_is_known(bmap, i))
 			continue;
 		bmap = isl_basic_map_remove_dims(bmap, isl_dim_div, i, 1);
 		if (!bmap)
@@ -2387,18 +3123,19 @@ error:
 
 __isl_give isl_set *isl_set_remove_unknown_divs(__isl_take isl_set *set)
 {
-	return (isl_set *)isl_map_remove_unknown_divs((isl_map *)set);
+	return set_from_map(isl_map_remove_unknown_divs(set_to_map(set)));
 }
 
 __isl_give isl_basic_set *isl_basic_set_remove_dims(
 	__isl_take isl_basic_set *bset,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return (isl_basic_set *)
-	    isl_basic_map_remove_dims((isl_basic_map *)bset, type, first, n);
+	isl_basic_map *bmap = bset_to_bmap(bset);
+	bmap = isl_basic_map_remove_dims(bmap, type, first, n);
+	return bset_from_bmap(bmap);
 }
 
-struct isl_map *isl_map_remove_dims(struct isl_map *map,
+__isl_give isl_map *isl_map_remove_dims(__isl_take isl_map *map,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
 	int i;
@@ -2427,7 +3164,8 @@ error:
 __isl_give isl_set *isl_set_remove_dims(__isl_take isl_set *bset,
 	enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return (isl_set *)isl_map_remove_dims((isl_map *)bset, type, first, n);
+	return set_from_map(isl_map_remove_dims(set_to_map(bset),
+						type, first, n));
 }
 
 /* Project out n inputs starting at first using Fourier-Motzkin */
@@ -2441,9 +3179,9 @@ static void dump_term(struct isl_basic_map *bmap,
 			isl_int c, int pos, FILE *out)
 {
 	const char *name;
-	unsigned in = isl_basic_map_n_in(bmap);
-	unsigned dim = in + isl_basic_map_n_out(bmap);
-	unsigned nparam = isl_basic_map_n_param(bmap);
+	unsigned in = isl_basic_map_dim(bmap, isl_dim_in);
+	unsigned dim = in + isl_basic_map_dim(bmap, isl_dim_out);
+	unsigned nparam = isl_basic_map_dim(bmap, isl_dim_param);
 	if (!pos)
 		isl_int_print(out, c, 0);
 	else {
@@ -2565,7 +3303,7 @@ void isl_basic_set_print_internal(struct isl_basic_set *bset,
 	fprintf(out, "ref: %d, nparam: %d, dim: %d, extra: %d, flags: %x\n",
 			bset->ref, bset->dim->nparam, bset->dim->n_out,
 			bset->extra, bset->flags);
-	dump((struct isl_basic_map *)bset, out, indent);
+	dump(bset_to_bmap(bset), out, indent);
 }
 
 void isl_basic_map_print_internal(struct isl_basic_map *bmap,
@@ -2612,23 +3350,9 @@ error:
 	return NULL;
 }
 
-struct isl_set *isl_set_alloc(struct isl_ctx *ctx,
-		unsigned nparam, unsigned dim, int n, unsigned flags)
-{
-	struct isl_set *set;
-	isl_space *dims;
-
-	dims = isl_space_alloc(ctx, nparam, 0, dim);
-	if (!dims)
-		return NULL;
-
-	set = isl_set_alloc_space(dims, n, flags);
-	return set;
-}
-
 /* Make sure "map" has room for at least "n" more basic maps.
  */
-struct isl_map *isl_map_grow(struct isl_map *map, int n)
+__isl_give isl_map *isl_map_grow(__isl_take isl_map *map, int n)
 {
 	int i;
 	struct isl_map *grown = NULL;
@@ -2659,31 +3383,15 @@ error:
  */
 struct isl_set *isl_set_grow(struct isl_set *set, int n)
 {
-	return (struct isl_set *)isl_map_grow((struct isl_map *)set, n);
-}
-
-struct isl_set *isl_set_dup(struct isl_set *set)
-{
-	int i;
-	struct isl_set *dup;
-
-	if (!set)
-		return NULL;
-
-	dup = isl_set_alloc_space(isl_space_copy(set->dim), set->n, set->flags);
-	if (!dup)
-		return NULL;
-	for (i = 0; i < set->n; ++i)
-		dup = isl_set_add_basic_set(dup, isl_basic_set_copy(set->p[i]));
-	return dup;
+	return set_from_map(isl_map_grow(set_to_map(set), n));
 }
 
-struct isl_set *isl_set_from_basic_set(struct isl_basic_set *bset)
+__isl_give isl_set *isl_set_from_basic_set(__isl_take isl_basic_set *bset)
 {
 	return isl_map_from_basic_map(bset);
 }
 
-struct isl_map *isl_map_from_basic_map(struct isl_basic_map *bmap)
+__isl_give isl_map *isl_map_from_basic_map(__isl_take isl_basic_map *bmap)
 {
 	struct isl_map *map;
 
@@ -2697,8 +3405,8 @@ struct isl_map *isl_map_from_basic_map(struct isl_basic_map *bmap)
 __isl_give isl_set *isl_set_add_basic_set(__isl_take isl_set *set,
 						__isl_take isl_basic_set *bset)
 {
-	return (struct isl_set *)isl_map_add_basic_map((struct isl_map *)set,
-						(struct isl_basic_map *)bset);
+	return set_from_map(isl_map_add_basic_map(set_to_map(set),
+						bset_to_bmap(bset)));
 }
 
 __isl_null isl_set *isl_set_free(__isl_take isl_set *set)
@@ -2747,17 +3455,14 @@ void isl_map_print_internal(struct isl_map *map, FILE *out, int indent)
 	}
 }
 
-struct isl_basic_map *isl_basic_map_intersect_domain(
-		struct isl_basic_map *bmap, struct isl_basic_set *bset)
+__isl_give isl_basic_map *isl_basic_map_intersect_domain(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *bset)
 {
 	struct isl_basic_map *bmap_domain;
 
-	if (!bmap || !bset)
+	if (isl_basic_map_check_equal_params(bmap, bset_to_bmap(bset)) < 0)
 		goto error;
 
-	isl_assert(bset->ctx, isl_space_match(bmap->dim, isl_dim_param,
-					bset->dim, isl_dim_param), goto error);
-
 	if (isl_space_dim(bset->dim, isl_dim_set) != 0)
 		isl_assert(bset->ctx,
 		    isl_basic_map_compatible_domain(bmap, bset), goto error);
@@ -2778,20 +3483,34 @@ error:
 	return NULL;
 }
 
-struct isl_basic_map *isl_basic_map_intersect_range(
-		struct isl_basic_map *bmap, struct isl_basic_set *bset)
+/* Check that the space of "bset" is the same as that of the range of "bmap".
+ */
+static isl_stat isl_basic_map_check_compatible_range(
+	__isl_keep isl_basic_map *bmap, __isl_keep isl_basic_set *bset)
+{
+	isl_bool ok;
+
+	ok = isl_basic_map_compatible_range(bmap, bset);
+	if (ok < 0)
+		return isl_stat_error;
+	if (!ok)
+		isl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,
+			"incompatible spaces", return isl_stat_error);
+
+	return isl_stat_ok;
+}
+
+__isl_give isl_basic_map *isl_basic_map_intersect_range(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *bset)
 {
 	struct isl_basic_map *bmap_range;
 
-	if (!bmap || !bset)
+	if (isl_basic_map_check_equal_params(bmap, bset_to_bmap(bset)) < 0)
 		goto error;
 
-	isl_assert(bset->ctx, isl_space_match(bmap->dim, isl_dim_param,
-					bset->dim, isl_dim_param), goto error);
-
-	if (isl_space_dim(bset->dim, isl_dim_set) != 0)
-		isl_assert(bset->ctx,
-		    isl_basic_map_compatible_range(bmap, bset), goto error);
+	if (isl_space_dim(bset->dim, isl_dim_set) != 0 &&
+	    isl_basic_map_check_compatible_range(bmap, bset) < 0)
+		goto error;
 
 	if (isl_basic_set_plain_is_universe(bset)) {
 		isl_basic_set_free(bset);
@@ -2803,7 +3522,7 @@ struct isl_basic_map *isl_basic_map_intersect_range(
 		goto error;
 	bmap = isl_basic_map_extend_space(bmap, isl_space_copy(bmap->dim),
 			bset->n_div, bset->n_eq, bset->n_ineq);
-	bmap_range = isl_basic_map_from_basic_set(bset, isl_space_copy(bset->dim));
+	bmap_range = bset_to_bmap(bset);
 	bmap = add_constraints(bmap, bmap_range, 0, 0);
 
 	bmap = isl_basic_map_simplify(bmap);
@@ -2826,7 +3545,7 @@ isl_bool isl_basic_map_contains(__isl_keep isl_basic_map *bmap,
 
 	total = 1 + isl_basic_map_total_dim(bmap);
 	if (total != vec->size)
-		return isl_bool_error;
+		return isl_bool_false;
 
 	isl_int_init(s);
 
@@ -2854,19 +3573,16 @@ isl_bool isl_basic_map_contains(__isl_keep isl_basic_map *bmap,
 isl_bool isl_basic_set_contains(__isl_keep isl_basic_set *bset,
 	__isl_keep isl_vec *vec)
 {
-	return isl_basic_map_contains((struct isl_basic_map *)bset, vec);
+	return isl_basic_map_contains(bset_to_bmap(bset), vec);
 }
 
-struct isl_basic_map *isl_basic_map_intersect(
-		struct isl_basic_map *bmap1, struct isl_basic_map *bmap2)
+__isl_give isl_basic_map *isl_basic_map_intersect(
+	__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)
 {
 	struct isl_vec *sample = NULL;
 
-	if (!bmap1 || !bmap2)
+	if (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)
 		goto error;
-
-	isl_assert(bmap1->ctx, isl_space_match(bmap1->dim, isl_dim_param,
-				     bmap2->dim, isl_dim_param), goto error);
 	if (isl_space_dim(bmap1->dim, isl_dim_all) ==
 				isl_space_dim(bmap1->dim, isl_dim_param) &&
 	    isl_space_dim(bmap2->dim, isl_dim_all) !=
@@ -2923,10 +3639,8 @@ error:
 struct isl_basic_set *isl_basic_set_intersect(
 		struct isl_basic_set *bset1, struct isl_basic_set *bset2)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_intersect(
-			(struct isl_basic_map *)bset1,
-			(struct isl_basic_map *)bset2);
+	return bset_from_bmap(isl_basic_map_intersect(bset_to_bmap(bset1),
+							bset_to_bmap(bset2)));
 }
 
 __isl_give isl_basic_set *isl_basic_set_intersect_params(
@@ -2951,9 +3665,6 @@ static __isl_give isl_map *map_intersect_add_constraint(
 	if (map2->p[0]->n_eq + map2->p[0]->n_ineq != 1)
 		return isl_map_intersect(map2, map1);
 
-	isl_assert(map2->ctx,
-		    map2->p[0]->n_eq + map2->p[0]->n_ineq == 1, goto error);
-
 	map1 = isl_map_cow(map1);
 	if (!map1)
 		goto error;
@@ -3077,9 +3788,8 @@ __isl_give isl_map *isl_map_intersect(__isl_take isl_map *map1,
 
 struct isl_set *isl_set_intersect(struct isl_set *set1, struct isl_set *set2)
 {
-	return (struct isl_set *)
-		isl_map_intersect((struct isl_map *)set1,
-				  (struct isl_map *)set2);
+	return set_from_map(isl_map_intersect(set_to_map(set1),
+					      set_to_map(set2)));
 }
 
 /* map_intersect_internal accepts intersections
@@ -3103,7 +3813,7 @@ __isl_give isl_set *isl_set_intersect_params(__isl_take isl_set *set,
 	return isl_map_intersect_params(set, params);
 }
 
-struct isl_basic_map *isl_basic_map_reverse(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_reverse(__isl_take isl_basic_map *bmap)
 {
 	isl_space *space;
 	unsigned pos, n1, n2;
@@ -3141,6 +3851,7 @@ __isl_give isl_basic_map *isl_basic_map_insert_dims(
 	__isl_take isl_basic_map *bmap, enum isl_dim_type type,
 	unsigned pos, unsigned n)
 {
+	isl_bool rational;
 	isl_space *res_dim;
 	struct isl_basic_map *res;
 	struct isl_dim_map *dim_map;
@@ -3174,7 +3885,10 @@ __isl_give isl_basic_map *isl_basic_map_insert_dims(
 
 	res = isl_basic_map_alloc_space(res_dim,
 			bmap->n_div, bmap->n_eq, bmap->n_ineq);
-	if (isl_basic_map_is_rational(bmap))
+	rational = isl_basic_map_is_rational(bmap);
+	if (rational < 0)
+		res = isl_basic_map_free(res);
+	if (rational)
 		res = isl_basic_map_set_rational(res);
 	if (isl_basic_map_plain_is_empty(bmap)) {
 		isl_basic_map_free(bmap);
@@ -3275,7 +3989,7 @@ __isl_give isl_set *isl_set_add_dims(__isl_take isl_set *set,
 	if (!set)
 		return NULL;
 	isl_assert(set->ctx, type != isl_dim_in, goto error);
-	return (isl_set *)isl_map_add_dims((isl_map *)set, type, n);
+	return set_from_map(isl_map_add_dims(set_to_map(set), type, n));
 error:
 	isl_set_free(set);
 	return NULL;
@@ -3293,11 +4007,14 @@ __isl_give isl_basic_map *isl_basic_map_move_dims(
 
 	if (!bmap)
 		return NULL;
-	if (n == 0)
+	if (n == 0) {
+		bmap = isl_basic_map_reset(bmap, src_type);
+		bmap = isl_basic_map_reset(bmap, dst_type);
 		return bmap;
+	}
 
-	isl_assert(bmap->ctx, src_pos + n <= isl_basic_map_dim(bmap, src_type),
-		goto error);
+	if (isl_basic_map_check_range(bmap, src_type, src_pos, n) < 0)
+		return isl_basic_map_free(bmap);
 
 	if (dst_type == src_type && dst_pos == src_pos)
 		return bmap;
@@ -3376,8 +4093,10 @@ __isl_give isl_basic_set *isl_basic_set_move_dims(__isl_take isl_basic_set *bset
 	enum isl_dim_type dst_type, unsigned dst_pos,
 	enum isl_dim_type src_type, unsigned src_pos, unsigned n)
 {
-	return (isl_basic_set *)isl_basic_map_move_dims(
-		(isl_basic_map *)bset, dst_type, dst_pos, src_type, src_pos, n);
+	isl_basic_map *bmap = bset_to_bmap(bset);
+	bmap = isl_basic_map_move_dims(bmap, dst_type, dst_pos,
+					src_type, src_pos, n);
+	return bset_from_bmap(bmap);
 }
 
 __isl_give isl_set *isl_set_move_dims(__isl_take isl_set *set,
@@ -3387,8 +4106,8 @@ __isl_give isl_set *isl_set_move_dims(__isl_take isl_set *set,
 	if (!set)
 		return NULL;
 	isl_assert(set->ctx, dst_type != isl_dim_in, goto error);
-	return (isl_set *)isl_map_move_dims((isl_map *)set, dst_type, dst_pos,
-					src_type, src_pos, n);
+	return set_from_map(isl_map_move_dims(set_to_map(set),
+				    dst_type, dst_pos, src_type, src_pos, n));
 error:
 	isl_set_free(set);
 	return NULL;
@@ -3402,8 +4121,11 @@ __isl_give isl_map *isl_map_move_dims(__isl_take isl_map *map,
 
 	if (!map)
 		return NULL;
-	if (n == 0)
+	if (n == 0) {
+		map = isl_map_reset(map, src_type);
+		map = isl_map_reset(map, dst_type);
 		return map;
+	}
 
 	isl_assert(map->ctx, src_pos + n <= isl_map_dim(map, src_type),
 		goto error);
@@ -3574,6 +4296,8 @@ __isl_give isl_basic_map *isl_basic_map_project_out(
 		__isl_take isl_basic_map *bmap,
 		enum isl_dim_type type, unsigned first, unsigned n)
 {
+	isl_bool empty;
+
 	if (n == 0)
 		return basic_map_space_reset(bmap, type);
 	if (type == isl_dim_div)
@@ -3581,6 +4305,12 @@ __isl_give isl_basic_map *isl_basic_map_project_out(
 			"cannot project out existentially quantified variables",
 			return isl_basic_map_free(bmap));
 
+	empty = isl_basic_map_plain_is_empty(bmap);
+	if (empty < 0)
+		return isl_basic_map_free(bmap);
+	if (empty)
+		bmap = isl_basic_map_set_to_empty(bmap);
+
 	bmap = drop_irrelevant_constraints(bmap, type, first, n);
 	if (!bmap)
 		return NULL;
@@ -3588,8 +4318,8 @@ __isl_give isl_basic_map *isl_basic_map_project_out(
 	if (ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL))
 		return isl_basic_map_remove_dims(bmap, type, first, n);
 
-	isl_assert(bmap->ctx, first + n <= isl_basic_map_dim(bmap, type),
-			goto error);
+	if (isl_basic_map_check_range(bmap, type, first, n) < 0)
+		return isl_basic_map_free(bmap);
 
 	bmap = move_last(bmap, type, first, n);
 	bmap = isl_basic_map_cow(bmap);
@@ -3614,8 +4344,8 @@ error:
 struct isl_basic_set *isl_basic_set_project_out(struct isl_basic_set *bset,
 		enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return (isl_basic_set *)isl_basic_map_project_out(
-			(isl_basic_map *)bset, type, first, n);
+	return bset_from_bmap(isl_basic_map_project_out(bset_to_bmap(bset),
+							type, first, n));
 }
 
 /* Turn the n dimensions of type type, starting at first
@@ -3660,7 +4390,8 @@ error:
 __isl_give isl_set *isl_set_project_out(__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned first, unsigned n)
 {
-	return (isl_set *)isl_map_project_out((isl_map *)set, type, first, n);
+	return set_from_map(isl_map_project_out(set_to_map(set),
+						type, first, n));
 }
 
 /* Return a map that projects the elements in "set" onto their
@@ -3719,12 +4450,8 @@ struct isl_basic_map *isl_basic_map_apply_range(
 	unsigned n_in, n_out, n, nparam, total, pos;
 	struct isl_dim_map *dim_map1, *dim_map2;
 
-	if (!bmap1 || !bmap2)
+	if (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)
 		goto error;
-	if (!isl_space_match(bmap1->dim, isl_dim_param,
-				bmap2->dim, isl_dim_param))
-		isl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,
-			"parameters don't match", goto error);
 	if (!isl_space_tuple_is_equal(bmap1->dim, isl_dim_out,
 				    bmap2->dim, isl_dim_in))
 		isl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,
@@ -3733,10 +4460,10 @@ struct isl_basic_map *isl_basic_map_apply_range(
 	dim_result = isl_space_join(isl_space_copy(bmap1->dim),
 				  isl_space_copy(bmap2->dim));
 
-	n_in = isl_basic_map_n_in(bmap1);
-	n_out = isl_basic_map_n_out(bmap2);
-	n = isl_basic_map_n_out(bmap1);
-	nparam = isl_basic_map_n_param(bmap1);
+	n_in = isl_basic_map_dim(bmap1, isl_dim_in);
+	n_out = isl_basic_map_dim(bmap2, isl_dim_out);
+	n = isl_basic_map_dim(bmap1, isl_dim_out);
+	nparam = isl_basic_map_dim(bmap1, isl_dim_param);
 
 	total = nparam + n_in + n_out + bmap1->n_div + bmap2->n_div + n;
 	dim_map1 = isl_dim_map_alloc(bmap1->ctx, total);
@@ -3775,8 +4502,8 @@ struct isl_basic_set *isl_basic_set_apply(
 	isl_assert(bset->ctx, isl_basic_map_compatible_domain(bmap, bset),
 		    goto error);
 
-	return (struct isl_basic_set *)
-		isl_basic_map_apply_range((struct isl_basic_map *)bset, bmap);
+	return bset_from_bmap(isl_basic_map_apply_range(bset_to_bmap(bset),
+							bmap));
 error:
 	isl_basic_set_free(bset);
 	isl_basic_map_free(bmap);
@@ -3786,14 +4513,12 @@ error:
 struct isl_basic_map *isl_basic_map_apply_domain(
 		struct isl_basic_map *bmap1, struct isl_basic_map *bmap2)
 {
-	if (!bmap1 || !bmap2)
+	if (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)
 		goto error;
-
-	isl_assert(bmap1->ctx,
-	    isl_basic_map_n_in(bmap1) == isl_basic_map_n_in(bmap2), goto error);
-	isl_assert(bmap1->ctx,
-	    isl_basic_map_n_param(bmap1) == isl_basic_map_n_param(bmap2),
-	    goto error);
+	if (!isl_space_tuple_is_equal(bmap1->dim, isl_dim_in,
+					bmap2->dim, isl_dim_in))
+		isl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,
+			"spaces don't match", goto error);
 
 	bmap1 = isl_basic_map_reverse(bmap1);
 	bmap1 = isl_basic_map_apply_range(bmap1, bmap2);
@@ -3807,8 +4532,8 @@ error:
 /* Given two basic maps A -> f(A) and B -> g(B), construct a basic map
  * A \cap B -> f(A) + f(B)
  */
-struct isl_basic_map *isl_basic_map_sum(
-		struct isl_basic_map *bmap1, struct isl_basic_map *bmap2)
+__isl_give isl_basic_map *isl_basic_map_sum(__isl_take isl_basic_map *bmap1,
+	__isl_take isl_basic_map *bmap2)
 {
 	unsigned n_in, n_out, nparam, total, pos;
 	struct isl_basic_map *bmap = NULL;
@@ -3821,9 +4546,9 @@ struct isl_basic_map *isl_basic_map_sum(
 	isl_assert(bmap1->ctx, isl_space_is_equal(bmap1->dim, bmap2->dim),
 		goto error);
 
-	nparam = isl_basic_map_n_param(bmap1);
-	n_in = isl_basic_map_n_in(bmap1);
-	n_out = isl_basic_map_n_out(bmap1);
+	nparam = isl_basic_map_dim(bmap1, isl_dim_param);
+	n_in = isl_basic_map_dim(bmap1, isl_dim_in);
+	n_out = isl_basic_map_dim(bmap1, isl_dim_out);
 
 	total = nparam + n_in + n_out + bmap1->n_div + bmap2->n_div + 2 * n_out;
 	dim_map1 = isl_dim_map_alloc(bmap1->ctx, total);
@@ -3866,7 +4591,8 @@ error:
 /* Given two maps A -> f(A) and B -> g(B), construct a map
  * A \cap B -> f(A) + f(B)
  */
-struct isl_map *isl_map_sum(struct isl_map *map1, struct isl_map *map2)
+__isl_give isl_map *isl_map_sum(__isl_take isl_map *map1,
+	__isl_take isl_map *map2)
 {
 	struct isl_map *result;
 	int i, j;
@@ -3905,12 +4631,12 @@ error:
 __isl_give isl_set *isl_set_sum(__isl_take isl_set *set1,
 	__isl_take isl_set *set2)
 {
-	return (isl_set *)isl_map_sum((isl_map *)set1, (isl_map *)set2);
+	return set_from_map(isl_map_sum(set_to_map(set1), set_to_map(set2)));
 }
 
 /* Given a basic map A -> f(A), construct A -> -f(A).
  */
-struct isl_basic_map *isl_basic_map_neg(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_neg(__isl_take isl_basic_map *bmap)
 {
 	int i, j;
 	unsigned off, n;
@@ -3941,7 +4667,7 @@ __isl_give isl_basic_set *isl_basic_set_neg(__isl_take isl_basic_set *bset)
 
 /* Given a map A -> f(A), construct A -> -f(A).
  */
-struct isl_map *isl_map_neg(struct isl_map *map)
+__isl_give isl_map *isl_map_neg(__isl_take isl_map *map)
 {
 	int i;
 
@@ -3963,13 +4689,13 @@ error:
 
 __isl_give isl_set *isl_set_neg(__isl_take isl_set *set)
 {
-	return (isl_set *)isl_map_neg((isl_map *)set);
+	return set_from_map(isl_map_neg(set_to_map(set)));
 }
 
 /* Given a basic map A -> f(A) and an integer d, construct a basic map
  * A -> floor(f(A)/d).
  */
-struct isl_basic_map *isl_basic_map_floordiv(struct isl_basic_map *bmap,
+__isl_give isl_basic_map *isl_basic_map_floordiv(__isl_take isl_basic_map *bmap,
 		isl_int d)
 {
 	unsigned n_in, n_out, nparam, total, pos;
@@ -3980,9 +4706,9 @@ struct isl_basic_map *isl_basic_map_floordiv(struct isl_basic_map *bmap,
 	if (!bmap)
 		return NULL;
 
-	nparam = isl_basic_map_n_param(bmap);
-	n_in = isl_basic_map_n_in(bmap);
-	n_out = isl_basic_map_n_out(bmap);
+	nparam = isl_basic_map_dim(bmap, isl_dim_param);
+	n_in = isl_basic_map_dim(bmap, isl_dim_in);
+	n_out = isl_basic_map_dim(bmap, isl_dim_out);
 
 	total = nparam + n_in + n_out + bmap->n_div + n_out;
 	dim_map = isl_dim_map_alloc(bmap->ctx, total);
@@ -4023,7 +4749,7 @@ error:
 /* Given a map A -> f(A) and an integer d, construct a map
  * A -> floor(f(A)/d).
  */
-struct isl_map *isl_map_floordiv(struct isl_map *map, isl_int d)
+__isl_give isl_map *isl_map_floordiv(__isl_take isl_map *map, isl_int d)
 {
 	int i;
 
@@ -4065,7 +4791,8 @@ error:
 	return NULL;
 }
 
-static struct isl_basic_map *var_equal(struct isl_basic_map *bmap, unsigned pos)
+static __isl_give isl_basic_map *var_equal(__isl_take isl_basic_map *bmap,
+	unsigned pos)
 {
 	int i;
 	unsigned nparam;
@@ -4074,8 +4801,8 @@ static struct isl_basic_map *var_equal(struct isl_basic_map *bmap, unsigned pos)
 	i = isl_basic_map_alloc_equality(bmap);
 	if (i < 0)
 		goto error;
-	nparam = isl_basic_map_n_param(bmap);
-	n_in = isl_basic_map_n_in(bmap);
+	nparam = isl_basic_map_dim(bmap, isl_dim_param);
+	n_in = isl_basic_map_dim(bmap, isl_dim_in);
 	isl_seq_clr(bmap->eq[i], 1 + isl_basic_map_total_dim(bmap));
 	isl_int_set_si(bmap->eq[i][1+nparam+pos], -1);
 	isl_int_set_si(bmap->eq[i][1+nparam+n_in+pos], 1);
@@ -4085,9 +4812,10 @@ error:
 	return NULL;
 }
 
-/* Add a constraints to "bmap" expressing i_pos < o_pos
+/* Add a constraint to "bmap" expressing i_pos < o_pos
  */
-static struct isl_basic_map *var_less(struct isl_basic_map *bmap, unsigned pos)
+static __isl_give isl_basic_map *var_less(__isl_take isl_basic_map *bmap,
+	unsigned pos)
 {
 	int i;
 	unsigned nparam;
@@ -4096,8 +4824,8 @@ static struct isl_basic_map *var_less(struct isl_basic_map *bmap, unsigned pos)
 	i = isl_basic_map_alloc_inequality(bmap);
 	if (i < 0)
 		goto error;
-	nparam = isl_basic_map_n_param(bmap);
-	n_in = isl_basic_map_n_in(bmap);
+	nparam = isl_basic_map_dim(bmap, isl_dim_param);
+	n_in = isl_basic_map_dim(bmap, isl_dim_in);
 	isl_seq_clr(bmap->ineq[i], 1 + isl_basic_map_total_dim(bmap));
 	isl_int_set_si(bmap->ineq[i][0], -1);
 	isl_int_set_si(bmap->ineq[i][1+nparam+pos], -1);
@@ -4120,8 +4848,8 @@ static __isl_give isl_basic_map *var_less_or_equal(
 	i = isl_basic_map_alloc_inequality(bmap);
 	if (i < 0)
 		goto error;
-	nparam = isl_basic_map_n_param(bmap);
-	n_in = isl_basic_map_n_in(bmap);
+	nparam = isl_basic_map_dim(bmap, isl_dim_param);
+	n_in = isl_basic_map_dim(bmap, isl_dim_in);
 	isl_seq_clr(bmap->ineq[i], 1 + isl_basic_map_total_dim(bmap));
 	isl_int_set_si(bmap->ineq[i][1+nparam+pos], -1);
 	isl_int_set_si(bmap->ineq[i][1+nparam+n_in+pos], 1);
@@ -4131,9 +4859,10 @@ error:
 	return NULL;
 }
 
-/* Add a constraints to "bmap" expressing i_pos > o_pos
+/* Add a constraint to "bmap" expressing i_pos > o_pos
  */
-static struct isl_basic_map *var_more(struct isl_basic_map *bmap, unsigned pos)
+static __isl_give isl_basic_map *var_more(__isl_take isl_basic_map *bmap,
+	unsigned pos)
 {
 	int i;
 	unsigned nparam;
@@ -4142,8 +4871,8 @@ static struct isl_basic_map *var_more(struct isl_basic_map *bmap, unsigned pos)
 	i = isl_basic_map_alloc_inequality(bmap);
 	if (i < 0)
 		goto error;
-	nparam = isl_basic_map_n_param(bmap);
-	n_in = isl_basic_map_n_in(bmap);
+	nparam = isl_basic_map_dim(bmap, isl_dim_param);
+	n_in = isl_basic_map_dim(bmap, isl_dim_in);
 	isl_seq_clr(bmap->ineq[i], 1 + isl_basic_map_total_dim(bmap));
 	isl_int_set_si(bmap->ineq[i][0], -1);
 	isl_int_set_si(bmap->ineq[i][1+nparam+pos], 1);
@@ -4166,8 +4895,8 @@ static __isl_give isl_basic_map *var_more_or_equal(
 	i = isl_basic_map_alloc_inequality(bmap);
 	if (i < 0)
 		goto error;
-	nparam = isl_basic_map_n_param(bmap);
-	n_in = isl_basic_map_n_in(bmap);
+	nparam = isl_basic_map_dim(bmap, isl_dim_param);
+	n_in = isl_basic_map_dim(bmap, isl_dim_in);
 	isl_seq_clr(bmap->ineq[i], 1 + isl_basic_map_total_dim(bmap));
 	isl_int_set_si(bmap->ineq[i][1+nparam+pos], 1);
 	isl_int_set_si(bmap->ineq[i][1+nparam+n_in+pos], -1);
@@ -4207,7 +4936,7 @@ __isl_give isl_basic_map *isl_basic_map_less_at(__isl_take isl_space *dim,
 	return isl_basic_map_finalize(bmap);
 }
 
-/* Return a relation on of dimension "dim" expressing i_[0..pos] <<= o_[0..pos]
+/* Return a relation on "dim" expressing i_[0..pos] <<= o_[0..pos]
  */
 __isl_give isl_basic_map *isl_basic_map_less_or_equal_at(
 	__isl_take isl_space *dim, unsigned pos)
@@ -4222,7 +4951,7 @@ __isl_give isl_basic_map *isl_basic_map_less_or_equal_at(
 	return isl_basic_map_finalize(bmap);
 }
 
-/* Return a relation on pairs of sets of dimension "dim" expressing i_pos > o_pos
+/* Return a relation on "dim" expressing i_pos > o_pos
  */
 __isl_give isl_basic_map *isl_basic_map_more_at(__isl_take isl_space *dim,
 	unsigned pos)
@@ -4239,7 +4968,7 @@ __isl_give isl_basic_map *isl_basic_map_more_at(__isl_take isl_space *dim,
 	return isl_basic_map_finalize(bmap);
 }
 
-/* Return a relation on of dimension "dim" expressing i_[0..pos] >>= o_[0..pos]
+/* Return a relation on "dim" expressing i_[0..pos] >>= o_[0..pos]
  */
 __isl_give isl_basic_map *isl_basic_map_more_or_equal_at(
 	__isl_take isl_space *dim, unsigned pos)
@@ -4442,31 +5171,11 @@ __isl_give isl_map *isl_map_lex_gt_map(__isl_take isl_map *map1,
 	return map;
 }
 
-__isl_give isl_basic_map *isl_basic_map_from_basic_set(
-	__isl_take isl_basic_set *bset, __isl_take isl_space *dim)
-{
-	struct isl_basic_map *bmap;
-
-	bset = isl_basic_set_cow(bset);
-	if (!bset || !dim)
-		goto error;
-
-	isl_assert(bset->ctx, isl_space_compatible(bset->dim, dim), goto error);
-	isl_space_free(bset->dim);
-	bmap = (struct isl_basic_map *) bset;
-	bmap->dim = dim;
-	return isl_basic_map_finalize(bmap);
-error:
-	isl_basic_set_free(bset);
-	isl_space_free(dim);
-	return NULL;
-}
-
 /* For a div d = floor(f/m), add the constraint
  *
  *		f - m d >= 0
  */
-static int add_upper_div_constraint(__isl_keep isl_basic_map *bmap,
+static isl_stat add_upper_div_constraint(__isl_keep isl_basic_map *bmap,
 	unsigned pos, isl_int *div)
 {
 	int i;
@@ -4474,18 +5183,18 @@ static int add_upper_div_constraint(__isl_keep isl_basic_map *bmap,
 
 	i = isl_basic_map_alloc_inequality(bmap);
 	if (i < 0)
-		return -1;
+		return isl_stat_error;
 	isl_seq_cpy(bmap->ineq[i], div + 1, 1 + total);
 	isl_int_neg(bmap->ineq[i][1 + pos], div[0]);
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* For a div d = floor(f/m), add the constraint
  *
  *		-(f-(m-1)) + m d >= 0
  */
-static int add_lower_div_constraint(__isl_keep isl_basic_map *bmap,
+static isl_stat add_lower_div_constraint(__isl_keep isl_basic_map *bmap,
 	unsigned pos, isl_int *div)
 {
 	int i;
@@ -4493,13 +5202,13 @@ static int add_lower_div_constraint(__isl_keep isl_basic_map *bmap,
 
 	i = isl_basic_map_alloc_inequality(bmap);
 	if (i < 0)
-		return -1;
+		return isl_stat_error;
 	isl_seq_neg(bmap->ineq[i], div + 1, 1 + total);
 	isl_int_set(bmap->ineq[i][1 + pos], div[0]);
 	isl_int_add(bmap->ineq[i][0], bmap->ineq[i][0], bmap->ineq[i][1 + pos]);
 	isl_int_sub_ui(bmap->ineq[i][0], bmap->ineq[i][0], 1);
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* For a div d = floor(f/m), add the constraints
@@ -4524,7 +5233,7 @@ int isl_basic_map_add_div_constraints_var(__isl_keep isl_basic_map *bmap,
 int isl_basic_set_add_div_constraints_var(__isl_keep isl_basic_set *bset,
 	unsigned pos, isl_int *div)
 {
-	return isl_basic_map_add_div_constraints_var((isl_basic_map *)bset,
+	return isl_basic_map_add_div_constraints_var(bset_to_bmap(bset),
 							pos, div);
 }
 
@@ -4593,13 +5302,8 @@ int isl_basic_map_add_div_constraint(__isl_keep isl_basic_map *bmap,
 		return add_lower_div_constraint(bmap, div_pos, bmap->div[div]);
 }
 
-int isl_basic_set_add_div_constraints(struct isl_basic_set *bset, unsigned div)
-{
-	return isl_basic_map_add_div_constraints(bset, div);
-}
-
-struct isl_basic_set *isl_basic_map_underlying_set(
-		struct isl_basic_map *bmap)
+__isl_give isl_basic_set *isl_basic_map_underlying_set(
+	__isl_take isl_basic_map *bmap)
 {
 	if (!bmap)
 		goto error;
@@ -4607,7 +5311,7 @@ struct isl_basic_set *isl_basic_map_underlying_set(
 	    bmap->n_div == 0 &&
 	    !isl_space_is_named_or_nested(bmap->dim, isl_dim_in) &&
 	    !isl_space_is_named_or_nested(bmap->dim, isl_dim_out))
-		return (struct isl_basic_set *)bmap;
+		return bset_from_bmap(bmap);
 	bmap = isl_basic_map_cow(bmap);
 	if (!bmap)
 		goto error;
@@ -4617,7 +5321,7 @@ struct isl_basic_set *isl_basic_map_underlying_set(
 	bmap->extra -= bmap->n_div;
 	bmap->n_div = 0;
 	bmap = isl_basic_map_finalize(bmap);
-	return (struct isl_basic_set *)bmap;
+	return bset_from_bmap(bmap);
 error:
 	isl_basic_map_free(bmap);
 	return NULL;
@@ -4626,7 +5330,7 @@ error:
 __isl_give isl_basic_set *isl_basic_set_underlying_set(
 		__isl_take isl_basic_set *bset)
 {
-	return isl_basic_map_underlying_set((isl_basic_map *)bset);
+	return isl_basic_map_underlying_set(bset_to_bmap(bset));
 }
 
 /* Replace each element in "list" by the result of applying
@@ -4653,8 +5357,8 @@ __isl_give isl_basic_set_list *isl_basic_map_list_underlying_set(
 	return list;
 }
 
-struct isl_basic_map *isl_basic_map_overlying_set(
-	struct isl_basic_set *bset, struct isl_basic_map *like)
+__isl_give isl_basic_map *isl_basic_map_overlying_set(
+	__isl_take isl_basic_set *bset, __isl_take isl_basic_map *like)
 {
 	struct isl_basic_map *bmap;
 	struct isl_ctx *ctx;
@@ -4677,7 +5381,7 @@ struct isl_basic_map *isl_basic_map_overlying_set(
 	if (!bset)
 		goto error;
 	total = bset->dim->n_out + bset->extra;
-	bmap = (struct isl_basic_map *)bset;
+	bmap = bset_to_bmap(bset);
 	isl_space_free(bmap->dim);
 	bmap->dim = isl_space_copy(like->dim);
 	if (!bmap->dim)
@@ -4719,45 +5423,11 @@ error:
 struct isl_basic_set *isl_basic_set_from_underlying_set(
 	struct isl_basic_set *bset, struct isl_basic_set *like)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_overlying_set(bset, (struct isl_basic_map *)like);
-}
-
-struct isl_set *isl_set_from_underlying_set(
-	struct isl_set *set, struct isl_basic_set *like)
-{
-	int i;
-
-	if (!set || !like)
-		goto error;
-	isl_assert(set->ctx, set->dim->n_out == isl_basic_set_total_dim(like),
-		    goto error);
-	if (isl_space_is_equal(set->dim, like->dim) && like->n_div == 0) {
-		isl_basic_set_free(like);
-		return set;
-	}
-	set = isl_set_cow(set);
-	if (!set)
-		goto error;
-	for (i = 0; i < set->n; ++i) {
-		set->p[i] = isl_basic_set_from_underlying_set(set->p[i],
-						      isl_basic_set_copy(like));
-		if (!set->p[i])
-			goto error;
-	}
-	isl_space_free(set->dim);
-	set->dim = isl_space_copy(like->dim);
-	if (!set->dim)
-		goto error;
-	isl_basic_set_free(like);
-	return set;
-error:
-	isl_basic_set_free(like);
-	isl_set_free(set);
-	return NULL;
+	return bset_from_bmap(isl_basic_map_overlying_set(bset,
+							bset_to_bmap(like)));
 }
 
-struct isl_set *isl_map_underlying_set(struct isl_map *map)
+__isl_give isl_set *isl_map_underlying_set(__isl_take isl_map *map)
 {
 	int i;
 
@@ -4772,8 +5442,8 @@ struct isl_set *isl_map_underlying_set(struct isl_map *map)
 		isl_assert(map->ctx, map->p[0]->n_div == map->p[i]->n_div,
 				goto error);
 	for (i = 0; i < map->n; ++i) {
-		map->p[i] = (struct isl_basic_map *)
-				isl_basic_map_underlying_set(map->p[i]);
+		map->p[i] = bset_to_bmap(
+				isl_basic_map_underlying_set(map->p[i]));
 		if (!map->p[i])
 			goto error;
 	}
@@ -4785,17 +5455,12 @@ struct isl_set *isl_map_underlying_set(struct isl_map *map)
 	}
 	if (!map->dim)
 		goto error;
-	return (struct isl_set *)map;
+	return set_from_map(map);
 error:
 	isl_map_free(map);
 	return NULL;
 }
 
-struct isl_set *isl_set_to_underlying_set(struct isl_set *set)
-{
-	return (struct isl_set *)isl_map_underlying_set((struct isl_map *)set);
-}
-
 /* Replace the space of "bmap" by "space".
  *
  * If the space of "bmap" is identical to "space" (including the identifiers
@@ -4805,16 +5470,12 @@ __isl_give isl_basic_map *isl_basic_map_reset_space(
 	__isl_take isl_basic_map *bmap, __isl_take isl_space *space)
 {
 	isl_bool equal;
+	isl_space *bmap_space;
 
-	if (!bmap)
-		goto error;
-	equal = isl_space_is_equal(bmap->dim, space);
-	if (equal >= 0 && equal)
-		equal = isl_space_match(bmap->dim, isl_dim_in,
-					space, isl_dim_in);
+	bmap_space = isl_basic_map_peek_space(bmap);
+	equal = isl_space_is_equal(bmap_space, space);
 	if (equal >= 0 && equal)
-		equal = isl_space_match(bmap->dim, isl_dim_out,
-					space, isl_dim_out);
+		equal = isl_space_has_equal_ids(bmap_space, space);
 	if (equal < 0)
 		goto error;
 	if (equal) {
@@ -4840,8 +5501,8 @@ error:
 __isl_give isl_basic_set *isl_basic_set_reset_space(
 	__isl_take isl_basic_set *bset, __isl_take isl_space *dim)
 {
-	return (isl_basic_set *)isl_basic_map_reset_space((isl_basic_map *)bset,
-							dim);
+	return bset_from_bmap(isl_basic_map_reset_space(bset_to_bmap(bset),
+							dim));
 }
 
 __isl_give isl_map *isl_map_reset_space(__isl_take isl_map *map,
@@ -4872,17 +5533,21 @@ error:
 __isl_give isl_set *isl_set_reset_space(__isl_take isl_set *set,
 	__isl_take isl_space *dim)
 {
-	return (struct isl_set *) isl_map_reset_space((struct isl_map *)set, dim);
+	return set_from_map(isl_map_reset_space(set_to_map(set), dim));
 }
 
 /* Compute the parameter domain of the given basic set.
  */
 __isl_give isl_basic_set *isl_basic_set_params(__isl_take isl_basic_set *bset)
 {
+	isl_bool is_params;
 	isl_space *space;
 	unsigned n;
 
-	if (isl_basic_set_is_params(bset))
+	is_params = isl_basic_set_is_params(bset);
+	if (is_params < 0)
+		return isl_basic_set_free(bset);
+	if (is_params)
 		return bset;
 
 	n = isl_basic_set_dim(bset, isl_dim_set);
@@ -4960,16 +5625,16 @@ struct isl_basic_set *isl_basic_map_domain(struct isl_basic_map *bmap)
 		return NULL;
 	space = isl_space_domain(isl_basic_map_get_space(bmap));
 
-	n_out = isl_basic_map_n_out(bmap);
+	n_out = isl_basic_map_dim(bmap, isl_dim_out);
 	bmap = isl_basic_map_project_out(bmap, isl_dim_out, 0, n_out);
 
 	return isl_basic_map_reset_space(bmap, space);
 }
 
-int isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap)
+isl_bool isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap)
 {
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	return isl_space_may_be_set(bmap->dim);
 }
 
@@ -4977,30 +5642,35 @@ int isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap)
  * Users should never call this function.  Outside of isl,
  * the type should indicate whether something is a set or a map.
  */
-int isl_basic_map_is_set(__isl_keep isl_basic_map *bmap)
+isl_bool isl_basic_map_is_set(__isl_keep isl_basic_map *bmap)
 {
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	return isl_space_is_set(bmap->dim);
 }
 
 struct isl_basic_set *isl_basic_map_range(struct isl_basic_map *bmap)
 {
-	if (!bmap)
-		return NULL;
-	if (isl_basic_map_is_set(bmap))
+	isl_bool is_set;
+
+	is_set = isl_basic_map_is_set(bmap);
+	if (is_set < 0)
+		goto error;
+	if (is_set)
 		return bmap;
 	return isl_basic_map_domain(isl_basic_map_reverse(bmap));
+error:
+	isl_basic_map_free(bmap);
+	return NULL;
 }
 
 __isl_give isl_basic_map *isl_basic_map_domain_map(
 	__isl_take isl_basic_map *bmap)
 {
-	int i, k;
+	int i;
 	isl_space *dim;
 	isl_basic_map *domain;
 	int nparam, n_in, n_out;
-	unsigned total;
 
 	nparam = isl_basic_map_dim(bmap, isl_dim_param);
 	n_in = isl_basic_map_dim(bmap, isl_dim_in);
@@ -5013,32 +5683,21 @@ __isl_give isl_basic_map *isl_basic_map_domain_map(
 	bmap = isl_basic_map_apply_range(bmap, domain);
 	bmap = isl_basic_map_extend_constraints(bmap, n_in, 0);
 
-	total = isl_basic_map_total_dim(bmap);
-
-	for (i = 0; i < n_in; ++i) {
-		k = isl_basic_map_alloc_equality(bmap);
-		if (k < 0)
-			goto error;
-		isl_seq_clr(bmap->eq[k], 1 + total);
-		isl_int_set_si(bmap->eq[k][1 + nparam + i], -1);
-		isl_int_set_si(bmap->eq[k][1 + nparam + n_in + n_out + i], 1);
-	}
+	for (i = 0; i < n_in; ++i)
+		bmap = isl_basic_map_equate(bmap, isl_dim_in, i,
+						    isl_dim_out, i);
 
 	bmap = isl_basic_map_gauss(bmap, NULL);
 	return isl_basic_map_finalize(bmap);
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
 }
 
 __isl_give isl_basic_map *isl_basic_map_range_map(
 	__isl_take isl_basic_map *bmap)
 {
-	int i, k;
+	int i;
 	isl_space *dim;
 	isl_basic_map *range;
 	int nparam, n_in, n_out;
-	unsigned total;
 
 	nparam = isl_basic_map_dim(bmap, isl_dim_param);
 	n_in = isl_basic_map_dim(bmap, isl_dim_in);
@@ -5051,22 +5710,12 @@ __isl_give isl_basic_map *isl_basic_map_range_map(
 	bmap = isl_basic_map_apply_range(bmap, range);
 	bmap = isl_basic_map_extend_constraints(bmap, n_out, 0);
 
-	total = isl_basic_map_total_dim(bmap);
-
-	for (i = 0; i < n_out; ++i) {
-		k = isl_basic_map_alloc_equality(bmap);
-		if (k < 0)
-			goto error;
-		isl_seq_clr(bmap->eq[k], 1 + total);
-		isl_int_set_si(bmap->eq[k][1 + nparam + n_in + i], -1);
-		isl_int_set_si(bmap->eq[k][1 + nparam + n_in + n_out + i], 1);
-	}
+	for (i = 0; i < n_out; ++i)
+		bmap = isl_basic_map_equate(bmap, isl_dim_in, n_in + i,
+						    isl_dim_out, i);
 
 	bmap = isl_basic_map_gauss(bmap, NULL);
 	return isl_basic_map_finalize(bmap);
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
 }
 
 int isl_map_may_be_set(__isl_keep isl_map *map)
@@ -5080,28 +5729,30 @@ int isl_map_may_be_set(__isl_keep isl_map *map)
  * Users should never call this function.  Outside of isl,
  * the type should indicate whether something is a set or a map.
  */
-int isl_map_is_set(__isl_keep isl_map *map)
+isl_bool isl_map_is_set(__isl_keep isl_map *map)
 {
 	if (!map)
-		return -1;
+		return isl_bool_error;
 	return isl_space_is_set(map->dim);
 }
 
-struct isl_set *isl_map_range(struct isl_map *map)
+__isl_give isl_set *isl_map_range(__isl_take isl_map *map)
 {
 	int i;
+	isl_bool is_set;
 	struct isl_set *set;
 
-	if (!map)
+	is_set = isl_map_is_set(map);
+	if (is_set < 0)
 		goto error;
-	if (isl_map_is_set(map))
-		return (isl_set *)map;
+	if (is_set)
+		return set_from_map(map);
 
 	map = isl_map_cow(map);
 	if (!map)
 		goto error;
 
-	set = (struct isl_set *) map;
+	set = set_from_map(map);
 	set->dim = isl_space_range(set->dim);
 	if (!set->dim)
 		goto error;
@@ -5190,32 +5841,6 @@ __isl_give isl_map *isl_set_wrapped_domain_map(__isl_take isl_set *set)
 	return map;
 }
 
-__isl_give isl_map *isl_map_from_set(__isl_take isl_set *set,
-	__isl_take isl_space *dim)
-{
-	int i;
-	struct isl_map *map = NULL;
-
-	set = isl_set_cow(set);
-	if (!set || !dim)
-		goto error;
-	isl_assert(set->ctx, isl_space_compatible(set->dim, dim), goto error);
-	map = (struct isl_map *)set;
-	for (i = 0; i < set->n; ++i) {
-		map->p[i] = isl_basic_map_from_basic_set(
-				set->p[i], isl_space_copy(dim));
-		if (!map->p[i])
-			goto error;
-	}
-	isl_space_free(map->dim);
-	map->dim = dim;
-	return map;
-error:
-	isl_space_free(dim);
-	isl_set_free(set);
-	return NULL;
-}
-
 __isl_give isl_basic_map *isl_basic_map_from_domain(
 	__isl_take isl_basic_set *bset)
 {
@@ -5229,7 +5854,7 @@ __isl_give isl_basic_map *isl_basic_map_from_range(
 	space = isl_basic_set_get_space(bset);
 	space = isl_space_from_range(space);
 	bset = isl_basic_set_reset_space(bset, space);
-	return (isl_basic_map *)bset;
+	return bset_to_bmap(bset);
 }
 
 /* Create a relation with the given set as range.
@@ -5242,7 +5867,7 @@ __isl_give isl_map *isl_map_from_range(__isl_take isl_set *set)
 	space = isl_set_get_space(set);
 	space = isl_space_from_range(space);
 	set = isl_set_reset_space(set, space);
-	return (struct isl_map *)set;
+	return set_to_map(set);
 }
 
 /* Create a relation with the given set as domain.
@@ -5299,21 +5924,6 @@ error:
 	return NULL;
 }
 
-struct isl_map *isl_map_alloc(struct isl_ctx *ctx,
-		unsigned nparam, unsigned in, unsigned out, int n,
-		unsigned flags)
-{
-	struct isl_map *map;
-	isl_space *dims;
-
-	dims = isl_space_alloc(ctx, nparam, in, out);
-	if (!dims)
-		return NULL;
-
-	map = isl_map_alloc_space(dims, n, flags);
-	return map;
-}
-
 __isl_give isl_basic_map *isl_basic_map_empty(__isl_take isl_space *dim)
 {
 	struct isl_basic_map *bmap;
@@ -5507,30 +6117,22 @@ error:
 	return NULL;
 }
 
-struct isl_basic_map *isl_basic_map_fix_si(struct isl_basic_map *bmap,
+__isl_give isl_basic_map *isl_basic_map_fix_si(__isl_take isl_basic_map *bmap,
 		enum isl_dim_type type, unsigned pos, int value)
 {
-	if (!bmap)
-		return NULL;
-	isl_assert(bmap->ctx, pos < isl_basic_map_dim(bmap, type), goto error);
+	if (isl_basic_map_check_range(bmap, type, pos, 1) < 0)
+		return isl_basic_map_free(bmap);
 	return isl_basic_map_fix_pos_si(bmap,
 		isl_basic_map_offset(bmap, type) + pos, value);
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
 }
 
 __isl_give isl_basic_map *isl_basic_map_fix(__isl_take isl_basic_map *bmap,
 		enum isl_dim_type type, unsigned pos, isl_int value)
 {
-	if (!bmap)
-		return NULL;
-	isl_assert(bmap->ctx, pos < isl_basic_map_dim(bmap, type), goto error);
+	if (isl_basic_map_check_range(bmap, type, pos, 1) < 0)
+		return isl_basic_map_free(bmap);
 	return isl_basic_map_fix_pos(bmap,
 		isl_basic_map_offset(bmap, type) + pos, value);
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
 }
 
 /* Fix the value of the variable at position "pos" of type "type" of "bmap"
@@ -5544,9 +6146,8 @@ __isl_give isl_basic_map *isl_basic_map_fix_val(__isl_take isl_basic_map *bmap,
 	if (!isl_val_is_int(v))
 		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
 			"expecting integer value", goto error);
-	if (pos >= isl_basic_map_dim(bmap, type))
-		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
-			"index out of bounds", goto error);
+	if (isl_basic_map_check_range(bmap, type, pos, 1) < 0)
+		goto error;
 	pos += isl_basic_map_offset(bmap, type);
 	bmap = isl_basic_map_fix_pos(bmap, pos, v->n);
 	isl_val_free(v);
@@ -5569,17 +6170,15 @@ __isl_give isl_basic_set *isl_basic_set_fix_val(__isl_take isl_basic_set *bset,
 struct isl_basic_set *isl_basic_set_fix_si(struct isl_basic_set *bset,
 		enum isl_dim_type type, unsigned pos, int value)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_fix_si((struct isl_basic_map *)bset,
-					type, pos, value);
+	return bset_from_bmap(isl_basic_map_fix_si(bset_to_bmap(bset),
+						    type, pos, value));
 }
 
 __isl_give isl_basic_set *isl_basic_set_fix(__isl_take isl_basic_set *bset,
 		enum isl_dim_type type, unsigned pos, isl_int value)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_fix((struct isl_basic_map *)bset,
-					type, pos, value);
+	return bset_from_bmap(isl_basic_map_fix(bset_to_bmap(bset),
+						    type, pos, value));
 }
 
 struct isl_basic_map *isl_basic_map_fix_input_si(struct isl_basic_map *bmap,
@@ -5591,9 +6190,8 @@ struct isl_basic_map *isl_basic_map_fix_input_si(struct isl_basic_map *bmap,
 struct isl_basic_set *isl_basic_set_fix_dim_si(struct isl_basic_set *bset,
 		unsigned dim, int value)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_fix_si((struct isl_basic_map *)bset,
-					isl_dim_set, dim, value);
+	return bset_from_bmap(isl_basic_map_fix_si(bset_to_bmap(bset),
+					isl_dim_set, dim, value));
 }
 
 static int remove_if_empty(__isl_keep isl_map *map, int i)
@@ -5648,7 +6246,7 @@ error:
 	return NULL;
 }
 
-struct isl_map *isl_map_fix_si(struct isl_map *map,
+__isl_give isl_map *isl_map_fix_si(__isl_take isl_map *map,
 		enum isl_dim_type type, unsigned pos, int value)
 {
 	int i;
@@ -5673,8 +6271,7 @@ error:
 __isl_give isl_set *isl_set_fix_si(__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, int value)
 {
-	return (struct isl_set *)
-		isl_map_fix_si((struct isl_map *)set, type, pos, value);
+	return set_from_map(isl_map_fix_si(set_to_map(set), type, pos, value));
 }
 
 __isl_give isl_map *isl_map_fix(__isl_take isl_map *map,
@@ -5702,7 +6299,7 @@ error:
 __isl_give isl_set *isl_set_fix(__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, isl_int value)
 {
-	return (struct isl_set *)isl_map_fix((isl_map *)set, type, pos, value);
+	return set_from_map(isl_map_fix(set_to_map(set), type, pos, value));
 }
 
 /* Fix the value of the variable at position "pos" of type "type" of "map"
@@ -5755,8 +6352,8 @@ struct isl_map *isl_map_fix_input_si(struct isl_map *map,
 
 struct isl_set *isl_set_fix_dim_si(struct isl_set *set, unsigned dim, int value)
 {
-	return (struct isl_set *)
-		isl_map_fix_si((struct isl_map *)set, isl_dim_set, dim, value);
+	return set_from_map(isl_map_fix_si(set_to_map(set),
+						isl_dim_set, dim, value));
 }
 
 static __isl_give isl_basic_map *basic_map_bound_si(
@@ -5765,9 +6362,8 @@ static __isl_give isl_basic_map *basic_map_bound_si(
 {
 	int j;
 
-	if (!bmap)
-		return NULL;
-	isl_assert(bmap->ctx, pos < isl_basic_map_dim(bmap, type), goto error);
+	if (isl_basic_map_check_range(bmap, type, pos, 1) < 0)
+		return isl_basic_map_free(bmap);
 	pos += isl_basic_map_offset(bmap, type);
 	bmap = isl_basic_map_cow(bmap);
 	bmap = isl_basic_map_extend_constraints(bmap, 0, 1);
@@ -5805,26 +6401,6 @@ __isl_give isl_basic_map *isl_basic_map_upper_bound_si(
 	return basic_map_bound_si(bmap, type, pos, value, 1);
 }
 
-struct isl_basic_set *isl_basic_set_lower_bound_dim(struct isl_basic_set *bset,
-	unsigned dim, isl_int value)
-{
-	int j;
-
-	bset = isl_basic_set_cow(bset);
-	bset = isl_basic_set_extend_constraints(bset, 0, 1);
-	j = isl_basic_set_alloc_inequality(bset);
-	if (j < 0)
-		goto error;
-	isl_seq_clr(bset->ineq[j], 1 + isl_basic_set_total_dim(bset));
-	isl_int_set_si(bset->ineq[j][1 + isl_basic_set_n_param(bset) + dim], 1);
-	isl_int_neg(bset->ineq[j][0], value);
-	bset = isl_basic_set_simplify(bset);
-	return isl_basic_set_finalize(bset);
-error:
-	isl_basic_set_free(bset);
-	return NULL;
-}
-
 static __isl_give isl_map *map_bound_si(__isl_take isl_map *map,
 	enum isl_dim_type type, unsigned pos, int value, int upper)
 {
@@ -5863,8 +6439,8 @@ __isl_give isl_map *isl_map_upper_bound_si(__isl_take isl_map *map,
 __isl_give isl_set *isl_set_lower_bound_si(__isl_take isl_set *set,
 		enum isl_dim_type type, unsigned pos, int value)
 {
-	return (struct isl_set *)
-		isl_map_lower_bound_si((struct isl_map *)set, type, pos, value);
+	return set_from_map(isl_map_lower_bound_si(set_to_map(set),
+							type, pos, value));
 }
 
 __isl_give isl_set *isl_set_upper_bound_si(__isl_take isl_set *set,
@@ -5882,11 +6458,8 @@ static __isl_give isl_basic_map *basic_map_bound(
 {
 	int j;
 
-	if (!bmap)
-		return NULL;
-	if (pos >= isl_basic_map_dim(bmap, type))
-		isl_die(bmap->ctx, isl_error_invalid,
-			"index out of bounds", goto error);
+	if (isl_basic_map_check_range(bmap, type, pos, 1) < 0)
+		return isl_basic_map_free(bmap);
 	pos += isl_basic_map_offset(bmap, type);
 	bmap = isl_basic_map_cow(bmap);
 	bmap = isl_basic_map_extend_constraints(bmap, 0, 1);
@@ -5999,28 +6572,57 @@ error:
 	return NULL;
 }
 
-struct isl_set *isl_set_lower_bound_dim(struct isl_set *set, unsigned dim,
-					isl_int value)
+/* Bound the given variable of "bset" from below (or above is "upper"
+ * is set) to "value".
+ */
+static __isl_give isl_basic_set *isl_basic_set_bound(
+	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,
+	isl_int value, int upper)
 {
-	int i;
-
-	set = isl_set_cow(set);
-	if (!set)
-		return NULL;
+	return bset_from_bmap(basic_map_bound(bset_to_bmap(bset),
+						type, pos, value, upper));
+}
 
-	isl_assert(set->ctx, dim < isl_set_n_dim(set), goto error);
-	for (i = 0; i < set->n; ++i) {
-		set->p[i] = isl_basic_set_lower_bound_dim(set->p[i], dim, value);
-		if (!set->p[i])
-			goto error;
-	}
-	return set;
+/* Bound the given variable of "bset" from below (or above is "upper"
+ * is set) to "value".
+ */
+static __isl_give isl_basic_set *isl_basic_set_bound_val(
+	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,
+	__isl_take isl_val *value, int upper)
+{
+	if (!value)
+		goto error;
+	if (!isl_val_is_int(value))
+		isl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,
+			"expecting integer value", goto error);
+	bset = isl_basic_set_bound(bset, type, pos, value->n, upper);
+	isl_val_free(value);
+	return bset;
 error:
-	isl_set_free(set);
+	isl_val_free(value);
+	isl_basic_set_free(bset);
 	return NULL;
 }
 
-struct isl_map *isl_map_reverse(struct isl_map *map)
+/* Bound the given variable of "bset" from below to "value".
+ */
+__isl_give isl_basic_set *isl_basic_set_lower_bound_val(
+	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,
+	__isl_take isl_val *value)
+{
+	return isl_basic_set_bound_val(bset, type, pos, value, 0);
+}
+
+/* Bound the given variable of "bset" from above to "value".
+ */
+__isl_give isl_basic_set *isl_basic_set_upper_bound_val(
+	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,
+	__isl_take isl_val *value)
+{
+	return isl_basic_set_bound_val(bset, type, pos, value, 1);
+}
+
+__isl_give isl_map *isl_map_reverse(__isl_take isl_map *map)
 {
 	int i;
 
@@ -6043,95 +6645,6 @@ error:
 	return NULL;
 }
 
-static struct isl_map *isl_basic_map_partial_lexopt(
-		struct isl_basic_map *bmap, struct isl_basic_set *dom,
-		struct isl_set **empty, int max)
-{
-	return isl_tab_basic_map_partial_lexopt(bmap, dom, empty, max);
-}
-
-struct isl_map *isl_basic_map_partial_lexmax(
-		struct isl_basic_map *bmap, struct isl_basic_set *dom,
-		struct isl_set **empty)
-{
-	return isl_basic_map_partial_lexopt(bmap, dom, empty, 1);
-}
-
-struct isl_map *isl_basic_map_partial_lexmin(
-		struct isl_basic_map *bmap, struct isl_basic_set *dom,
-		struct isl_set **empty)
-{
-	return isl_basic_map_partial_lexopt(bmap, dom, empty, 0);
-}
-
-struct isl_set *isl_basic_set_partial_lexmin(
-		struct isl_basic_set *bset, struct isl_basic_set *dom,
-		struct isl_set **empty)
-{
-	return (struct isl_set *)
-		isl_basic_map_partial_lexmin((struct isl_basic_map *)bset,
-			dom, empty);
-}
-
-struct isl_set *isl_basic_set_partial_lexmax(
-		struct isl_basic_set *bset, struct isl_basic_set *dom,
-		struct isl_set **empty)
-{
-	return (struct isl_set *)
-		isl_basic_map_partial_lexmax((struct isl_basic_map *)bset,
-			dom, empty);
-}
-
-__isl_give isl_pw_multi_aff *isl_basic_map_partial_lexmin_pw_multi_aff(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty)
-{
-	return isl_basic_map_partial_lexopt_pw_multi_aff(bmap, dom, empty, 0);
-}
-
-__isl_give isl_pw_multi_aff *isl_basic_map_partial_lexmax_pw_multi_aff(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty)
-{
-	return isl_basic_map_partial_lexopt_pw_multi_aff(bmap, dom, empty, 1);
-}
-
-__isl_give isl_pw_multi_aff *isl_basic_set_partial_lexmin_pw_multi_aff(
-	__isl_take isl_basic_set *bset, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty)
-{
-	return isl_basic_map_partial_lexmin_pw_multi_aff(bset, dom, empty);
-}
-
-__isl_give isl_pw_multi_aff *isl_basic_set_partial_lexmax_pw_multi_aff(
-	__isl_take isl_basic_set *bset, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty)
-{
-	return isl_basic_map_partial_lexmax_pw_multi_aff(bset, dom, empty);
-}
-
-__isl_give isl_pw_multi_aff *isl_basic_map_lexopt_pw_multi_aff(
-	__isl_take isl_basic_map *bmap, int max)
-{
-	isl_basic_set *dom = NULL;
-	isl_space *dom_space;
-
-	if (!bmap)
-		goto error;
-	dom_space = isl_space_domain(isl_space_copy(bmap->dim));
-	dom = isl_basic_set_universe(dom_space);
-	return isl_basic_map_partial_lexopt_pw_multi_aff(bmap, dom, NULL, max);
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
-}
-
-__isl_give isl_pw_multi_aff *isl_basic_map_lexmin_pw_multi_aff(
-	__isl_take isl_basic_map *bmap)
-{
-	return isl_basic_map_lexopt_pw_multi_aff(bmap, 0);
-}
-
 #undef TYPE
 #define TYPE	isl_pw_multi_aff
 #undef SUFFIX
@@ -6147,6 +6660,9 @@ __isl_give isl_pw_multi_aff *isl_basic_map_lexmin_pw_multi_aff(
  * in the form of an isl_pw_multi_aff.
  * If "empty" is not NULL, then set *empty to those elements in dom that
  * do not have an image element.
+ * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
+ * should be computed over the domain of "map".  "empty" is also NULL
+ * in this case.
  *
  * We first compute the lexicographically minimal or maximal element
  * in the first basic map.  This results in a partial solution "res"
@@ -6158,13 +6674,15 @@ __isl_give isl_pw_multi_aff *isl_basic_map_lexmin_pw_multi_aff(
  */
 static __isl_give isl_pw_multi_aff *isl_map_partial_lexopt_aligned_pw_multi_aff(
 	__isl_take isl_map *map, __isl_take isl_set *dom,
-	__isl_give isl_set **empty, int max)
+	__isl_give isl_set **empty, unsigned flags)
 {
 	int i;
+	int full;
 	isl_pw_multi_aff *res;
 	isl_set *todo;
 
-	if (!map || !dom)
+	full = ISL_FL_ISSET(flags, ISL_OPT_FULL);
+	if (!map || (!full && !dom))
 		goto error;
 
 	if (isl_map_plain_is_empty(map)) {
@@ -6177,7 +6695,7 @@ static __isl_give isl_pw_multi_aff *isl_map_partial_lexopt_aligned_pw_multi_aff(
 
 	res = basic_map_partial_lexopt_pw_multi_aff(
 					    isl_basic_map_copy(map->p[0]),
-					    isl_set_copy(dom), empty, max);
+					    isl_set_copy(dom), empty, flags);
 
 	if (empty)
 		todo = *empty;
@@ -6186,9 +6704,9 @@ static __isl_give isl_pw_multi_aff *isl_map_partial_lexopt_aligned_pw_multi_aff(
 
 		res_i = basic_map_partial_lexopt_pw_multi_aff(
 					    isl_basic_map_copy(map->p[i]),
-					    isl_set_copy(dom), empty, max);
+					    isl_set_copy(dom), empty, flags);
 
-		if (max)
+		if (ISL_FL_ISSET(flags, ISL_OPT_MAX))
 			res = isl_pw_multi_aff_union_lexmax(res, res_i);
 		else
 			res = isl_pw_multi_aff_union_lexmin(res, res_i);
@@ -6227,6 +6745,9 @@ error:
  * in the form of an isl_map.
  * If "empty" is not NULL, then set *empty to those elements in "dom" that
  * do not have an image element.
+ * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
+ * should be computed over the domain of "map".  "empty" is also NULL
+ * in this case.
  *
  * If the input consists of more than one disjunct, then first
  * compute the desired result in the form of an isl_pw_multi_aff and
@@ -6243,13 +6764,15 @@ error:
  * even more splintering.
  */
 static __isl_give isl_map *isl_map_partial_lexopt_aligned(
-		__isl_take isl_map *map, __isl_take isl_set *dom,
-		__isl_give isl_set **empty, int max)
+	__isl_take isl_map *map, __isl_take isl_set *dom,
+	__isl_give isl_set **empty, unsigned flags)
 {
+	int full;
 	struct isl_map *res;
 	isl_pw_multi_aff *pma;
 
-	if (!map || !dom)
+	full = ISL_FL_ISSET(flags, ISL_OPT_FULL);
+	if (!map || (!full && !dom))
 		goto error;
 
 	if (isl_map_plain_is_empty(map)) {
@@ -6262,12 +6785,13 @@ static __isl_give isl_map *isl_map_partial_lexopt_aligned(
 
 	if (map->n == 1) {
 		res = basic_map_partial_lexopt(isl_basic_map_copy(map->p[0]),
-						dom, empty, max);
+						dom, empty, flags);
 		isl_map_free(map);
 		return res;
 	}
 
-	pma = isl_map_partial_lexopt_aligned_pw_multi_aff(map, dom, empty, max);
+	pma = isl_map_partial_lexopt_aligned_pw_multi_aff(map, dom, empty,
+							flags);
 	return isl_map_from_pw_multi_aff(pma);
 error:
 	if (empty)
@@ -6281,7 +6805,7 @@ __isl_give isl_map *isl_map_partial_lexmax(
 		__isl_take isl_map *map, __isl_take isl_set *dom,
 		__isl_give isl_set **empty)
 {
-	return isl_map_partial_lexopt(map, dom, empty, 1);
+	return isl_map_partial_lexopt(map, dom, empty, ISL_OPT_MAX);
 }
 
 __isl_give isl_map *isl_map_partial_lexmin(
@@ -6295,67 +6819,52 @@ __isl_give isl_set *isl_set_partial_lexmin(
 		__isl_take isl_set *set, __isl_take isl_set *dom,
 		__isl_give isl_set **empty)
 {
-	return (struct isl_set *)
-		isl_map_partial_lexmin((struct isl_map *)set,
-			dom, empty);
+	return set_from_map(isl_map_partial_lexmin(set_to_map(set),
+						    dom, empty));
 }
 
 __isl_give isl_set *isl_set_partial_lexmax(
 		__isl_take isl_set *set, __isl_take isl_set *dom,
 		__isl_give isl_set **empty)
 {
-	return (struct isl_set *)
-		isl_map_partial_lexmax((struct isl_map *)set,
-			dom, empty);
+	return set_from_map(isl_map_partial_lexmax(set_to_map(set),
+						    dom, empty));
 }
 
-/* Compute the lexicographic minimum (or maximum if "max" is set)
- * of "bmap" over its domain.
- *
- * Since we are not interested in the part of the domain space where
- * there is no solution, we initialize the domain to those constraints
- * of "bmap" that only involve the parameters and the input dimensions.
- * This relieves the parametric programming engine from detecting those
- * inequalities and transferring them to the context.  More importantly,
- * it ensures that those inequalities are transferred first and not
- * intermixed with inequalities that actually split the domain.
+/* Compute the lexicographic minimum (or maximum if "flags" includes
+ * ISL_OPT_MAX) of "bset" over its parametric domain.
  */
-__isl_give isl_map *isl_basic_map_lexopt(__isl_take isl_basic_map *bmap, int max)
-{
-	int n_div;
-	int n_out;
-	isl_basic_map *copy;
-	isl_basic_set *dom;
-
-	n_div = isl_basic_map_dim(bmap, isl_dim_div);
-	n_out = isl_basic_map_dim(bmap, isl_dim_out);
-	copy = isl_basic_map_copy(bmap);
-	copy = isl_basic_map_drop_constraints_involving_dims(copy,
-							isl_dim_div, 0, n_div);
-	copy = isl_basic_map_drop_constraints_involving_dims(copy,
-							isl_dim_out, 0, n_out);
-	dom = isl_basic_map_domain(copy);
-	return isl_basic_map_partial_lexopt(bmap, dom, NULL, max);
-}
-
-__isl_give isl_map *isl_basic_map_lexmin(__isl_take isl_basic_map *bmap)
+__isl_give isl_set *isl_basic_set_lexopt(__isl_take isl_basic_set *bset,
+	unsigned flags)
 {
-	return isl_basic_map_lexopt(bmap, 0);
+	return isl_basic_map_lexopt(bset, flags);
 }
 
 __isl_give isl_map *isl_basic_map_lexmax(__isl_take isl_basic_map *bmap)
 {
-	return isl_basic_map_lexopt(bmap, 1);
+	return isl_basic_map_lexopt(bmap, ISL_OPT_MAX);
 }
 
 __isl_give isl_set *isl_basic_set_lexmin(__isl_take isl_basic_set *bset)
 {
-	return (isl_set *)isl_basic_map_lexmin((isl_basic_map *)bset);
+	return set_from_map(isl_basic_map_lexmin(bset_to_bmap(bset)));
 }
 
 __isl_give isl_set *isl_basic_set_lexmax(__isl_take isl_basic_set *bset)
 {
-	return (isl_set *)isl_basic_map_lexmax((isl_basic_map *)bset);
+	return set_from_map(isl_basic_map_lexmax(bset_to_bmap(bset)));
+}
+
+/* Compute the lexicographic minimum of "bset" over its parametric domain
+ * for the purpose of quantifier elimination.
+ * That is, find an explicit representation for all the existentially
+ * quantified variables in "bset" by computing their lexicographic
+ * minimum.
+ */
+static __isl_give isl_set *isl_basic_set_lexmin_compute_divs(
+	__isl_take isl_basic_set *bset)
+{
+	return isl_basic_set_lexopt(bset, ISL_OPT_QE);
 }
 
 /* Extract the first and only affine expression from list
@@ -6363,7 +6872,7 @@ __isl_give isl_set *isl_basic_set_lexmax(__isl_take isl_basic_set *bset)
  * This domain is known to be disjoint from other domains
  * because of the way isl_basic_map_foreach_lexmax works.
  */
-static int update_dim_opt(__isl_take isl_basic_set *dom,
+static isl_stat update_dim_opt(__isl_take isl_basic_set *dom,
 	__isl_take isl_aff_list *list, void *user)
 {
 	isl_ctx *ctx = isl_basic_set_get_ctx(dom);
@@ -6384,11 +6893,11 @@ static int update_dim_opt(__isl_take isl_basic_set *dom,
 
 	isl_aff_list_free(list);
 
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_basic_set_free(dom);
 	isl_aff_list_free(list);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Given a basic map with one output dimension, compute the minimum or
@@ -6402,7 +6911,7 @@ static __isl_give isl_pw_aff *basic_map_dim_opt(__isl_keep isl_basic_map *bmap,
 {
 	isl_space *dim = isl_basic_map_get_space(bmap);
 	isl_pw_aff *pwaff;
-	int r;
+	isl_stat r;
 
 	dim = isl_space_from_domain(isl_space_domain(dim));
 	dim = isl_space_add_dims(dim, isl_dim_out, 1);
@@ -6455,6 +6964,15 @@ static __isl_give isl_pw_aff *map_dim_opt(__isl_take isl_map *map, int pos,
 	return pwaff;
 }
 
+/* Compute the minimum of the given output dimension as a function of the
+ * parameters and input dimensions, but independently of
+ * the other output dimensions.
+ */
+__isl_give isl_pw_aff *isl_map_dim_min(__isl_take isl_map *map, int pos)
+{
+	return map_dim_opt(map, pos, 0);
+}
+
 /* Compute the maximum of the given output dimension as a function of the
  * parameters and input dimensions, but independently of
  * the other output dimensions.
@@ -6493,8 +7011,8 @@ __isl_give isl_pw_aff *isl_set_dim_min(__isl_take isl_set *set, int pos)
 /* Apply a preimage specified by "mat" on the parameters of "bset".
  * bset is assumed to have only parameters and divs.
  */
-static struct isl_basic_set *basic_set_parameter_preimage(
-	struct isl_basic_set *bset, struct isl_mat *mat)
+static __isl_give isl_basic_set *basic_set_parameter_preimage(
+	__isl_take isl_basic_set *bset, __isl_take isl_mat *mat)
 {
 	unsigned nparam;
 
@@ -6561,8 +7079,8 @@ error:
 /* Intersect the basic set "bset" with the affine space specified by the
  * equalities in "eq".
  */
-static struct isl_basic_set *basic_set_append_equalities(
-	struct isl_basic_set *bset, struct isl_mat *eq)
+static __isl_give isl_basic_set *basic_set_append_equalities(
+	__isl_take isl_basic_set *bset, __isl_take isl_mat *eq)
 {
 	int i, k;
 	unsigned len;
@@ -6669,7 +7187,7 @@ static __isl_give isl_set *base_compute_divs(__isl_take isl_basic_set *bset)
 	if (!bset)
 		return NULL;
 	if (bset->n_eq == 0)
-		return isl_basic_set_lexmin(bset);
+		return isl_basic_set_lexmin_compute_divs(bset);
 
 	morph1 = isl_basic_set_parameter_compression(bset);
 	bset = isl_morph_basic_set(isl_morph_copy(morph1), bset);
@@ -6679,7 +7197,7 @@ static __isl_give isl_set *base_compute_divs(__isl_take isl_basic_set *bset)
 	n = isl_basic_set_dim(bset, isl_dim_set);
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 0, n);
 
-	set = isl_basic_set_lexmin(bset);
+	set = isl_basic_set_lexmin_compute_divs(bset);
 
 	set = isl_morph_set(isl_morph_inverse(morph1), set);
 
@@ -6906,10 +7424,10 @@ static struct isl_map *compute_divs(struct isl_basic_map *bmap)
 		bmap->extra -= n_known;
 	}
 	bmap = isl_basic_map_reset_space(bmap, dim);
-	bset = (struct isl_basic_set *)bmap;
+	bset = bset_from_bmap(bmap);
 
 	set = parameter_compute_divs(bset);
-	map = (struct isl_map *)set;
+	map = set_to_map(set);
 	map = replace_space_by_local_space(map, ls);
 
 	return map;
@@ -6924,12 +7442,12 @@ error:
 __isl_give isl_basic_map *isl_basic_map_mark_div_unknown(
 	__isl_take isl_basic_map *bmap, int div)
 {
-	isl_bool known;
+	isl_bool unknown;
 
-	known = isl_basic_map_div_is_known(bmap, div);
-	if (known < 0)
+	unknown = isl_basic_map_div_is_marked_unknown(bmap, div);
+	if (unknown < 0)
 		return isl_basic_map_free(bmap);
-	if (!known)
+	if (unknown)
 		return bmap;
 
 	bmap = isl_basic_map_cow(bmap);
@@ -6939,16 +7457,19 @@ __isl_give isl_basic_map *isl_basic_map_mark_div_unknown(
 	return bmap;
 }
 
-/* Does local variable "div" of "bmap" have an explicit representation?
+/* Is local variable "div" of "bmap" marked as not having an explicit
+ * representation?
+ * Note that even if "div" is not marked in this way and therefore
+ * has an explicit representation, this representation may still
+ * depend (indirectly) on other local variables that do not
+ * have an explicit representation.
  */
-isl_bool isl_basic_map_div_is_known(__isl_keep isl_basic_map *bmap, int div)
+isl_bool isl_basic_map_div_is_marked_unknown(__isl_keep isl_basic_map *bmap,
+	int div)
 {
-	if (!bmap)
+	if (isl_basic_map_check_range(bmap, isl_dim_div, div, 1) < 0)
 		return isl_bool_error;
-	if (div < 0 || div >= isl_basic_map_dim(bmap, isl_dim_div))
-		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
-			"position out of bounds", return isl_bool_error);
-	return !isl_int_is_zero(bmap->div[div][0]);
+	return isl_int_is_zero(bmap->div[div][0]);
 }
 
 /* Return the position of the first local variable that does not
@@ -6971,6 +7492,17 @@ int isl_basic_map_first_unknown_div(__isl_keep isl_basic_map *bmap)
 	return bmap->n_div;
 }
 
+/* Return the position of the first local variable that does not
+ * have an explicit representation.
+ * Return the total number of local variables if they all have
+ * an explicit representation.
+ * Return -1 on error.
+ */
+int isl_basic_set_first_unknown_div(__isl_keep isl_basic_set *bset)
+{
+	return isl_basic_map_first_unknown_div(bset);
+}
+
 /* Does "bmap" have an explicit representation for all local variables?
  */
 isl_bool isl_basic_map_divs_known(__isl_keep isl_basic_map *bmap)
@@ -7008,7 +7540,7 @@ isl_bool isl_map_divs_known(__isl_keep isl_map *map)
  * quite expensive, so first try to remove divs that aren't
  * strictly needed.
  */
-struct isl_map *isl_basic_map_compute_divs(struct isl_basic_map *bmap)
+__isl_give isl_map *isl_basic_map_compute_divs(__isl_take isl_basic_map *bmap)
 {
 	int known;
 	struct isl_map *map;
@@ -7034,7 +7566,7 @@ error:
 	return NULL;
 }
 
-struct isl_map *isl_map_compute_divs(struct isl_map *map)
+__isl_give isl_map *isl_map_compute_divs(__isl_take isl_map *map)
 {
 	int i;
 	int known;
@@ -7067,19 +7599,17 @@ struct isl_map *isl_map_compute_divs(struct isl_map *map)
 	return res;
 }
 
-struct isl_set *isl_basic_set_compute_divs(struct isl_basic_set *bset)
+__isl_give isl_set *isl_basic_set_compute_divs(__isl_take isl_basic_set *bset)
 {
-	return (struct isl_set *)
-		isl_basic_map_compute_divs((struct isl_basic_map *)bset);
+	return set_from_map(isl_basic_map_compute_divs(bset_to_bmap(bset)));
 }
 
 struct isl_set *isl_set_compute_divs(struct isl_set *set)
 {
-	return (struct isl_set *)
-		isl_map_compute_divs((struct isl_map *)set);
+	return set_from_map(isl_map_compute_divs(set_to_map(set)));
 }
 
-struct isl_set *isl_map_domain(struct isl_map *map)
+__isl_give isl_set *isl_map_domain(__isl_take isl_map *map)
 {
 	int i;
 	struct isl_set *set;
@@ -7091,7 +7621,7 @@ struct isl_set *isl_map_domain(struct isl_map *map)
 	if (!map)
 		return NULL;
 
-	set = (struct isl_set *)map;
+	set = set_from_map(map);
 	set->dim = isl_space_domain(set->dim);
 	if (!set->dim)
 		goto error;
@@ -7250,18 +7780,16 @@ __isl_give isl_map *isl_map_union(__isl_take isl_map *map1,
 	return isl_map_align_params_map_map_and(map1, map2, &map_union_aligned);
 }
 
-struct isl_set *isl_set_union_disjoint(
-			struct isl_set *set1, struct isl_set *set2)
+__isl_give isl_set *isl_set_union_disjoint(
+	__isl_take isl_set *set1, __isl_take isl_set *set2)
 {
-	return (struct isl_set *)
-		isl_map_union_disjoint(
-			(struct isl_map *)set1, (struct isl_map *)set2);
+	return set_from_map(isl_map_union_disjoint(set_to_map(set1),
+						    set_to_map(set2)));
 }
 
 struct isl_set *isl_set_union(struct isl_set *set1, struct isl_set *set2)
 {
-	return (struct isl_set *)
-		isl_map_union((struct isl_map *)set1, (struct isl_map *)set2);
+	return set_from_map(isl_map_union(set_to_map(set1), set_to_map(set2)));
 }
 
 /* Apply "fn" to pairs of elements from "map" and "set" and collect
@@ -7306,10 +7834,12 @@ static __isl_give isl_map *map_intersect_set(__isl_take isl_map *map,
 static __isl_give isl_map *map_intersect_range(__isl_take isl_map *map,
 	__isl_take isl_set *set)
 {
-	if (!map || !set)
-		goto error;
+	isl_bool ok;
 
-	if (!isl_map_compatible_range(map, set))
+	ok = isl_map_compatible_range(map, set);
+	if (ok < 0)
+		goto error;
+	if (!ok)
 		isl_die(set->ctx, isl_error_invalid,
 			"incompatible spaces", goto error);
 
@@ -7329,10 +7859,12 @@ __isl_give isl_map *isl_map_intersect_range(__isl_take isl_map *map,
 static __isl_give isl_map *map_intersect_domain(__isl_take isl_map *map,
 	__isl_take isl_set *set)
 {
-	if (!map || !set)
-		goto error;
+	isl_bool ok;
 
-	if (!isl_map_compatible_domain(map, set))
+	ok = isl_map_compatible_domain(map, set);
+	if (ok < 0)
+		goto error;
+	if (!ok)
 		isl_die(set->ctx, isl_error_invalid,
 			"incompatible spaces", goto error);
 
@@ -7350,6 +7882,63 @@ __isl_give isl_map *isl_map_intersect_domain(__isl_take isl_map *map,
 						&map_intersect_domain);
 }
 
+/* Given a map "map" in a space [A -> B] -> C and a map "factor"
+ * in the space B -> C, return the intersection.
+ * The parameters are assumed to have been aligned.
+ *
+ * The map "factor" is first extended to a map living in the space
+ * [A -> B] -> C and then a regular intersection is computed.
+ */
+static __isl_give isl_map *map_intersect_domain_factor_range(
+	__isl_take isl_map *map, __isl_take isl_map *factor)
+{
+	isl_space *space;
+	isl_map *ext_factor;
+
+	space = isl_space_domain_factor_domain(isl_map_get_space(map));
+	ext_factor = isl_map_universe(space);
+	ext_factor = isl_map_domain_product(ext_factor, factor);
+	return map_intersect(map, ext_factor);
+}
+
+/* Given a map "map" in a space [A -> B] -> C and a map "factor"
+ * in the space B -> C, return the intersection.
+ */
+__isl_give isl_map *isl_map_intersect_domain_factor_range(
+	__isl_take isl_map *map, __isl_take isl_map *factor)
+{
+	return isl_map_align_params_map_map_and(map, factor,
+					    &map_intersect_domain_factor_range);
+}
+
+/* Given a map "map" in a space A -> [B -> C] and a map "factor"
+ * in the space A -> C, return the intersection.
+ *
+ * The map "factor" is first extended to a map living in the space
+ * A -> [B -> C] and then a regular intersection is computed.
+ */
+static __isl_give isl_map *map_intersect_range_factor_range(
+	__isl_take isl_map *map, __isl_take isl_map *factor)
+{
+	isl_space *space;
+	isl_map *ext_factor;
+
+	space = isl_space_range_factor_domain(isl_map_get_space(map));
+	ext_factor = isl_map_universe(space);
+	ext_factor = isl_map_range_product(ext_factor, factor);
+	return isl_map_intersect(map, ext_factor);
+}
+
+/* Given a map "map" in a space A -> [B -> C] and a map "factor"
+ * in the space A -> C, return the intersection.
+ */
+__isl_give isl_map *isl_map_intersect_range_factor_range(
+	__isl_take isl_map *map, __isl_take isl_map *factor)
+{
+	return isl_map_align_params_map_map_and(map, factor,
+					    &map_intersect_range_factor_range);
+}
+
 static __isl_give isl_map *map_apply_domain(__isl_take isl_map *map1,
 	__isl_take isl_map *map2)
 {
@@ -7415,7 +8004,7 @@ __isl_give isl_map *isl_map_apply_range(__isl_take isl_map *map1,
 /*
  * returns range - domain
  */
-struct isl_basic_set *isl_basic_map_deltas(struct isl_basic_map *bmap)
+__isl_give isl_basic_set *isl_basic_map_deltas(__isl_take isl_basic_map *bmap)
 {
 	isl_space *target_space;
 	struct isl_basic_set *bset;
@@ -7429,8 +8018,8 @@ struct isl_basic_set *isl_basic_map_deltas(struct isl_basic_map *bmap)
 						  bmap->dim, isl_dim_out),
 		   goto error);
 	target_space = isl_space_domain(isl_basic_map_get_space(bmap));
-	dim = isl_basic_map_n_in(bmap);
-	nparam = isl_basic_map_n_param(bmap);
+	dim = isl_basic_map_dim(bmap, isl_dim_in);
+	nparam = isl_basic_map_dim(bmap, isl_dim_param);
 	bmap = isl_basic_map_from_range(isl_basic_map_wrap(bmap));
 	bmap = isl_basic_map_add_dims(bmap, isl_dim_in, dim);
 	bmap = isl_basic_map_extend_constraints(bmap, dim, 0);
@@ -7726,17 +8315,18 @@ error:
 	return NULL;
 }
 
-static int foreach_orthant(__isl_take isl_set *set, int *signs, int first,
-	int len, int (*fn)(__isl_take isl_set *orthant, int *signs, void *user),
+static isl_stat foreach_orthant(__isl_take isl_set *set, int *signs, int first,
+	int len,
+	isl_stat (*fn)(__isl_take isl_set *orthant, int *signs, void *user),
 	void *user)
 {
 	isl_set *half;
 
 	if (!set)
-		return -1;
+		return isl_stat_error;
 	if (isl_set_plain_is_empty(set)) {
 		isl_set_free(set);
-		return 0;
+		return isl_stat_ok;
 	}
 	if (first == len)
 		return fn(set, signs, user);
@@ -7755,7 +8345,7 @@ static int foreach_orthant(__isl_take isl_set *set, int *signs, int first,
 	return foreach_orthant(half, signs, first + 1, len, fn, user);
 error:
 	isl_set_free(set);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Call "fn" on the intersections of "set" with each of the orthants
@@ -7763,19 +8353,19 @@ error:
  * by the signs array, with each entry having value 1 or -1 according
  * to the sign of the corresponding variable.
  */
-int isl_set_foreach_orthant(__isl_keep isl_set *set,
-	int (*fn)(__isl_take isl_set *orthant, int *signs, void *user),
+isl_stat isl_set_foreach_orthant(__isl_keep isl_set *set,
+	isl_stat (*fn)(__isl_take isl_set *orthant, int *signs, void *user),
 	void *user)
 {
 	unsigned nparam;
 	unsigned nvar;
 	int *signs;
-	int r;
+	isl_stat r;
 
 	if (!set)
-		return -1;
+		return isl_stat_error;
 	if (isl_set_plain_is_empty(set))
-		return 0;
+		return isl_stat_ok;
 
 	nparam = isl_set_dim(set, isl_dim_param);
 	nvar = isl_set_dim(set, isl_dim_set);
@@ -7792,7 +8382,7 @@ int isl_set_foreach_orthant(__isl_keep isl_set *set,
 
 isl_bool isl_set_is_equal(__isl_keep isl_set *set1, __isl_keep isl_set *set2)
 {
-	return isl_map_is_equal((struct isl_map *)set1, (struct isl_map *)set2);
+	return isl_map_is_equal(set_to_map(set1), set_to_map(set2));
 }
 
 isl_bool isl_basic_map_is_subset(__isl_keep isl_basic_map *bmap1,
@@ -7840,7 +8430,7 @@ isl_bool isl_basic_set_is_equal(__isl_keep isl_basic_set *bset1,
 	__isl_keep isl_basic_set *bset2)
 {
 	return isl_basic_map_is_equal(
-		(struct isl_basic_map *)bset1, (struct isl_basic_map *)bset2);
+		bset_to_bmap(bset1), bset_to_bmap(bset2));
 }
 
 isl_bool isl_map_is_empty(__isl_keep isl_map *map)
@@ -7872,21 +8462,23 @@ isl_bool isl_set_plain_is_empty(__isl_keep isl_set *set)
 
 isl_bool isl_set_is_empty(__isl_keep isl_set *set)
 {
-	return isl_map_is_empty((struct isl_map *)set);
+	return isl_map_is_empty(set_to_map(set));
 }
 
-int isl_map_has_equal_space(__isl_keep isl_map *map1, __isl_keep isl_map *map2)
+isl_bool isl_map_has_equal_space(__isl_keep isl_map *map1,
+	__isl_keep isl_map *map2)
 {
 	if (!map1 || !map2)
-		return -1;
+		return isl_bool_error;
 
 	return isl_space_is_equal(map1->dim, map2->dim);
 }
 
-int isl_set_has_equal_space(__isl_keep isl_set *set1, __isl_keep isl_set *set2)
+isl_bool isl_set_has_equal_space(__isl_keep isl_set *set1,
+	__isl_keep isl_set *set2)
 {
 	if (!set1 || !set2)
-		return -1;
+		return isl_bool_error;
 
 	return isl_space_is_equal(set1->dim, set2->dim);
 }
@@ -7904,8 +8496,18 @@ static isl_bool map_is_equal(__isl_keep isl_map *map1, __isl_keep isl_map *map2)
 	return is_subset;
 }
 
+/* Is "map1" equal to "map2"?
+ *
+ * First check if they are obviously equal.
+ * If not, then perform a more detailed analysis.
+ */
 isl_bool isl_map_is_equal(__isl_keep isl_map *map1, __isl_keep isl_map *map2)
 {
+	isl_bool equal;
+
+	equal = isl_map_plain_is_equal(map1, map2);
+	if (equal < 0 || equal)
+		return equal;
 	return isl_map_align_params_map_map_and_test(map1, map2, &map_is_equal);
 }
 
@@ -7944,7 +8546,7 @@ isl_bool isl_map_is_strict_subset(__isl_keep isl_map *map1,
 isl_bool isl_set_is_strict_subset(__isl_keep isl_set *set1,
 	__isl_keep isl_set *set2)
 {
-	return isl_map_is_strict_subset((isl_map *)set1, (isl_map *)set2);
+	return isl_map_is_strict_subset(set_to_map(set1), set_to_map(set2));
 }
 
 /* Is "bmap" obviously equal to the universe with the same space?
@@ -8036,7 +8638,7 @@ isl_bool isl_map_plain_is_universe(__isl_keep isl_map *map)
 
 isl_bool isl_set_plain_is_universe(__isl_keep isl_set *set)
 {
-	return isl_map_plain_is_universe((isl_map *) set);
+	return isl_map_plain_is_universe(set_to_map(set));
 }
 
 isl_bool isl_basic_map_is_empty(__isl_keep isl_basic_map *bmap)
@@ -8118,11 +8720,11 @@ isl_bool isl_basic_map_plain_is_non_empty(__isl_keep isl_basic_map *bmap)
 
 isl_bool isl_basic_set_is_empty(__isl_keep isl_basic_set *bset)
 {
-	return isl_basic_map_is_empty((struct isl_basic_map *)bset);
+	return isl_basic_map_is_empty(bset_to_bmap(bset));
 }
 
-struct isl_map *isl_basic_map_union(
-	struct isl_basic_map *bmap1, struct isl_basic_map *bmap2)
+__isl_give isl_map *isl_basic_map_union(__isl_take isl_basic_map *bmap1,
+	__isl_take isl_basic_map *bmap2)
 {
 	struct isl_map *map;
 	if (!bmap1 || !bmap2)
@@ -8145,13 +8747,13 @@ error:
 struct isl_set *isl_basic_set_union(
 		struct isl_basic_set *bset1, struct isl_basic_set *bset2)
 {
-	return (struct isl_set *)isl_basic_map_union(
-					    (struct isl_basic_map *)bset1,
-					    (struct isl_basic_map *)bset2);
+	return set_from_map(isl_basic_map_union(bset_to_bmap(bset1),
+						bset_to_bmap(bset2)));
 }
 
 /* Order divs such that any div only depends on previous divs */
-struct isl_basic_map *isl_basic_map_order_divs(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_order_divs(
+	__isl_take isl_basic_map *bmap)
 {
 	int i;
 	unsigned off;
@@ -8181,8 +8783,7 @@ struct isl_basic_map *isl_basic_map_order_divs(struct isl_basic_map *bmap)
 
 struct isl_basic_set *isl_basic_set_order_divs(struct isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_order_divs((struct isl_basic_map *)bset);
+	return bset_from_bmap(isl_basic_map_order_divs(bset_to_bmap(bset)));
 }
 
 __isl_give isl_map *isl_map_order_divs(__isl_take isl_map *map)
@@ -8204,6 +8805,14 @@ error:
 	return NULL;
 }
 
+/* Sort the local variables of "bset".
+ */
+__isl_give isl_basic_set *isl_basic_set_sort_divs(
+	__isl_take isl_basic_set *bset)
+{
+	return bset_from_bmap(isl_basic_map_sort_divs(bset_to_bmap(bset)));
+}
+
 /* Apply the expansion computed by isl_merge_divs.
  * The expansion itself is given by "exp" while the resulting
  * list of divs is given by "div".
@@ -8215,7 +8824,7 @@ error:
  * in the definitions of the extra integer divisions.
  */
 __isl_give isl_basic_map *isl_basic_map_expand_divs(
-	__isl_take isl_basic_set *bmap, __isl_take isl_mat *div, int *exp)
+	__isl_take isl_basic_map *bmap, __isl_take isl_mat *div, int *exp)
 {
 	int i, j;
 	int n_div;
@@ -8248,7 +8857,7 @@ __isl_give isl_basic_map *isl_basic_map_expand_divs(
 			j++;
 		} else {
 			isl_seq_cpy(bmap->div[i], div->row[i], div->n_col);
-			if (!isl_basic_map_div_is_known(bmap, i))
+			if (isl_basic_map_div_is_marked_unknown(bmap, i))
 				continue;
 			if (isl_basic_map_add_div_constraints(bmap, i) < 0)
 				goto error;
@@ -8279,8 +8888,8 @@ __isl_give isl_basic_set *isl_basic_set_expand_divs(
  * Returns -1 if no corresponding div was found and the position
  * of the corresponding div in dst otherwise.
  */
-static int find_div(struct isl_basic_map *dst,
-			struct isl_basic_map *src, unsigned div)
+static int find_div(__isl_keep isl_basic_map *dst,
+	__isl_keep isl_basic_map *src, unsigned div)
 {
 	int i;
 
@@ -8354,14 +8963,7 @@ __isl_give isl_basic_map *isl_basic_map_align_divs(
 	return dst;
 }
 
-struct isl_basic_set *isl_basic_set_align_divs(
-		struct isl_basic_set *dst, struct isl_basic_set *src)
-{
-	return (struct isl_basic_set *)isl_basic_map_align_divs(
-		(struct isl_basic_map *)dst, (struct isl_basic_map *)src);
-}
-
-struct isl_map *isl_map_align_divs(struct isl_map *map)
+__isl_give isl_map *isl_map_align_divs_internal(__isl_take isl_map *map)
 {
 	int i;
 
@@ -8386,9 +8988,14 @@ struct isl_map *isl_map_align_divs(struct isl_map *map)
 	return map;
 }
 
+__isl_give isl_map *isl_map_align_divs(__isl_take isl_map *map)
+{
+	return isl_map_align_divs_internal(map);
+}
+
 struct isl_set *isl_set_align_divs(struct isl_set *set)
 {
-	return (struct isl_set *)isl_map_align_divs((struct isl_map *)set);
+	return set_from_map(isl_map_align_divs_internal(set_to_map(set)));
 }
 
 /* Align the divs of the basic maps in "map" to those
@@ -8418,7 +9025,7 @@ __isl_give isl_map *isl_map_align_divs_to_basic_map_list(
 	if (!map->p[0])
 		return isl_map_free(map);
 
-	return isl_map_align_divs(map);
+	return isl_map_align_divs_internal(map);
 }
 
 /* Align the divs of each element of "list" to those of "bmap".
@@ -8447,9 +9054,14 @@ __isl_give isl_basic_map_list *isl_basic_map_list_align_divs_to_basic_map(
 static __isl_give isl_set *set_apply( __isl_take isl_set *set,
 	__isl_take isl_map *map)
 {
-	if (!set || !map)
+	isl_bool ok;
+
+	ok = isl_map_compatible_domain(map, set);
+	if (ok < 0)
 		goto error;
-	isl_assert(set->ctx, isl_map_compatible_domain(map, set), goto error);
+	if (!ok)
+		isl_die(isl_set_get_ctx(set), isl_error_invalid,
+			"incompatible spaces", goto error);
 	map = isl_map_intersect_domain(map, set);
 	set = isl_map_range(map);
 	return set;
@@ -8468,7 +9080,7 @@ __isl_give isl_set *isl_set_apply( __isl_take isl_set *set,
 /* There is no need to cow as removing empty parts doesn't change
  * the meaning of the set.
  */
-struct isl_map *isl_map_remove_empty_parts(struct isl_map *map)
+__isl_give isl_map *isl_map_remove_empty_parts(__isl_take isl_map *map)
 {
 	int i;
 
@@ -8483,58 +9095,7 @@ struct isl_map *isl_map_remove_empty_parts(struct isl_map *map)
 
 struct isl_set *isl_set_remove_empty_parts(struct isl_set *set)
 {
-	return (struct isl_set *)
-		isl_map_remove_empty_parts((struct isl_map *)set);
-}
-
-struct isl_basic_map *isl_map_copy_basic_map(struct isl_map *map)
-{
-	struct isl_basic_map *bmap;
-	if (!map || map->n == 0)
-		return NULL;
-	bmap = map->p[map->n-1];
-	isl_assert(map->ctx, ISL_F_ISSET(bmap, ISL_BASIC_SET_FINAL), return NULL);
-	return isl_basic_map_copy(bmap);
-}
-
-struct isl_basic_set *isl_set_copy_basic_set(struct isl_set *set)
-{
-	return (struct isl_basic_set *)
-		isl_map_copy_basic_map((struct isl_map *)set);
-}
-
-__isl_give isl_map *isl_map_drop_basic_map(__isl_take isl_map *map,
-						__isl_keep isl_basic_map *bmap)
-{
-	int i;
-
-	if (!map || !bmap)
-		goto error;
-	for (i = map->n-1; i >= 0; --i) {
-		if (map->p[i] != bmap)
-			continue;
-		map = isl_map_cow(map);
-		if (!map)
-			goto error;
-		isl_basic_map_free(map->p[i]);
-		if (i != map->n-1) {
-			ISL_F_CLR(map, ISL_SET_NORMALIZED);
-			map->p[i] = map->p[map->n-1];
-		}
-		map->n--;
-		return map;
-	}
-	return map;
-error:
-	isl_map_free(map);
-	return NULL;
-}
-
-struct isl_set *isl_set_drop_basic_set(struct isl_set *set,
-						struct isl_basic_set *bset)
-{
-	return (struct isl_set *)isl_map_drop_basic_map((struct isl_map *)set,
-						(struct isl_basic_map *)bset);
+	return set_from_map(isl_map_remove_empty_parts(set_to_map(set)));
 }
 
 /* Given two basic sets bset1 and bset2, compute the maximal difference
@@ -8545,14 +9106,13 @@ static enum isl_lp_result basic_set_maximal_difference_at(
 	__isl_keep isl_basic_set *bset1, __isl_keep isl_basic_set *bset2,
 	int pos, isl_int *opt)
 {
-	isl_space *dims;
-	struct isl_basic_map *bmap1 = NULL;
-	struct isl_basic_map *bmap2 = NULL;
+	isl_basic_map *bmap1;
+	isl_basic_map *bmap2;
 	struct isl_ctx *ctx;
 	struct isl_vec *obj;
 	unsigned total;
 	unsigned nparam;
-	unsigned dim1, dim2;
+	unsigned dim1;
 	enum isl_lp_result res;
 
 	if (!bset1 || !bset2)
@@ -8560,25 +9120,22 @@ static enum isl_lp_result basic_set_maximal_difference_at(
 
 	nparam = isl_basic_set_n_param(bset1);
 	dim1 = isl_basic_set_n_dim(bset1);
-	dim2 = isl_basic_set_n_dim(bset2);
-	dims = isl_space_alloc(bset1->ctx, nparam, pos, dim1 - pos);
-	bmap1 = isl_basic_map_from_basic_set(isl_basic_set_copy(bset1), dims);
-	dims = isl_space_alloc(bset2->ctx, nparam, pos, dim2 - pos);
-	bmap2 = isl_basic_map_from_basic_set(isl_basic_set_copy(bset2), dims);
-	if (!bmap1 || !bmap2)
-		goto error;
-	bmap1 = isl_basic_map_cow(bmap1);
-	bmap1 = isl_basic_map_extend(bmap1, nparam,
-			pos, (dim1 - pos) + (dim2 - pos),
-			bmap2->n_div, bmap2->n_eq, bmap2->n_ineq);
-	bmap1 = add_constraints(bmap1, bmap2, 0, dim1 - pos);
+
+	bmap1 = isl_basic_map_from_range(isl_basic_set_copy(bset1));
+	bmap2 = isl_basic_map_from_range(isl_basic_set_copy(bset2));
+	bmap1 = isl_basic_map_move_dims(bmap1, isl_dim_in, 0,
+					isl_dim_out, 0, pos);
+	bmap2 = isl_basic_map_move_dims(bmap2, isl_dim_in, 0,
+					isl_dim_out, 0, pos);
+	bmap1 = isl_basic_map_range_product(bmap1, bmap2);
 	if (!bmap1)
-		goto error2;
+		return isl_lp_error;
+
 	total = isl_basic_map_total_dim(bmap1);
 	ctx = bmap1->ctx;
 	obj = isl_vec_alloc(ctx, 1 + total);
 	if (!obj)
-		goto error2;
+		goto error;
 	isl_seq_clr(obj->block.data, 1 + total);
 	isl_int_set_si(obj->block.data[1+nparam+pos], 1);
 	isl_int_set_si(obj->block.data[1+nparam+pos+(dim1-pos)], -1);
@@ -8588,8 +9145,6 @@ static enum isl_lp_result basic_set_maximal_difference_at(
 	isl_vec_free(obj);
 	return res;
 error:
-	isl_basic_map_free(bmap2);
-error2:
 	isl_basic_map_free(bmap1);
 	return isl_lp_error;
 }
@@ -8701,15 +9256,15 @@ int isl_set_follows_at(__isl_keep isl_set *set1,
 	return follows;
 }
 
-static int isl_basic_map_plain_has_fixed_var(__isl_keep isl_basic_map *bmap,
-	unsigned pos, isl_int *val)
+static isl_bool isl_basic_map_plain_has_fixed_var(
+	__isl_keep isl_basic_map *bmap, unsigned pos, isl_int *val)
 {
 	int i;
 	int d;
 	unsigned total;
 
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	total = isl_basic_map_total_dim(bmap);
 	for (i = 0, d = total-1; i < bmap->n_eq && d+1 > pos; ++i) {
 		for (; d+1 > pos; --d)
@@ -8718,39 +9273,39 @@ static int isl_basic_map_plain_has_fixed_var(__isl_keep isl_basic_map *bmap,
 		if (d != pos)
 			continue;
 		if (isl_seq_first_non_zero(bmap->eq[i]+1, d) != -1)
-			return 0;
+			return isl_bool_false;
 		if (isl_seq_first_non_zero(bmap->eq[i]+1+d+1, total-d-1) != -1)
-			return 0;
+			return isl_bool_false;
 		if (!isl_int_is_one(bmap->eq[i][1+d]))
-			return 0;
+			return isl_bool_false;
 		if (val)
 			isl_int_neg(*val, bmap->eq[i][0]);
-		return 1;
+		return isl_bool_true;
 	}
-	return 0;
+	return isl_bool_false;
 }
 
-static int isl_map_plain_has_fixed_var(__isl_keep isl_map *map,
+static isl_bool isl_map_plain_has_fixed_var(__isl_keep isl_map *map,
 	unsigned pos, isl_int *val)
 {
 	int i;
 	isl_int v;
 	isl_int tmp;
-	int fixed;
+	isl_bool fixed;
 
 	if (!map)
-		return -1;
+		return isl_bool_error;
 	if (map->n == 0)
-		return 0;
+		return isl_bool_false;
 	if (map->n == 1)
 		return isl_basic_map_plain_has_fixed_var(map->p[0], pos, val); 
 	isl_int_init(v);
 	isl_int_init(tmp);
 	fixed = isl_basic_map_plain_has_fixed_var(map->p[0], pos, &v); 
-	for (i = 1; fixed == 1 && i < map->n; ++i) {
+	for (i = 1; fixed == isl_bool_true && i < map->n; ++i) {
 		fixed = isl_basic_map_plain_has_fixed_var(map->p[i], pos, &tmp); 
-		if (fixed == 1 && isl_int_ne(tmp, v))
-			fixed = 0;
+		if (fixed == isl_bool_true && isl_int_ne(tmp, v))
+			fixed = isl_bool_false;
 	}
 	if (val)
 		isl_int_set(*val, v);
@@ -8759,24 +9314,18 @@ static int isl_map_plain_has_fixed_var(__isl_keep isl_map *map,
 	return fixed;
 }
 
-static int isl_basic_set_plain_has_fixed_var(__isl_keep isl_basic_set *bset,
-	unsigned pos, isl_int *val)
+static isl_bool isl_basic_set_plain_has_fixed_var(
+	__isl_keep isl_basic_set *bset, unsigned pos, isl_int *val)
 {
-	return isl_basic_map_plain_has_fixed_var((struct isl_basic_map *)bset,
+	return isl_basic_map_plain_has_fixed_var(bset_to_bmap(bset),
 						pos, val);
 }
 
-static int isl_set_plain_has_fixed_var(__isl_keep isl_set *set, unsigned pos,
-	isl_int *val)
-{
-	return isl_map_plain_has_fixed_var((struct isl_map *)set, pos, val);
-}
-
-int isl_basic_map_plain_is_fixed(__isl_keep isl_basic_map *bmap,
+isl_bool isl_basic_map_plain_is_fixed(__isl_keep isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned pos, isl_int *val)
 {
-	if (pos >= isl_basic_map_dim(bmap, type))
-		return -1;
+	if (isl_basic_map_check_range(bmap, type, pos, 1) < 0)
+		return isl_bool_error;
 	return isl_basic_map_plain_has_fixed_var(bmap,
 		isl_basic_map_offset(bmap, type) - 1 + pos, val);
 }
@@ -8791,7 +9340,7 @@ __isl_give isl_val *isl_basic_map_plain_get_val_if_fixed(
 {
 	isl_ctx *ctx;
 	isl_val *v;
-	int fixed;
+	isl_bool fixed;
 
 	if (!bmap)
 		return NULL;
@@ -8810,11 +9359,12 @@ __isl_give isl_val *isl_basic_map_plain_get_val_if_fixed(
 	return isl_val_nan(ctx);
 }
 
-int isl_map_plain_is_fixed(__isl_keep isl_map *map,
+isl_bool isl_map_plain_is_fixed(__isl_keep isl_map *map,
 	enum isl_dim_type type, unsigned pos, isl_int *val)
 {
 	if (pos >= isl_map_dim(map, type))
-		return -1;
+		isl_die(isl_map_get_ctx(map), isl_error_invalid,
+			"position out of bounds", return isl_bool_error);
 	return isl_map_plain_has_fixed_var(map,
 		map_offset(map, type) - 1 + pos, val);
 }
@@ -8828,7 +9378,7 @@ __isl_give isl_val *isl_map_plain_get_val_if_fixed(__isl_keep isl_map *map,
 {
 	isl_ctx *ctx;
 	isl_val *v;
-	int fixed;
+	isl_bool fixed;
 
 	if (!map)
 		return NULL;
@@ -8857,7 +9407,7 @@ __isl_give isl_val *isl_set_plain_get_val_if_fixed(__isl_keep isl_set *set,
 	return isl_map_plain_get_val_if_fixed(set, type, pos);
 }
 
-int isl_set_plain_is_fixed(__isl_keep isl_set *set,
+isl_bool isl_set_plain_is_fixed(__isl_keep isl_set *set,
 	enum isl_dim_type type, unsigned pos, isl_int *val)
 {
 	return isl_map_plain_is_fixed(set, type, pos, val);
@@ -8866,108 +9416,13 @@ int isl_set_plain_is_fixed(__isl_keep isl_set *set,
 /* Check if dimension dim has fixed value and if so and if val is not NULL,
  * then return this fixed value in *val.
  */
-int isl_basic_set_plain_dim_is_fixed(__isl_keep isl_basic_set *bset,
+isl_bool isl_basic_set_plain_dim_is_fixed(__isl_keep isl_basic_set *bset,
 	unsigned dim, isl_int *val)
 {
 	return isl_basic_set_plain_has_fixed_var(bset,
 					isl_basic_set_n_param(bset) + dim, val);
 }
 
-/* Check if dimension dim has fixed value and if so and if val is not NULL,
- * then return this fixed value in *val.
- */
-int isl_set_plain_dim_is_fixed(__isl_keep isl_set *set,
-	unsigned dim, isl_int *val)
-{
-	return isl_set_plain_has_fixed_var(set, isl_set_n_param(set) + dim, val);
-}
-
-/* Check if input variable in has fixed value and if so and if val is not NULL,
- * then return this fixed value in *val.
- */
-int isl_map_plain_input_is_fixed(__isl_keep isl_map *map,
-	unsigned in, isl_int *val)
-{
-	return isl_map_plain_has_fixed_var(map, isl_map_n_param(map) + in, val);
-}
-
-/* Check if dimension dim has an (obvious) fixed lower bound and if so
- * and if val is not NULL, then return this lower bound in *val.
- */
-int isl_basic_set_plain_dim_has_fixed_lower_bound(
-	__isl_keep isl_basic_set *bset, unsigned dim, isl_int *val)
-{
-	int i, i_eq = -1, i_ineq = -1;
-	isl_int *c;
-	unsigned total;
-	unsigned nparam;
-
-	if (!bset)
-		return -1;
-	total = isl_basic_set_total_dim(bset);
-	nparam = isl_basic_set_n_param(bset);
-	for (i = 0; i < bset->n_eq; ++i) {
-		if (isl_int_is_zero(bset->eq[i][1+nparam+dim]))
-			continue;
-		if (i_eq != -1)
-			return 0;
-		i_eq = i;
-	}
-	for (i = 0; i < bset->n_ineq; ++i) {
-		if (!isl_int_is_pos(bset->ineq[i][1+nparam+dim]))
-			continue;
-		if (i_eq != -1 || i_ineq != -1)
-			return 0;
-		i_ineq = i;
-	}
-	if (i_eq == -1 && i_ineq == -1)
-		return 0;
-	c = i_eq != -1 ? bset->eq[i_eq] : bset->ineq[i_ineq];
-	/* The coefficient should always be one due to normalization. */
-	if (!isl_int_is_one(c[1+nparam+dim]))
-		return 0;
-	if (isl_seq_first_non_zero(c+1, nparam+dim) != -1)
-		return 0;
-	if (isl_seq_first_non_zero(c+1+nparam+dim+1,
-					total - nparam - dim - 1) != -1)
-		return 0;
-	if (val)
-		isl_int_neg(*val, c[0]);
-	return 1;
-}
-
-int isl_set_plain_dim_has_fixed_lower_bound(__isl_keep isl_set *set,
-	unsigned dim, isl_int *val)
-{
-	int i;
-	isl_int v;
-	isl_int tmp;
-	int fixed;
-
-	if (!set)
-		return -1;
-	if (set->n == 0)
-		return 0;
-	if (set->n == 1)
-		return isl_basic_set_plain_dim_has_fixed_lower_bound(set->p[0],
-								dim, val);
-	isl_int_init(v);
-	isl_int_init(tmp);
-	fixed = isl_basic_set_plain_dim_has_fixed_lower_bound(set->p[0],
-								dim, &v);
-	for (i = 1; fixed == 1 && i < set->n; ++i) {
-		fixed = isl_basic_set_plain_dim_has_fixed_lower_bound(set->p[i],
-								dim, &tmp);
-		if (fixed == 1 && isl_int_ne(tmp, v))
-			fixed = 0;
-	}
-	if (val)
-		isl_int_set(*val, v);
-	isl_int_clear(tmp);
-	isl_int_clear(v);
-	return fixed;
-}
-
 /* Return -1 if the constraint "c1" should be sorted before "c2"
  * and 1 if it should be sorted after "c2".
  * Return 0 if the two constraints are the same (up to the constant term).
@@ -9046,11 +9501,12 @@ __isl_give isl_basic_map *isl_basic_map_sort_constraints(
 __isl_give isl_basic_set *isl_basic_set_sort_constraints(
 	__isl_take isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)isl_basic_map_sort_constraints(
-						(struct isl_basic_map *)bset);
+	isl_basic_map *bmap = bset_to_bmap(bset);
+	return bset_from_bmap(isl_basic_map_sort_constraints(bmap));
 }
 
-struct isl_basic_map *isl_basic_map_normalize(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_normalize(
+	__isl_take isl_basic_map *bmap)
 {
 	if (!bmap)
 		return NULL;
@@ -9062,33 +9518,26 @@ struct isl_basic_map *isl_basic_map_normalize(struct isl_basic_map *bmap)
 		ISL_F_SET(bmap, ISL_BASIC_MAP_NORMALIZED);
 	return bmap;
 }
-
-struct isl_basic_set *isl_basic_set_normalize(struct isl_basic_set *bset)
-{
-	return (struct isl_basic_set *)isl_basic_map_normalize(
-						(struct isl_basic_map *)bset);
-}
-
-int isl_basic_map_plain_cmp(const __isl_keep isl_basic_map *bmap1,
-	const __isl_keep isl_basic_map *bmap2)
+int isl_basic_map_plain_cmp(__isl_keep isl_basic_map *bmap1,
+	__isl_keep isl_basic_map *bmap2)
 {
 	int i, cmp;
 	unsigned total;
+	isl_space *space1, *space2;
 
 	if (!bmap1 || !bmap2)
 		return -1;
 
 	if (bmap1 == bmap2)
 		return 0;
+	space1 = isl_basic_map_peek_space(bmap1);
+	space2 = isl_basic_map_peek_space(bmap2);
+	cmp = isl_space_cmp(space1, space2);
+	if (cmp)
+		return cmp;
 	if (ISL_F_ISSET(bmap1, ISL_BASIC_MAP_RATIONAL) !=
 	    ISL_F_ISSET(bmap2, ISL_BASIC_MAP_RATIONAL))
 		return ISL_F_ISSET(bmap1, ISL_BASIC_MAP_RATIONAL) ? -1 : 1;
-	if (isl_basic_map_n_param(bmap1) != isl_basic_map_n_param(bmap2))
-		return isl_basic_map_n_param(bmap1) - isl_basic_map_n_param(bmap2);
-	if (isl_basic_map_n_in(bmap1) != isl_basic_map_n_in(bmap2))
-		return isl_basic_map_n_out(bmap1) - isl_basic_map_n_out(bmap2);
-	if (isl_basic_map_n_out(bmap1) != isl_basic_map_n_out(bmap2))
-		return isl_basic_map_n_out(bmap1) - isl_basic_map_n_out(bmap2);
 	if (ISL_F_ISSET(bmap1, ISL_BASIC_MAP_EMPTY) &&
 	    ISL_F_ISSET(bmap2, ISL_BASIC_MAP_EMPTY))
 		return 0;
@@ -9121,8 +9570,8 @@ int isl_basic_map_plain_cmp(const __isl_keep isl_basic_map *bmap1,
 	return 0;
 }
 
-int isl_basic_set_plain_cmp(const __isl_keep isl_basic_set *bset1,
-	const __isl_keep isl_basic_set *bset2)
+int isl_basic_set_plain_cmp(__isl_keep isl_basic_set *bset1,
+	__isl_keep isl_basic_set *bset2)
 {
 	return isl_basic_map_plain_cmp(bset1, bset2);
 }
@@ -9156,14 +9605,14 @@ isl_bool isl_basic_map_plain_is_equal(__isl_keep isl_basic_map *bmap1,
 isl_bool isl_basic_set_plain_is_equal(__isl_keep isl_basic_set *bset1,
 	__isl_keep isl_basic_set *bset2)
 {
-	return isl_basic_map_plain_is_equal((isl_basic_map *)bset1,
-					    (isl_basic_map *)bset2);
+	return isl_basic_map_plain_is_equal(bset_to_bmap(bset1),
+					    bset_to_bmap(bset2));
 }
 
 static int qsort_bmap_cmp(const void *p1, const void *p2)
 {
-	const struct isl_basic_map *bmap1 = *(const struct isl_basic_map **)p1;
-	const struct isl_basic_map *bmap2 = *(const struct isl_basic_map **)p2;
+	isl_basic_map *bmap1 = *(isl_basic_map **) p1;
+	isl_basic_map *bmap2 = *(isl_basic_map **) p2;
 
 	return isl_basic_map_plain_cmp(bmap1, bmap2);
 }
@@ -9260,7 +9709,7 @@ error:
 
 struct isl_set *isl_set_normalize(struct isl_set *set)
 {
-	return (struct isl_set *)isl_map_normalize((struct isl_map *)set);
+	return set_from_map(isl_map_normalize(set_to_map(set)));
 }
 
 isl_bool isl_map_plain_is_equal(__isl_keep isl_map *map1,
@@ -9301,38 +9750,7 @@ error:
 isl_bool isl_set_plain_is_equal(__isl_keep isl_set *set1,
 	__isl_keep isl_set *set2)
 {
-	return isl_map_plain_is_equal((struct isl_map *)set1,
-						(struct isl_map *)set2);
-}
-
-/* Return an interval that ranges from min to max (inclusive)
- */
-struct isl_basic_set *isl_basic_set_interval(struct isl_ctx *ctx,
-	isl_int min, isl_int max)
-{
-	int k;
-	struct isl_basic_set *bset = NULL;
-
-	bset = isl_basic_set_alloc(ctx, 0, 1, 0, 0, 2);
-	if (!bset)
-		goto error;
-
-	k = isl_basic_set_alloc_inequality(bset);
-	if (k < 0)
-		goto error;
-	isl_int_set_si(bset->ineq[k][1], 1);
-	isl_int_neg(bset->ineq[k][0], min);
-
-	k = isl_basic_set_alloc_inequality(bset);
-	if (k < 0)
-		goto error;
-	isl_int_set_si(bset->ineq[k][1], -1);
-	isl_int_set(bset->ineq[k][0], max);
-
-	return bset;
-error:
-	isl_basic_set_free(bset);
-	return NULL;
+	return isl_map_plain_is_equal(set_to_map(set1), set_to_map(set2));
 }
 
 /* Return the basic maps in "map" as a list.
@@ -9399,6 +9817,41 @@ __isl_give isl_basic_set *isl_basic_set_list_intersect(
 	return isl_basic_map_list_intersect(list);
 }
 
+/* Return the union of the elements of "list".
+ * The list is required to have at least one element.
+ */
+__isl_give isl_set *isl_basic_set_list_union(
+	__isl_take isl_basic_set_list *list)
+{
+	int i, n;
+	isl_space *space;
+	isl_basic_set *bset;
+	isl_set *set;
+
+	if (!list)
+		return NULL;
+	n = isl_basic_set_list_n_basic_set(list);
+	if (n < 1)
+		isl_die(isl_basic_set_list_get_ctx(list), isl_error_invalid,
+			"expecting non-empty list", goto error);
+
+	bset = isl_basic_set_list_get_basic_set(list, 0);
+	space = isl_basic_set_get_space(bset);
+	isl_basic_set_free(bset);
+
+	set = isl_set_alloc_space(space, n, 0);
+	for (i = 0; i < n; ++i) {
+		bset = isl_basic_set_list_get_basic_set(list, i);
+		set = isl_set_add_basic_set(set, bset);
+	}
+
+	isl_basic_set_list_free(list);
+	return set;
+error:
+	isl_basic_set_list_free(list);
+	return NULL;
+}
+
 /* Return the union of the elements in the non-empty list "list".
  * All elements are assumed to live in the same space.
  */
@@ -9429,76 +9882,24 @@ error:
 	return NULL;
 }
 
-/* Return the Cartesian product of the basic sets in list (in the given order).
- */
-__isl_give isl_basic_set *isl_basic_set_list_product(
-	__isl_take struct isl_basic_set_list *list)
-{
-	int i;
-	unsigned dim;
-	unsigned nparam;
-	unsigned extra;
-	unsigned n_eq;
-	unsigned n_ineq;
-	struct isl_basic_set *product = NULL;
-
-	if (!list)
-		goto error;
-	isl_assert(list->ctx, list->n > 0, goto error);
-	isl_assert(list->ctx, list->p[0], goto error);
-	nparam = isl_basic_set_n_param(list->p[0]);
-	dim = isl_basic_set_n_dim(list->p[0]);
-	extra = list->p[0]->n_div;
-	n_eq = list->p[0]->n_eq;
-	n_ineq = list->p[0]->n_ineq;
-	for (i = 1; i < list->n; ++i) {
-		isl_assert(list->ctx, list->p[i], goto error);
-		isl_assert(list->ctx,
-		    nparam == isl_basic_set_n_param(list->p[i]), goto error);
-		dim += isl_basic_set_n_dim(list->p[i]);
-		extra += list->p[i]->n_div;
-		n_eq += list->p[i]->n_eq;
-		n_ineq += list->p[i]->n_ineq;
-	}
-	product = isl_basic_set_alloc(list->ctx, nparam, dim, extra,
-					n_eq, n_ineq);
-	if (!product)
-		goto error;
-	dim = 0;
-	for (i = 0; i < list->n; ++i) {
-		isl_basic_set_add_constraints(product,
-					isl_basic_set_copy(list->p[i]), dim);
-		dim += isl_basic_set_n_dim(list->p[i]);
-	}
-	isl_basic_set_list_free(list);
-	return product;
-error:
-	isl_basic_set_free(product);
-	isl_basic_set_list_free(list);
-	return NULL;
-}
-
-struct isl_basic_map *isl_basic_map_product(
-		struct isl_basic_map *bmap1, struct isl_basic_map *bmap2)
+__isl_give isl_basic_map *isl_basic_map_product(
+	__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)
 {
 	isl_space *dim_result = NULL;
 	struct isl_basic_map *bmap;
 	unsigned in1, in2, out1, out2, nparam, total, pos;
 	struct isl_dim_map *dim_map1, *dim_map2;
 
-	if (!bmap1 || !bmap2)
-		goto error;
-
-	isl_assert(bmap1->ctx, isl_space_match(bmap1->dim, isl_dim_param,
-				     bmap2->dim, isl_dim_param), goto error);
+	if (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)
+		goto error;
 	dim_result = isl_space_product(isl_space_copy(bmap1->dim),
 						   isl_space_copy(bmap2->dim));
 
-	in1 = isl_basic_map_n_in(bmap1);
-	in2 = isl_basic_map_n_in(bmap2);
-	out1 = isl_basic_map_n_out(bmap1);
-	out2 = isl_basic_map_n_out(bmap2);
-	nparam = isl_basic_map_n_param(bmap1);
+	in1 = isl_basic_map_dim(bmap1, isl_dim_in);
+	in2 = isl_basic_map_dim(bmap2, isl_dim_in);
+	out1 = isl_basic_map_dim(bmap1, isl_dim_out);
+	out2 = isl_basic_map_dim(bmap2, isl_dim_out);
+	nparam = isl_basic_map_dim(bmap1, isl_dim_param);
 
 	total = nparam + in1 + in2 + out1 + out2 + bmap1->n_div + bmap2->n_div;
 	dim_map1 = isl_dim_map_alloc(bmap1->ctx, total);
@@ -9590,26 +9991,28 @@ error:
 __isl_give isl_basic_map *isl_basic_map_range_product(
 	__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)
 {
+	isl_bool rational;
 	isl_space *dim_result = NULL;
 	isl_basic_map *bmap;
 	unsigned in, out1, out2, nparam, total, pos;
 	struct isl_dim_map *dim_map1, *dim_map2;
 
-	if (!bmap1 || !bmap2)
+	rational = isl_basic_map_is_rational(bmap1);
+	if (rational >= 0 && rational)
+		rational = isl_basic_map_is_rational(bmap2);
+	if (!bmap1 || !bmap2 || rational < 0)
 		goto error;
 
-	if (!isl_space_match(bmap1->dim, isl_dim_param,
-			    bmap2->dim, isl_dim_param))
-		isl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,
-			"parameters don't match", goto error);
+	if (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)
+		goto error;
 
 	dim_result = isl_space_range_product(isl_space_copy(bmap1->dim),
 					   isl_space_copy(bmap2->dim));
 
 	in = isl_basic_map_dim(bmap1, isl_dim_in);
-	out1 = isl_basic_map_n_out(bmap1);
-	out2 = isl_basic_map_n_out(bmap2);
-	nparam = isl_basic_map_n_param(bmap1);
+	out1 = isl_basic_map_dim(bmap1, isl_dim_out);
+	out2 = isl_basic_map_dim(bmap2, isl_dim_out);
+	nparam = isl_basic_map_dim(bmap1, isl_dim_param);
 
 	total = nparam + in + out1 + out2 + bmap1->n_div + bmap2->n_div;
 	dim_map1 = isl_dim_map_alloc(bmap1->ctx, total);
@@ -9629,6 +10032,8 @@ __isl_give isl_basic_map *isl_basic_map_range_product(
 			bmap1->n_ineq + bmap2->n_ineq);
 	bmap = isl_basic_map_add_constraints_dim_map(bmap, bmap1, dim_map1);
 	bmap = isl_basic_map_add_constraints_dim_map(bmap, bmap2, dim_map2);
+	if (rational)
+		bmap = isl_basic_map_set_rational(bmap);
 	bmap = isl_basic_map_simplify(bmap);
 	return isl_basic_map_finalize(bmap);
 error:
@@ -9667,12 +10072,14 @@ static __isl_give isl_map *map_product(__isl_take isl_map *map1,
 	unsigned flags = 0;
 	struct isl_map *result;
 	int i, j;
+	isl_bool m;
 
-	if (!map1 || !map2)
+	m = isl_map_has_equal_params(map1, map2);
+	if (m < 0)
 		goto error;
-
-	isl_assert(map1->ctx, isl_space_match(map1->dim, isl_dim_param,
-					 map2->dim, isl_dim_param), goto error);
+	if (!m)
+		isl_die(isl_map_get_ctx(map1), isl_error_invalid,
+			"parameters don't match", goto error);
 
 	if (ISL_F_ISSET(map1, ISL_MAP_DISJOINT) &&
 	    ISL_F_ISSET(map2, ISL_MAP_DISJOINT))
@@ -9988,7 +10395,7 @@ uint32_t isl_basic_map_get_hash(__isl_keep isl_basic_map *bmap)
 
 uint32_t isl_basic_set_get_hash(__isl_keep isl_basic_set *bset)
 {
-	return isl_basic_map_get_hash((isl_basic_map *)bset);
+	return isl_basic_map_get_hash(bset_to_bmap(bset));
 }
 
 uint32_t isl_map_get_hash(__isl_keep isl_map *map)
@@ -10017,45 +10424,7 @@ uint32_t isl_map_get_hash(__isl_keep isl_map *map)
 
 uint32_t isl_set_get_hash(__isl_keep isl_set *set)
 {
-	return isl_map_get_hash((isl_map *)set);
-}
-
-/* Check if the value for dimension dim is completely determined
- * by the values of the other parameters and variables.
- * That is, check if dimension dim is involved in an equality.
- */
-int isl_basic_set_dim_is_unique(struct isl_basic_set *bset, unsigned dim)
-{
-	int i;
-	unsigned nparam;
-
-	if (!bset)
-		return -1;
-	nparam = isl_basic_set_n_param(bset);
-	for (i = 0; i < bset->n_eq; ++i)
-		if (!isl_int_is_zero(bset->eq[i][1 + nparam + dim]))
-			return 1;
-	return 0;
-}
-
-/* Check if the value for dimension dim is completely determined
- * by the values of the other parameters and variables.
- * That is, check if dimension dim is involved in an equality
- * for each of the subsets.
- */
-int isl_set_dim_is_unique(struct isl_set *set, unsigned dim)
-{
-	int i;
-
-	if (!set)
-		return -1;
-	for (i = 0; i < set->n; ++i) {
-		int unique;
-		unique = isl_basic_set_dim_is_unique(set->p[i], dim);
-		if (unique != 1)
-			return unique;
-	}
-	return 1;
+	return isl_map_get_hash(set_to_map(set));
 }
 
 /* Return the number of basic maps in the (current) representation of "map".
@@ -10156,7 +10525,7 @@ __isl_give isl_set *isl_set_lift(__isl_take isl_set *set)
 	isl_space *dim;
 	unsigned n_div;
 
-	set = isl_set_align_divs(set);
+	set = set_from_map(isl_map_align_divs_internal(set_to_map(set)));
 
 	if (!set)
 		return NULL;
@@ -10185,67 +10554,6 @@ error:
 	return NULL;
 }
 
-__isl_give isl_map *isl_set_lifting(__isl_take isl_set *set)
-{
-	isl_space *dim;
-	struct isl_basic_map *bmap;
-	unsigned n_set;
-	unsigned n_div;
-	unsigned n_param;
-	unsigned total;
-	int i, k, l;
-
-	set = isl_set_align_divs(set);
-
-	if (!set)
-		return NULL;
-
-	dim = isl_set_get_space(set);
-	if (set->n == 0 || set->p[0]->n_div == 0) {
-		isl_set_free(set);
-		return isl_map_identity(isl_space_map_from_set(dim));
-	}
-
-	n_div = set->p[0]->n_div;
-	dim = isl_space_map_from_set(dim);
-	n_param = isl_space_dim(dim, isl_dim_param);
-	n_set = isl_space_dim(dim, isl_dim_in);
-	dim = isl_space_extend(dim, n_param, n_set, n_set + n_div);
-	bmap = isl_basic_map_alloc_space(dim, 0, n_set, 2 * n_div);
-	for (i = 0; i < n_set; ++i)
-		bmap = var_equal(bmap, i);
-
-	total = n_param + n_set + n_set + n_div;
-	for (i = 0; i < n_div; ++i) {
-		k = isl_basic_map_alloc_inequality(bmap);
-		if (k < 0)
-			goto error;
-		isl_seq_cpy(bmap->ineq[k], set->p[0]->div[i]+1, 1+n_param);
-		isl_seq_clr(bmap->ineq[k]+1+n_param, n_set);
-		isl_seq_cpy(bmap->ineq[k]+1+n_param+n_set,
-			    set->p[0]->div[i]+1+1+n_param, n_set + n_div);
-		isl_int_neg(bmap->ineq[k][1+n_param+n_set+n_set+i],
-			    set->p[0]->div[i][0]);
-
-		l = isl_basic_map_alloc_inequality(bmap);
-		if (l < 0)
-			goto error;
-		isl_seq_neg(bmap->ineq[l], bmap->ineq[k], 1 + total);
-		isl_int_add(bmap->ineq[l][0], bmap->ineq[l][0],
-			    set->p[0]->div[i][0]);
-		isl_int_sub_ui(bmap->ineq[l][0], bmap->ineq[l][0], 1);
-	}
-
-	isl_set_free(set);
-	bmap = isl_basic_map_simplify(bmap);
-	bmap = isl_basic_map_finalize(bmap);
-	return isl_map_from_basic_map(bmap);
-error:
-	isl_set_free(set);
-	isl_basic_map_free(bmap);
-	return NULL;
-}
-
 int isl_basic_set_size(__isl_keep isl_basic_set *bset)
 {
 	unsigned dim;
@@ -10284,12 +10592,9 @@ static isl_bool basic_map_dim_is_bounded(__isl_keep isl_basic_map *bmap,
 {
 	int i;
 
-	if (!bmap)
+	if (isl_basic_map_check_range(bmap, type, pos, 1) < 0)
 		return isl_bool_error;
 
-	isl_assert(bmap->ctx, pos < isl_basic_map_dim(bmap, type),
-		return isl_bool_error);
-
 	pos += isl_basic_map_offset(bmap, type);
 
 	for (i = 0; i < bmap->n_div; ++i) {
@@ -10314,7 +10619,7 @@ static isl_bool basic_map_dim_is_bounded(__isl_keep isl_basic_map *bmap,
 	return lower && upper;
 }
 
-int isl_basic_map_dim_is_bounded(__isl_keep isl_basic_map *bmap,
+isl_bool isl_basic_map_dim_is_bounded(__isl_keep isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned pos)
 {
 	return basic_map_dim_is_bounded(bmap, type, pos, 0, 0);
@@ -10332,31 +10637,31 @@ isl_bool isl_basic_map_dim_has_upper_bound(__isl_keep isl_basic_map *bmap,
 	return basic_map_dim_is_bounded(bmap, type, pos, 1, 0);
 }
 
-int isl_map_dim_is_bounded(__isl_keep isl_map *map,
+isl_bool isl_map_dim_is_bounded(__isl_keep isl_map *map,
 	enum isl_dim_type type, unsigned pos)
 {
 	int i;
 
 	if (!map)
-		return -1;
+		return isl_bool_error;
 
 	for (i = 0; i < map->n; ++i) {
-		int bounded;
+		isl_bool bounded;
 		bounded = isl_basic_map_dim_is_bounded(map->p[i], type, pos);
 		if (bounded < 0 || !bounded)
 			return bounded;
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
-/* Return 1 if the specified dim is involved in both an upper bound
+/* Return true if the specified dim is involved in both an upper bound
  * and a lower bound.
  */
-int isl_set_dim_is_bounded(__isl_keep isl_set *set,
+isl_bool isl_set_dim_is_bounded(__isl_keep isl_set *set,
 	enum isl_dim_type type, unsigned pos)
 {
-	return isl_map_dim_is_bounded((isl_map *)set, type, pos);
+	return isl_map_dim_is_bounded(set_to_map(set), type, pos);
 }
 
 /* Does "map" have a bound (according to "fn") for any of its basic maps?
@@ -10445,7 +10750,7 @@ isl_bool isl_set_dim_has_upper_bound(__isl_keep isl_set *set,
  *	-1 means that the variable is non-positive
  *	0 means the variable attains both positive and negative values.
  */
-int isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,
+isl_stat isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,
 	unsigned first, unsigned n, int *signs)
 {
 	isl_vec *bound = NULL;
@@ -10454,7 +10759,7 @@ int isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,
 	int i;
 
 	if (!bset || !signs)
-		return -1;
+		return isl_stat_error;
 
 	bound = isl_vec_alloc(bset->ctx, 1 + isl_basic_set_total_dim(bset));
 	tab = isl_tab_from_basic_set(bset, 0);
@@ -10494,20 +10799,20 @@ int isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,
 
 	isl_tab_free(tab);
 	isl_vec_free(bound);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_tab_free(tab);
 	isl_vec_free(bound);
-	return -1;
+	return isl_stat_error;
 }
 
-int isl_basic_set_dims_get_sign(__isl_keep isl_basic_set *bset,
+isl_stat isl_basic_set_dims_get_sign(__isl_keep isl_basic_set *bset,
 	enum isl_dim_type type, unsigned first, unsigned n, int *signs)
 {
 	if (!bset || !signs)
-		return -1;
+		return isl_stat_error;
 	isl_assert(bset->ctx, first + n <= isl_basic_set_dim(bset, type),
-		return -1);
+		return isl_stat_error);
 
 	first += pos(bset->dim, type) - 1;
 	return isl_basic_set_vars_get_sign(bset, first, n, signs);
@@ -10521,32 +10826,35 @@ int isl_basic_set_dims_get_sign(__isl_keep isl_basic_set *bset,
  * Otherwise, we check if it actually depends on them or on any integer
  * divisions that may depend on them.
  */
-static int div_may_involve_output(__isl_keep isl_basic_map *bmap, int div)
+static isl_bool div_may_involve_output(__isl_keep isl_basic_map *bmap, int div)
 {
 	int i;
 	unsigned n_out, o_out;
 	unsigned n_div, o_div;
 
 	if (isl_int_is_zero(bmap->div[div][0]))
-		return 1;
+		return isl_bool_true;
 
 	n_out = isl_basic_map_dim(bmap, isl_dim_out);
 	o_out = isl_basic_map_offset(bmap, isl_dim_out);
 
 	if (isl_seq_first_non_zero(bmap->div[div] + 1 + o_out, n_out) != -1)
-		return 1;
+		return isl_bool_true;
 
 	n_div = isl_basic_map_dim(bmap, isl_dim_div);
 	o_div = isl_basic_map_offset(bmap, isl_dim_div);
 
 	for (i = 0; i < n_div; ++i) {
+		isl_bool may_involve;
+
 		if (isl_int_is_zero(bmap->div[div][1 + o_div + i]))
 			continue;
-		if (div_may_involve_output(bmap, i))
-			return 1;
+		may_involve = div_may_involve_output(bmap, i);
+		if (may_involve < 0 || may_involve)
+			return may_involve;
 	}
 
-	return 0;
+	return isl_bool_false;
 }
 
 /* Return the first integer division of "bmap" in the range
@@ -10563,9 +10871,14 @@ static int first_div_may_involve_output(__isl_keep isl_basic_map *bmap,
 		return -1;
 
 	for (k = first; k < first + n; ++k) {
+		isl_bool may_involve;
+
 		if (isl_int_is_zero(c[k]))
 			continue;
-		if (div_may_involve_output(bmap, k))
+		may_involve = div_may_involve_output(bmap, k);
+		if (may_involve < 0)
+			return -1;
+		if (may_involve)
 			return k;
 	}
 
@@ -10863,7 +11176,7 @@ isl_bool isl_map_is_bijective(__isl_keep isl_map *map)
 
 isl_bool isl_set_is_singleton(__isl_keep isl_set *set)
 {
-	return isl_map_is_single_valued((isl_map *)set);
+	return isl_map_is_single_valued(set_to_map(set));
 }
 
 /* Does "map" only map elements to themselves?
@@ -10913,17 +11226,17 @@ static int unique(isl_int *p, unsigned pos, unsigned len)
 	return 1;
 }
 
-int isl_basic_set_is_box(__isl_keep isl_basic_set *bset)
+isl_bool isl_basic_set_is_box(__isl_keep isl_basic_set *bset)
 {
 	int i, j;
 	unsigned nvar;
 	unsigned ovar;
 
 	if (!bset)
-		return -1;
+		return isl_bool_error;
 
 	if (isl_basic_set_dim(bset, isl_dim_div) != 0)
-		return 0;
+		return isl_bool_false;
 
 	nvar = isl_basic_set_dim(bset, isl_dim_set);
 	ovar = isl_space_offset(bset->dim, isl_dim_set);
@@ -10933,7 +11246,7 @@ int isl_basic_set_is_box(__isl_keep isl_basic_set *bset)
 			if (isl_int_is_zero(bset->eq[i][1 + ovar + j]))
 				continue;
 			if (!unique(bset->eq[i] + 1 + ovar, j, nvar))
-				return 0;
+				return isl_bool_false;
 			break;
 		}
 		if (i < bset->n_eq)
@@ -10942,25 +11255,25 @@ int isl_basic_set_is_box(__isl_keep isl_basic_set *bset)
 			if (isl_int_is_zero(bset->ineq[i][1 + ovar + j]))
 				continue;
 			if (!unique(bset->ineq[i] + 1 + ovar, j, nvar))
-				return 0;
+				return isl_bool_false;
 			if (isl_int_is_pos(bset->ineq[i][1 + ovar + j]))
 				lower = 1;
 			else
 				upper = 1;
 		}
 		if (!lower || !upper)
-			return 0;
+			return isl_bool_false;
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
-int isl_set_is_box(__isl_keep isl_set *set)
+isl_bool isl_set_is_box(__isl_keep isl_set *set)
 {
 	if (!set)
-		return -1;
+		return isl_bool_error;
 	if (set->n != 1)
-		return 0;
+		return isl_bool_false;
 
 	return isl_basic_set_is_box(set->p[0]);
 }
@@ -11020,6 +11333,13 @@ isl_bool isl_map_domain_is_wrapping(__isl_keep isl_map *map)
 	return isl_space_domain_is_wrapping(map->dim);
 }
 
+/* Does "map" have a wrapped relation in both domain and range?
+ */
+isl_bool isl_map_is_product(__isl_keep isl_map *map)
+{
+	return isl_space_is_product(isl_map_peek_space(map));
+}
+
 /* Is the range of "map" a wrapped relation?
  */
 isl_bool isl_map_range_is_wrapping(__isl_keep isl_map *map)
@@ -11042,7 +11362,7 @@ __isl_give isl_basic_set *isl_basic_map_wrap(__isl_take isl_basic_map *bmap)
 
 	bmap = isl_basic_map_finalize(bmap);
 
-	return (isl_basic_set *)bmap;
+	return bset_from_bmap(bmap);
 error:
 	isl_basic_map_free(bmap);
 	return NULL;
@@ -11067,7 +11387,7 @@ __isl_give isl_basic_map *isl_basic_set_unwrap(__isl_take isl_basic_set *bset)
 
 	bset = isl_basic_set_finalize(bset);
 
-	return (isl_basic_map *)bset;
+	return bset_to_bmap(bset);
 error:
 	isl_basic_set_free(bset);
 	return NULL;
@@ -11163,7 +11483,7 @@ error:
 
 __isl_give isl_basic_set *isl_basic_set_flatten(__isl_take isl_basic_set *bset)
 {
-	return (isl_basic_set *)isl_basic_map_flatten((isl_basic_map *)bset);
+	return bset_from_bmap(isl_basic_map_flatten(bset_to_bmap(bset)));
 }
 
 __isl_give isl_basic_map *isl_basic_map_flatten_domain(
@@ -11231,7 +11551,7 @@ __isl_give isl_map *isl_map_flatten(__isl_take isl_map *map)
 
 __isl_give isl_set *isl_set_flatten(__isl_take isl_set *set)
 {
-	return (isl_set *)isl_map_flatten((isl_map *)set);
+	return set_from_map(isl_map_flatten(set_to_map(set)));
 }
 
 __isl_give isl_map *isl_set_flatten_map(__isl_take isl_set *set)
@@ -11346,13 +11666,14 @@ error:
 __isl_give isl_set *isl_set_realign(__isl_take isl_set *set,
 	__isl_take isl_reordering *r)
 {
-	return (isl_set *)isl_map_realign((isl_map *)set, r);
+	return set_from_map(isl_map_realign(set_to_map(set), r));
 }
 
 __isl_give isl_map *isl_map_align_params(__isl_take isl_map *map,
 	__isl_take isl_space *model)
 {
 	isl_ctx *ctx;
+	isl_bool aligned;
 
 	if (!map || !model)
 		goto error;
@@ -11361,10 +11682,12 @@ __isl_give isl_map *isl_map_align_params(__isl_take isl_map *map,
 	if (!isl_space_has_named_params(model))
 		isl_die(ctx, isl_error_invalid,
 			"model has unnamed parameters", goto error);
-	if (!isl_space_has_named_params(map->dim))
-		isl_die(ctx, isl_error_invalid,
-			"relation has unnamed parameters", goto error);
-	if (!isl_space_match(map->dim, isl_dim_param, model, isl_dim_param)) {
+	if (isl_map_check_named_params(map) < 0)
+		goto error;
+	aligned = isl_map_space_has_equal_params(map, model);
+	if (aligned < 0)
+		goto error;
+	if (!aligned) {
 		isl_reordering *exp;
 
 		model = isl_space_drop_dims(model, isl_dim_in,
@@ -11397,6 +11720,7 @@ __isl_give isl_basic_map *isl_basic_map_align_params(
 	__isl_take isl_basic_map *bmap, __isl_take isl_space *model)
 {
 	isl_ctx *ctx;
+	isl_bool equal_params;
 
 	if (!bmap || !model)
 		goto error;
@@ -11408,7 +11732,10 @@ __isl_give isl_basic_map *isl_basic_map_align_params(
 	if (!isl_space_has_named_params(bmap->dim))
 		isl_die(ctx, isl_error_invalid,
 			"relation has unnamed parameters", goto error);
-	if (!isl_space_match(bmap->dim, isl_dim_param, model, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(bmap->dim, model);
+	if (equal_params < 0)
+		goto error;
+	if (!equal_params) {
 		isl_reordering *exp;
 		struct isl_dim_map *dim_map;
 
@@ -11435,6 +11762,36 @@ error:
 	return NULL;
 }
 
+/* Do "bset" and "space" have the same parameters?
+ */
+isl_bool isl_basic_set_space_has_equal_params(__isl_keep isl_basic_set *bset,
+	__isl_keep isl_space *space)
+{
+	isl_space *bset_space;
+
+	bset_space = isl_basic_set_peek_space(bset);
+	return isl_space_has_equal_params(bset_space, space);
+}
+
+/* Do "map" and "space" have the same parameters?
+ */
+isl_bool isl_map_space_has_equal_params(__isl_keep isl_map *map,
+	__isl_keep isl_space *space)
+{
+	isl_space *map_space;
+
+	map_space = isl_map_peek_space(map);
+	return isl_space_has_equal_params(map_space, space);
+}
+
+/* Do "set" and "space" have the same parameters?
+ */
+isl_bool isl_set_space_has_equal_params(__isl_keep isl_set *set,
+	__isl_keep isl_space *space)
+{
+	return isl_map_space_has_equal_params(set_to_map(set), space);
+}
+
 /* Align the parameters of "bset" to those of "model", introducing
  * additional parameters if needed.
  */
@@ -11585,7 +11942,7 @@ __isl_give isl_mat *isl_basic_set_equalities_matrix(
 	__isl_keep isl_basic_set *bset, enum isl_dim_type c1,
 	enum isl_dim_type c2, enum isl_dim_type c3, enum isl_dim_type c4)
 {
-	return isl_basic_map_equalities_matrix((isl_basic_map *)bset,
+	return isl_basic_map_equalities_matrix(bset_to_bmap(bset),
 						c1, c2, c3, c4, isl_dim_in);
 }
 
@@ -11593,7 +11950,7 @@ __isl_give isl_mat *isl_basic_set_inequalities_matrix(
 	__isl_keep isl_basic_set *bset, enum isl_dim_type c1,
 	enum isl_dim_type c2, enum isl_dim_type c3, enum isl_dim_type c4)
 {
-	return isl_basic_map_inequalities_matrix((isl_basic_map *)bset,
+	return isl_basic_map_inequalities_matrix(bset_to_bmap(bset),
 						 c1, c2, c3, c4, isl_dim_in);
 }
 
@@ -11602,9 +11959,10 @@ __isl_give isl_basic_set *isl_basic_set_from_constraint_matrices(
 	__isl_take isl_mat *eq, __isl_take isl_mat *ineq, enum isl_dim_type c1,
 	enum isl_dim_type c2, enum isl_dim_type c3, enum isl_dim_type c4)
 {
-	return (isl_basic_set*)
-	    isl_basic_map_from_constraint_matrices(dim, eq, ineq,
+	isl_basic_map *bmap;
+	bmap = isl_basic_map_from_constraint_matrices(dim, eq, ineq,
 						   c1, c2, c3, c4, isl_dim_in);
+	return bset_from_bmap(bmap);
 }
 
 isl_bool isl_basic_map_can_zip(__isl_keep isl_basic_map *bmap)
@@ -11824,10 +12182,12 @@ __isl_give isl_map *isl_map_uncurry(__isl_take isl_map *map)
 
 /* Construct a basic map mapping the domain of the affine expression
  * to a one-dimensional range prescribed by the affine expression.
+ * If "rational" is set, then construct a rational basic map.
  *
  * A NaN affine expression cannot be converted to a basic map.
  */
-__isl_give isl_basic_map *isl_basic_map_from_aff(__isl_take isl_aff *aff)
+static __isl_give isl_basic_map *isl_basic_map_from_aff2(
+	__isl_take isl_aff *aff, int rational)
 {
 	int k;
 	int pos;
@@ -11858,6 +12218,9 @@ __isl_give isl_basic_map *isl_basic_map_from_aff(__isl_take isl_aff *aff)
 		    aff->v->size - (pos + 1));
 
 	isl_aff_free(aff);
+	if (rational)
+		bmap = isl_basic_map_set_rational(bmap);
+	bmap = isl_basic_map_gauss(bmap, NULL);
 	bmap = isl_basic_map_finalize(bmap);
 	return bmap;
 error:
@@ -11866,6 +12229,14 @@ error:
 	return NULL;
 }
 
+/* Construct a basic map mapping the domain of the affine expression
+ * to a one-dimensional range prescribed by the affine expression.
+ */
+__isl_give isl_basic_map *isl_basic_map_from_aff(__isl_take isl_aff *aff)
+{
+	return isl_basic_map_from_aff2(aff, 0);
+}
+
 /* Construct a map mapping the domain of the affine expression
  * to a one-dimensional range prescribed by the affine expression.
  */
@@ -11880,9 +12251,10 @@ __isl_give isl_map *isl_map_from_aff(__isl_take isl_aff *aff)
 /* Construct a basic map mapping the domain the multi-affine expression
  * to its range, with each dimension in the range equated to the
  * corresponding affine expression.
+ * If "rational" is set, then construct a rational basic map.
  */
-__isl_give isl_basic_map *isl_basic_map_from_multi_aff(
-	__isl_take isl_multi_aff *maff)
+__isl_give isl_basic_map *isl_basic_map_from_multi_aff2(
+	__isl_take isl_multi_aff *maff, int rational)
 {
 	int i;
 	isl_space *space;
@@ -11897,13 +12269,15 @@ __isl_give isl_basic_map *isl_basic_map_from_multi_aff(
 
 	space = isl_space_domain(isl_multi_aff_get_space(maff));
 	bmap = isl_basic_map_universe(isl_space_from_domain(space));
+	if (rational)
+		bmap = isl_basic_map_set_rational(bmap);
 
 	for (i = 0; i < maff->n; ++i) {
 		isl_aff *aff;
 		isl_basic_map *bmap_i;
 
 		aff = isl_aff_copy(maff->p[i]);
-		bmap_i = isl_basic_map_from_aff(aff);
+		bmap_i = isl_basic_map_from_aff2(aff, rational);
 
 		bmap = isl_basic_map_flat_range_product(bmap, bmap_i);
 	}
@@ -11917,6 +12291,16 @@ error:
 	return NULL;
 }
 
+/* Construct a basic map mapping the domain the multi-affine expression
+ * to its range, with each dimension in the range equated to the
+ * corresponding affine expression.
+ */
+__isl_give isl_basic_map *isl_basic_map_from_multi_aff(
+	__isl_take isl_multi_aff *ma)
+{
+	return isl_basic_map_from_multi_aff2(ma, 0);
+}
+
 /* Construct a map mapping the domain the multi-affine expression
  * to its range, with each dimension in the range equated to the
  * corresponding affine expression.
@@ -12377,18 +12761,17 @@ error:
 
 /* Check if the range of "ma" is compatible with the domain or range
  * (depending on "type") of "bmap".
- * Return -1 if anything is wrong.
  */
-static int check_basic_map_compatible_range_multi_aff(
+static isl_stat check_basic_map_compatible_range_multi_aff(
 	__isl_keep isl_basic_map *bmap, enum isl_dim_type type,
 	__isl_keep isl_multi_aff *ma)
 {
-	int m;
+	isl_bool m;
 	isl_space *ma_space;
 
 	ma_space = isl_multi_aff_get_space(ma);
 
-	m = isl_space_match(bmap->dim, isl_dim_param, ma_space, isl_dim_param);
+	m = isl_space_has_equal_params(bmap->dim, ma_space);
 	if (m < 0)
 		goto error;
 	if (!m)
@@ -12402,10 +12785,10 @@ static int check_basic_map_compatible_range_multi_aff(
 			"spaces don't match", goto error);
 
 	isl_space_free(ma_space);
-	return m;
+	return isl_stat_ok;
 error:
 	isl_space_free(ma_space);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Copy the divs from "ma" to "bmap", adding zeros for the "n_before"
@@ -12449,7 +12832,7 @@ static int set_ma_divs(__isl_keep isl_basic_map *bmap,
 		o_bmap += n_div;
 		o_ls += n_div;
 		isl_seq_clr(bmap->div[i] + o_bmap, bmap->n_div - n_div);
-		if (isl_basic_set_add_div_constraints(bmap, i) < 0)
+		if (isl_basic_map_add_div_constraints(bmap, i) < 0)
 			goto error;
 	}
 
@@ -12615,7 +12998,8 @@ __isl_give isl_basic_map *isl_basic_map_preimage_multi_aff(
 	isl_basic_map *res = NULL;
 	int n_before, n_after, n_div_bmap, n_div_ma;
 	isl_int f, c1, c2, g;
-	int rational, strides;
+	isl_bool rational;
+	int strides;
 
 	isl_int_init(f);
 	isl_int_init(c1);
@@ -12689,7 +13073,7 @@ __isl_give isl_basic_map *isl_basic_map_preimage_multi_aff(
 	isl_int_clear(g);
 	isl_basic_map_free(bmap);
 	isl_multi_aff_free(ma);
-	res = isl_basic_set_simplify(res);
+	res = isl_basic_map_simplify(res);
 	return isl_basic_map_finalize(res);
 error:
 	isl_int_clear(f);
@@ -12738,22 +13122,24 @@ __isl_give isl_basic_map *isl_basic_map_preimage_range_multi_aff(
 
 /* Check if the range of "ma" is compatible with the domain or range
  * (depending on "type") of "map".
- * Return -1 if anything is wrong.
+ * Return isl_stat_error if anything is wrong.
  */
-static int check_map_compatible_range_multi_aff(
+static isl_stat check_map_compatible_range_multi_aff(
 	__isl_keep isl_map *map, enum isl_dim_type type,
 	__isl_keep isl_multi_aff *ma)
 {
-	int m;
+	isl_bool m;
 	isl_space *ma_space;
 
 	ma_space = isl_multi_aff_get_space(ma);
 	m = isl_space_tuple_is_equal(map->dim, type, ma_space, isl_dim_out);
 	isl_space_free(ma_space);
-	if (m >= 0 && !m)
+	if (m < 0)
+		return isl_stat_error;
+	if (!m)
 		isl_die(isl_map_get_ctx(map), isl_error_invalid,
-			"spaces don't match", return -1);
-	return m;
+			"spaces don't match", return isl_stat_error);
+	return isl_stat_ok;
 }
 
 /* Compute the preimage of the domain or range (depending on "type")
@@ -12814,14 +13200,20 @@ error:
 __isl_give isl_map *isl_map_preimage_multi_aff(__isl_take isl_map *map,
 	enum isl_dim_type type, __isl_take isl_multi_aff *ma)
 {
+	isl_bool aligned;
+
 	if (!map || !ma)
 		goto error;
 
-	if (isl_space_match(map->dim, isl_dim_param, ma->space, isl_dim_param))
+	aligned = isl_map_space_has_equal_params(map, ma->space);
+	if (aligned < 0)
+		goto error;
+	if (aligned)
 		return map_preimage_multi_aff(map, type, ma);
 
-	if (!isl_space_has_named_params(map->dim) ||
-	    !isl_space_has_named_params(ma->space))
+	if (isl_map_check_named_params(map) < 0)
+		goto error;
+	if (!isl_space_has_named_params(ma->space))
 		isl_die(map->ctx, isl_error_invalid,
 			"unaligned unnamed parameters", goto error);
 	map = isl_map_align_params(map, isl_multi_aff_get_space(ma));
@@ -12933,14 +13325,20 @@ error:
 __isl_give isl_map *isl_map_preimage_pw_multi_aff(__isl_take isl_map *map,
 	enum isl_dim_type type, __isl_take isl_pw_multi_aff *pma)
 {
+	isl_bool aligned;
+
 	if (!map || !pma)
 		goto error;
 
-	if (isl_space_match(map->dim, isl_dim_param, pma->dim, isl_dim_param))
+	aligned = isl_map_space_has_equal_params(map, pma->dim);
+	if (aligned < 0)
+		goto error;
+	if (aligned)
 		return isl_map_preimage_pw_multi_aff_aligned(map, type, pma);
 
-	if (!isl_space_has_named_params(map->dim) ||
-	    !isl_space_has_named_params(pma->dim))
+	if (isl_map_check_named_params(map) < 0)
+		goto error;
+	if (!isl_space_has_named_params(pma->dim))
 		isl_die(map->ctx, isl_error_invalid,
 			"unaligned unnamed parameters", goto error);
 	map = isl_map_align_params(map, isl_pw_multi_aff_get_space(pma));
@@ -13046,3 +13444,207 @@ __isl_give isl_set *isl_set_preimage_multi_pw_aff(__isl_take isl_set *set,
 {
 	return isl_map_preimage_multi_pw_aff(set, isl_dim_set, mpa);
 }
+
+/* Return a copy of the equality constraints of "bset" as a matrix.
+ */
+__isl_give isl_mat *isl_basic_set_extract_equalities(
+	__isl_keep isl_basic_set *bset)
+{
+	isl_ctx *ctx;
+	unsigned total;
+
+	if (!bset)
+		return NULL;
+
+	ctx = isl_basic_set_get_ctx(bset);
+	total = 1 + isl_basic_set_dim(bset, isl_dim_all);
+	return isl_mat_sub_alloc6(ctx, bset->eq, 0, bset->n_eq, 0, total);
+}
+
+/* Are the "n" "coefficients" starting at "first" of the integer division
+ * expressions at position "pos1" in "bmap1" and "pos2" in "bmap2" equal
+ * to each other?
+ * The "coefficient" at position 0 is the denominator.
+ * The "coefficient" at position 1 is the constant term.
+ */
+isl_bool isl_basic_map_equal_div_expr_part(__isl_keep isl_basic_map *bmap1,
+	int pos1, __isl_keep isl_basic_map *bmap2, int pos2,
+	unsigned first, unsigned n)
+{
+	if (isl_basic_map_check_range(bmap1, isl_dim_div, pos1, 1) < 0)
+		return isl_bool_error;
+	if (isl_basic_map_check_range(bmap2, isl_dim_div, pos2, 1) < 0)
+		return isl_bool_error;
+	return isl_seq_eq(bmap1->div[pos1] + first,
+			  bmap2->div[pos2] + first, n);
+}
+
+/* Are the integer division expressions at position "pos1" in "bmap1" and
+ * "pos2" in "bmap2" equal to each other, except that the constant terms
+ * are different?
+ */
+isl_bool isl_basic_map_equal_div_expr_except_constant(
+	__isl_keep isl_basic_map *bmap1, int pos1,
+	__isl_keep isl_basic_map *bmap2, int pos2)
+{
+	isl_bool equal;
+	unsigned total;
+
+	if (!bmap1 || !bmap2)
+		return isl_bool_error;
+	total = isl_basic_map_total_dim(bmap1);
+	if (total != isl_basic_map_total_dim(bmap2))
+		isl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,
+			"incomparable div expressions", return isl_bool_error);
+	equal = isl_basic_map_equal_div_expr_part(bmap1, pos1, bmap2, pos2,
+						0, 1);
+	if (equal < 0 || !equal)
+		return equal;
+	equal = isl_basic_map_equal_div_expr_part(bmap1, pos1, bmap2, pos2,
+						1, 1);
+	if (equal < 0 || equal)
+		return isl_bool_not(equal);
+	return isl_basic_map_equal_div_expr_part(bmap1, pos1, bmap2, pos2,
+						2, total);
+}
+
+/* Replace the numerator of the constant term of the integer division
+ * expression at position "div" in "bmap" by "value".
+ * The caller guarantees that this does not change the meaning
+ * of the input.
+ */
+__isl_give isl_basic_map *isl_basic_map_set_div_expr_constant_num_si_inplace(
+	__isl_take isl_basic_map *bmap, int div, int value)
+{
+	if (isl_basic_map_check_range(bmap, isl_dim_div, div, 1) < 0)
+		return isl_basic_map_free(bmap);
+
+	isl_int_set_si(bmap->div[div][1], value);
+
+	return bmap;
+}
+
+/* Is the point "inner" internal to inequality constraint "ineq"
+ * of "bset"?
+ * The point is considered to be internal to the inequality constraint,
+ * if it strictly lies on the positive side of the inequality constraint,
+ * or if it lies on the constraint and the constraint is lexico-positive.
+ */
+static isl_bool is_internal(__isl_keep isl_vec *inner,
+	__isl_keep isl_basic_set *bset, int ineq)
+{
+	isl_ctx *ctx;
+	int pos;
+	unsigned total;
+
+	if (!inner || !bset)
+		return isl_bool_error;
+
+	ctx = isl_basic_set_get_ctx(bset);
+	isl_seq_inner_product(inner->el, bset->ineq[ineq], inner->size,
+				&ctx->normalize_gcd);
+	if (!isl_int_is_zero(ctx->normalize_gcd))
+		return isl_int_is_nonneg(ctx->normalize_gcd);
+
+	total = isl_basic_set_dim(bset, isl_dim_all);
+	pos = isl_seq_first_non_zero(bset->ineq[ineq] + 1, total);
+	return isl_int_is_pos(bset->ineq[ineq][1 + pos]);
+}
+
+/* Tighten the inequality constraints of "bset" that are outward with respect
+ * to the point "vec".
+ * That is, tighten the constraints that are not satisfied by "vec".
+ *
+ * "vec" is a point internal to some superset S of "bset" that is used
+ * to make the subsets of S disjoint, by tightening one half of the constraints
+ * that separate two subsets.  In particular, the constraints of S
+ * are all satisfied by "vec" and should not be tightened.
+ * Of the internal constraints, those that have "vec" on the outside
+ * are tightened.  The shared facet is included in the adjacent subset
+ * with the opposite constraint.
+ * For constraints that saturate "vec", this criterion cannot be used
+ * to determine which of the two sides should be tightened.
+ * Instead, the sign of the first non-zero coefficient is used
+ * to make this choice.  Note that this second criterion is never used
+ * on the constraints of S since "vec" is interior to "S".
+ */
+__isl_give isl_basic_set *isl_basic_set_tighten_outward(
+	__isl_take isl_basic_set *bset, __isl_keep isl_vec *vec)
+{
+	int j;
+
+	bset = isl_basic_set_cow(bset);
+	if (!bset)
+		return NULL;
+	for (j = 0; j < bset->n_ineq; ++j) {
+		isl_bool internal;
+
+		internal = is_internal(vec, bset, j);
+		if (internal < 0)
+			return isl_basic_set_free(bset);
+		if (internal)
+			continue;
+		isl_int_sub_ui(bset->ineq[j][0], bset->ineq[j][0], 1);
+	}
+
+	return bset;
+}
+
+/* Replace the variables x of type "type" starting at "first" in "bmap"
+ * by x' with x = M x' with M the matrix trans.
+ * That is, replace the corresponding coefficients c by c M.
+ *
+ * The transformation matrix should be a square matrix.
+ */
+__isl_give isl_basic_map *isl_basic_map_transform_dims(
+	__isl_take isl_basic_map *bmap, enum isl_dim_type type, unsigned first,
+	__isl_take isl_mat *trans)
+{
+	unsigned pos;
+
+	bmap = isl_basic_map_cow(bmap);
+	if (!bmap || !trans)
+		goto error;
+
+	if (trans->n_row != trans->n_col)
+		isl_die(trans->ctx, isl_error_invalid,
+			"expecting square transformation matrix", goto error);
+	if (first + trans->n_row > isl_basic_map_dim(bmap, type))
+		isl_die(trans->ctx, isl_error_invalid,
+			"oversized transformation matrix", goto error);
+
+	pos = isl_basic_map_offset(bmap, type) + first;
+
+	if (isl_mat_sub_transform(bmap->eq, bmap->n_eq, pos,
+			isl_mat_copy(trans)) < 0)
+		goto error;
+	if (isl_mat_sub_transform(bmap->ineq, bmap->n_ineq, pos,
+		      isl_mat_copy(trans)) < 0)
+		goto error;
+	if (isl_mat_sub_transform(bmap->div, bmap->n_div, 1 + pos,
+		      isl_mat_copy(trans)) < 0)
+		goto error;
+
+	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
+	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED_DIVS);
+
+	isl_mat_free(trans);
+	return bmap;
+error:
+	isl_mat_free(trans);
+	isl_basic_map_free(bmap);
+	return NULL;
+}
+
+/* Replace the variables x of type "type" starting at "first" in "bset"
+ * by x' with x = M x' with M the matrix trans.
+ * That is, replace the corresponding coefficients c by c M.
+ *
+ * The transformation matrix should be a square matrix.
+ */
+__isl_give isl_basic_set *isl_basic_set_transform_dims(
+	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned first,
+	__isl_take isl_mat *trans)
+{
+	return isl_basic_map_transform_dims(bset, type, first, trans);
+}
diff --git a/lib/Analysis/isl/isl_map_lexopt_templ.c b/lib/Analysis/isl/isl_map_lexopt_templ.c
index d3b6a67..780a54f 100644
--- a/lib/Analysis/isl/isl_map_lexopt_templ.c
+++ b/lib/Analysis/isl/isl_map_lexopt_templ.c
@@ -17,24 +17,84 @@
 #define xSF(TYPE,SUFFIX) TYPE ## SUFFIX
 #define SF(TYPE,SUFFIX) xSF(TYPE,SUFFIX)
 
+/* Compute the lexicographic minimum (or maximum if "flags" includes
+ * ISL_OPT_MAX) of "bmap" over the domain "dom" and return the result.
+ * If "empty" is not NULL, then *empty is assigned a set that
+ * contains those parts of the domain where there is no solution.
+ * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
+ * should be computed over the domain of "bmap".  "empty" is also NULL
+ * in this case.
+ * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
+ * then the rational optimum is computed.  Otherwise, the integral optimum
+ * is computed.
+ */
+static __isl_give TYPE *SF(isl_basic_map_partial_lexopt,SUFFIX)(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty, unsigned flags)
+{
+	return SF(isl_tab_basic_map_partial_lexopt,SUFFIX)(bmap, dom, empty,
+							    flags);
+}
+
+__isl_give TYPE *SF(isl_basic_map_partial_lexmax,SUFFIX)(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty)
+{
+	unsigned flags = ISL_OPT_MAX;
+	return SF(isl_basic_map_partial_lexopt,SUFFIX)(bmap, dom, empty, flags);
+}
+
+__isl_give TYPE *SF(isl_basic_map_partial_lexmin,SUFFIX)(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty)
+{
+	unsigned flags = 0;
+	return SF(isl_basic_map_partial_lexopt,SUFFIX)(bmap, dom, empty, flags);
+}
+
+__isl_give TYPE *SF(isl_basic_set_partial_lexmin,SUFFIX)(
+	__isl_take isl_basic_set *bset, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty)
+{
+	return SF(isl_basic_map_partial_lexmin,SUFFIX)(bset, dom, empty);
+}
+
+__isl_give TYPE *SF(isl_basic_set_partial_lexmax,SUFFIX)(
+	__isl_take isl_basic_set *bset, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty)
+{
+	return SF(isl_basic_map_partial_lexmax,SUFFIX)(bset, dom, empty);
+}
+
 /* Given a basic map "bmap", compute the lexicographically minimal
  * (or maximal) image element for each domain element in dom.
  * If empty is not NULL, then set *empty to those elements in dom
  * that do not have an image element.
+ * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
+ * should be computed over the domain of "bmap".  "empty" is also NULL
+ * in this case.
  *
  * We first make sure the basic sets in dom are disjoint and then
  * simply collect the results over each of the basic sets separately.
  * We could probably improve the efficiency a bit by moving the union
  * domain down into the parametric integer programming.
+ *
+ * If a full optimum is being computed (i.e., "flags" includes ISL_OPT_FULL),
+ * then no domain is given and there is then also no need to consider
+ * the disjuncts of the domain.
  */
 static __isl_give TYPE *SF(basic_map_partial_lexopt,SUFFIX)(
 	__isl_take isl_basic_map *bmap, __isl_take isl_set *dom,
-	__isl_give isl_set **empty, int max)
+	__isl_give isl_set **empty, unsigned flags)
 {
 	int i;
 	TYPE *res;
 	isl_set *all_empty;
 
+	if (ISL_FL_ISSET(flags, ISL_OPT_FULL))
+		return SF(isl_basic_map_partial_lexopt,SUFFIX)(bmap, NULL,
+								empty, flags);
+
 	dom = isl_set_make_disjoint(dom);
 	if (!dom)
 		goto error;
@@ -50,7 +110,7 @@ static __isl_give TYPE *SF(basic_map_partial_lexopt,SUFFIX)(
 	}
 
 	res = SF(isl_basic_map_partial_lexopt,SUFFIX)(isl_basic_map_copy(bmap),
-			isl_basic_set_copy(dom->p[0]), empty, max);
+			isl_basic_set_copy(dom->p[0]), empty, flags);
 
 	if (empty)
 		all_empty = *empty;
@@ -59,7 +119,7 @@ static __isl_give TYPE *SF(basic_map_partial_lexopt,SUFFIX)(
 
 		res_i = SF(isl_basic_map_partial_lexopt,SUFFIX)(
 				isl_basic_map_copy(bmap),
-				isl_basic_set_copy(dom->p[i]), empty, max);
+				isl_basic_set_copy(dom->p[i]), empty, flags);
 
 		res = ADD(res, res_i);
 		if (empty)
@@ -79,9 +139,29 @@ error:
 	return NULL;
 }
 
+/* Compute the lexicographic minimum (or maximum if "flags" includes
+ * ISL_OPT_MAX) of "bmap" over its domain.
+ */
+__isl_give TYPE *SF(isl_basic_map_lexopt,SUFFIX)(
+	__isl_take isl_basic_map *bmap, unsigned flags)
+{
+	ISL_FL_SET(flags, ISL_OPT_FULL);
+	return SF(isl_basic_map_partial_lexopt,SUFFIX)(bmap, NULL, NULL, flags);
+}
+
+__isl_give TYPE *SF(isl_basic_map_lexmin,SUFFIX)(__isl_take isl_basic_map *bmap)
+{
+	return SF(isl_basic_map_lexopt,SUFFIX)(bmap, 0);
+}
+
 static __isl_give TYPE *SF(isl_map_partial_lexopt_aligned,SUFFIX)(
 	__isl_take isl_map *map, __isl_take isl_set *dom,
-	__isl_give isl_set **empty, int max);
+	__isl_give isl_set **empty, unsigned flags);
+/* This function is currently only used when TYPE is defined as isl_map. */
+static __isl_give TYPE *SF(isl_map_partial_lexopt,SUFFIX)(
+	__isl_take isl_map *map, __isl_take isl_set *dom,
+	__isl_give isl_set **empty, unsigned flags)
+	__attribute__ ((unused));
 
 /* Given a map "map", compute the lexicographically minimal
  * (or maximal) image element for each domain element in dom.
@@ -91,20 +171,24 @@ static __isl_give TYPE *SF(isl_map_partial_lexopt_aligned,SUFFIX)(
  */
 static __isl_give TYPE *SF(isl_map_partial_lexopt,SUFFIX)(
 	__isl_take isl_map *map, __isl_take isl_set *dom,
-	__isl_give isl_set **empty, int max)
+	__isl_give isl_set **empty, unsigned flags)
 {
-	if (!map || !dom)
+	isl_bool aligned;
+
+	aligned = isl_map_set_has_equal_params(map, dom);
+	if (aligned < 0)
 		goto error;
-	if (isl_space_match(map->dim, isl_dim_param, dom->dim, isl_dim_param))
+	if (aligned)
 		return SF(isl_map_partial_lexopt_aligned,SUFFIX)(map, dom,
-								empty, max);
+								empty, flags);
 	if (!isl_space_has_named_params(map->dim) ||
 	    !isl_space_has_named_params(dom->dim))
 		isl_die(map->ctx, isl_error_invalid,
 			"unaligned unnamed parameters", goto error);
 	map = isl_map_align_params(map, isl_map_get_space(dom));
 	dom = isl_map_align_params(dom, isl_map_get_space(map));
-	return SF(isl_map_partial_lexopt_aligned,SUFFIX)(map, dom, empty, max);
+	return SF(isl_map_partial_lexopt_aligned,SUFFIX)(map, dom, empty,
+							flags);
 error:
 	if (empty)
 		*empty = NULL;
@@ -113,19 +197,15 @@ error:
 	return NULL;
 }
 
-__isl_give TYPE *SF(isl_map_lexopt,SUFFIX)(__isl_take isl_map *map, int max)
+/* Compute the lexicographic minimum (or maximum if "flags" includes
+ * ISL_OPT_MAX) of "map" over its domain.
+ */
+__isl_give TYPE *SF(isl_map_lexopt,SUFFIX)(__isl_take isl_map *map,
+	unsigned flags)
 {
-	isl_set *dom = NULL;
-	isl_space *dom_space;
-
-	if (!map)
-		goto error;
-	dom_space = isl_space_domain(isl_space_copy(map->dim));
-	dom = isl_set_universe(dom_space);
-	return SF(isl_map_partial_lexopt,SUFFIX)(map, dom, NULL, max);
-error:
-	isl_map_free(map);
-	return NULL;
+	ISL_FL_SET(flags, ISL_OPT_FULL);
+	return SF(isl_map_partial_lexopt_aligned,SUFFIX)(map, NULL, NULL,
+							flags);
 }
 
 __isl_give TYPE *SF(isl_map_lexmin,SUFFIX)(__isl_take isl_map *map)
@@ -135,7 +215,7 @@ __isl_give TYPE *SF(isl_map_lexmin,SUFFIX)(__isl_take isl_map *map)
 
 __isl_give TYPE *SF(isl_map_lexmax,SUFFIX)(__isl_take isl_map *map)
 {
-	return SF(isl_map_lexopt,SUFFIX)(map, 1);
+	return SF(isl_map_lexopt,SUFFIX)(map, ISL_OPT_MAX);
 }
 
 __isl_give TYPE *SF(isl_set_lexmin,SUFFIX)(__isl_take isl_set *set)
diff --git a/lib/Analysis/isl/isl_map_private.h b/lib/Analysis/isl/isl_map_private.h
index 5fd828d..ba2937e 100644
--- a/lib/Analysis/isl/isl_map_private.h
+++ b/lib/Analysis/isl/isl_map_private.h
@@ -146,34 +146,30 @@ __isl_give isl_basic_map *isl_basic_map_extend_constraints(
 __isl_give isl_basic_map *isl_basic_map_simplify(
 	__isl_take isl_basic_map *bmap);
 
-__isl_give isl_set *isl_set_alloc(isl_ctx *ctx,
-	unsigned nparam, unsigned dim, int n, unsigned flags);
 __isl_give isl_set *isl_set_add_basic_set(__isl_take isl_set *set,
 	__isl_take isl_basic_set *bset);
-__isl_give isl_set *isl_set_finalize(__isl_take isl_set *set);
-__isl_give isl_set *isl_set_dup(__isl_keep isl_set *set);
 
-__isl_give isl_map *isl_map_alloc(isl_ctx *ctx,
-	unsigned nparam, unsigned in, unsigned out, int n, unsigned flags);
 __isl_give isl_map *isl_map_add_basic_map(__isl_take isl_map *map,
 	__isl_take isl_basic_map *bmap);
 __isl_give isl_map *isl_map_dup(__isl_keep isl_map *map);
-__isl_give isl_map *isl_map_finalize(__isl_take isl_map *map);
 
 __isl_give isl_basic_set *isl_basic_set_from_underlying_set(
 	__isl_take isl_basic_set *bset, __isl_take isl_basic_set *like);
-__isl_give isl_set *isl_set_from_underlying_set(
-	__isl_take isl_set *set, __isl_take isl_basic_set *like);
-__isl_give isl_set *isl_set_to_underlying_set(__isl_take isl_set *set);
 
 __isl_give isl_map *isl_map_realign(__isl_take isl_map *map,
 	__isl_take isl_reordering *r);
 __isl_give isl_set *isl_set_realign(__isl_take isl_set *set,
 	__isl_take isl_reordering *r);
 
+__isl_give isl_basic_map *isl_basic_map_reset(__isl_take isl_basic_map *bmap,
+	enum isl_dim_type type);
 __isl_give isl_map *isl_map_reset(__isl_take isl_map *map,
 	enum isl_dim_type type);
 
+__isl_keep isl_space *isl_basic_map_peek_space(
+	__isl_keep const isl_basic_map *bmap);
+__isl_keep isl_space *isl_basic_set_peek_space(__isl_keep isl_basic_set *bset);
+
 __isl_give isl_basic_set *isl_basic_set_reset_space(
 	__isl_take isl_basic_set *bset, __isl_take isl_space *dim);
 __isl_give isl_basic_map *isl_basic_map_reset_space(
@@ -183,27 +179,29 @@ __isl_give isl_map *isl_map_reset_space(__isl_take isl_map *map,
 
 unsigned isl_basic_map_offset(struct isl_basic_map *bmap,
 					enum isl_dim_type type);
-unsigned isl_basic_set_offset(struct isl_basic_set *bset,
+unsigned isl_basic_set_offset(__isl_keep isl_basic_set *bset,
 					enum isl_dim_type type);
 
-int isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap);
+isl_bool isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap);
 int isl_map_may_be_set(__isl_keep isl_map *map);
-int isl_map_compatible_domain(struct isl_map *map, struct isl_set *set);
-int isl_basic_map_compatible_domain(struct isl_basic_map *bmap,
-		struct isl_basic_set *bset);
-int isl_basic_map_compatible_range(struct isl_basic_map *bmap,
-		struct isl_basic_set *bset);
-
-struct isl_basic_map *isl_basic_map_extend_space(struct isl_basic_map *base,
-		__isl_take isl_space *dim, unsigned extra,
-		unsigned n_eq, unsigned n_ineq);
-struct isl_basic_set *isl_basic_set_extend_space(struct isl_basic_set *base,
+isl_bool isl_map_compatible_domain(__isl_keep isl_map *map,
+	__isl_keep isl_set *set);
+isl_bool isl_basic_map_compatible_domain(__isl_keep isl_basic_map *bmap,
+	__isl_keep isl_basic_set *bset);
+isl_bool isl_basic_map_compatible_range(__isl_keep isl_basic_map *bmap,
+	__isl_keep isl_basic_set *bset);
+
+__isl_give isl_basic_map *isl_basic_map_extend_space(
+	__isl_take isl_basic_map *base, __isl_take isl_space *dim,
+	unsigned extra, unsigned n_eq, unsigned n_ineq);
+__isl_give isl_basic_set *isl_basic_set_extend_space(
+	__isl_take isl_basic_set *base,
 		__isl_take isl_space *dim, unsigned extra,
 		unsigned n_eq, unsigned n_ineq);
 struct isl_basic_set *isl_basic_set_add_constraints(struct isl_basic_set *bset1,
 		struct isl_basic_set *bset2, unsigned pos);
 
-struct isl_map *isl_map_grow(struct isl_map *map, int n);
+__isl_give isl_map *isl_map_grow(__isl_take isl_map *map, int n);
 struct isl_set *isl_set_grow(struct isl_set *set, int n);
 
 isl_bool isl_basic_set_contains(__isl_keep isl_basic_set *bset,
@@ -220,24 +218,24 @@ __isl_give isl_basic_map *isl_basic_map_alloc_space(__isl_take isl_space *dim,
 __isl_give isl_map *isl_map_alloc_space(__isl_take isl_space *dim, int n,
 	unsigned flags);
 
-unsigned isl_basic_map_total_dim(const struct isl_basic_map *bmap);
-
 int isl_basic_map_alloc_equality(struct isl_basic_map *bmap);
 int isl_basic_set_alloc_equality(struct isl_basic_set *bset);
 int isl_basic_set_free_inequality(struct isl_basic_set *bset, unsigned n);
 int isl_basic_map_free_equality(struct isl_basic_map *bmap, unsigned n);
 int isl_basic_set_free_equality(struct isl_basic_set *bset, unsigned n);
-int isl_basic_set_alloc_inequality(struct isl_basic_set *bset);
-int isl_basic_map_alloc_inequality(struct isl_basic_map *bmap);
+int isl_basic_set_alloc_inequality(__isl_keep isl_basic_set *bset);
+int isl_basic_map_alloc_inequality(__isl_keep isl_basic_map *bmap);
 int isl_basic_map_free_inequality(struct isl_basic_map *bmap, unsigned n);
 int isl_basic_map_alloc_div(struct isl_basic_map *bmap);
+__isl_give isl_basic_map *isl_basic_map_insert_div(
+	__isl_take isl_basic_map *bmap, int pos, __isl_keep isl_vec *div);
 int isl_basic_set_alloc_div(struct isl_basic_set *bset);
-int isl_basic_map_free_div(struct isl_basic_map *bmap, unsigned n);
-int isl_basic_set_free_div(struct isl_basic_set *bset, unsigned n);
+isl_stat isl_basic_map_free_div(struct isl_basic_map *bmap, unsigned n);
+__isl_give isl_basic_map *isl_basic_map_drop_div(
+	__isl_take isl_basic_map *bmap, unsigned div);
 void isl_basic_map_inequality_to_equality(
 		struct isl_basic_map *bmap, unsigned pos);
 int isl_basic_map_drop_equality(struct isl_basic_map *bmap, unsigned pos);
-int isl_basic_set_drop_equality(struct isl_basic_set *bset, unsigned pos);
 int isl_basic_set_drop_inequality(struct isl_basic_set *bset, unsigned pos);
 int isl_basic_map_drop_inequality(struct isl_basic_map *bmap, unsigned pos);
 __isl_give isl_basic_set *isl_basic_set_add_eq(__isl_take isl_basic_set *bset,
@@ -249,60 +247,72 @@ __isl_give isl_basic_set *isl_basic_set_add_ineq(__isl_take isl_basic_set *bset,
 __isl_give isl_basic_map *isl_basic_map_add_ineq(__isl_take isl_basic_map *bmap,
 	isl_int *ineq);
 
+__isl_give isl_basic_set *isl_basic_set_tighten_outward(
+	__isl_take isl_basic_set *bset, __isl_keep isl_vec *vec);
+
 int isl_inequality_negate(struct isl_basic_map *bmap, unsigned pos);
 
-struct isl_basic_set *isl_basic_set_cow(struct isl_basic_set *bset);
-struct isl_basic_map *isl_basic_map_cow(struct isl_basic_map *bmap);
-struct isl_set *isl_set_cow(struct isl_set *set);
-struct isl_map *isl_map_cow(struct isl_map *map);
+__isl_give isl_basic_set *isl_basic_set_cow(__isl_take isl_basic_set *bset);
+__isl_give isl_basic_map *isl_basic_map_cow(__isl_take isl_basic_map *bmap);
+__isl_give isl_set *isl_set_cow(__isl_take isl_set *set);
+__isl_give isl_map *isl_map_cow(__isl_take isl_map *map);
 
 uint32_t isl_basic_map_get_hash(__isl_keep isl_basic_map *bmap);
 
-struct isl_basic_map *isl_basic_map_set_to_empty(struct isl_basic_map *bmap);
-struct isl_basic_set *isl_basic_set_set_to_empty(struct isl_basic_set *bset);
+__isl_give isl_set *isl_basic_set_list_union(
+	__isl_take isl_basic_set_list *list);
+
+__isl_give isl_basic_map *isl_basic_map_set_to_empty(
+	__isl_take isl_basic_map *bmap);
+__isl_give isl_basic_set *isl_basic_set_set_to_empty(
+	__isl_take isl_basic_set *bset);
 struct isl_basic_set *isl_basic_set_order_divs(struct isl_basic_set *bset);
 void isl_basic_map_swap_div(struct isl_basic_map *bmap, int a, int b);
-struct isl_basic_map *isl_basic_map_order_divs(struct isl_basic_map *bmap);
+void isl_basic_set_swap_div(struct isl_basic_set *bset, int a, int b);
+__isl_give isl_basic_map *isl_basic_map_order_divs(
+	__isl_take isl_basic_map *bmap);
 __isl_give isl_map *isl_map_order_divs(__isl_take isl_map *map);
-struct isl_basic_map *isl_basic_map_align_divs(
-		struct isl_basic_map *dst, struct isl_basic_map *src);
-struct isl_basic_set *isl_basic_set_align_divs(
-		struct isl_basic_set *dst, struct isl_basic_set *src);
+__isl_give isl_basic_map *isl_basic_map_align_divs(
+	__isl_take isl_basic_map *dst, __isl_keep isl_basic_map *src);
 __isl_give isl_map *isl_map_align_divs_to_basic_map_list(
 	__isl_take isl_map *map, __isl_keep isl_basic_map_list *list);
 __isl_give isl_basic_map_list *isl_basic_map_list_align_divs_to_basic_map(
 	__isl_take isl_basic_map_list *list, __isl_keep isl_basic_map *bmap);
+__isl_give isl_map *isl_map_align_divs_internal(__isl_take isl_map *map);
+__isl_give isl_basic_set *isl_basic_set_sort_divs(
+	__isl_take isl_basic_set *bset);
 __isl_give isl_basic_map *isl_basic_map_sort_divs(
 	__isl_take isl_basic_map *bmap);
 __isl_give isl_map *isl_map_sort_divs(__isl_take isl_map *map);
-struct isl_basic_map *isl_basic_map_gauss(
-	struct isl_basic_map *bmap, int *progress);
-struct isl_basic_set *isl_basic_set_gauss(
-	struct isl_basic_set *bset, int *progress);
+__isl_give isl_basic_map *isl_basic_map_gauss(__isl_take isl_basic_map *bmap,
+	int *progress);
+__isl_give isl_basic_set *isl_basic_set_gauss(
+	__isl_take isl_basic_set *bset, int *progress);
 int isl_basic_map_constraint_cmp(__isl_keep isl_basic_map *bmap,
 	isl_int *c1, isl_int *c2);
 __isl_give isl_basic_map *isl_basic_map_sort_constraints(
 	__isl_take isl_basic_map *bmap);
 __isl_give isl_basic_set *isl_basic_set_sort_constraints(
 	__isl_take isl_basic_set *bset);
-int isl_basic_map_plain_cmp(const __isl_keep isl_basic_map *bmap1,
-	const __isl_keep isl_basic_map *bmap2);
+int isl_basic_map_plain_cmp(__isl_keep isl_basic_map *bmap1,
+	__isl_keep isl_basic_map *bmap2);
 isl_bool isl_basic_map_plain_is_equal(__isl_keep isl_basic_map *bmap1,
 	__isl_keep isl_basic_map *bmap2);
-struct isl_basic_map *isl_basic_map_normalize_constraints(
-	struct isl_basic_map *bmap);
-struct isl_basic_set *isl_basic_set_normalize_constraints(
-	struct isl_basic_set *bset);
-struct isl_basic_map *isl_basic_map_implicit_equalities(
-						struct isl_basic_map *bmap);
-struct isl_basic_set *isl_basic_map_underlying_set(struct isl_basic_map *bmap);
+__isl_give isl_basic_map *isl_basic_map_normalize_constraints(
+	__isl_take isl_basic_map *bmap);
+__isl_give isl_basic_set *isl_basic_set_normalize_constraints(
+	__isl_take isl_basic_set *bset);
+__isl_give isl_basic_map *isl_basic_map_implicit_equalities(
+	__isl_take isl_basic_map *bmap);
+__isl_give isl_basic_set *isl_basic_map_underlying_set(
+	__isl_take isl_basic_map *bmap);
 __isl_give isl_basic_set *isl_basic_set_underlying_set(
 		__isl_take isl_basic_set *bset);
 __isl_give isl_basic_set_list *isl_basic_map_list_underlying_set(
 	__isl_take isl_basic_map_list *list);
-struct isl_set *isl_map_underlying_set(struct isl_map *map);
-struct isl_basic_map *isl_basic_map_overlying_set(struct isl_basic_set *bset,
-	struct isl_basic_map *like);
+__isl_give isl_set *isl_map_underlying_set(__isl_take isl_map *map);
+__isl_give isl_basic_map *isl_basic_map_overlying_set(
+	__isl_take isl_basic_set *bset, __isl_take isl_basic_map *like);
 __isl_give isl_basic_map *isl_basic_map_drop_constraint_involving_unknown_divs(
 	__isl_take isl_basic_map *bmap);
 __isl_give isl_map *isl_map_drop_constraint_involving_unknown_divs(
@@ -311,17 +321,13 @@ __isl_give isl_basic_set *isl_basic_set_drop_constraints_involving(
 	__isl_take isl_basic_set *bset, unsigned first, unsigned n);
 __isl_give isl_basic_set *isl_basic_set_drop(__isl_take isl_basic_set *bset,
 	enum isl_dim_type type, unsigned first, unsigned n);
-struct isl_basic_map *isl_basic_map_drop(struct isl_basic_map *bmap,
+__isl_give isl_basic_map *isl_basic_map_drop(__isl_take isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned first, unsigned n);
-struct isl_set *isl_set_drop(struct isl_set *set,
+__isl_give isl_set *isl_set_drop(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned first, unsigned n);
-struct isl_basic_set *isl_basic_set_drop_dims(
-		struct isl_basic_set *bset, unsigned first, unsigned n);
-struct isl_set *isl_set_drop_dims(
-		struct isl_set *set, unsigned first, unsigned n);
-struct isl_map *isl_map_drop_inputs(
-		struct isl_map *map, unsigned first, unsigned n);
-struct isl_map *isl_map_drop(struct isl_map *map,
+__isl_give isl_basic_set *isl_basic_set_drop_dims(
+	__isl_take isl_basic_set *bset, unsigned first, unsigned n);
+__isl_give isl_map *isl_map_drop(__isl_take isl_map *map,
 	enum isl_dim_type type, unsigned first, unsigned n);
 __isl_give isl_basic_map *isl_basic_map_drop_unrelated_constraints(
 	__isl_take isl_basic_map *bmap, __isl_take int *group);
@@ -331,7 +337,7 @@ __isl_give isl_basic_map *isl_basic_map_remove_duplicate_constraints(
 __isl_give isl_basic_map *isl_basic_map_detect_inequality_pairs(
 	__isl_take isl_basic_map *bmap, int *progress);
 
-struct isl_map *isl_map_remove_empty_parts(struct isl_map *map);
+__isl_give isl_map *isl_map_remove_empty_parts(__isl_take isl_map *map);
 struct isl_set *isl_set_remove_empty_parts(struct isl_set *set);
 __isl_give isl_map *isl_map_remove_obvious_duplicates(__isl_take isl_map *map);
 
@@ -340,8 +346,8 @@ struct isl_set *isl_set_normalize(struct isl_set *set);
 struct isl_set *isl_set_drop_vars(
 		struct isl_set *set, unsigned first, unsigned n);
 
-struct isl_basic_map *isl_basic_map_eliminate_vars(
-	struct isl_basic_map *bmap, unsigned pos, unsigned n);
+__isl_give isl_basic_map *isl_basic_map_eliminate_vars(
+	__isl_take isl_basic_map *bmap, unsigned pos, unsigned n);
 struct isl_basic_set *isl_basic_set_eliminate_vars(
 	struct isl_basic_set *bset, unsigned pos, unsigned n);
 
@@ -350,36 +356,45 @@ __isl_give isl_map *isl_map_eliminate(__isl_take isl_map *map,
 __isl_give isl_set *isl_set_eliminate(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned first, unsigned n);
 
-int isl_basic_set_constraint_is_redundant(struct isl_basic_set **bset,
-	isl_int *c, isl_int *opt_n, isl_int *opt_d);
-
 int isl_basic_map_add_div_constraint(__isl_keep isl_basic_map *bmap,
 	unsigned div, int sign);
 int isl_basic_map_add_div_constraints(struct isl_basic_map *bmap, unsigned div);
 __isl_give isl_basic_map *isl_basic_map_add_known_div_constraints(
 	__isl_take isl_basic_map *bmap);
-struct isl_basic_map *isl_basic_map_drop_redundant_divs(
-	struct isl_basic_map *bmap);
-struct isl_basic_set *isl_basic_set_drop_redundant_divs(
-	struct isl_basic_set *bset);
+__isl_give isl_basic_map *isl_basic_map_drop_redundant_divs(
+	__isl_take isl_basic_map *bmap);
 
-struct isl_basic_set *isl_basic_set_recession_cone(struct isl_basic_set *bset);
-struct isl_basic_set *isl_basic_set_lineality_space(struct isl_basic_set *bset);
+__isl_give isl_basic_set *isl_basic_set_recession_cone(
+	__isl_take isl_basic_set *bset);
+__isl_give isl_basic_set *isl_basic_set_lineality_space(
+	__isl_take isl_basic_set *bset);
+__isl_give isl_basic_set *isl_set_combined_lineality_space(
+	__isl_take isl_set *set);
 
-struct isl_basic_set *isl_basic_set_set_rational(struct isl_basic_set *bset);
+__isl_give isl_basic_set *isl_basic_set_set_integral(
+	__isl_take isl_basic_set *bset);
+__isl_give isl_basic_set *isl_basic_set_set_rational(
+	__isl_take isl_basic_set *bset);
 __isl_give isl_set *isl_set_set_rational(__isl_take isl_set *set);
 __isl_give isl_basic_map *isl_basic_map_set_rational(
 	__isl_take isl_basic_map *bmap);
 __isl_give isl_map *isl_map_set_rational(__isl_take isl_map *map);
 
-int isl_map_has_rational(__isl_keep isl_map *map);
-int isl_set_has_rational(__isl_keep isl_set *set);
+isl_bool isl_map_is_rational(__isl_keep isl_map *map);
+isl_bool isl_set_is_rational(__isl_keep isl_set *set);
+
+isl_bool isl_map_has_rational(__isl_keep isl_map *map);
+isl_bool isl_set_has_rational(__isl_keep isl_set *set);
+
+__isl_give isl_basic_map *isl_basic_map_from_multi_aff2(
+	__isl_take isl_multi_aff *maff, int rational);
 
 struct isl_mat;
 
-struct isl_basic_set *isl_basic_set_preimage(struct isl_basic_set *bset,
-	struct isl_mat *mat);
-struct isl_set *isl_set_preimage(struct isl_set *set, struct isl_mat *mat);
+__isl_give isl_basic_set *isl_basic_set_preimage(
+	__isl_take isl_basic_set *bset, __isl_take isl_mat *mat);
+__isl_give isl_set *isl_set_preimage(
+	__isl_take isl_set *set, __isl_take isl_mat *mat);
 
 __isl_give isl_basic_map *isl_basic_map_transform_dims(
 	__isl_take isl_basic_map *bmap, enum isl_dim_type type, unsigned first,
@@ -396,19 +411,21 @@ isl_bool isl_basic_map_contains_point(__isl_keep isl_basic_map *bmap,
 isl_bool isl_set_contains_point(__isl_keep isl_set *set,
 	__isl_keep isl_point *point);
 
-int isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,
+isl_stat isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,
 	unsigned first, unsigned n, int *signs);
-int isl_set_foreach_orthant(__isl_keep isl_set *set,
-	int (*fn)(__isl_take isl_set *orthant, int *signs, void *user),
+isl_stat isl_set_foreach_orthant(__isl_keep isl_set *set,
+	isl_stat (*fn)(__isl_take isl_set *orthant, int *signs, void *user),
 	void *user);
 
+isl_bool isl_basic_set_eq_is_stride(__isl_keep isl_basic_set *bset, int i);
+
 int isl_basic_map_add_div_constraints_var(__isl_keep isl_basic_map *bmap,
 	unsigned pos, isl_int *div);
 int isl_basic_set_add_div_constraints_var(__isl_keep isl_basic_set *bset,
 	unsigned pos, isl_int *div);
-int isl_basic_map_is_div_constraint(__isl_keep isl_basic_map *bmap,
+isl_bool isl_basic_map_is_div_constraint(__isl_keep isl_basic_map *bmap,
 	isl_int *constraint, unsigned div);
-int isl_basic_set_is_div_constraint(__isl_keep isl_basic_set *bset,
+isl_bool isl_basic_set_is_div_constraint(__isl_keep isl_basic_set *bset,
 	isl_int *constraint, unsigned div);
 
 __isl_give isl_basic_set *isl_basic_set_from_local_space(
@@ -420,9 +437,17 @@ __isl_give isl_basic_set *isl_basic_set_expand_divs(
 __isl_give isl_basic_map *isl_basic_map_expand_divs(
 	__isl_take isl_basic_set *bmap, __isl_take isl_mat *div, int *exp);
 
+int isl_basic_set_n_equality(__isl_keep isl_basic_set *bset);
+int isl_basic_map_n_equality(__isl_keep isl_basic_map *bmap);
+int isl_basic_set_n_inequality(__isl_keep isl_basic_set *bset);
+int isl_basic_map_n_inequality(__isl_keep isl_basic_map *bmap);
+
 __isl_give isl_basic_map *isl_basic_map_mark_div_unknown(
 	__isl_take isl_basic_map *bmap, int div);
+isl_bool isl_basic_map_div_is_marked_unknown(__isl_keep isl_basic_map *bmap,
+	int div);
 isl_bool isl_basic_map_div_is_known(__isl_keep isl_basic_map *bmap, int div);
+int isl_basic_set_first_unknown_div(__isl_keep isl_basic_set *bset);
 int isl_basic_map_first_unknown_div(__isl_keep isl_basic_map *bmap);
 isl_bool isl_basic_map_divs_known(__isl_keep isl_basic_map *bmap);
 isl_bool isl_map_divs_known(__isl_keep isl_map *map);
@@ -432,6 +457,17 @@ __isl_give isl_mat *isl_basic_map_get_divs(__isl_keep isl_basic_map *bmap);
 __isl_give isl_map *isl_map_inline_foreach_basic_map(__isl_take isl_map *map,
 	__isl_give isl_basic_map *(*fn)(__isl_take isl_basic_map *bmap));
 
+isl_stat isl_map_check_named_params(__isl_keep isl_map *map);
+
+isl_bool isl_map_has_equal_params(__isl_keep isl_map *map1,
+	__isl_keep isl_map *map2);
+isl_bool isl_basic_set_space_has_equal_params(__isl_keep isl_basic_set *bset,
+	__isl_keep isl_space *space);
+isl_bool isl_set_space_has_equal_params(__isl_keep isl_set *set,
+	__isl_keep isl_space *space);
+isl_bool isl_map_space_has_equal_params(__isl_keep isl_map *map,
+	__isl_keep isl_space *space);
+
 __isl_give isl_map *isl_map_align_params_map_map_and(
 	__isl_take isl_map *map1, __isl_take isl_map *map2,
 	__isl_give isl_map *(*fn)(__isl_take isl_map *map1,
@@ -440,13 +476,9 @@ isl_bool isl_map_align_params_map_map_and_test(__isl_keep isl_map *map1,
 	__isl_keep isl_map *map2,
 	isl_bool (*fn)(__isl_keep isl_map *map1, __isl_keep isl_map *map2));
 
-int isl_basic_map_foreach_lexopt(__isl_keep isl_basic_map *bmap, int max,
-	int (*fn)(__isl_take isl_basic_set *dom, __isl_take isl_aff_list *list,
-		  void *user),
-	void *user);
-int isl_basic_set_foreach_lexopt(__isl_keep isl_basic_set *bset, int max,
-	int (*fn)(__isl_take isl_basic_set *dom, __isl_take isl_aff_list *list,
-		  void *user),
+isl_stat isl_basic_map_foreach_lexopt(__isl_keep isl_basic_map *bmap, int max,
+	isl_stat (*fn)(__isl_take isl_basic_set *dom,
+		__isl_take isl_aff_list *list, void *user),
 	void *user);
 
 __isl_give isl_set *isl_set_substitute(__isl_take isl_set *set,
@@ -455,27 +487,32 @@ __isl_give isl_set *isl_set_substitute(__isl_take isl_set *set,
 __isl_give isl_set *isl_set_gist_params_basic_set(__isl_take isl_set *set,
 	__isl_take isl_basic_set *context);
 
-int isl_map_compatible_range(__isl_keep isl_map *map, __isl_keep isl_set *set);
+isl_bool isl_map_compatible_range(__isl_keep isl_map *map,
+	__isl_keep isl_set *set);
 
 isl_bool isl_basic_map_plain_is_non_empty(__isl_keep isl_basic_map *bmap);
 isl_bool isl_basic_map_plain_is_single_valued(__isl_keep isl_basic_map *bmap);
 
-int isl_map_is_set(__isl_keep isl_map *map);
+isl_bool isl_map_is_set(__isl_keep isl_map *map);
 
-int isl_basic_set_plain_dim_is_fixed(__isl_keep isl_basic_set *bset,
+isl_bool isl_basic_set_plain_dim_is_fixed(__isl_keep isl_basic_set *bset,
 	unsigned dim, isl_int *val);
 
+__isl_give isl_set *isl_set_plain_gist_basic_set(__isl_take isl_set *set,
+	__isl_take isl_basic_set *context);
 __isl_give isl_map *isl_map_plain_gist_basic_map(__isl_take isl_map *map,
 	__isl_take isl_basic_map *context);
+__isl_give isl_map *isl_map_plain_gist(__isl_take isl_map *map,
+	__isl_take isl_map *context);
 
 __isl_give isl_basic_set *isl_basic_set_plain_affine_hull(
 	__isl_take isl_basic_set *bset);
 __isl_give isl_basic_map *isl_basic_map_plain_affine_hull(
 	__isl_take isl_basic_map *bmap);
 
-int isl_basic_set_dim_residue_class(struct isl_basic_set *bset,
+isl_stat isl_basic_set_dim_residue_class(__isl_keep isl_basic_set *bset,
 	int pos, isl_int *modulo, isl_int *residue);
-int isl_set_dim_residue_class(struct isl_set *set,
+isl_stat isl_set_dim_residue_class(__isl_keep isl_set *set,
 	int pos, isl_int *modulo, isl_int *residue);
 
 __isl_give isl_basic_set *isl_basic_set_fix(__isl_take isl_basic_set *bset,
@@ -484,7 +521,7 @@ __isl_give isl_basic_map *isl_basic_map_fix(__isl_take isl_basic_map *bmap,
 	enum isl_dim_type type, unsigned pos, isl_int value);
 __isl_give isl_set *isl_set_fix(__isl_take isl_set *set,
 	enum isl_dim_type type, unsigned pos, isl_int value);
-int isl_map_plain_is_fixed(__isl_keep isl_map *map,
+isl_bool isl_map_plain_is_fixed(__isl_keep isl_map *map,
 	enum isl_dim_type type, unsigned pos, isl_int *val);
 
 int isl_basic_map_output_defining_equality(__isl_keep isl_basic_map *bmap,
@@ -505,4 +542,16 @@ int isl_basic_set_count_upto(__isl_keep isl_basic_set *bset,
 	isl_int max, isl_int *count);
 int isl_set_count_upto(__isl_keep isl_set *set, isl_int max, isl_int *count);
 
+__isl_give isl_mat *isl_basic_set_extract_equalities(
+	__isl_keep isl_basic_set *bset);
+
+isl_bool isl_basic_map_equal_div_expr_part(__isl_keep isl_basic_map *bmap1,
+	int pos1, __isl_keep isl_basic_map *bmap2, int pos2,
+	unsigned first, unsigned n);
+isl_bool isl_basic_map_equal_div_expr_except_constant(
+	__isl_keep isl_basic_map *bmap1, int pos1,
+	__isl_keep isl_basic_map *bmap2, int pos2);
+__isl_give isl_basic_map *isl_basic_map_set_div_expr_constant_num_si_inplace(
+	__isl_take isl_basic_map *bmap, int div, int value);
+
 #endif
diff --git a/lib/Analysis/isl/isl_map_simplify.c b/lib/Analysis/isl/isl_map_simplify.c
index e4102dd..06806d9 100644
--- a/lib/Analysis/isl/isl_map_simplify.c
+++ b/lib/Analysis/isl/isl_map_simplify.c
@@ -23,6 +23,11 @@
 #include <isl_mat_private.h>
 #include <isl_vec_private.h>
 
+#include <bset_to_bmap.c>
+#include <bset_from_bmap.c>
+#include <set_to_map.c>
+#include <set_from_map.c>
+
 static void swap_equality(struct isl_basic_map *bmap, int a, int b)
 {
 	isl_int *t = bmap->eq[a];
@@ -39,284 +44,8 @@ static void swap_inequality(struct isl_basic_map *bmap, int a, int b)
 	}
 }
 
-static void constraint_drop_vars(isl_int *c, unsigned n, unsigned rem)
-{
-	isl_seq_cpy(c, c + n, rem);
-	isl_seq_clr(c + rem, n);
-}
-
-/* Drop n dimensions starting at first.
- *
- * In principle, this frees up some extra variables as the number
- * of columns remains constant, but we would have to extend
- * the div array too as the number of rows in this array is assumed
- * to be equal to extra.
- */
-struct isl_basic_set *isl_basic_set_drop_dims(
-		struct isl_basic_set *bset, unsigned first, unsigned n)
-{
-	int i;
-
-	if (!bset)
-		goto error;
-
-	isl_assert(bset->ctx, first + n <= bset->dim->n_out, goto error);
-
-	if (n == 0 && !isl_space_get_tuple_name(bset->dim, isl_dim_set))
-		return bset;
-
-	bset = isl_basic_set_cow(bset);
-	if (!bset)
-		return NULL;
-
-	for (i = 0; i < bset->n_eq; ++i)
-		constraint_drop_vars(bset->eq[i]+1+bset->dim->nparam+first, n,
-				     (bset->dim->n_out-first-n)+bset->extra);
-
-	for (i = 0; i < bset->n_ineq; ++i)
-		constraint_drop_vars(bset->ineq[i]+1+bset->dim->nparam+first, n,
-				     (bset->dim->n_out-first-n)+bset->extra);
-
-	for (i = 0; i < bset->n_div; ++i)
-		constraint_drop_vars(bset->div[i]+1+1+bset->dim->nparam+first, n,
-				     (bset->dim->n_out-first-n)+bset->extra);
-
-	bset->dim = isl_space_drop_outputs(bset->dim, first, n);
-	if (!bset->dim)
-		goto error;
-
-	ISL_F_CLR(bset, ISL_BASIC_SET_NORMALIZED);
-	bset = isl_basic_set_simplify(bset);
-	return isl_basic_set_finalize(bset);
-error:
-	isl_basic_set_free(bset);
-	return NULL;
-}
-
-struct isl_set *isl_set_drop_dims(
-		struct isl_set *set, unsigned first, unsigned n)
-{
-	int i;
-
-	if (!set)
-		goto error;
-
-	isl_assert(set->ctx, first + n <= set->dim->n_out, goto error);
-
-	if (n == 0 && !isl_space_get_tuple_name(set->dim, isl_dim_set))
-		return set;
-	set = isl_set_cow(set);
-	if (!set)
-		goto error;
-	set->dim = isl_space_drop_outputs(set->dim, first, n);
-	if (!set->dim)
-		goto error;
-
-	for (i = 0; i < set->n; ++i) {
-		set->p[i] = isl_basic_set_drop_dims(set->p[i], first, n);
-		if (!set->p[i])
-			goto error;
-	}
-
-	ISL_F_CLR(set, ISL_SET_NORMALIZED);
-	return set;
-error:
-	isl_set_free(set);
-	return NULL;
-}
-
-/* Move "n" divs starting at "first" to the end of the list of divs.
- */
-static struct isl_basic_map *move_divs_last(struct isl_basic_map *bmap,
-	unsigned first, unsigned n)
-{
-	isl_int **div;
-	int i;
-
-	if (first + n == bmap->n_div)
-		return bmap;
-
-	div = isl_alloc_array(bmap->ctx, isl_int *, n);
-	if (!div)
-		goto error;
-	for (i = 0; i < n; ++i)
-		div[i] = bmap->div[first + i];
-	for (i = 0; i < bmap->n_div - first - n; ++i)
-		bmap->div[first + i] = bmap->div[first + n + i];
-	for (i = 0; i < n; ++i)
-		bmap->div[bmap->n_div - n + i] = div[i];
-	free(div);
-	return bmap;
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
-}
-
-/* Drop "n" dimensions of type "type" starting at "first".
- *
- * In principle, this frees up some extra variables as the number
- * of columns remains constant, but we would have to extend
- * the div array too as the number of rows in this array is assumed
- * to be equal to extra.
- */
-struct isl_basic_map *isl_basic_map_drop(struct isl_basic_map *bmap,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	int i;
-	unsigned dim;
-	unsigned offset;
-	unsigned left;
-
-	if (!bmap)
-		goto error;
-
-	dim = isl_basic_map_dim(bmap, type);
-	isl_assert(bmap->ctx, first + n <= dim, goto error);
-
-	if (n == 0 && !isl_space_is_named_or_nested(bmap->dim, type))
-		return bmap;
-
-	bmap = isl_basic_map_cow(bmap);
-	if (!bmap)
-		return NULL;
-
-	offset = isl_basic_map_offset(bmap, type) + first;
-	left = isl_basic_map_total_dim(bmap) - (offset - 1) - n;
-	for (i = 0; i < bmap->n_eq; ++i)
-		constraint_drop_vars(bmap->eq[i]+offset, n, left);
-
-	for (i = 0; i < bmap->n_ineq; ++i)
-		constraint_drop_vars(bmap->ineq[i]+offset, n, left);
-
-	for (i = 0; i < bmap->n_div; ++i)
-		constraint_drop_vars(bmap->div[i]+1+offset, n, left);
-
-	if (type == isl_dim_div) {
-		bmap = move_divs_last(bmap, first, n);
-		if (!bmap)
-			goto error;
-		isl_basic_map_free_div(bmap, n);
-	} else
-		bmap->dim = isl_space_drop_dims(bmap->dim, type, first, n);
-	if (!bmap->dim)
-		goto error;
-
-	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
-	bmap = isl_basic_map_simplify(bmap);
-	return isl_basic_map_finalize(bmap);
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
-}
-
-__isl_give isl_basic_set *isl_basic_set_drop(__isl_take isl_basic_set *bset,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	return (isl_basic_set *)isl_basic_map_drop((isl_basic_map *)bset,
-							type, first, n);
-}
-
-struct isl_basic_map *isl_basic_map_drop_inputs(
-		struct isl_basic_map *bmap, unsigned first, unsigned n)
-{
-	return isl_basic_map_drop(bmap, isl_dim_in, first, n);
-}
-
-struct isl_map *isl_map_drop(struct isl_map *map,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	int i;
-
-	if (!map)
-		goto error;
-
-	isl_assert(map->ctx, first + n <= isl_map_dim(map, type), goto error);
-
-	if (n == 0 && !isl_space_get_tuple_name(map->dim, type))
-		return map;
-	map = isl_map_cow(map);
-	if (!map)
-		goto error;
-	map->dim = isl_space_drop_dims(map->dim, type, first, n);
-	if (!map->dim)
-		goto error;
-
-	for (i = 0; i < map->n; ++i) {
-		map->p[i] = isl_basic_map_drop(map->p[i], type, first, n);
-		if (!map->p[i])
-			goto error;
-	}
-	ISL_F_CLR(map, ISL_MAP_NORMALIZED);
-
-	return map;
-error:
-	isl_map_free(map);
-	return NULL;
-}
-
-struct isl_set *isl_set_drop(struct isl_set *set,
-	enum isl_dim_type type, unsigned first, unsigned n)
-{
-	return (isl_set *)isl_map_drop((isl_map *)set, type, first, n);
-}
-
-struct isl_map *isl_map_drop_inputs(
-		struct isl_map *map, unsigned first, unsigned n)
-{
-	return isl_map_drop(map, isl_dim_in, first, n);
-}
-
-/*
- * We don't cow, as the div is assumed to be redundant.
- */
-static struct isl_basic_map *isl_basic_map_drop_div(
-		struct isl_basic_map *bmap, unsigned div)
-{
-	int i;
-	unsigned pos;
-
-	if (!bmap)
-		goto error;
-
-	pos = 1 + isl_space_dim(bmap->dim, isl_dim_all) + div;
-
-	isl_assert(bmap->ctx, div < bmap->n_div, goto error);
-
-	for (i = 0; i < bmap->n_eq; ++i)
-		constraint_drop_vars(bmap->eq[i]+pos, 1, bmap->extra-div-1);
-
-	for (i = 0; i < bmap->n_ineq; ++i) {
-		if (!isl_int_is_zero(bmap->ineq[i][pos])) {
-			isl_basic_map_drop_inequality(bmap, i);
-			--i;
-			continue;
-		}
-		constraint_drop_vars(bmap->ineq[i]+pos, 1, bmap->extra-div-1);
-	}
-
-	for (i = 0; i < bmap->n_div; ++i)
-		constraint_drop_vars(bmap->div[i]+1+pos, 1, bmap->extra-div-1);
-
-	if (div != bmap->n_div - 1) {
-		int j;
-		isl_int *t = bmap->div[div];
-
-		for (j = div; j < bmap->n_div - 1; ++j)
-			bmap->div[j] = bmap->div[j+1];
-
-		bmap->div[bmap->n_div - 1] = t;
-	}
-	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
-	isl_basic_map_free_div(bmap, 1);
-
-	return bmap;
-error:
-	isl_basic_map_free(bmap);
-	return NULL;
-}
-
-struct isl_basic_map *isl_basic_map_normalize_constraints(
-	struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_normalize_constraints(
+	__isl_take isl_basic_map *bmap)
 {
 	int i;
 	isl_int gcd;
@@ -369,33 +98,46 @@ struct isl_basic_map *isl_basic_map_normalize_constraints(
 	return bmap;
 }
 
-struct isl_basic_set *isl_basic_set_normalize_constraints(
-	struct isl_basic_set *bset)
+__isl_give isl_basic_set *isl_basic_set_normalize_constraints(
+	__isl_take isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)isl_basic_map_normalize_constraints(
-		(struct isl_basic_map *)bset);
+	isl_basic_map *bmap = bset_to_bmap(bset);
+	return bset_from_bmap(isl_basic_map_normalize_constraints(bmap));
 }
 
-/* Assuming the variable at position "pos" has an integer coefficient
- * in integer division "div", extract it from this integer division.
+/* Reduce the coefficient of the variable at position "pos"
+ * in integer division "div", such that it lies in the half-open
+ * interval (1/2,1/2], extracting any excess value from this integer division.
  * "pos" is as determined by isl_basic_map_offset, i.e., pos == 0
  * corresponds to the constant term.
  *
  * That is, the integer division is of the form
  *
- *	floor((... + c * d * x_pos + ...)/d)
+ *	floor((... + (c * d + r) * x_pos + ...)/d)
  *
+ * with -d < 2 * r <= d.
  * Replace it by
  *
- *	floor((... + 0 * x_pos + ...)/d) + c * x_pos
+ *	floor((... + r * x_pos + ...)/d) + c * x_pos
+ *
+ * If 2 * ((c * d + r) % d) <= d, then c = floor((c * d + r)/d).
+ * Otherwise, c = floor((c * d + r)/d) + 1.
+ *
+ * This is the same normalization that is performed by isl_aff_floor.
  */
-static __isl_give isl_basic_map *remove_var_from_div(
+static __isl_give isl_basic_map *reduce_coefficient_in_div(
 	__isl_take isl_basic_map *bmap, int div, int pos)
 {
 	isl_int shift;
+	int add_one;
 
 	isl_int_init(shift);
-	isl_int_divexact(shift, bmap->div[div][1 + pos], bmap->div[div][0]);
+	isl_int_fdiv_r(shift, bmap->div[div][1 + pos], bmap->div[div][0]);
+	isl_int_mul_ui(shift, shift, 2);
+	add_one = isl_int_gt(shift, bmap->div[div][0]);
+	isl_int_fdiv_q(shift, bmap->div[div][1 + pos], bmap->div[div][0]);
+	if (add_one)
+		isl_int_add_ui(shift, shift, 1);
 	isl_int_neg(shift, shift);
 	bmap = isl_basic_map_shift_div(bmap, div, pos, shift);
 	isl_int_clear(shift);
@@ -403,22 +145,49 @@ static __isl_give isl_basic_map *remove_var_from_div(
 	return bmap;
 }
 
-/* Check if integer division "div" has any integral coefficient
- * (or constant term).  If so, extract them from the integer division.
+/* Does the coefficient of the variable at position "pos"
+ * in integer division "div" need to be reduced?
+ * That is, does it lie outside the half-open interval (1/2,1/2]?
+ * The coefficient c/d lies outside this interval if abs(2 * c) >= d and
+ * 2 * c != d.
+ */
+static isl_bool needs_reduction(__isl_keep isl_basic_map *bmap, int div,
+	int pos)
+{
+	isl_bool r;
+
+	if (isl_int_is_zero(bmap->div[div][1 + pos]))
+		return isl_bool_false;
+
+	isl_int_mul_ui(bmap->div[div][1 + pos], bmap->div[div][1 + pos], 2);
+	r = isl_int_abs_ge(bmap->div[div][1 + pos], bmap->div[div][0]) &&
+	    !isl_int_eq(bmap->div[div][1 + pos], bmap->div[div][0]);
+	isl_int_divexact_ui(bmap->div[div][1 + pos],
+			    bmap->div[div][1 + pos], 2);
+
+	return r;
+}
+
+/* Reduce the coefficients (including the constant term) of
+ * integer division "div", if needed.
+ * In particular, make sure all coefficients lie in
+ * the half-open interval (1/2,1/2].
  */
-static __isl_give isl_basic_map *remove_independent_vars_from_div(
+static __isl_give isl_basic_map *reduce_div_coefficients_of_div(
 	__isl_take isl_basic_map *bmap, int div)
 {
 	int i;
 	unsigned total = 1 + isl_basic_map_total_dim(bmap);
 
 	for (i = 0; i < total; ++i) {
-		if (isl_int_is_zero(bmap->div[div][1 + i]))
-			continue;
-		if (!isl_int_is_divisible_by(bmap->div[div][1 + i],
-					     bmap->div[div][0]))
+		isl_bool reduce;
+
+		reduce = needs_reduction(bmap, div, i);
+		if (reduce < 0)
+			return isl_basic_map_free(bmap);
+		if (!reduce)
 			continue;
-		bmap = remove_var_from_div(bmap, div, i);
+		bmap = reduce_coefficient_in_div(bmap, div, i);
 		if (!bmap)
 			break;
 	}
@@ -426,10 +195,12 @@ static __isl_give isl_basic_map *remove_independent_vars_from_div(
 	return bmap;
 }
 
-/* Check if any known integer division has any integral coefficient
- * (or constant term).  If so, extract them from the integer division.
+/* Reduce the coefficients (including the constant term) of
+ * the known integer divisions, if needed
+ * In particular, make sure all coefficients lie in
+ * the half-open interval (1/2,1/2].
  */
-static __isl_give isl_basic_map *remove_independent_vars_from_divs(
+static __isl_give isl_basic_map *reduce_div_coefficients(
 	__isl_take isl_basic_map *bmap)
 {
 	int i;
@@ -442,7 +213,7 @@ static __isl_give isl_basic_map *remove_independent_vars_from_divs(
 	for (i = 0; i < bmap->n_div; ++i) {
 		if (isl_int_is_zero(bmap->div[i][0]))
 			continue;
-		bmap = remove_independent_vars_from_div(bmap, i);
+		bmap = reduce_div_coefficients_of_div(bmap, i);
 		if (!bmap)
 			break;
 	}
@@ -586,7 +357,7 @@ static __isl_give isl_basic_map *eliminate_div(__isl_take isl_basic_map *bmap,
 /* Check if elimination of div "div" using equality "eq" would not
  * result in a div depending on a later div.
  */
-static int ok_to_eliminate_div(struct isl_basic_map *bmap, isl_int *eq,
+static isl_bool ok_to_eliminate_div(__isl_keep isl_basic_map *bmap, isl_int *eq,
 	unsigned div)
 {
 	int k;
@@ -596,22 +367,22 @@ static int ok_to_eliminate_div(struct isl_basic_map *bmap, isl_int *eq,
 
 	last_div = isl_seq_last_non_zero(eq + 1 + space_total, bmap->n_div);
 	if (last_div < 0 || last_div <= div)
-		return 1;
+		return isl_bool_true;
 
 	for (k = 0; k <= last_div; ++k) {
 		if (isl_int_is_zero(bmap->div[k][0]))
-			return 1;
+			continue;
 		if (!isl_int_is_zero(bmap->div[k][1 + 1 + pos]))
-			return 0;
+			return isl_bool_false;
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
-/* Elimininate divs based on equalities
+/* Eliminate divs based on equalities
  */
-static struct isl_basic_map *eliminate_divs_eq(
-		struct isl_basic_map *bmap, int *progress)
+static __isl_give isl_basic_map *eliminate_divs_eq(
+	__isl_take isl_basic_map *bmap, int *progress)
 {
 	int d;
 	int i;
@@ -627,10 +398,15 @@ static struct isl_basic_map *eliminate_divs_eq(
 
 	for (d = bmap->n_div - 1; d >= 0 ; --d) {
 		for (i = 0; i < bmap->n_eq; ++i) {
+			isl_bool ok;
+
 			if (!isl_int_is_one(bmap->eq[i][off + d]) &&
 			    !isl_int_is_negone(bmap->eq[i][off + d]))
 				continue;
-			if (!ok_to_eliminate_div(bmap, bmap->eq[i], d))
+			ok = ok_to_eliminate_div(bmap, bmap->eq[i], d);
+			if (ok < 0)
+				return isl_basic_map_free(bmap);
+			if (!ok)
 				continue;
 			modified = 1;
 			*progress = 1;
@@ -645,10 +421,10 @@ static struct isl_basic_map *eliminate_divs_eq(
 	return bmap;
 }
 
-/* Elimininate divs based on inequalities
+/* Eliminate divs based on inequalities
  */
-static struct isl_basic_map *eliminate_divs_ineq(
-		struct isl_basic_map *bmap, int *progress)
+static __isl_give isl_basic_map *eliminate_divs_ineq(
+	__isl_take isl_basic_map *bmap, int *progress)
 {
 	int d;
 	int i;
@@ -683,8 +459,90 @@ static struct isl_basic_map *eliminate_divs_ineq(
 	return bmap;
 }
 
-struct isl_basic_map *isl_basic_map_gauss(
-	struct isl_basic_map *bmap, int *progress)
+/* Does the equality constraint at position "eq" in "bmap" involve
+ * any local variables in the range [first, first + n)
+ * that are not marked as having an explicit representation?
+ */
+static isl_bool bmap_eq_involves_unknown_divs(__isl_keep isl_basic_map *bmap,
+	int eq, unsigned first, unsigned n)
+{
+	unsigned o_div;
+	int i;
+
+	if (!bmap)
+		return isl_bool_error;
+
+	o_div = isl_basic_map_offset(bmap, isl_dim_div);
+	for (i = 0; i < n; ++i) {
+		isl_bool unknown;
+
+		if (isl_int_is_zero(bmap->eq[eq][o_div + first + i]))
+			continue;
+		unknown = isl_basic_map_div_is_marked_unknown(bmap, first + i);
+		if (unknown < 0)
+			return isl_bool_error;
+		if (unknown)
+			return isl_bool_true;
+	}
+
+	return isl_bool_false;
+}
+
+/* The last local variable involved in the equality constraint
+ * at position "eq" in "bmap" is the local variable at position "div".
+ * It can therefore be used to extract an explicit representation
+ * for that variable.
+ * Do so unless the local variable already has an explicit representation or
+ * the explicit representation would involve any other local variables
+ * that in turn do not have an explicit representation.
+ * An equality constraint involving local variables without an explicit
+ * representation can be used in isl_basic_map_drop_redundant_divs
+ * to separate out an independent local variable.  Introducing
+ * an explicit representation here would block this transformation,
+ * while the partial explicit representation in itself is not very useful.
+ * Set *progress if anything is changed.
+ *
+ * The equality constraint is of the form
+ *
+ *	f(x) + n e >= 0
+ *
+ * with n a positive number.  The explicit representation derived from
+ * this constraint is
+ *
+ *	floor((-f(x))/n)
+ */
+static __isl_give isl_basic_map *set_div_from_eq(__isl_take isl_basic_map *bmap,
+	int div, int eq, int *progress)
+{
+	unsigned total, o_div;
+	isl_bool involves;
+
+	if (!bmap)
+		return NULL;
+
+	if (!isl_int_is_zero(bmap->div[div][0]))
+		return bmap;
+
+	involves = bmap_eq_involves_unknown_divs(bmap, eq, 0, div);
+	if (involves < 0)
+		return isl_basic_map_free(bmap);
+	if (involves)
+		return bmap;
+
+	total = isl_basic_map_dim(bmap, isl_dim_all);
+	o_div = isl_basic_map_offset(bmap, isl_dim_div);
+	isl_seq_neg(bmap->div[div] + 1, bmap->eq[eq], 1 + total);
+	isl_int_set_si(bmap->div[div][1 + o_div + div], 0);
+	isl_int_set(bmap->div[div][0], bmap->eq[eq][o_div + div]);
+	if (progress)
+		*progress = 1;
+	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
+
+	return bmap;
+}
+
+__isl_give isl_basic_map *isl_basic_map_gauss(__isl_take isl_basic_map *bmap,
+	int *progress)
 {
 	int k;
 	int done;
@@ -719,17 +577,11 @@ struct isl_basic_map *isl_basic_map_gauss(
 		eliminate_var_using_equality(bmap, last_var, bmap->eq[done], 1,
 						progress);
 
-		if (last_var >= total_var &&
-		    isl_int_is_zero(bmap->div[last_var - total_var][0])) {
-			unsigned div = last_var - total_var;
-			isl_seq_neg(bmap->div[div]+1, bmap->eq[done], 1+total);
-			isl_int_set_si(bmap->div[div][1+1+last_var], 0);
-			isl_int_set(bmap->div[div][0],
-				    bmap->eq[done][1+last_var]);
-			if (progress)
-				*progress = 1;
-			ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
-		}
+		if (last_var >= total_var)
+			bmap = set_div_from_eq(bmap, last_var - total_var,
+						done, progress);
+		if (!bmap)
+			return NULL;
 	}
 	if (done == bmap->n_eq)
 		return bmap;
@@ -742,11 +594,11 @@ struct isl_basic_map *isl_basic_map_gauss(
 	return bmap;
 }
 
-struct isl_basic_set *isl_basic_set_gauss(
-	struct isl_basic_set *bset, int *progress)
+__isl_give isl_basic_set *isl_basic_set_gauss(
+	__isl_take isl_basic_set *bset, int *progress)
 {
-	return (struct isl_basic_set*)isl_basic_map_gauss(
-			(struct isl_basic_map *)bset, progress);
+	return bset_from_bmap(isl_basic_map_gauss(bset_to_bmap(bset),
+							progress));
 }
 
 
@@ -837,7 +689,7 @@ static int hash_index(struct isl_constraint_index *ci,
 }
 
 static int set_hash_index(struct isl_constraint_index *ci,
-			  struct isl_basic_set *bset, int k)
+	__isl_keep isl_basic_set *bset, int k)
 {
 	return hash_index(ci, bset, k);
 }
@@ -889,8 +741,8 @@ static isl_bool constraint_index_is_redundant(struct isl_constraint_index *ci,
  * change the position of the other divs that still need to
  * be removed.
  */
-static struct isl_basic_map *remove_duplicate_divs(
-	struct isl_basic_map *bmap, int *progress)
+static __isl_give isl_basic_map *remove_duplicate_divs(
+	__isl_take isl_basic_map *bmap, int *progress)
 {
 	unsigned int size;
 	int *index;
@@ -1033,8 +885,8 @@ static int n_pure_div_eq(struct isl_basic_map *bmap)
  * we have to replace each x'', i.e., the x'_k with (g_kk = 1),
  * by the corresponding row from C_2.
  */
-static struct isl_basic_map *normalize_divs(
-	struct isl_basic_map *bmap, int *progress)
+static __isl_give isl_basic_map *normalize_divs(__isl_take isl_basic_map *bmap,
+	int *progress)
 {
 	int i, j, k;
 	int total;
@@ -1045,7 +897,7 @@ static struct isl_basic_map *normalize_divs(
 	struct isl_mat *C = NULL;
 	struct isl_mat *C2 = NULL;
 	isl_int v;
-	int *pos;
+	int *pos = NULL;
 	int dropped, needed;
 
 	if (!bmap)
@@ -1176,14 +1028,15 @@ done:
 
 	return bmap;
 error:
+	free(pos);
 	isl_mat_free(C);
 	isl_mat_free(C2);
 	isl_mat_free(T);
 	return bmap;
 }
 
-static struct isl_basic_map *set_div_from_lower_bound(
-	struct isl_basic_map *bmap, int div, int ineq)
+static __isl_give isl_basic_map *set_div_from_lower_bound(
+	__isl_take isl_basic_map *bmap, int div, int ineq)
 {
 	unsigned total = 1 + isl_space_dim(bmap->dim, isl_dim_all);
 
@@ -1202,7 +1055,7 @@ static struct isl_basic_map *set_div_from_lower_bound(
  * any other undefined divs or if any known div is defined in
  * terms of the unknown div.
  */
-static int ok_to_set_div_from_bound(struct isl_basic_map *bmap,
+static isl_bool ok_to_set_div_from_bound(__isl_keep isl_basic_map *bmap,
 	int div, int ineq)
 {
 	int j;
@@ -1215,7 +1068,7 @@ static int ok_to_set_div_from_bound(struct isl_basic_map *bmap,
 		if (isl_int_is_zero(bmap->ineq[ineq][total + j]))
 			continue;
 		if (isl_int_is_zero(bmap->div[j][0]))
-			return 0;
+			return isl_bool_false;
 	}
 
 	/* No other div defined in terms of this one => avoid loops */
@@ -1225,10 +1078,10 @@ static int ok_to_set_div_from_bound(struct isl_basic_map *bmap,
 		if (isl_int_is_zero(bmap->div[j][0]))
 			continue;
 		if (!isl_int_is_zero(bmap->div[j][1 + total + div]))
-			return 0;
+			return isl_bool_false;
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
 /* Would an expression for div "div" based on inequality "ineq" of "bmap"
@@ -1239,7 +1092,7 @@ static int ok_to_set_div_from_bound(struct isl_basic_map *bmap,
  * (disregarding the div that it would define) is in an earlier position
  * than the last variable involved in the current div expression.
  */
-static int better_div_constraint(__isl_keep isl_basic_map *bmap,
+static isl_bool better_div_constraint(__isl_keep isl_basic_map *bmap,
 	int div, int ineq)
 {
 	unsigned total = 1 + isl_space_dim(bmap->dim, isl_dim_all);
@@ -1247,11 +1100,11 @@ static int better_div_constraint(__isl_keep isl_basic_map *bmap,
 	int last_ineq;
 
 	if (isl_int_is_zero(bmap->div[div][0]))
-		return 1;
+		return isl_bool_true;
 
 	if (isl_seq_last_non_zero(bmap->ineq[ineq] + total + div + 1,
 				  bmap->n_div - (div + 1)) >= 0)
-		return 0;
+		return isl_bool_false;
 
 	last_ineq = isl_seq_last_non_zero(bmap->ineq[ineq], total + div);
 	last_div = isl_seq_last_non_zero(bmap->div[div] + 1,
@@ -1272,20 +1125,26 @@ static int better_div_constraint(__isl_keep isl_basic_map *bmap,
  * any other undefined divs or if any known div is defined in
  * terms of the unknown div.
  */
-static struct isl_basic_map *check_for_div_constraints(
-	struct isl_basic_map *bmap, int k, int l, isl_int sum, int *progress)
+static __isl_give isl_basic_map *check_for_div_constraints(
+	__isl_take isl_basic_map *bmap, int k, int l, isl_int sum,
+	int *progress)
 {
 	int i;
 	unsigned total = 1 + isl_space_dim(bmap->dim, isl_dim_all);
 
 	for (i = 0; i < bmap->n_div; ++i) {
+		isl_bool set_div;
+
 		if (isl_int_is_zero(bmap->ineq[k][total + i]))
 			continue;
 		if (isl_int_abs_ge(sum, bmap->ineq[k][total + i]))
 			continue;
-		if (!better_div_constraint(bmap, i, k))
-			continue;
-		if (!ok_to_set_div_from_bound(bmap, i, k))
+		set_div = better_div_constraint(bmap, i, k);
+		if (set_div >= 0 && set_div)
+			set_div = ok_to_set_div_from_bound(bmap, i, k);
+		if (set_div < 0)
+			return isl_basic_map_free(bmap);
+		if (!set_div)
 			break;
 		if (isl_int_is_pos(bmap->ineq[k][total + i]))
 			bmap = set_div_from_lower_bound(bmap, i, k);
@@ -1419,7 +1278,7 @@ __isl_give isl_basic_map *isl_basic_map_detect_inequality_pairs(
  * We skip integral divs, i.e., those with denominator 1, as we would
  * risk eliminating the div from the div constraints.  We do not need
  * to handle those divs here anyway since the div constraints will turn
- * out to form an equality and this equality can then be use to eliminate
+ * out to form an equality and this equality can then be used to eliminate
  * the div from all constraints.
  */
 static __isl_give isl_basic_map *eliminate_unit_divs(
@@ -1477,19 +1336,22 @@ static __isl_give isl_basic_map *eliminate_unit_divs(
 	return bmap;
 }
 
-struct isl_basic_map *isl_basic_map_simplify(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_simplify(__isl_take isl_basic_map *bmap)
 {
 	int progress = 1;
 	if (!bmap)
 		return NULL;
 	while (progress) {
+		isl_bool empty;
+
 		progress = 0;
-		if (!bmap)
-			break;
-		if (isl_basic_map_plain_is_empty(bmap))
+		empty = isl_basic_map_plain_is_empty(bmap);
+		if (empty < 0)
+			return isl_basic_map_free(bmap);
+		if (empty)
 			break;
 		bmap = isl_basic_map_normalize_constraints(bmap);
-		bmap = remove_independent_vars_from_divs(bmap);
+		bmap = reduce_div_coefficients(bmap);
 		bmap = normalize_div_expressions(bmap);
 		bmap = remove_duplicate_divs(bmap, &progress);
 		bmap = eliminate_unit_divs(bmap, &progress);
@@ -1508,18 +1370,17 @@ struct isl_basic_map *isl_basic_map_simplify(struct isl_basic_map *bmap)
 
 struct isl_basic_set *isl_basic_set_simplify(struct isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_simplify((struct isl_basic_map *)bset);
+	return bset_from_bmap(isl_basic_map_simplify(bset_to_bmap(bset)));
 }
 
 
-int isl_basic_map_is_div_constraint(__isl_keep isl_basic_map *bmap,
+isl_bool isl_basic_map_is_div_constraint(__isl_keep isl_basic_map *bmap,
 	isl_int *constraint, unsigned div)
 {
 	unsigned pos;
 
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 
 	pos = 1 + isl_space_dim(bmap->dim, isl_dim_all) + div;
 
@@ -1533,23 +1394,23 @@ int isl_basic_map_is_div_constraint(__isl_keep isl_basic_map *bmap,
 		isl_int_add(bmap->div[div][1],
 				bmap->div[div][1], bmap->div[div][0]);
 		if (!neg)
-			return 0;
+			return isl_bool_false;
 		if (isl_seq_first_non_zero(constraint+pos+1,
 					    bmap->n_div-div-1) != -1)
-			return 0;
+			return isl_bool_false;
 	} else if (isl_int_abs_eq(constraint[pos], bmap->div[div][0])) {
 		if (!isl_seq_eq(constraint, bmap->div[div]+1, pos))
-			return 0;
+			return isl_bool_false;
 		if (isl_seq_first_non_zero(constraint+pos+1,
 					    bmap->n_div-div-1) != -1)
-			return 0;
+			return isl_bool_false;
 	} else
-		return 0;
+		return isl_bool_false;
 
-	return 1;
+	return isl_bool_true;
 }
 
-int isl_basic_set_is_div_constraint(__isl_keep isl_basic_set *bset,
+isl_bool isl_basic_set_is_div_constraint(__isl_keep isl_basic_set *bset,
 	isl_int *constraint, unsigned div)
 {
 	return isl_basic_map_is_div_constraint(bset, constraint, div);
@@ -1564,30 +1425,33 @@ int isl_basic_set_is_div_constraint(__isl_keep isl_basic_set *bset,
  *
  * then it can safely be removed.
  */
-static int div_is_redundant(struct isl_basic_map *bmap, int div)
+static isl_bool div_is_redundant(__isl_keep isl_basic_map *bmap, int div)
 {
 	int i;
 	unsigned pos = 1 + isl_space_dim(bmap->dim, isl_dim_all) + div;
 
 	for (i = 0; i < bmap->n_eq; ++i)
 		if (!isl_int_is_zero(bmap->eq[i][pos]))
-			return 0;
+			return isl_bool_false;
 
 	for (i = 0; i < bmap->n_ineq; ++i) {
+		isl_bool red;
+
 		if (isl_int_is_zero(bmap->ineq[i][pos]))
 			continue;
-		if (!isl_basic_map_is_div_constraint(bmap, bmap->ineq[i], div))
-			return 0;
+		red = isl_basic_map_is_div_constraint(bmap, bmap->ineq[i], div);
+		if (red < 0 || !red)
+			return red;
 	}
 
 	for (i = 0; i < bmap->n_div; ++i) {
 		if (isl_int_is_zero(bmap->div[i][0]))
 			continue;
 		if (!isl_int_is_zero(bmap->div[i][1+pos]))
-			return 0;
+			return isl_bool_false;
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
 /*
@@ -1596,7 +1460,8 @@ static int div_is_redundant(struct isl_basic_map *bmap, int div)
  * when the divs of a basic map have been temporarily aligned
  * with the divs of another basic map.
  */
-static struct isl_basic_map *remove_redundant_divs(struct isl_basic_map *bmap)
+static __isl_give isl_basic_map *remove_redundant_divs(
+	__isl_take isl_basic_map *bmap)
 {
 	int i;
 
@@ -1604,7 +1469,12 @@ static struct isl_basic_map *remove_redundant_divs(struct isl_basic_map *bmap)
 		return NULL;
 
 	for (i = bmap->n_div-1; i >= 0; --i) {
-		if (!div_is_redundant(bmap, i))
+		isl_bool redundant;
+
+		redundant = div_is_redundant(bmap, i);
+		if (redundant < 0)
+			return isl_basic_map_free(bmap);
+		if (!redundant)
 			continue;
 		bmap = isl_basic_map_drop_div(bmap, i);
 	}
@@ -1626,7 +1496,7 @@ __isl_give isl_basic_map *isl_basic_map_mark_final(
 
 /* Mark "bmap" as final, after removing obviously redundant integer divisions.
  */
-struct isl_basic_map *isl_basic_map_finalize(struct isl_basic_map *bmap)
+__isl_give isl_basic_map *isl_basic_map_finalize(__isl_take isl_basic_map *bmap)
 {
 	bmap = remove_redundant_divs(bmap);
 	bmap = isl_basic_map_mark_final(bmap);
@@ -1635,52 +1505,15 @@ struct isl_basic_map *isl_basic_map_finalize(struct isl_basic_map *bmap)
 
 struct isl_basic_set *isl_basic_set_finalize(struct isl_basic_set *bset)
 {
-	return (struct isl_basic_set *)
-		isl_basic_map_finalize((struct isl_basic_map *)bset);
-}
-
-struct isl_set *isl_set_finalize(struct isl_set *set)
-{
-	int i;
-
-	if (!set)
-		return NULL;
-	for (i = 0; i < set->n; ++i) {
-		set->p[i] = isl_basic_set_finalize(set->p[i]);
-		if (!set->p[i])
-			goto error;
-	}
-	return set;
-error:
-	isl_set_free(set);
-	return NULL;
-}
-
-struct isl_map *isl_map_finalize(struct isl_map *map)
-{
-	int i;
-
-	if (!map)
-		return NULL;
-	for (i = 0; i < map->n; ++i) {
-		map->p[i] = isl_basic_map_finalize(map->p[i]);
-		if (!map->p[i])
-			goto error;
-	}
-	ISL_F_CLR(map, ISL_MAP_NORMALIZED);
-	return map;
-error:
-	isl_map_free(map);
-	return NULL;
+	return bset_from_bmap(isl_basic_map_finalize(bset_to_bmap(bset)));
 }
 
-
 /* Remove definition of any div that is defined in terms of the given variable.
  * The div itself is not removed.  Functions such as
  * eliminate_divs_ineq depend on the other divs remaining in place.
  */
-static struct isl_basic_map *remove_dependent_vars(struct isl_basic_map *bmap,
-									int pos)
+static __isl_give isl_basic_map *remove_dependent_vars(
+	__isl_take isl_basic_map *bmap, int pos)
 {
 	int i;
 
@@ -1702,8 +1535,8 @@ static struct isl_basic_map *remove_dependent_vars(struct isl_basic_map *bmap,
 /* Eliminate the specified variables from the constraints using
  * Fourier-Motzkin.  The variables themselves are not removed.
  */
-struct isl_basic_map *isl_basic_map_eliminate_vars(
-	struct isl_basic_map *bmap, unsigned pos, unsigned n)
+__isl_give isl_basic_map *isl_basic_map_eliminate_vars(
+	__isl_take isl_basic_map *bmap, unsigned pos, unsigned n)
 {
 	int d;
 	int i, j, k;
@@ -1799,8 +1632,8 @@ error:
 struct isl_basic_set *isl_basic_set_eliminate_vars(
 	struct isl_basic_set *bset, unsigned pos, unsigned n)
 {
-	return (struct isl_basic_set *)isl_basic_map_eliminate_vars(
-			(struct isl_basic_map *)bset, pos, n);
+	return bset_from_bmap(isl_basic_map_eliminate_vars(bset_to_bmap(bset),
+								pos, n));
 }
 
 /* Eliminate the specified n dimensions starting at first from the
@@ -1929,7 +1762,7 @@ __isl_give isl_map *isl_map_drop_constraint_involving_unknown_divs(
 /* Don't assume equalities are in order, because align_divs
  * may have changed the order of the divs.
  */
-static void compute_elimination_index(struct isl_basic_map *bmap, int *elim)
+static void compute_elimination_index(__isl_keep isl_basic_map *bmap, int *elim)
 {
 	int d, i;
 	unsigned total;
@@ -1947,13 +1780,14 @@ static void compute_elimination_index(struct isl_basic_map *bmap, int *elim)
 	}
 }
 
-static void set_compute_elimination_index(struct isl_basic_set *bset, int *elim)
+static void set_compute_elimination_index(__isl_keep isl_basic_set *bset,
+	int *elim)
 {
-	compute_elimination_index((struct isl_basic_map *)bset, elim);
+	compute_elimination_index(bset_to_bmap(bset), elim);
 }
 
 static int reduced_using_equalities(isl_int *dst, isl_int *src,
-	struct isl_basic_map *bmap, int *elim)
+	__isl_keep isl_basic_map *bmap, int *elim)
 {
 	int d;
 	int copied = 0;
@@ -1975,14 +1809,14 @@ static int reduced_using_equalities(isl_int *dst, isl_int *src,
 }
 
 static int set_reduced_using_equalities(isl_int *dst, isl_int *src,
-	struct isl_basic_set *bset, int *elim)
+	__isl_keep isl_basic_set *bset, int *elim)
 {
 	return reduced_using_equalities(dst, src,
-					(struct isl_basic_map *)bset, elim);
+					bset_to_bmap(bset), elim);
 }
 
-static struct isl_basic_set *isl_basic_set_reduce_using_equalities(
-	struct isl_basic_set *bset, struct isl_basic_set *context)
+static __isl_give isl_basic_set *isl_basic_set_reduce_using_equalities(
+	__isl_take isl_basic_set *bset, __isl_take isl_basic_set *context)
 {
 	int i;
 	int *elim;
@@ -2066,8 +1900,8 @@ error:
 	return isl_stat_error;
 }
 
-static struct isl_basic_set *remove_shifted_constraints(
-	struct isl_basic_set *bset, struct isl_basic_set *context)
+static __isl_give isl_basic_set *remove_shifted_constraints(
+	__isl_take isl_basic_set *bset, __isl_keep isl_basic_set *context)
 {
 	struct isl_constraint_index ci;
 	int k;
@@ -2501,7 +2335,6 @@ static __isl_give isl_basic_set *uset_gist_full(__isl_take isl_basic_set *bset,
 	isl_basic_set *combined = NULL;
 	struct isl_tab *tab = NULL;
 	unsigned n_eq, context_ineq;
-	unsigned total;
 
 	if (!bset || !ineq || !context)
 		goto error;
@@ -2551,7 +2384,6 @@ static __isl_give isl_basic_set *uset_gist_full(__isl_take isl_basic_set *bset,
 		goto error;
 	if (isl_tab_detect_redundant(tab) < 0)
 		goto error;
-	total = isl_basic_set_total_dim(bset);
 	for (i = bset->n_ineq - 1; i >= 0; --i) {
 		isl_basic_set *test;
 		int is_empty;
@@ -3198,8 +3030,8 @@ static __isl_give isl_basic_map *gist_strides(__isl_take isl_basic_map *bmap,
  * also simplified with respecting to the other equality constraints
  * in "bmap" and with respect to all equality constraints in "context".
  */
-struct isl_basic_map *isl_basic_map_gist(struct isl_basic_map *bmap,
-	struct isl_basic_map *context)
+__isl_give isl_basic_map *isl_basic_map_gist(__isl_take isl_basic_map *bmap,
+	__isl_take isl_basic_map *context)
 {
 	isl_basic_set *bset, *eq;
 	isl_basic_map *eq_bmap;
@@ -3539,6 +3371,34 @@ error:
 	return NULL;
 }
 
+/* Remove the constraints in "context" from "set".
+ * If any of the disjuncts in the result turns out to be the universe,
+ * then return this universe.
+ * "context" is assumed to have explicit representations
+ * for all local variables.
+ */
+__isl_give isl_set *isl_set_plain_gist_basic_set(__isl_take isl_set *set,
+	__isl_take isl_basic_set *context)
+{
+	return set_from_map(isl_map_plain_gist_basic_map(set_to_map(set),
+							bset_to_bmap(context)));
+}
+
+/* Remove the constraints in "context" from "map".
+ * If any of the disjuncts in the result turns out to be the universe,
+ * then return this universe.
+ * "context" is assumed to consist of a single disjunct and
+ * to have explicit representations for all local variables.
+ */
+__isl_give isl_map *isl_map_plain_gist(__isl_take isl_map *map,
+	__isl_take isl_map *context)
+{
+	isl_basic_map *hull;
+
+	hull = isl_map_unshifted_simple_hull(context);
+	return isl_map_plain_gist_basic_map(map, hull);
+}
+
 /* Replace "map" by a universe map in the same space and free "drop".
  */
 static __isl_give isl_map *replace_by_universe(__isl_take isl_map *map,
@@ -3644,15 +3504,15 @@ __isl_give isl_map *isl_map_gist(__isl_take isl_map *map,
 struct isl_basic_set *isl_basic_set_gist(struct isl_basic_set *bset,
 						struct isl_basic_set *context)
 {
-	return (struct isl_basic_set *)isl_basic_map_gist(
-		(struct isl_basic_map *)bset, (struct isl_basic_map *)context);
+	return bset_from_bmap(isl_basic_map_gist(bset_to_bmap(bset),
+						bset_to_bmap(context)));
 }
 
 __isl_give isl_set *isl_set_gist_basic_set(__isl_take isl_set *set,
 	__isl_take isl_basic_set *context)
 {
-	return (struct isl_set *)isl_map_gist_basic_map((struct isl_map *)set,
-					(struct isl_basic_map *)context);
+	return set_from_map(isl_map_gist_basic_map(set_to_map(set),
+					bset_to_bmap(context)));
 }
 
 __isl_give isl_set *isl_set_gist_params_basic_set(__isl_take isl_set *set,
@@ -3667,8 +3527,7 @@ __isl_give isl_set *isl_set_gist_params_basic_set(__isl_take isl_set *set,
 __isl_give isl_set *isl_set_gist(__isl_take isl_set *set,
 	__isl_take isl_set *context)
 {
-	return (struct isl_set *)isl_map_gist((struct isl_map *)set,
-					(struct isl_map *)context);
+	return set_from_map(isl_map_gist(set_to_map(set), set_to_map(context)));
 }
 
 /* Compute the gist of "bmap" with respect to the constraints "context"
@@ -3787,8 +3646,8 @@ error:
 int isl_basic_set_plain_is_disjoint(__isl_keep isl_basic_set *bset1,
 	__isl_keep isl_basic_set *bset2)
 {
-	return isl_basic_map_plain_is_disjoint((struct isl_basic_map *)bset1,
-					      (struct isl_basic_map *)bset2);
+	return isl_basic_map_plain_is_disjoint(bset_to_bmap(bset1),
+					      bset_to_bmap(bset2));
 }
 
 /* Does "test" hold for all pairs of basic maps in "map1" and "map2"?
@@ -3874,8 +3733,7 @@ isl_bool isl_map_plain_is_disjoint(__isl_keep isl_map *map1,
 	if (disjoint < 0 || disjoint)
 		return disjoint;
 
-	match = isl_space_match(map1->dim, isl_dim_param,
-				map2->dim, isl_dim_param);
+	match = isl_map_has_equal_params(map1, map2);
 	if (match < 0 || !match)
 		return match < 0 ? isl_bool_error : isl_bool_false;
 
@@ -3887,13 +3745,24 @@ isl_bool isl_map_plain_is_disjoint(__isl_keep isl_map *map1,
 }
 
 /* Are "map1" and "map2" disjoint?
+ * The parameters are assumed to have been aligned.
+ *
+ * In particular, check whether all pairs of basic maps are disjoint.
+ */
+static isl_bool isl_map_is_disjoint_aligned(__isl_keep isl_map *map1,
+	__isl_keep isl_map *map2)
+{
+	return all_pairs(map1, map2, &isl_basic_map_is_disjoint);
+}
+
+/* Are "map1" and "map2" disjoint?
  *
  * They are disjoint if they are "obviously disjoint" or if one of them
  * is empty.  Otherwise, they are not disjoint if one of them is universal.
  * If the two inputs are (obviously) equal and not empty, then they are
  * not disjoint.
  * If none of these cases apply, then check if all pairs of basic maps
- * are disjoint.
+ * are disjoint after aligning the parameters.
  */
 isl_bool isl_map_is_disjoint(__isl_keep isl_map *map1, __isl_keep isl_map *map2)
 {
@@ -3924,7 +3793,8 @@ isl_bool isl_map_is_disjoint(__isl_keep isl_map *map1, __isl_keep isl_map *map2)
 	if (intersect < 0 || intersect)
 		return isl_bool_not(intersect);
 
-	return all_pairs(map1, map2, &isl_basic_map_is_disjoint);
+	return isl_map_align_params_map_map_and_test(map1, map2,
+						&isl_map_is_disjoint_aligned);
 }
 
 /* Are "bmap1" and "bmap2" disjoint?
@@ -3980,8 +3850,7 @@ isl_bool isl_basic_set_is_disjoint(__isl_keep isl_basic_set *bset1,
 isl_bool isl_set_plain_is_disjoint(__isl_keep isl_set *set1,
 	__isl_keep isl_set *set2)
 {
-	return isl_map_plain_is_disjoint((struct isl_map *)set1,
-					(struct isl_map *)set2);
+	return isl_map_plain_is_disjoint(set_to_map(set1), set_to_map(set2));
 }
 
 /* Are "set1" and "set2" disjoint?
@@ -4018,7 +3887,7 @@ static int is_zero_or_one(isl_int v)
  * of this second div b and such that in any constraint that contains
  * a (except for the given lower and upper bound), also contains b
  * with a coefficient that is m times that of b.
- * That is, all constraints (execpt for the lower and upper bound)
+ * That is, all constraints (except for the lower and upper bound)
  * are of the form
  *
  *	e + f (a + m b) >= 0
@@ -4259,8 +4128,8 @@ static isl_bool int_between_bounds(__isl_keep isl_basic_map *bmap, int i,
  * In particular, the value attained by the bound with unit coefficient
  * can serve as this intermediate value.
  */
-static struct isl_basic_map *drop_more_redundant_divs(
-	struct isl_basic_map *bmap, int *pairs, int n)
+static __isl_give isl_basic_map *drop_more_redundant_divs(
+	__isl_take isl_basic_map *bmap, __isl_take int *pairs, int n)
 {
 	isl_ctx *ctx;
 	struct test_ineq_data data = { NULL, NULL };
@@ -4361,7 +4230,7 @@ error:
  * i.e., the coefficient of div is f.
  *
  * Otherwise, we first need to introduce div1 into the constraint.
- * Let the l be
+ * Let l be
  *
  *	div1 + f >=0
  *
@@ -4390,8 +4259,11 @@ error:
  *
  * After all constraints have been modified, we drop the lower and upper
  * bound and then drop div1.
+ * Since the new div is only placed in the same location that used
+ * to store div2, but otherwise has a different meaning, any possible
+ * explicit representation of the original div2 is removed.
  */
-static struct isl_basic_map *coalesce_divs(struct isl_basic_map *bmap,
+static __isl_give isl_basic_map *coalesce_divs(__isl_take isl_basic_map *bmap,
 	unsigned div1, unsigned div2, unsigned l, unsigned u)
 {
 	isl_ctx *ctx;
@@ -4434,6 +4306,7 @@ static struct isl_basic_map *coalesce_divs(struct isl_basic_map *bmap,
 		isl_basic_map_drop_inequality(bmap, u);
 		isl_basic_map_drop_inequality(bmap, l);
 	}
+	bmap = isl_basic_map_mark_div_unknown(bmap, div2);
 	bmap = isl_basic_map_drop_div(bmap, div1);
 	return bmap;
 }
@@ -4446,8 +4319,8 @@ static struct isl_basic_map *coalesce_divs(struct isl_basic_map *bmap,
  * is any other div "c" with which we can coalesce the div
  * and if so, perform the coalescing.
  */
-static struct isl_basic_map *coalesce_or_drop_more_redundant_divs(
-	struct isl_basic_map *bmap, int *pairs, int n)
+static __isl_give isl_basic_map *coalesce_or_drop_more_redundant_divs(
+	__isl_take isl_basic_map *bmap, int *pairs, int n)
 {
 	int i, l, u;
 	unsigned dim;
@@ -4475,8 +4348,10 @@ static struct isl_basic_map *coalesce_or_drop_more_redundant_divs(
 		}
 	}
 
-	if (ISL_F_ISSET(bmap, ISL_BASIC_MAP_EMPTY))
+	if (ISL_F_ISSET(bmap, ISL_BASIC_MAP_EMPTY)) {
+		free(pairs);
 		return bmap;
+	}
 
 	return drop_more_redundant_divs(bmap, pairs, n);
 }
@@ -4502,7 +4377,7 @@ static int is_opposite_part(__isl_keep isl_basic_map *bmap, int i, int j,
 /* Are inequality constraints "i" and "j" of "bmap" opposite to each other,
  * apart from the constant term?
  */
-static int is_opposite(__isl_keep isl_basic_map *bmap, int i, int j)
+static isl_bool is_opposite(__isl_keep isl_basic_map *bmap, int i, int j)
 {
 	unsigned total;
 
@@ -4554,41 +4429,47 @@ static __isl_give isl_basic_map *drop_redundant_divs_again(
  * in inequality constraint "ineq" of "bmap"?
  * "div" is known to have a non-zero coefficient in "ineq".
  */
-static int single_unknown(__isl_keep isl_basic_map *bmap, int ineq, int div)
+static isl_bool single_unknown(__isl_keep isl_basic_map *bmap, int ineq,
+	int div)
 {
 	int i;
 	unsigned n_div, o_div;
+	isl_bool known;
 
-	if (isl_basic_map_div_is_known(bmap, div))
-		return 0;
+	known = isl_basic_map_div_is_known(bmap, div);
+	if (known < 0 || known)
+		return isl_bool_not(known);
 	n_div = isl_basic_map_dim(bmap, isl_dim_div);
 	if (n_div == 1)
-		return 1;
+		return isl_bool_true;
 	o_div = isl_basic_map_offset(bmap, isl_dim_div);
 	for (i = 0; i < n_div; ++i) {
+		isl_bool known;
+
 		if (i == div)
 			continue;
 		if (isl_int_is_zero(bmap->ineq[ineq][o_div + i]))
 			continue;
-		if (!isl_basic_map_div_is_known(bmap, i))
-			return 0;
+		known = isl_basic_map_div_is_known(bmap, i);
+		if (known < 0 || !known)
+			return known;
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
 /* Does integer division "div" have coefficient 1 in inequality constraint
  * "ineq" of "map"?
  */
-static int has_coef_one(__isl_keep isl_basic_map *bmap, int div, int ineq)
+static isl_bool has_coef_one(__isl_keep isl_basic_map *bmap, int div, int ineq)
 {
 	unsigned o_div;
 
 	o_div = isl_basic_map_offset(bmap, isl_dim_div);
 	if (isl_int_is_one(bmap->ineq[ineq][o_div + div]))
-		return 1;
+		return isl_bool_true;
 
-	return 0;
+	return isl_bool_false;
 }
 
 /* Turn inequality constraint "ineq" of "bmap" into an equality and
@@ -4703,11 +4584,10 @@ static int lower_bound_is_cst(__isl_keep isl_basic_map *bmap, int div, int ineq)
 {
 	int i;
 	int lower = -1, upper = -1;
-	unsigned o_div, n_div;
+	unsigned o_div;
 	isl_int l, u;
 	int equal;
 
-	n_div = isl_basic_map_dim(bmap, isl_dim_div);
 	o_div = isl_basic_map_offset(bmap, isl_dim_div);
 	for (i = 0; i < bmap->n_ineq && (lower < 0 || upper < 0); ++i) {
 		if (i == ineq)
@@ -4844,6 +4724,7 @@ static __isl_give isl_basic_map *isl_basic_map_drop_redundant_divs_ineq(
 		int last_pos, last_neg;
 		int redundant;
 		int defined;
+		isl_bool opp, set_div;
 
 		defined = !isl_int_is_zero(bmap->div[i][0]);
 		for (j = i; j < bmap->n_div; ++j)
@@ -4876,14 +4757,27 @@ static __isl_give isl_basic_map *isl_basic_map_drop_redundant_divs_ineq(
 			bmap = isl_basic_map_drop_div(bmap, i);
 			return drop_redundant_divs_again(bmap, pairs, 0);
 		}
-		if (pairs[i] != 1 || !is_opposite(bmap, last_pos, last_neg)) {
-			int single, lower;
+		if (pairs[i] != 1)
+			opp = isl_bool_false;
+		else
+			opp = is_opposite(bmap, last_pos, last_neg);
+		if (opp < 0)
+			goto error;
+		if (!opp) {
+			int lower;
+			isl_bool single, one;
+
 			if (pos != 1)
 				continue;
 			single = single_unknown(bmap, last_pos, i);
+			if (single < 0)
+				goto error;
 			if (!single)
 				continue;
-			if (has_coef_one(bmap, i, last_pos))
+			one = has_coef_one(bmap, i, last_pos);
+			if (one < 0)
+				goto error;
+			if (one)
 				return set_eq_and_try_again(bmap, last_pos,
 							    pairs);
 			lower = lower_bound_is_cst(bmap, i, last_pos);
@@ -4906,7 +4800,13 @@ static __isl_give isl_basic_map *isl_basic_map_drop_redundant_divs_ineq(
 		if (redundant)
 			return drop_div_and_try_again(bmap, i,
 						    last_pos, last_neg, pairs);
-		if (!defined && ok_to_set_div_from_bound(bmap, i, last_pos)) {
+		if (defined)
+			set_div = isl_bool_false;
+		else
+			set_div = ok_to_set_div_from_bound(bmap, i, last_pos);
+		if (set_div < 0)
+			return isl_basic_map_free(bmap);
+		if (set_div) {
 			bmap = set_div_from_lower_bound(bmap, i, last_pos);
 			return drop_redundant_divs_again(bmap, pairs, 1);
 		}
@@ -4983,7 +4883,7 @@ static __isl_give isl_basic_map *isl_basic_map_preimage_vars(
 		if (preimage(bmap->ineq[i] + 1 + pos, T) < 0)
 			goto error;
 	for (i = 0; i < bmap->n_div; ++i) {
-		if (!isl_basic_map_div_is_known(bmap, i))
+		if (isl_basic_map_div_is_marked_unknown(bmap, i))
 			continue;
 		if (preimage(bmap->div[i] + 1 + 1 + pos, T) < 0)
 			goto error;
@@ -5096,37 +4996,6 @@ __isl_give isl_basic_map *isl_basic_map_drop_redundant_divs(
 	return isl_basic_map_drop_redundant_divs(bmap);
 }
 
-struct isl_basic_set *isl_basic_set_drop_redundant_divs(
-	struct isl_basic_set *bset)
-{
-	return (struct isl_basic_set *)
-	    isl_basic_map_drop_redundant_divs((struct isl_basic_map *)bset);
-}
-
-struct isl_map *isl_map_drop_redundant_divs(struct isl_map *map)
-{
-	int i;
-
-	if (!map)
-		return NULL;
-	for (i = 0; i < map->n; ++i) {
-		map->p[i] = isl_basic_map_drop_redundant_divs(map->p[i]);
-		if (!map->p[i])
-			goto error;
-	}
-	ISL_F_CLR(map, ISL_MAP_NORMALIZED);
-	return map;
-error:
-	isl_map_free(map);
-	return NULL;
-}
-
-struct isl_set *isl_set_drop_redundant_divs(struct isl_set *set)
-{
-	return (struct isl_set *)
-	    isl_map_drop_redundant_divs((struct isl_map *)set);
-}
-
 /* Does "bmap" satisfy any equality that involves more than 2 variables
  * and/or has coefficients different from -1 and 1?
  */
@@ -5211,6 +5080,13 @@ static __isl_give isl_vec *normalize_constraint(__isl_take isl_vec *v,
  * We therefore call isl_basic_map_detect_inequality_pairs,
  * which checks for such pairs of inequalities as well as eliminate_divs_eq
  * and isl_basic_map_gauss if such a pair was found.
+ *
+ * Note that this function may leave the result in an inconsistent state.
+ * In particular, the constraints may not be gaussed.
+ * Unfortunately, isl_map_coalesce actually depends on this inconsistent state
+ * for some of the test cases to pass successfully.
+ * Any potential modification of the representation is therefore only
+ * performed on a single copy of the basic map.
  */
 __isl_give isl_basic_map *isl_basic_map_reduce_coefficients(
 	__isl_take isl_basic_map *bmap)
@@ -5250,6 +5126,10 @@ __isl_give isl_basic_map *isl_basic_map_reduce_coefficients(
 		return isl_basic_map_set_to_empty(bmap);
 	}
 
+	bmap = isl_basic_map_cow(bmap);
+	if (!bmap)
+		goto error;
+
 	tightened = 0;
 	for (i = 0; i < bmap->n_ineq; ++i) {
 		isl_seq_cpy(v->el, bmap->ineq[i], 1 + total);
@@ -5304,6 +5184,8 @@ __isl_give isl_basic_map *isl_basic_map_shift_div(
 	int i;
 	unsigned total;
 
+	if (isl_int_is_zero(shift))
+		return bmap;
 	if (!bmap)
 		return NULL;
 
diff --git a/lib/Analysis/isl/isl_map_subtract.c b/lib/Analysis/isl/isl_map_subtract.c
index 036737e..df16ea9 100644
--- a/lib/Analysis/isl/isl_map_subtract.c
+++ b/lib/Analysis/isl/isl_map_subtract.c
@@ -15,6 +15,9 @@
 #include <isl_point_private.h>
 #include <isl_vec_private.h>
 
+#include <set_to_map.c>
+#include <set_from_map.c>
+
 /* Expand the constraint "c" into "v".  The initial "dim" dimensions
  * are the same, but "v" may have more divs than "c" and the divs of "c"
  * may appear in different positions in "v".
@@ -43,7 +46,7 @@ static void expand_constraint(isl_vec *v, unsigned dim,
 /* Add all constraints of bmap to tab.  The equalities of bmap
  * are added as a pair of inequalities.
  */
-static int tab_add_constraints(struct isl_tab *tab,
+static isl_stat tab_add_constraints(struct isl_tab *tab,
 	__isl_keep isl_basic_map *bmap, int *div_map)
 {
 	int i;
@@ -53,18 +56,18 @@ static int tab_add_constraints(struct isl_tab *tab,
 	isl_vec *v;
 
 	if (!tab || !bmap)
-		return -1;
+		return isl_stat_error;
 
 	tab_total = isl_basic_map_total_dim(tab->bmap);
 	bmap_total = isl_basic_map_total_dim(bmap);
 	dim = isl_space_dim(tab->bmap->dim, isl_dim_all);
 
 	if (isl_tab_extend_cons(tab, 2 * bmap->n_eq + bmap->n_ineq) < 0)
-		return -1;
+		return isl_stat_error;
 
 	v = isl_vec_alloc(bmap->ctx, 1 + tab_total);
 	if (!v)
-		return -1;
+		return isl_stat_error;
 
 	for (i = 0; i < bmap->n_eq; ++i) {
 		expand_constraint(v, dim, bmap->eq[i], div_map, bmap->n_div);
@@ -88,10 +91,10 @@ static int tab_add_constraints(struct isl_tab *tab,
 	}
 
 	isl_vec_free(v);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_vec_free(v);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Add a specific constraint of bmap (or its opposite) to tab.
@@ -103,17 +106,17 @@ error:
  * tab_add_constraints (and later removed again), so there should
  * already be a row available for the constraint.
  */
-static int tab_add_constraint(struct isl_tab *tab,
+static isl_stat tab_add_constraint(struct isl_tab *tab,
 	__isl_keep isl_basic_map *bmap, int *div_map, int c, int oppose)
 {
 	unsigned dim;
 	unsigned tab_total;
 	unsigned bmap_total;
 	isl_vec *v;
-	int r;
+	isl_stat r;
 
 	if (!tab || !bmap)
-		return -1;
+		return isl_stat_error;
 
 	tab_total = isl_basic_map_total_dim(tab->bmap);
 	bmap_total = isl_basic_map_total_dim(bmap);
@@ -121,7 +124,7 @@ static int tab_add_constraint(struct isl_tab *tab,
 
 	v = isl_vec_alloc(bmap->ctx, 1 + tab_total);
 	if (!v)
-		return -1;
+		return isl_stat_error;
 
 	if (c < 2 * bmap->n_eq) {
 		if ((c % 2) != oppose)
@@ -156,8 +159,8 @@ static int tab_add_constraint(struct isl_tab *tab,
 	return r;
 }
 
-static int tab_add_divs(struct isl_tab *tab, __isl_keep isl_basic_map *bmap,
-	int **div_map)
+static isl_stat tab_add_divs(struct isl_tab *tab,
+	__isl_keep isl_basic_map *bmap, int **div_map)
 {
 	int i, j;
 	struct isl_vec *vec;
@@ -165,20 +168,20 @@ static int tab_add_divs(struct isl_tab *tab, __isl_keep isl_basic_map *bmap,
 	unsigned dim;
 
 	if (!bmap)
-		return -1;
+		return isl_stat_error;
 	if (!bmap->n_div)
-		return 0;
+		return isl_stat_ok;
 
 	if (!*div_map)
 		*div_map = isl_alloc_array(bmap->ctx, int, bmap->n_div);
 	if (!*div_map)
-		return -1;
+		return isl_stat_error;
 
 	total = isl_basic_map_total_dim(tab->bmap);
 	dim = total - tab->bmap->n_div;
 	vec = isl_vec_alloc(bmap->ctx, 2 + total + bmap->n_div);
 	if (!vec)
-		return -1;
+		return isl_stat_error;
 
 	for (i = 0; i < bmap->n_div; ++i) {
 		isl_seq_cpy(vec->el, bmap->div[i], 2 + dim);
@@ -193,18 +196,18 @@ static int tab_add_divs(struct isl_tab *tab, __isl_keep isl_basic_map *bmap,
 		(*div_map)[i] = j;
 		if (j == tab->bmap->n_div) {
 			vec->size = 2 + dim + tab->bmap->n_div;
-			if (isl_tab_add_div(tab, vec, NULL, NULL) < 0)
+			if (isl_tab_add_div(tab, vec) < 0)
 				goto error;
 		}
 	}
 
 	isl_vec_free(vec);
 
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_vec_free(vec);
 
-	return -1;
+	return isl_stat_error;
 }
 
 /* Freeze all constraints of tableau tab.
@@ -258,7 +261,7 @@ static int n_non_redundant(isl_ctx *ctx, struct isl_tab *tab,
  * return a negative value.
  */
 struct isl_diff_collector {
-	int (*add)(struct isl_diff_collector *dc,
+	isl_stat (*add)(struct isl_diff_collector *dc,
 		    __isl_take isl_basic_map *bmap);
 };
 
@@ -468,7 +471,7 @@ struct isl_subtract_diff_collector {
 
 /* isl_subtract_diff_collector callback.
  */
-static int basic_map_subtract_add(struct isl_diff_collector *dc,
+static isl_stat basic_map_subtract_add(struct isl_diff_collector *dc,
 			    __isl_take isl_basic_map *bmap)
 {
 	struct isl_subtract_diff_collector *sdc;
@@ -477,7 +480,7 @@ static int basic_map_subtract_add(struct isl_diff_collector *dc,
 	sdc->diff = isl_map_union_disjoint(sdc->diff,
 			isl_map_from_basic_map(bmap));
 
-	return sdc->diff ? 0 : -1;
+	return sdc->diff ? isl_stat_ok : isl_stat_error;
 }
 
 /* Return the set difference between bmap and map.
@@ -579,9 +582,8 @@ __isl_give isl_map *isl_map_subtract( __isl_take isl_map *map1,
 
 struct isl_set *isl_set_subtract(struct isl_set *set1, struct isl_set *set2)
 {
-	return (struct isl_set *)
-		isl_map_subtract(
-			(struct isl_map *)set1, (struct isl_map *)set2);
+	return set_from_map(isl_map_subtract(set_to_map(set1),
+					    set_to_map(set2)));
 }
 
 /* Remove the elements of "dom" from the domain of "map".
@@ -589,9 +591,13 @@ struct isl_set *isl_set_subtract(struct isl_set *set1, struct isl_set *set2)
 static __isl_give isl_map *map_subtract_domain(__isl_take isl_map *map,
 	__isl_take isl_set *dom)
 {
+	isl_bool ok;
 	isl_map *ext_dom;
 
-	if (!isl_map_compatible_domain(map, dom))
+	ok = isl_map_compatible_domain(map, dom);
+	if (ok < 0)
+		goto error;
+	if (!ok)
 		isl_die(isl_set_get_ctx(dom), isl_error_invalid,
 			"incompatible spaces", goto error);
 	
@@ -615,9 +621,13 @@ __isl_give isl_map *isl_map_subtract_domain(__isl_take isl_map *map,
 static __isl_give isl_map *map_subtract_range(__isl_take isl_map *map,
 	__isl_take isl_set *dom)
 {
+	isl_bool ok;
 	isl_map *ext_dom;
 
-	if (!isl_map_compatible_range(map, dom))
+	ok = isl_map_compatible_range(map, dom);
+	if (ok < 0)
+		goto error;
+	if (!ok)
 		isl_die(isl_set_get_ctx(dom), isl_error_invalid,
 			"incompatible spaces", goto error);
 	
@@ -646,7 +656,7 @@ struct isl_is_empty_diff_collector {
 
 /* isl_is_empty_diff_collector callback.
  */
-static int basic_map_is_empty_add(struct isl_diff_collector *dc,
+static isl_stat basic_map_is_empty_add(struct isl_diff_collector *dc,
 			    __isl_take isl_basic_map *bmap)
 {
 	struct isl_is_empty_diff_collector *edc;
@@ -655,7 +665,7 @@ static int basic_map_is_empty_add(struct isl_diff_collector *dc,
 	edc->empty = 0;
 
 	isl_basic_map_free(bmap);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Check if bmap \ map is empty by computing this set difference
@@ -703,27 +713,27 @@ static isl_bool map_diff_is_empty(__isl_keep isl_map *map1,
 	return is_empty;
 }
 
-/* Return 1 if "bmap" contains a single element.
+/* Return true if "bmap" contains a single element.
  */
-int isl_basic_map_plain_is_singleton(__isl_keep isl_basic_map *bmap)
+isl_bool isl_basic_map_plain_is_singleton(__isl_keep isl_basic_map *bmap)
 {
 	if (!bmap)
-		return -1;
+		return isl_bool_error;
 	if (bmap->n_div)
-		return 0;
+		return isl_bool_false;
 	if (bmap->n_ineq)
-		return 0;
+		return isl_bool_false;
 	return bmap->n_eq == isl_basic_map_total_dim(bmap);
 }
 
-/* Return 1 if "map" contains a single element.
+/* Return true if "map" contains a single element.
  */
-int isl_map_plain_is_singleton(__isl_keep isl_map *map)
+isl_bool isl_map_plain_is_singleton(__isl_keep isl_map *map)
 {
 	if (!map)
-		return -1;
+		return isl_bool_error;
 	if (map->n != 1)
-		return 0;
+		return isl_bool_false;
 
 	return isl_basic_map_plain_is_singleton(map->p[0]);
 }
@@ -817,8 +827,8 @@ static isl_bool map_is_subset(__isl_keep isl_map *map1,
 	__isl_keep isl_map *map2)
 {
 	isl_bool is_subset = isl_bool_false;
-	isl_bool empty;
-	int rat1, rat2;
+	isl_bool empty, single;
+	isl_bool rat1, rat2;
 
 	if (!map1 || !map2)
 		return isl_bool_error;
@@ -848,8 +858,11 @@ static isl_bool map_is_subset(__isl_keep isl_map *map1,
 	if (isl_map_plain_is_universe(map2))
 		return isl_bool_true;
 
+	single = isl_map_plain_is_singleton(map1);
+	if (single < 0)
+		return isl_bool_error;
 	map2 = isl_map_compute_divs(isl_map_copy(map2));
-	if (isl_map_plain_is_singleton(map1)) {
+	if (single) {
 		is_subset = map_is_singleton_subset(map1, map2);
 		isl_map_free(map2);
 		return is_subset;
@@ -868,8 +881,7 @@ isl_bool isl_map_is_subset(__isl_keep isl_map *map1, __isl_keep isl_map *map2)
 
 isl_bool isl_set_is_subset(__isl_keep isl_set *set1, __isl_keep isl_set *set2)
 {
-	return isl_map_is_subset(
-			(struct isl_map *)set1, (struct isl_map *)set2);
+	return isl_map_is_subset(set_to_map(set1), set_to_map(set2));
 }
 
 __isl_give isl_map *isl_map_make_disjoint(__isl_take isl_map *map)
@@ -910,7 +922,7 @@ __isl_give isl_map *isl_map_make_disjoint(__isl_take isl_map *map)
 
 __isl_give isl_set *isl_set_make_disjoint(__isl_take isl_set *set)
 {
-	return (struct isl_set *)isl_map_make_disjoint((struct isl_map *)set);
+	return set_from_map(isl_map_make_disjoint(set_to_map(set)));
 }
 
 __isl_give isl_map *isl_map_complement(__isl_take isl_map *map)
diff --git a/lib/Analysis/isl/isl_mat.c b/lib/Analysis/isl/isl_mat.c
index b0af75e..0e9666c 100644
--- a/lib/Analysis/isl/isl_mat.c
+++ b/lib/Analysis/isl/isl_mat.c
@@ -194,7 +194,7 @@ void isl_mat_sub_neg(struct isl_ctx *ctx, isl_int **dst, isl_int **src,
 		isl_seq_neg(dst[i]+dst_col, src[i]+src_col, n_col);
 }
 
-struct isl_mat *isl_mat_copy(struct isl_mat *mat)
+__isl_give isl_mat *isl_mat_copy(__isl_keep isl_mat *mat)
 {
 	if (!mat)
 		return NULL;
@@ -203,7 +203,7 @@ struct isl_mat *isl_mat_copy(struct isl_mat *mat)
 	return mat;
 }
 
-struct isl_mat *isl_mat_dup(struct isl_mat *mat)
+__isl_give isl_mat *isl_mat_dup(__isl_keep isl_mat *mat)
 {
 	int i;
 	struct isl_mat *mat2;
@@ -218,7 +218,7 @@ struct isl_mat *isl_mat_dup(struct isl_mat *mat)
 	return mat2;
 }
 
-struct isl_mat *isl_mat_cow(struct isl_mat *mat)
+__isl_give isl_mat *isl_mat_cow(__isl_take isl_mat *mat)
 {
 	struct isl_mat *mat2;
 	if (!mat)
@@ -259,16 +259,36 @@ int isl_mat_cols(__isl_keep isl_mat *mat)
 	return mat ? mat->n_col : -1;
 }
 
-int isl_mat_get_element(__isl_keep isl_mat *mat, int row, int col, isl_int *v)
+/* Check that "col" is a valid column position for "mat".
+ */
+static isl_stat check_col(__isl_keep isl_mat *mat, int col)
 {
 	if (!mat)
-		return -1;
-	if (row < 0 || row >= mat->n_row)
-		isl_die(mat->ctx, isl_error_invalid, "row out of range",
-			return -1);
+		return isl_stat_error;
 	if (col < 0 || col >= mat->n_col)
-		isl_die(mat->ctx, isl_error_invalid, "column out of range",
-			return -1);
+		isl_die(isl_mat_get_ctx(mat), isl_error_invalid,
+			"column out of range", return isl_stat_error);
+	return isl_stat_ok;
+}
+
+/* Check that "row" is a valid row position for "mat".
+ */
+static isl_stat check_row(__isl_keep isl_mat *mat, int row)
+{
+	if (!mat)
+		return isl_stat_error;
+	if (row < 0 || row >= mat->n_row)
+		isl_die(isl_mat_get_ctx(mat), isl_error_invalid,
+			"row out of range", return isl_stat_error);
+	return isl_stat_ok;
+}
+
+int isl_mat_get_element(__isl_keep isl_mat *mat, int row, int col, isl_int *v)
+{
+	if (check_row(mat, row) < 0)
+		return -1;
+	if (check_col(mat, col) < 0)
+		return -1;
 	isl_int_set(*v, mat->row[row][col]);
 	return 0;
 }
@@ -280,15 +300,11 @@ __isl_give isl_val *isl_mat_get_element_val(__isl_keep isl_mat *mat,
 {
 	isl_ctx *ctx;
 
-	if (!mat)
+	if (check_row(mat, row) < 0)
+		return NULL;
+	if (check_col(mat, col) < 0)
 		return NULL;
 	ctx = isl_mat_get_ctx(mat);
-	if (row < 0 || row >= mat->n_row)
-		isl_die(ctx, isl_error_invalid, "row out of range",
-			return NULL);
-	if (col < 0 || col >= mat->n_col)
-		isl_die(ctx, isl_error_invalid, "column out of range",
-			return NULL);
 	return isl_val_int_from_isl_int(ctx, mat->row[row][col]);
 }
 
@@ -296,38 +312,24 @@ __isl_give isl_mat *isl_mat_set_element(__isl_take isl_mat *mat,
 	int row, int col, isl_int v)
 {
 	mat = isl_mat_cow(mat);
-	if (!mat)
-		return NULL;
-	if (row < 0 || row >= mat->n_row)
-		isl_die(mat->ctx, isl_error_invalid, "row out of range",
-			goto error);
-	if (col < 0 || col >= mat->n_col)
-		isl_die(mat->ctx, isl_error_invalid, "column out of range",
-			goto error);
+	if (check_row(mat, row) < 0)
+		return isl_mat_free(mat);
+	if (check_col(mat, col) < 0)
+		return isl_mat_free(mat);
 	isl_int_set(mat->row[row][col], v);
 	return mat;
-error:
-	isl_mat_free(mat);
-	return NULL;
 }
 
 __isl_give isl_mat *isl_mat_set_element_si(__isl_take isl_mat *mat,
 	int row, int col, int v)
 {
 	mat = isl_mat_cow(mat);
-	if (!mat)
-		return NULL;
-	if (row < 0 || row >= mat->n_row)
-		isl_die(mat->ctx, isl_error_invalid, "row out of range",
-			goto error);
-	if (col < 0 || col >= mat->n_col)
-		isl_die(mat->ctx, isl_error_invalid, "column out of range",
-			goto error);
+	if (check_row(mat, row) < 0)
+		return isl_mat_free(mat);
+	if (check_col(mat, col) < 0)
+		return isl_mat_free(mat);
 	isl_int_set_si(mat->row[row][col], v);
 	return mat;
-error:
-	isl_mat_free(mat);
-	return NULL;
 }
 
 /* Replace the element at row "row", column "col" of "mat" by "v".
@@ -365,6 +367,22 @@ __isl_give isl_mat *isl_mat_diag(isl_ctx *ctx, unsigned n_row, isl_int d)
 	return mat;
 }
 
+/* Create an "n_row" by "n_col" matrix with zero elements.
+ */
+__isl_give isl_mat *isl_mat_zero(isl_ctx *ctx, unsigned n_row, unsigned n_col)
+{
+	int i;
+	isl_mat *mat;
+
+	mat = isl_mat_alloc(ctx, n_row, n_col);
+	if (!mat)
+		return NULL;
+	for (i = 0; i < n_row; ++i)
+		isl_seq_clr(mat->row[i], n_col);
+
+	return mat;
+}
+
 __isl_give isl_mat *isl_mat_identity(isl_ctx *ctx, unsigned n_row)
 {
 	if (!ctx)
@@ -396,7 +414,8 @@ int isl_mat_is_scaled_identity(__isl_keep isl_mat *mat)
 	return 1;
 }
 
-struct isl_vec *isl_mat_vec_product(struct isl_mat *mat, struct isl_vec *vec)
+__isl_give isl_vec *isl_mat_vec_product(__isl_take isl_mat *mat,
+	__isl_take isl_vec *vec)
 {
 	int i;
 	struct isl_vec *prod;
@@ -451,7 +470,8 @@ error:
 	return NULL;
 }
 
-struct isl_vec *isl_vec_mat_product(struct isl_vec *vec, struct isl_mat *mat)
+__isl_give isl_vec *isl_vec_mat_product(__isl_take isl_vec *vec,
+	__isl_take isl_mat *mat)
 {
 	int i, j;
 	struct isl_vec *prod;
@@ -479,8 +499,8 @@ error:
 	return NULL;
 }
 
-struct isl_mat *isl_mat_aff_direct_sum(struct isl_mat *left,
-	struct isl_mat *right)
+__isl_give isl_mat *isl_mat_aff_direct_sum(__isl_take isl_mat *left,
+	__isl_take isl_mat *right)
 {
 	int i;
 	struct isl_mat *sum;
@@ -585,8 +605,8 @@ static void oppose(struct isl_mat *M, struct isl_mat **U,
  * column.
  * If U or Q are NULL, then these matrices are not computed.
  */
-struct isl_mat *isl_mat_left_hermite(struct isl_mat *M, int neg,
-	struct isl_mat **U, struct isl_mat **Q)
+__isl_give isl_mat *isl_mat_left_hermite(__isl_take isl_mat *M, int neg,
+	__isl_give isl_mat **U, __isl_give isl_mat **Q)
 {
 	isl_int c;
 	int row, col;
@@ -663,6 +683,109 @@ error:
 	return NULL;
 }
 
+/* Use row "row" of "mat" to eliminate column "col" from all other rows.
+ */
+static __isl_give isl_mat *eliminate(__isl_take isl_mat *mat, int row, int col)
+{
+	int k, nr, nc;
+	isl_ctx *ctx;
+
+	if (!mat)
+		return NULL;
+
+	ctx = isl_mat_get_ctx(mat);
+	nr = isl_mat_rows(mat);
+	nc = isl_mat_cols(mat);
+
+	for (k = 0; k < nr; ++k) {
+		if (k == row)
+			continue;
+		if (isl_int_is_zero(mat->row[k][col]))
+			continue;
+		mat = isl_mat_cow(mat);
+		if (!mat)
+			return NULL;
+		isl_seq_elim(mat->row[k], mat->row[row], col, nc, NULL);
+		isl_seq_normalize(ctx, mat->row[k], nc);
+	}
+
+	return mat;
+}
+
+/* Perform Gaussian elimination on the rows of "mat", but start
+ * from the final row and the final column.
+ * Any zero rows that result from the elimination are removed.
+ *
+ * In particular, for each column from last to first,
+ * look for the last row with a non-zero coefficient in that column,
+ * move it last (but before other rows moved last in previous steps) and
+ * use it to eliminate the column from the other rows.
+ */
+__isl_give isl_mat *isl_mat_reverse_gauss(__isl_take isl_mat *mat)
+{
+	int k, row, last, nr, nc;
+
+	if (!mat)
+		return NULL;
+
+	nr = isl_mat_rows(mat);
+	nc = isl_mat_cols(mat);
+
+	last = nc - 1;
+	for (row = nr - 1; row >= 0; --row) {
+		for (; last >= 0; --last) {
+			for (k = row; k >= 0; --k)
+				if (!isl_int_is_zero(mat->row[k][last]))
+					break;
+			if (k >= 0)
+				break;
+		}
+		if (last < 0)
+			break;
+		if (k != row)
+			mat = isl_mat_swap_rows(mat, k, row);
+		if (!mat)
+			return NULL;
+		if (isl_int_is_neg(mat->row[row][last]))
+			mat = isl_mat_row_neg(mat, row);
+		mat = eliminate(mat, row, last);
+		if (!mat)
+			return NULL;
+	}
+	mat = isl_mat_drop_rows(mat, 0, row + 1);
+
+	return mat;
+}
+
+/* Negate the lexicographically negative rows of "mat" such that
+ * all rows in the result are lexicographically non-negative.
+ */
+__isl_give isl_mat *isl_mat_lexnonneg_rows(__isl_take isl_mat *mat)
+{
+	int i, nr, nc;
+
+	if (!mat)
+		return NULL;
+
+	nr = isl_mat_rows(mat);
+	nc = isl_mat_cols(mat);
+
+	for (i = 0; i < nr; ++i) {
+		int pos;
+
+		pos = isl_seq_first_non_zero(mat->row[i], nc);
+		if (pos < 0)
+			continue;
+		if (isl_int_is_nonneg(mat->row[i][pos]))
+			continue;
+		mat = isl_mat_row_neg(mat, i);
+		if (!mat)
+			return NULL;
+	}
+
+	return mat;
+}
+
 struct isl_mat *isl_mat_right_kernel(struct isl_mat *mat)
 {
 	int i, rank;
@@ -692,7 +815,7 @@ error:
 	return NULL;
 }
 
-struct isl_mat *isl_mat_lin_to_aff(struct isl_mat *mat)
+__isl_give isl_mat *isl_mat_lin_to_aff(__isl_take isl_mat *mat)
 {
 	int i;
 	struct isl_mat *mat2;
@@ -775,11 +898,15 @@ static int row_abs_min_non_zero(isl_int **row, unsigned n_row, unsigned col)
 	return min;
 }
 
-static void inv_exchange(struct isl_mat *left, struct isl_mat *right,
-	unsigned i, unsigned j)
+static isl_stat inv_exchange(__isl_keep isl_mat **left,
+	__isl_keep isl_mat **right, unsigned i, unsigned j)
 {
-	left = isl_mat_swap_rows(left, i, j);
-	right = isl_mat_swap_rows(right, i, j);
+	*left = isl_mat_swap_rows(*left, i, j);
+	*right = isl_mat_swap_rows(*right, i, j);
+
+	if (!*left || !*right)
+		return isl_stat_error;
+	return isl_stat_ok;
 }
 
 static void inv_oppose(
@@ -803,8 +930,8 @@ static void inv_subtract(struct isl_mat *left, struct isl_mat *right,
 
 /* Compute inv(left)*right
  */
-struct isl_mat *isl_mat_inverse_product(struct isl_mat *left,
-	struct isl_mat *right)
+__isl_give isl_mat *isl_mat_inverse_product(__isl_take isl_mat *left,
+	__isl_take isl_mat *right)
 {
 	int row;
 	isl_int a, b;
@@ -837,7 +964,8 @@ struct isl_mat *isl_mat_inverse_product(struct isl_mat *left,
 		}
 		pivot += row;
 		if (pivot != row)
-			inv_exchange(left, right, pivot, row);
+			if (inv_exchange(&left, &right, pivot, row) < 0)
+				goto error;
 		if (isl_int_is_neg(left->row[row][row]))
 			inv_oppose(left, right, row);
 		first = row+1;
@@ -847,10 +975,12 @@ struct isl_mat *isl_mat_inverse_product(struct isl_mat *left,
 			isl_int_fdiv_q(a, left->row[first][row],
 					left->row[row][row]);
 			inv_subtract(left, right, row, first, a);
-			if (!isl_int_is_zero(left->row[first][row]))
-				inv_exchange(left, right, row, first);
-			else
+			if (!isl_int_is_zero(left->row[first][row])) {
+				if (inv_exchange(&left, &right, row, first) < 0)
+					goto error;
+			} else {
 				++first;
+			}
 		}
 		for (i = 0; i < row; ++i) {
 			if (isl_int_is_zero(left->row[i][row]))
@@ -916,7 +1046,7 @@ void isl_mat_col_combine(struct isl_mat *mat, unsigned dst,
 	isl_int_clear(tmp);
 }
 
-struct isl_mat *isl_mat_right_inverse(struct isl_mat *mat)
+__isl_give isl_mat *isl_mat_right_inverse(__isl_take isl_mat *mat)
 {
 	struct isl_mat *inv;
 	int row;
@@ -995,7 +1125,7 @@ error:
 	return NULL;
 }
 
-struct isl_mat *isl_mat_transpose(struct isl_mat *mat)
+__isl_give isl_mat *isl_mat_transpose(__isl_take isl_mat *mat)
 {
 	struct isl_mat *transpose = NULL;
 	int i, j;
@@ -1025,7 +1155,8 @@ error:
 	return NULL;
 }
 
-struct isl_mat *isl_mat_swap_cols(struct isl_mat *mat, unsigned i, unsigned j)
+__isl_give isl_mat *isl_mat_swap_cols(__isl_take isl_mat *mat,
+	unsigned i, unsigned j)
 {
 	int r;
 
@@ -1043,7 +1174,8 @@ error:
 	return NULL;
 }
 
-struct isl_mat *isl_mat_swap_rows(struct isl_mat *mat, unsigned i, unsigned j)
+__isl_give isl_mat *isl_mat_swap_rows(__isl_take isl_mat *mat,
+	unsigned i, unsigned j)
 {
 	isl_int *t;
 
@@ -1152,8 +1284,8 @@ static int preimage(struct isl_ctx *ctx, isl_int **q, unsigned n,
  * the div array too as the number of rows in this array is assumed
  * to be equal to extra.
  */
-struct isl_basic_set *isl_basic_set_preimage(struct isl_basic_set *bset,
-	struct isl_mat *mat)
+__isl_give isl_basic_set *isl_basic_set_preimage(
+	__isl_take isl_basic_set *bset, __isl_take isl_mat *mat)
 {
 	struct isl_ctx *ctx;
 
@@ -1208,7 +1340,8 @@ error2:
 	return NULL;
 }
 
-struct isl_set *isl_set_preimage(struct isl_set *set, struct isl_mat *mat)
+__isl_give isl_set *isl_set_preimage(
+	__isl_take isl_set *set, __isl_take isl_mat *mat)
 {
 	int i;
 
@@ -1238,84 +1371,28 @@ error:
 	return NULL;
 }
 
-/* Replace the variables x starting at pos in the rows q
- * by x' with x = M x' with M the matrix mat.
+/* Replace the variables x starting at "first_col" in the rows "rows"
+ * of some coefficient matrix by x' with x = M x' with M the matrix mat.
  * That is, replace the corresponding coefficients c by c M.
  */
-static int transform(isl_ctx *ctx, isl_int **q, unsigned n,
-	unsigned pos, __isl_take isl_mat *mat)
+isl_stat isl_mat_sub_transform(isl_int **row, unsigned n_row,
+	unsigned first_col, __isl_take isl_mat *mat)
 {
 	int i;
+	isl_ctx *ctx;
 	isl_mat *t;
 
-	t = isl_mat_sub_alloc6(ctx, q, 0, n, pos, mat->n_row);
+	if (!mat)
+		return isl_stat_error;
+	ctx = isl_mat_get_ctx(mat);
+	t = isl_mat_sub_alloc6(ctx, row, 0, n_row, first_col, mat->n_row);
 	t = isl_mat_product(t, mat);
 	if (!t)
-		return -1;
-	for (i = 0; i < n; ++i)
-		isl_seq_swp_or_cpy(q[i] + pos, t->row[i], t->n_col);
+		return isl_stat_error;
+	for (i = 0; i < n_row; ++i)
+		isl_seq_swp_or_cpy(row[i] + first_col, t->row[i], t->n_col);
 	isl_mat_free(t);
-	return 0;
-}
-
-/* Replace the variables x of type "type" starting at "first" in "bmap"
- * by x' with x = M x' with M the matrix trans.
- * That is, replace the corresponding coefficients c by c M.
- *
- * The transformation matrix should be a square matrix.
- */
-__isl_give isl_basic_map *isl_basic_map_transform_dims(
-	__isl_take isl_basic_map *bmap, enum isl_dim_type type, unsigned first,
-	__isl_take isl_mat *trans)
-{
-	isl_ctx *ctx;
-	unsigned pos;
-
-	bmap = isl_basic_map_cow(bmap);
-	if (!bmap || !trans)
-		goto error;
-
-	ctx = isl_basic_map_get_ctx(bmap);
-	if (trans->n_row != trans->n_col)
-		isl_die(trans->ctx, isl_error_invalid,
-			"expecting square transformation matrix", goto error);
-	if (first + trans->n_row > isl_basic_map_dim(bmap, type))
-		isl_die(trans->ctx, isl_error_invalid,
-			"oversized transformation matrix", goto error);
-
-	pos = isl_basic_map_offset(bmap, type) + first;
-
-	if (transform(ctx, bmap->eq, bmap->n_eq, pos, isl_mat_copy(trans)) < 0)
-		goto error;
-	if (transform(ctx, bmap->ineq, bmap->n_ineq, pos,
-		      isl_mat_copy(trans)) < 0)
-		goto error;
-	if (transform(ctx, bmap->div, bmap->n_div, 1 + pos,
-		      isl_mat_copy(trans)) < 0)
-		goto error;
-
-	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED);
-	ISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED_DIVS);
-
-	isl_mat_free(trans);
-	return bmap;
-error:
-	isl_mat_free(trans);
-	isl_basic_map_free(bmap);
-	return NULL;
-}
-
-/* Replace the variables x of type "type" starting at "first" in "bset"
- * by x' with x = M x' with M the matrix trans.
- * That is, replace the corresponding coefficients c by c M.
- *
- * The transformation matrix should be a square matrix.
- */
-__isl_give isl_basic_set *isl_basic_set_transform_dims(
-	__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned first,
-	__isl_take isl_mat *trans)
-{
-	return isl_basic_map_transform_dims(bset, type, first, trans);
+	return isl_stat_ok;
 }
 
 void isl_mat_print_internal(__isl_keep isl_mat *mat, FILE *out, int indent)
@@ -1352,7 +1429,8 @@ void isl_mat_dump(__isl_keep isl_mat *mat)
 	isl_mat_print_internal(mat, stderr, 0);
 }
 
-struct isl_mat *isl_mat_drop_cols(struct isl_mat *mat, unsigned col, unsigned n)
+__isl_give isl_mat *isl_mat_drop_cols(__isl_take isl_mat *mat,
+	unsigned col, unsigned n)
 {
 	int r;
 
@@ -1372,7 +1450,8 @@ struct isl_mat *isl_mat_drop_cols(struct isl_mat *mat, unsigned col, unsigned n)
 	return mat;
 }
 
-struct isl_mat *isl_mat_drop_rows(struct isl_mat *mat, unsigned row, unsigned n)
+__isl_give isl_mat *isl_mat_drop_rows(__isl_take isl_mat *mat,
+	unsigned row, unsigned n)
 {
 	int r;
 
@@ -1522,7 +1601,66 @@ void isl_mat_col_mul(struct isl_mat *mat, int dst_col, isl_int f, int src_col)
 		isl_int_mul(mat->row[i][dst_col], f, mat->row[i][src_col]);
 }
 
-struct isl_mat *isl_mat_unimodular_complete(struct isl_mat *M, int row)
+/* Add "f" times column "src_col" to column "dst_col" of "mat" and
+ * return the result.
+ */
+__isl_give isl_mat *isl_mat_col_addmul(__isl_take isl_mat *mat, int dst_col,
+	isl_int f, int src_col)
+{
+	int i;
+
+	if (check_col(mat, dst_col) < 0 || check_col(mat, src_col) < 0)
+		return isl_mat_free(mat);
+
+	for (i = 0; i < mat->n_row; ++i) {
+		if (isl_int_is_zero(mat->row[i][src_col]))
+			continue;
+		mat = isl_mat_cow(mat);
+		if (!mat)
+			return NULL;
+		isl_int_addmul(mat->row[i][dst_col], f, mat->row[i][src_col]);
+	}
+
+	return mat;
+}
+
+/* Negate column "col" of "mat" and return the result.
+ */
+__isl_give isl_mat *isl_mat_col_neg(__isl_take isl_mat *mat, int col)
+{
+	int i;
+
+	if (check_col(mat, col) < 0)
+		return isl_mat_free(mat);
+
+	for (i = 0; i < mat->n_row; ++i) {
+		if (isl_int_is_zero(mat->row[i][col]))
+			continue;
+		mat = isl_mat_cow(mat);
+		if (!mat)
+			return NULL;
+		isl_int_neg(mat->row[i][col], mat->row[i][col]);
+	}
+
+	return mat;
+}
+
+/* Negate row "row" of "mat" and return the result.
+ */
+__isl_give isl_mat *isl_mat_row_neg(__isl_take isl_mat *mat, int row)
+{
+	if (check_row(mat, row) < 0)
+		return isl_mat_free(mat);
+	if (isl_seq_first_non_zero(mat->row[row], mat->n_col) == -1)
+		return mat;
+	mat = isl_mat_cow(mat);
+	if (!mat)
+		return NULL;
+	isl_seq_neg(mat->row[row], mat->row[row], mat->n_col);
+	return mat;
+}
+
+__isl_give isl_mat *isl_mat_unimodular_complete(__isl_take isl_mat *M, int row)
 {
 	int r;
 	struct isl_mat *H = NULL, *Q = NULL;
@@ -1584,24 +1722,24 @@ error:
 	return NULL;
 }
 
-int isl_mat_is_equal(__isl_keep isl_mat *mat1, __isl_keep isl_mat *mat2)
+isl_bool isl_mat_is_equal(__isl_keep isl_mat *mat1, __isl_keep isl_mat *mat2)
 {
 	int i;
 
 	if (!mat1 || !mat2)
-		return -1;
+		return isl_bool_error;
 
 	if (mat1->n_row != mat2->n_row)
-		return 0;
+		return isl_bool_false;
 
 	if (mat1->n_col != mat2->n_col)
-		return 0;
+		return isl_bool_false;
 
 	for (i = 0; i < mat1->n_row; ++i)
 		if (!isl_seq_eq(mat1->row[i], mat2->row[i], mat1->n_col))
-			return 0;
+			return isl_bool_false;
 
-	return 1;
+	return isl_bool_true;
 }
 
 __isl_give isl_mat *isl_mat_from_row_vec(__isl_take isl_vec *vec)
@@ -1697,12 +1835,9 @@ error:
  */
 isl_stat isl_mat_row_gcd(__isl_keep isl_mat *mat, int row, isl_int *gcd)
 {
-	if (!mat)
+	if (check_row(mat, row) < 0)
 		return isl_stat_error;
 
-	if (row < 0 || row >= mat->n_row)
-		isl_die(isl_mat_get_ctx(mat), isl_error_invalid,
-			"row out of range", return isl_stat_error);
 	isl_seq_gcd(mat->row[row], mat->n_col, gcd);
 
 	return isl_stat_ok;
@@ -1725,6 +1860,25 @@ void isl_mat_gcd(__isl_keep isl_mat *mat, isl_int *gcd)
 	isl_int_clear(g);
 }
 
+/* Return the result of scaling "mat" by a factor of "m".
+ */
+__isl_give isl_mat *isl_mat_scale(__isl_take isl_mat *mat, isl_int m)
+{
+	int i;
+
+	if (isl_int_is_one(m))
+		return mat;
+
+	mat = isl_mat_cow(mat);
+	if (!mat)
+		return NULL;
+
+	for (i = 0; i < mat->n_row; ++i)
+		isl_seq_scale(mat->row[i], mat->row[i], m, mat->n_col);
+
+	return mat;
+}
+
 __isl_give isl_mat *isl_mat_scale_down(__isl_take isl_mat *mat, isl_int m)
 {
 	int i;
diff --git a/lib/Analysis/isl/isl_mat_private.h b/lib/Analysis/isl/isl_mat_private.h
index fd808ed..7733d81 100644
--- a/lib/Analysis/isl/isl_mat_private.h
+++ b/lib/Analysis/isl/isl_mat_private.h
@@ -22,6 +22,7 @@ struct isl_mat {
 
 uint32_t isl_mat_get_hash(__isl_keep isl_mat *mat);
 
+__isl_give isl_mat *isl_mat_zero(isl_ctx *ctx, unsigned n_row, unsigned n_col);
 __isl_give isl_mat *isl_mat_sub_alloc(__isl_keep isl_mat *mat,
 	unsigned first_row, unsigned n_row, unsigned first_col, unsigned n_col);
 __isl_give isl_mat *isl_mat_sub_alloc6(isl_ctx *ctx, isl_int **row,
@@ -30,13 +31,20 @@ void isl_mat_sub_copy(struct isl_ctx *ctx, isl_int **dst, isl_int **src,
 	unsigned n_row, unsigned dst_col, unsigned src_col, unsigned n_col);
 void isl_mat_sub_neg(struct isl_ctx *ctx, isl_int **dst, isl_int **src,
 	unsigned n_row, unsigned dst_col, unsigned src_col, unsigned n_col);
+isl_stat isl_mat_sub_transform(isl_int **row, unsigned n_row,
+	unsigned first_col, __isl_take isl_mat *mat);
 __isl_give isl_mat *isl_mat_diag(isl_ctx *ctx, unsigned n_row, isl_int d);
 
+__isl_give isl_mat *isl_mat_reverse_gauss(__isl_take isl_mat *mat);
+
+__isl_give isl_mat *isl_mat_scale(__isl_take isl_mat *mat, isl_int m);
 __isl_give isl_mat *isl_mat_scale_down_row(__isl_take isl_mat *mat, int row,
 	isl_int m);
 
 __isl_give isl_vec *isl_mat_get_row(__isl_keep isl_mat *mat, unsigned row);
 
+__isl_give isl_mat *isl_mat_lexnonneg_rows(__isl_take isl_mat *mat);
+
 int isl_mat_is_scaled_identity(__isl_keep isl_mat *mat);
 
 isl_stat isl_mat_row_gcd(__isl_keep isl_mat *mat, int row, isl_int *gcd);
@@ -44,6 +52,10 @@ isl_stat isl_mat_row_gcd(__isl_keep isl_mat *mat, int row, isl_int *gcd);
 void isl_mat_col_mul(struct isl_mat *mat, int dst_col, isl_int f, int src_col);
 void isl_mat_col_submul(struct isl_mat *mat,
 			int dst_col, isl_int f, int src_col);
+__isl_give isl_mat *isl_mat_col_addmul(__isl_take isl_mat *mat, int dst_col,
+	isl_int f, int src_col);
+__isl_give isl_mat *isl_mat_col_neg(__isl_take isl_mat *mat, int col);
+__isl_give isl_mat *isl_mat_row_neg(__isl_take isl_mat *mat, int row);
 
 int isl_mat_get_element(__isl_keep isl_mat *mat, int row, int col, isl_int *v);
 __isl_give isl_mat *isl_mat_set_element(__isl_take isl_mat *mat,
diff --git a/lib/Analysis/isl/isl_maybe_map.h b/lib/Analysis/isl/isl_maybe_map.h
new file mode 100644
index 0000000..460a89e
--- /dev/null
+++ b/lib/Analysis/isl/isl_maybe_map.h
@@ -0,0 +1,10 @@
+#ifndef ISL_MAYBE_MAP_H
+#define ISL_MAYBE_MAP_H
+
+#include <isl/map_type.h>
+
+#define ISL_TYPE	isl_map
+#include <isl/maybe_templ.h>
+#undef ISL_TYPE
+
+#endif
diff --git a/lib/Analysis/isl/isl_morph.c b/lib/Analysis/isl/isl_morph.c
index 1917148..9b615f1 100644
--- a/lib/Analysis/isl/isl_morph.c
+++ b/lib/Analysis/isl/isl_morph.c
@@ -17,6 +17,7 @@
 #include <isl_mat_private.h>
 #include <isl_space_private.h>
 #include <isl_equalities.h>
+#include <isl_id_private.h>
 
 isl_ctx *isl_morph_get_ctx(__isl_keep isl_morph *morph)
 {
@@ -83,19 +84,21 @@ __isl_give isl_morph *isl_morph_cow(__isl_take isl_morph *morph)
 	return isl_morph_dup(morph);
 }
 
-void isl_morph_free(__isl_take isl_morph *morph)
+__isl_null isl_morph *isl_morph_free(__isl_take isl_morph *morph)
 {
 	if (!morph)
-		return;
+		return NULL;
 
 	if (--morph->ref > 0)
-		return;
+		return NULL;
 
 	isl_basic_set_free(morph->dom);
 	isl_basic_set_free(morph->ran);
 	isl_mat_free(morph->map);
 	isl_mat_free(morph->inv);
 	free(morph);
+
+	return NULL;
 }
 
 /* Is "morph" an identity on the parameters?
@@ -381,8 +384,9 @@ error:
 	return NULL;
 }
 
-/* Given a basic set, exploit the equalties in the basic set to construct
- * a morphishm that maps the basic set to a lower-dimensional space.
+/* Given a basic set, exploit the equalities in the basic set to construct
+ * a morphism that maps the basic set to a lower-dimensional space
+ * with identifier "id".
  * Specifically, the morphism reduces the number of dimensions of type "type".
  *
  * We first select the equalities of interest, that is those that involve
@@ -406,15 +410,16 @@ error:
  * Both matrices are extended to map the full original space to the full
  * compressed space.
  */
-__isl_give isl_morph *isl_basic_set_variable_compression(
-	__isl_keep isl_basic_set *bset, enum isl_dim_type type)
+__isl_give isl_morph *isl_basic_set_variable_compression_with_id(
+	__isl_keep isl_basic_set *bset, enum isl_dim_type type,
+	__isl_keep isl_id *id)
 {
 	unsigned otype;
 	unsigned ntype;
 	unsigned orest;
 	unsigned nrest;
 	int f_eq, n_eq;
-	isl_space *dim;
+	isl_space *space;
 	isl_mat *E, *Q, *C;
 	isl_basic_set *dom, *ran;
 
@@ -453,15 +458,27 @@ __isl_give isl_morph *isl_basic_set_variable_compression(
 	Q = isl_mat_diagonal(Q, isl_mat_identity(bset->ctx, nrest));
 	C = isl_mat_diagonal(C, isl_mat_identity(bset->ctx, nrest));
 
-	dim = isl_space_copy(bset->dim);
-	dim = isl_space_drop_dims(dim, type, 0, ntype);
-	dim = isl_space_add_dims(dim, type, ntype - n_eq);
-	ran = isl_basic_set_universe(dim);
+	space = isl_space_copy(bset->dim);
+	space = isl_space_drop_dims(space, type, 0, ntype);
+	space = isl_space_add_dims(space, type, ntype - n_eq);
+	space = isl_space_set_tuple_id(space, isl_dim_set, isl_id_copy(id));
+	ran = isl_basic_set_universe(space);
 	dom = copy_equalities(bset, f_eq, n_eq);
 
 	return isl_morph_alloc(dom, ran, Q, C);
 }
 
+/* Given a basic set, exploit the equalities in the basic set to construct
+ * a morphism that maps the basic set to a lower-dimensional space.
+ * Specifically, the morphism reduces the number of dimensions of type "type".
+ */
+__isl_give isl_morph *isl_basic_set_variable_compression(
+	__isl_keep isl_basic_set *bset, enum isl_dim_type type)
+{
+	return isl_basic_set_variable_compression_with_id(bset, type,
+							&isl_id_none);
+}
+
 /* Construct a parameter compression for "bset".
  * We basically just call isl_mat_parameter_compression with the right input
  * and then extend the resulting matrix to include the variables.
@@ -771,7 +788,7 @@ __isl_give isl_morph *isl_morph_inverse(__isl_take isl_morph *morph)
 	return morph;
 }
 
-/* We detect all the equalities first to avoid implicit equalties
+/* We detect all the equalities first to avoid implicit equalities
  * being discovered during the computations.  In particular,
  * the compression on the variables could expose additional stride
  * constraints on the parameters.  This would result in existentially
diff --git a/lib/Analysis/isl/isl_morph.h b/lib/Analysis/isl/isl_morph.h
index 4f6b8d4..8ded753 100644
--- a/lib/Analysis/isl/isl_morph.h
+++ b/lib/Analysis/isl/isl_morph.h
@@ -42,7 +42,7 @@ __isl_give isl_morph *isl_morph_alloc(
 	__isl_take isl_mat *map, __isl_take isl_mat *inv);
 __isl_give isl_morph *isl_morph_copy(__isl_keep isl_morph *morph);
 __isl_give isl_morph *isl_morph_identity(__isl_keep isl_basic_set *bset);
-void isl_morph_free(__isl_take isl_morph *morph);
+__isl_null isl_morph *isl_morph_free(__isl_take isl_morph *morph);
 
 __isl_give isl_space *isl_morph_get_dom_space(__isl_keep isl_morph *morph);
 __isl_give isl_space *isl_morph_get_ran_space(__isl_keep isl_morph *morph);
@@ -67,6 +67,9 @@ void isl_morph_dump(__isl_take isl_morph *morph);
 
 __isl_give isl_morph *isl_basic_set_variable_compression(
 	__isl_keep isl_basic_set *bset, enum isl_dim_type type);
+__isl_give isl_morph *isl_basic_set_variable_compression_with_id(
+	__isl_keep isl_basic_set *bset, enum isl_dim_type type,
+	__isl_keep isl_id *id);
 __isl_give isl_morph *isl_basic_set_parameter_compression(
 	__isl_keep isl_basic_set *bset);
 __isl_give isl_morph *isl_basic_set_full_compression(
diff --git a/lib/Analysis/isl/isl_multi_apply_templ.c b/lib/Analysis/isl/isl_multi_apply_templ.c
index d4f70b2..44fcb9a 100644
--- a/lib/Analysis/isl/isl_multi_apply_templ.c
+++ b/lib/Analysis/isl/isl_multi_apply_templ.c
@@ -56,13 +56,16 @@ static __isl_give MULTI(BASE) *FN(FN(MULTI(BASE),apply),APPLY_DOMBASE)(
 	__isl_take MULTI(BASE) *multi, __isl_take APPLY_DOM *set,
 	__isl_give EL *(*fn)(EL *el, __isl_take APPLY_DOM *set))
 {
+	isl_bool aligned;
 	isl_ctx *ctx;
 
 	if (!multi || !set)
 		goto error;
 
-	if (isl_space_match(multi->space, isl_dim_param,
-			    set->dim, isl_dim_param))
+	aligned = FN(APPLY_DOM,space_has_equal_params)(set, multi->space);
+	if (aligned < 0)
+		goto error;
+	if (aligned)
 		return FN(FN(MULTI(BASE),apply_aligned),APPLY_DOMBASE)(multi,
 								    set, fn);
 	ctx = FN(MULTI(BASE),get_ctx)(multi);
diff --git a/lib/Analysis/isl/isl_multi_templ.c b/lib/Analysis/isl/isl_multi_templ.c
index f8924dd..f2f2618 100644
--- a/lib/Analysis/isl/isl_multi_templ.c
+++ b/lib/Analysis/isl/isl_multi_templ.c
@@ -291,7 +291,7 @@ __isl_give MULTI(BASE) *FN(FN(MULTI(BASE),set),BASE)(
 {
 	isl_space *multi_space = NULL;
 	isl_space *el_space = NULL;
-	int match;
+	isl_bool match;
 
 	multi = FN(MULTI(BASE),cow)(multi);
 	if (!multi || !el)
@@ -509,13 +509,16 @@ __isl_give MULTI(BASE) *FN(MULTI(BASE),align_params)(
 	__isl_take MULTI(BASE) *multi, __isl_take isl_space *model)
 {
 	isl_ctx *ctx;
+	isl_bool equal_params;
 	isl_reordering *exp;
 
 	if (!multi || !model)
 		goto error;
 
-	if (isl_space_match(multi->space, isl_dim_param,
-			     model, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(multi->space, model);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params) {
 		isl_space_free(model);
 		return multi;
 	}
@@ -702,11 +705,11 @@ __isl_give MULTI(BASE) *FN(MULTI(BASE),drop_dims)(
 	if (first + n > dim || first + n < first)
 		isl_die(FN(MULTI(BASE),get_ctx)(multi), isl_error_invalid,
 			"index out of bounds",
-			return FN(MULTI(BASE),cow)(multi));
+			return FN(MULTI(BASE),free)(multi));
 
 	multi->space = isl_space_drop_dims(multi->space, type, first, n);
 	if (!multi->space)
-		return FN(MULTI(BASE),cow)(multi);
+		return FN(MULTI(BASE),free)(multi);
 
 	if (type == isl_dim_out) {
 		for (i = 0; i < n; ++i)
@@ -721,7 +724,7 @@ __isl_give MULTI(BASE) *FN(MULTI(BASE),drop_dims)(
 	for (i = 0; i < multi->n; ++i) {
 		multi->p[i] = FN(EL,drop_dims)(multi->p[i], type, first, n);
 		if (!multi->p[i])
-			return FN(MULTI(BASE),cow)(multi);
+			return FN(MULTI(BASE),free)(multi);
 	}
 
 	return multi;
@@ -735,11 +738,14 @@ static __isl_give MULTI(BASE) *FN(MULTI(BASE),align_params_multi_multi_and)(
 		__isl_take MULTI(BASE) *multi2))
 {
 	isl_ctx *ctx;
+	isl_bool equal_params;
 
 	if (!multi1 || !multi2)
 		goto error;
-	if (isl_space_match(multi1->space, isl_dim_param,
-			    multi2->space, isl_dim_param))
+	equal_params = isl_space_has_equal_params(multi1->space, multi2->space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return fn(multi1, multi2);
 	ctx = FN(MULTI(BASE),get_ctx)(multi1);
 	if (!isl_space_has_named_params(multi1->space) ||
@@ -1442,6 +1448,26 @@ isl_bool FN(MULTI(BASE),plain_is_equal)(__isl_keep MULTI(BASE) *multi1,
 	return isl_bool_true;
 }
 
+/* Does "multi" involve any NaNs?
+ */
+isl_bool FN(MULTI(BASE),involves_nan)(__isl_keep MULTI(BASE) *multi)
+{
+	int i;
+
+	if (!multi)
+		return isl_bool_error;
+	if (multi->n == 0)
+		return isl_bool_false;
+
+	for (i = 0; i < multi->n; ++i) {
+		isl_bool has_nan = FN(EL,involves_nan)(multi->p[i]);
+		if (has_nan < 0 || has_nan)
+			return has_nan;
+	}
+
+	return isl_bool_false;
+}
+
 #ifndef NO_DOMAIN
 /* Return the shared domain of the elements of "multi".
  */
diff --git a/lib/Analysis/isl/isl_options.c b/lib/Analysis/isl/isl_options.c
index ad6ce3d..eb3dd02 100644
--- a/lib/Analysis/isl/isl_options.c
+++ b/lib/Analysis/isl/isl_options.c
@@ -169,6 +169,8 @@ ISL_ARG_BOOL(struct isl_options, schedule_whole_component, 0,
 ISL_ARG_CHOICE(struct isl_options, schedule_algorithm, 0,
 	"schedule-algorithm", isl_schedule_algorithm_choice,
 	ISL_SCHEDULE_ALGORITHM_ISL, "scheduling algorithm to use")
+ISL_ARG_BOOL(struct isl_options, schedule_carry_self_first, 0,
+	"schedule-carry-self-first", 1, "try and carry self-dependences first")
 ISL_ARG_BOOL(struct isl_options, schedule_serialize_sccs, 0,
 	"schedule-serialize-sccs", 0,
 	"serialize strongly connected components in dependence graph")
@@ -295,6 +297,11 @@ ISL_CTX_GET_CHOICE_DEF(isl_options, struct isl_options, isl_options_args,
 	schedule_algorithm)
 
 ISL_CTX_SET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
+	schedule_carry_self_first)
+ISL_CTX_GET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
+	schedule_carry_self_first)
+
+ISL_CTX_SET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
 	schedule_serialize_sccs)
 ISL_CTX_GET_BOOL_DEF(isl_options, struct isl_options, isl_options_args,
 	schedule_serialize_sccs)
diff --git a/lib/Analysis/isl/isl_options_private.h b/lib/Analysis/isl/isl_options_private.h
index 400ba0b..13f21a7 100644
--- a/lib/Analysis/isl/isl_options_private.h
+++ b/lib/Analysis/isl/isl_options_private.h
@@ -46,6 +46,7 @@ struct isl_options {
 	int			schedule_separate_components;
 	int			schedule_whole_component;
 	unsigned		schedule_algorithm;
+	int			schedule_carry_self_first;
 	int			schedule_serialize_sccs;
 
 	int			tile_scale_tile_loops;
diff --git a/lib/Analysis/isl/isl_output.c b/lib/Analysis/isl/isl_output.c
index be78aa6..93442a9 100644
--- a/lib/Analysis/isl/isl_output.c
+++ b/lib/Analysis/isl/isl_output.c
@@ -28,10 +28,14 @@
 #include <isl_local_space_private.h>
 #include <isl_aff_private.h>
 #include <isl_val_private.h>
+#include <isl_constraint_private.h>
 #include <isl/ast_build.h>
 #include <isl_sort.h>
 #include <isl_output_private.h>
 
+#include <bset_to_bmap.c>
+#include <set_to_map.c>
+
 static const char *s_to[2] = { " -> ", " \\to " };
 static const char *s_and[2] = { " and ", " \\wedge " };
 static const char *s_or[2] = { " or ", " \\vee " };
@@ -100,7 +104,7 @@ static __isl_give isl_printer *print_constraints_polylib(
 static __isl_give isl_printer *bset_print_constraints_polylib(
 	struct isl_basic_set *bset, __isl_take isl_printer *p)
 {
-	return print_constraints_polylib((struct isl_basic_map *)bset, p);
+	return print_constraints_polylib(bset_to_bmap(bset), p);
 }
 
 static __isl_give isl_printer *isl_basic_map_print_polylib(
@@ -132,7 +136,7 @@ static __isl_give isl_printer *isl_basic_map_print_polylib(
 static __isl_give isl_printer *isl_basic_set_print_polylib(
 	__isl_keep isl_basic_set *bset, __isl_take isl_printer *p, int ext)
 {
-	return isl_basic_map_print_polylib((struct isl_basic_map *)bset, p, ext);
+	return isl_basic_map_print_polylib(bset_to_bmap(bset), p, ext);
 }
 
 static __isl_give isl_printer *isl_map_print_polylib(__isl_keep isl_map *map,
@@ -154,7 +158,7 @@ static __isl_give isl_printer *isl_map_print_polylib(__isl_keep isl_map *map,
 static __isl_give isl_printer *isl_set_print_polylib(__isl_keep isl_set *set,
 	__isl_take isl_printer *p, int ext)
 {
-	return isl_map_print_polylib((struct isl_map *)set, p, ext);
+	return isl_map_print_polylib(set_to_map(set), p, ext);
 }
 
 static int count_same_name(__isl_keep isl_space *dim,
@@ -460,10 +464,15 @@ static int next_is_opposite(__isl_keep isl_basic_map *bmap, int i, int last)
 		return 0;
 	if (isl_seq_last_non_zero(bmap->ineq[i + 1], 1 + total) != last)
 		return 0;
-	if (last >= o_div &&
-	    isl_basic_map_is_div_constraint(bmap, bmap->ineq[i + 1],
-					    last - o_div))
-		return 0;
+	if (last >= o_div) {
+		isl_bool is_div;
+		is_div = isl_basic_map_is_div_constraint(bmap,
+					    bmap->ineq[i + 1], last - o_div);
+		if (is_div < 0)
+			return -1;
+		if (is_div)
+			return 0;
+	}
 	return isl_int_abs_eq(bmap->ineq[i][last], bmap->ineq[i + 1][last]) &&
 		!isl_int_eq(bmap->ineq[i][last], bmap->ineq[i + 1][last]);
 }
@@ -497,7 +506,8 @@ static const char *constraint_op(int sign, int strict, int latex)
  * "first_constraint" is set if this is the first constraint
  * in the conjunction.
  */
-static __isl_give isl_printer *print_half_constraint(struct isl_basic_map *bmap,
+static __isl_give isl_printer *print_half_constraint(
+	__isl_keep isl_basic_map *bmap,
 	__isl_keep isl_space *space, __isl_keep isl_mat *div,
 	__isl_take isl_printer *p, isl_int *c, int last, const char *op,
 	int first_constraint, int latex)
@@ -527,7 +537,7 @@ static __isl_give isl_printer *print_half_constraint(struct isl_basic_map *bmap,
  * "first_constraint" is set if this is the first constraint
  * in the conjunction.
  */
-static __isl_give isl_printer *print_constraint(struct isl_basic_map *bmap,
+static __isl_give isl_printer *print_constraint(__isl_keep isl_basic_map *bmap,
 	__isl_keep isl_space *space, __isl_keep isl_mat *div,
 	__isl_take isl_printer *p,
 	isl_int *c, int last, const char *op, int first_constraint, int latex)
@@ -599,9 +609,13 @@ static __isl_give isl_printer *print_constraints(__isl_keep isl_basic_map *bmap,
 	unsigned total = isl_basic_map_total_dim(bmap);
 	unsigned o_div = isl_basic_map_offset(bmap, isl_dim_div);
 	int first = 1;
+	int dump;
 
+	if (!p)
+		return NULL;
 	bmap = isl_basic_map_copy(bmap);
-	if (!p->dump)
+	dump = p->dump;
+	if (!dump)
 		bmap = isl_basic_map_sort_constraints(bmap);
 	if (!bmap)
 		goto error;
@@ -633,11 +647,16 @@ static __isl_give isl_printer *print_constraints(__isl_keep isl_basic_map *bmap,
 		const char *op;
 		if (l < 0)
 			continue;
-		if (!p->dump && l >= o_div &&
-		    can_print_div_expr(p, div, l - o_div) &&
-		    isl_basic_map_is_div_constraint(bmap, bmap->ineq[i],
-						    l - o_div))
-			continue;
+		if (!dump && l >= o_div &&
+		    can_print_div_expr(p, div, l - o_div)) {
+			isl_bool is_div;
+			is_div = isl_basic_map_is_div_constraint(bmap,
+						    bmap->ineq[i], l - o_div);
+			if (is_div < 0)
+				goto error;
+			if (is_div)
+				continue;
+		}
 		s = isl_int_sgn(bmap->ineq[i][l]);
 		strict = !rational && isl_int_is_negone(bmap->ineq[i][0]);
 		if (s < 0)
@@ -646,7 +665,7 @@ static __isl_give isl_printer *print_constraints(__isl_keep isl_basic_map *bmap,
 			isl_seq_neg(c->el, bmap->ineq[i], 1 + total);
 		if (strict)
 			isl_int_set_si(c->el[0], 0);
-		if (!p->dump && next_is_opposite(bmap, i, l)) {
+		if (!dump && next_is_opposite(bmap, i, l)) {
 			op = constraint_op(-s, strict, latex);
 			p = print_half_constraint(bmap, space, div, p, c->el, l,
 						op, first, latex);
@@ -722,24 +741,52 @@ static __isl_give isl_printer *print_div_list(__isl_take isl_printer *p,
 	return p;
 }
 
-/* Does printing "bmap" require an "exists" clause?
+/* Does printing an object with local variables described by "div"
+ * require an "exists" clause?
  * That is, are there any local variables without an explicit representation?
+ * An exists clause is also needed in "dump" mode because
+ * explicit div representations are not printed inline in that case.
  */
-static isl_bool need_exists(__isl_keep isl_printer *p,
-	__isl_keep isl_basic_map *bmap, __isl_keep isl_mat *div)
+static isl_bool need_exists(__isl_keep isl_printer *p, __isl_keep isl_mat *div)
 {
-	int i;
+	int i, n;
 
-	if (!p || !bmap)
+	if (!p || !div)
 		return isl_bool_error;
-	if (bmap->n_div == 0)
+	n = isl_mat_rows(div);
+	if (n == 0)
 		return isl_bool_false;
-	for (i = 0; i < bmap->n_div; ++i)
+	if (p->dump)
+		return isl_bool_true;
+	for (i = 0; i < n; ++i)
 		if (!can_print_div_expr(p, div, i))
 			return isl_bool_true;
 	return isl_bool_false;
 }
 
+/* Print the start of an exists clause, i.e.,
+ *
+ *	(exists variables:
+ *
+ * In dump mode, local variables with an explicit definition are printed
+ * as well because they will not be printed inline.
+ */
+static __isl_give isl_printer *open_exists(__isl_take isl_printer *p,
+	__isl_keep isl_space *space, __isl_keep isl_mat *div, int latex)
+{
+	int dump;
+
+	if (!p)
+		return NULL;
+
+	dump = p->dump;
+	p = isl_printer_print_str(p, s_open_exists[latex]);
+	p = print_div_list(p, space, div, latex, dump);
+	p = isl_printer_print_str(p, ": ");
+
+	return p;
+}
+
 /* Print the constraints of "bmap" to "p".
  * The names of the variables are taken from "space".
  * "latex" is set if the constraints should be printed in LaTeX format.
@@ -748,23 +795,19 @@ static isl_bool need_exists(__isl_keep isl_printer *p,
 static __isl_give isl_printer *print_disjunct(__isl_keep isl_basic_map *bmap,
 	__isl_keep isl_space *space, __isl_take isl_printer *p, int latex)
 {
+	int dump;
 	isl_mat *div;
 	isl_bool exists;
 
 	if (!p)
 		return NULL;
+	dump = p->dump;
 	div = isl_basic_map_get_divs(bmap);
-	if (p->dump)
-		exists = bmap->n_div > 0;
-	else
-		exists = need_exists(p, bmap, div);
-	if (exists >= 0 && exists) {
-		p = isl_printer_print_str(p, s_open_exists[latex]);
-		p = print_div_list(p, space, div, latex, p->dump);
-		p = isl_printer_print_str(p, ": ");
-	}
+	exists = need_exists(p, div);
+	if (exists >= 0 && exists)
+		p = open_exists(p, space, div, latex);
 
-	if (p->dump)
+	if (dump)
 		div = isl_mat_free(div);
 	p = print_constraints(bmap, space, div, p, latex);
 	isl_mat_free(div);
@@ -842,6 +885,23 @@ static __isl_give isl_printer *isl_set_print_omega(__isl_keep isl_set *set,
 	return p;
 }
 
+/* Print the list of parameters in "space", followed by an arrow, to "p",
+ * if there are any parameters.
+ */
+static __isl_give isl_printer *print_param_tuple(__isl_take isl_printer *p,
+	__isl_keep isl_space *space, struct isl_print_space_data *data)
+{
+	if (!p || !space)
+		return isl_printer_free(p);
+	if (isl_space_dim(space, isl_dim_param) == 0)
+		return p;
+
+	p = print_tuple(space, p, isl_dim_param, data);
+	p = isl_printer_print_str(p, s_to[data->latex]);
+
+	return p;
+}
+
 static __isl_give isl_printer *isl_basic_map_print_isl(
 	__isl_keep isl_basic_map *bmap, __isl_take isl_printer *p,
 	int latex)
@@ -849,10 +909,7 @@ static __isl_give isl_printer *isl_basic_map_print_isl(
 	struct isl_print_space_data data = { .latex = latex };
 	int rational = ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);
 
-	if (isl_basic_map_dim(bmap, isl_dim_param) > 0) {
-		p = print_tuple(bmap->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, bmap->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	p = isl_print_space(bmap->dim, p, rational, &data);
 	p = isl_printer_print_str(p, " : ");
@@ -1194,6 +1251,8 @@ static __isl_give isl_printer *isl_map_print_isl_body(__isl_keep isl_map *map,
 	struct isl_aff_split *split = NULL;
 	int rational;
 
+	if (!p || !map)
+		return isl_printer_free(p);
 	if (!p->dump && map->n > 0)
 		split = split_aff(map);
 	if (split) {
@@ -1213,10 +1272,7 @@ static __isl_give isl_printer *isl_map_print_isl(__isl_keep isl_map *map,
 {
 	struct isl_print_space_data data = { 0 };
 
-	if (isl_map_dim(map, isl_dim_param) > 0) {
-		p = print_tuple(map->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, s_to[0]);
-	}
+	p = print_param_tuple(p, map->dim, &data);
 	p = isl_printer_print_str(p, s_open_set[0]);
 	p = isl_map_print_isl_body(map, p);
 	p = isl_printer_print_str(p, s_close_set[0]);
@@ -1229,10 +1285,7 @@ static __isl_give isl_printer *print_latex_map(__isl_keep isl_map *map,
 	struct isl_print_space_data data = { 0 };
 
 	data.latex = 1;
-	if (isl_map_dim(map, isl_dim_param) > 0) {
-		p = print_tuple(map->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, s_to[1]);
-	}
+	p = print_param_tuple(p, map->dim, &data);
 	p = isl_printer_print_str(p, s_open_set[1]);
 	data.print_dim = &print_dim_eq;
 	data.user = aff;
@@ -1310,7 +1363,7 @@ __isl_give isl_printer *isl_printer_print_set(__isl_take isl_printer *p,
 	if (!p || !set)
 		goto error;
 	if (p->output_format == ISL_FORMAT_ISL)
-		return isl_map_print_isl((isl_map *)set, p);
+		return isl_map_print_isl(set_to_map(set), p);
 	else if (p->output_format == ISL_FORMAT_POLYLIB)
 		return isl_set_print_polylib(set, p, 0);
 	else if (p->output_format == ISL_FORMAT_EXT_POLYLIB)
@@ -1318,7 +1371,7 @@ __isl_give isl_printer *isl_printer_print_set(__isl_take isl_printer *p,
 	else if (p->output_format == ISL_FORMAT_OMEGA)
 		return isl_set_print_omega(set, p);
 	else if (p->output_format == ISL_FORMAT_LATEX)
-		return isl_map_print_latex((isl_map *)set, p);
+		return isl_map_print_latex(set_to_map(set), p);
 	isl_assert(set->ctx, 0, goto error);
 error:
 	isl_printer_free(p);
@@ -1372,14 +1425,11 @@ static __isl_give isl_printer *isl_union_map_print_isl(
 {
 	struct isl_union_print_data data;
 	struct isl_print_space_data space_data = { 0 };
-	isl_space *dim;
+	isl_space *space;
 
-	dim = isl_union_map_get_space(umap);
-	if (isl_space_dim(dim, isl_dim_param) > 0) {
-		p = print_tuple(dim, p, isl_dim_param, &space_data);
-		p = isl_printer_print_str(p, s_to[0]);
-	}
-	isl_space_free(dim);
+	space = isl_union_map_get_space(umap);
+	p = print_param_tuple(p, space, &space_data);
+	isl_space_free(space);
 	p = isl_printer_print_str(p, s_open_set[0]);
 	data.p = p;
 	data.first = 1;
@@ -1525,14 +1575,17 @@ static __isl_give isl_printer *print_pow(__isl_take isl_printer *p,
 	return p;
 }
 
+/* Print the polynomial "up" defined over the domain space "space" and
+ * local variables defined by "div" to "p".
+ */
 static __isl_give isl_printer *upoly_print(__isl_keep struct isl_upoly *up,
-	__isl_keep isl_space *dim, __isl_keep isl_mat *div,
-	__isl_take isl_printer *p, int outer)
+	__isl_keep isl_space *space, __isl_keep isl_mat *div,
+	__isl_take isl_printer *p)
 {
 	int i, n, first, print_parens;
 	struct isl_upoly_rec *rec;
 
-	if (!p || !up || !dim || !div)
+	if (!p || !up || !space || !div)
 		goto error;
 
 	if (isl_upoly_is_cst(up))
@@ -1542,8 +1595,7 @@ static __isl_give isl_printer *upoly_print(__isl_keep struct isl_upoly *up,
 	if (!rec)
 		goto error;
 	n = upoly_rec_n_non_zero(rec);
-	print_parens = n > 1 ||
-		    (outer && rec->up.var >= isl_space_dim(dim, isl_dim_all));
+	print_parens = n > 1;
 	if (print_parens)
 		p = isl_printer_print_str(p, "(");
 	for (i = 0, first = 1; i < rec->n; ++i) {
@@ -1563,7 +1615,7 @@ static __isl_give isl_printer *upoly_print(__isl_keep struct isl_upoly *up,
 			if (!first)
 				p = isl_printer_print_str(p, " + ");
 			if (i == 0 || !isl_upoly_is_one(rec->p[i]))
-				p = upoly_print(rec->p[i], dim, div, p, 0);
+				p = upoly_print(rec->p[i], space, div, p);
 		}
 		first = 0;
 		if (i == 0)
@@ -1571,7 +1623,7 @@ static __isl_give isl_printer *upoly_print(__isl_keep struct isl_upoly *up,
 		if (!isl_upoly_is_one(rec->p[i]) &&
 		    !isl_upoly_is_negone(rec->p[i]))
 			p = isl_printer_print_str(p, " * ");
-		p = print_pow(p, dim, div, rec->up.var, i);
+		p = print_pow(p, space, div, rec->up.var, i);
 	}
 	if (print_parens)
 		p = isl_printer_print_str(p, ")");
@@ -1586,7 +1638,7 @@ static __isl_give isl_printer *print_qpolynomial(__isl_take isl_printer *p,
 {
 	if (!p || !qp)
 		goto error;
-	p = upoly_print(qp->upoly, qp->dim, qp->div, p, 1);
+	p = upoly_print(qp->upoly, qp->dim, qp->div, p);
 	return p;
 error:
 	isl_printer_free(p);
@@ -1601,10 +1653,7 @@ static __isl_give isl_printer *print_qpolynomial_isl(__isl_take isl_printer *p,
 	if (!p || !qp)
 		goto error;
 
-	if (isl_space_dim(qp->dim, isl_dim_param) > 0) {
-		p = print_tuple(qp->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, qp->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	if (!isl_space_is_params(qp->dim)) {
 		p = isl_print_space(qp->dim, p, 0, &data);
@@ -1618,8 +1667,11 @@ error:
 	return NULL;
 }
 
+/* Print the quasi-polynomial "qp" to "p" in C format, with the variable names
+ * taken from the domain space "space".
+ */
 static __isl_give isl_printer *print_qpolynomial_c(__isl_take isl_printer *p,
-	__isl_keep isl_space *dim, __isl_keep isl_qpolynomial *qp)
+	__isl_keep isl_space *space, __isl_keep isl_qpolynomial *qp)
 {
 	isl_int den;
 
@@ -1634,7 +1686,7 @@ static __isl_give isl_printer *print_qpolynomial_c(__isl_take isl_printer *p,
 		qp = isl_qpolynomial_mul(qp, f);
 	}
 	if (qp)
-		p = upoly_print(qp->upoly, dim, qp->div, p, 0);
+		p = upoly_print(qp->upoly, space, qp->div, p);
 	else
 		p = isl_printer_free(p);
 	if (!isl_int_is_one(den)) {
@@ -1731,7 +1783,7 @@ static __isl_give isl_printer *isl_pwqp_print_isl_body(
 			p = isl_printer_print_str(p, " -> ");
 		}
 		p = print_qpolynomial(p, pwqp->p[i].qp);
-		p = print_disjuncts((isl_map *)pwqp->p[i].set, space, p, 0);
+		p = print_disjuncts(set_to_map(pwqp->p[i].set), space, p, 0);
 		isl_space_free(space);
 	}
 
@@ -1746,10 +1798,7 @@ static __isl_give isl_printer *print_pw_qpolynomial_isl(
 	if (!p || !pwqp)
 		goto error;
 
-	if (isl_space_dim(pwqp->dim, isl_dim_param) > 0) {
-		p = print_tuple(pwqp->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, pwqp->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	if (pwqp->n == 0) {
 		if (!isl_space_is_set(pwqp->dim)) {
@@ -1798,7 +1847,7 @@ static __isl_give isl_printer *isl_pwf_print_isl_body(
 			p = isl_printer_print_str(p, " -> ");
 		}
 		p = qpolynomial_fold_print(pwf->p[i].fold, p);
-		p = print_disjuncts((isl_map *)pwf->p[i].set, space, p, 0);
+		p = print_disjuncts(set_to_map(pwf->p[i].set), space, p, 0);
 		isl_space_free(space);
 	}
 
@@ -1810,10 +1859,7 @@ static __isl_give isl_printer *print_pw_qpolynomial_fold_isl(
 {
 	struct isl_print_space_data data = { 0 };
 
-	if (isl_space_dim(pwf->dim, isl_dim_param) > 0) {
-		p = print_tuple(pwf->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, pwf->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	if (pwf->n == 0) {
 		if (!isl_space_is_set(pwf->dim)) {
@@ -1925,8 +1971,13 @@ static __isl_give isl_printer *print_constraint_c(__isl_take isl_printer *p,
 	o_div = isl_basic_set_offset(bset, isl_dim_div);
 	n_div = isl_basic_set_dim(bset, isl_dim_div);
 	div = isl_seq_last_non_zero(c + o_div, n_div);
-	if (div >= 0 && isl_basic_set_is_div_constraint(bset, c, div))
-		return p;
+	if (div >= 0) {
+		isl_bool is_div = isl_basic_set_is_div_constraint(bset, c, div);
+		if (is_div < 0)
+			return isl_printer_free(p);
+		if (is_div)
+			return p;
+	}
 
 	if (!*first)
 		p = isl_printer_print_str(p, " && ");
@@ -1996,22 +2047,30 @@ static __isl_give isl_printer *print_set_c(__isl_take isl_printer *p,
 	return p;
 }
 
+/* Print the piecewise quasi-polynomial "pwqp" to "p" in C format.
+ */
 static __isl_give isl_printer *print_pw_qpolynomial_c(
 	__isl_take isl_printer *p, __isl_keep isl_pw_qpolynomial *pwqp)
 {
 	int i;
+	isl_space *space;
 
-	if (pwqp->n == 1 && isl_set_plain_is_universe(pwqp->p[0].set))
-		return print_qpolynomial_c(p, pwqp->dim, pwqp->p[0].qp);
+	space = isl_pw_qpolynomial_get_domain_space(pwqp);
+	if (pwqp->n == 1 && isl_set_plain_is_universe(pwqp->p[0].set)) {
+		p = print_qpolynomial_c(p, space, pwqp->p[0].qp);
+		isl_space_free(space);
+		return p;
+	}
 
 	for (i = 0; i < pwqp->n; ++i) {
 		p = isl_printer_print_str(p, "(");
-		p = print_set_c(p, pwqp->dim, pwqp->p[i].set);
+		p = print_set_c(p, space, pwqp->p[i].set);
 		p = isl_printer_print_str(p, ") ? (");
-		p = print_qpolynomial_c(p, pwqp->dim, pwqp->p[i].qp);
+		p = print_qpolynomial_c(p, space, pwqp->p[i].qp);
 		p = isl_printer_print_str(p, ") : ");
 	}
 
+	isl_space_free(space);
 	p = isl_printer_print_str(p, "0");
 	return p;
 }
@@ -2052,14 +2111,11 @@ static __isl_give isl_printer *print_union_pw_qpolynomial_isl(
 {
 	struct isl_union_print_data data;
 	struct isl_print_space_data space_data = { 0 };
-	isl_space *dim;
+	isl_space *space;
 
-	dim = isl_union_pw_qpolynomial_get_space(upwqp);
-	if (isl_space_dim(dim, isl_dim_param) > 0) {
-		p = print_tuple(dim, p, isl_dim_param, &space_data);
-		p = isl_printer_print_str(p, " -> ");
-	}
-	isl_space_free(dim);
+	space = isl_union_pw_qpolynomial_get_space(upwqp);
+	p = print_param_tuple(p, space, &space_data);
+	isl_space_free(space);
 	p = isl_printer_print_str(p, "{ ");
 	data.p = p;
 	data.first = 1;
@@ -2086,8 +2142,11 @@ error:
 	return NULL;
 }
 
+/* Print the quasi-polynomial reduction "fold" to "p" in C format,
+ * with the variable names taken from the domain space "space".
+ */
 static __isl_give isl_printer *print_qpolynomial_fold_c(
-	__isl_take isl_printer *p, __isl_keep isl_space *dim,
+	__isl_take isl_printer *p, __isl_keep isl_space *space,
 	__isl_keep isl_qpolynomial_fold *fold)
 {
 	int i;
@@ -2101,7 +2160,7 @@ static __isl_give isl_printer *print_qpolynomial_fold_c(
 	for (i = 0; i < fold->n; ++i) {
 		if (i)
 			p = isl_printer_print_str(p, ", ");
-		p = print_qpolynomial_c(p, dim, fold->qp[i]);
+		p = print_qpolynomial_c(p, space, fold->qp[i]);
 		if (i)
 			p = isl_printer_print_str(p, ")");
 	}
@@ -2124,22 +2183,30 @@ error:
 	return NULL;
 }
 
+/* Print the piecewise quasi-polynomial reduction "pwf" to "p" in C format.
+ */
 static __isl_give isl_printer *print_pw_qpolynomial_fold_c(
 	__isl_take isl_printer *p, __isl_keep isl_pw_qpolynomial_fold *pwf)
 {
 	int i;
+	isl_space *space;
 
-	if (pwf->n == 1 && isl_set_plain_is_universe(pwf->p[0].set))
-		return print_qpolynomial_fold_c(p, pwf->dim, pwf->p[0].fold);
+	space = isl_pw_qpolynomial_fold_get_domain_space(pwf);
+	if (pwf->n == 1 && isl_set_plain_is_universe(pwf->p[0].set)) {
+		p = print_qpolynomial_fold_c(p, space, pwf->p[0].fold);
+		isl_space_free(space);
+		return p;
+	}
 
 	for (i = 0; i < pwf->n; ++i) {
 		p = isl_printer_print_str(p, "(");
-		p = print_set_c(p, pwf->dim, pwf->p[i].set);
+		p = print_set_c(p, space, pwf->p[i].set);
 		p = isl_printer_print_str(p, ") ? (");
-		p = print_qpolynomial_fold_c(p, pwf->dim, pwf->p[i].fold);
+		p = print_qpolynomial_fold_c(p, space, pwf->p[i].fold);
 		p = isl_printer_print_str(p, ") : ");
 	}
 
+	isl_space_free(space);
 	p = isl_printer_print_str(p, "0");
 	return p;
 }
@@ -2197,14 +2264,11 @@ static __isl_give isl_printer *print_union_pw_qpolynomial_fold_isl(
 {
 	struct isl_union_print_data data;
 	struct isl_print_space_data space_data = { 0 };
-	isl_space *dim;
+	isl_space *space;
 
-	dim = isl_union_pw_qpolynomial_fold_get_space(upwf);
-	if (isl_space_dim(dim, isl_dim_param) > 0) {
-		p = print_tuple(dim, p, isl_dim_param, &space_data);
-		p = isl_printer_print_str(p, " -> ");
-	}
-	isl_space_free(dim);
+	space = isl_union_pw_qpolynomial_fold_get_space(upwf);
+	p = print_param_tuple(p, space, &space_data);
+	isl_space_free(space);
 	p = isl_printer_print_str(p, "{ ");
 	data.p = p;
 	data.first = 1;
@@ -2232,17 +2296,43 @@ error:
 	return NULL;
 }
 
+/* Print the isl_constraint "c" to "p".
+ */
 __isl_give isl_printer *isl_printer_print_constraint(__isl_take isl_printer *p,
 	__isl_keep isl_constraint *c)
 {
-	isl_basic_map *bmap;
+	struct isl_print_space_data data = { 0 };
+	isl_local_space *ls;
+	isl_space *space;
+	isl_bool exists;
 
 	if (!p || !c)
 		goto error;
 
-	bmap = isl_basic_map_from_constraint(isl_constraint_copy(c));
-	p = isl_printer_print_basic_map(p, bmap);
-	isl_basic_map_free(bmap);
+	ls = isl_constraint_get_local_space(c);
+	if (!ls)
+		return isl_printer_free(p);
+	space = isl_local_space_get_space(ls);
+	p = print_param_tuple(p, space, &data);
+	p = isl_printer_print_str(p, "{ ");
+	p = isl_print_space(space, p, 0, &data);
+	p = isl_printer_print_str(p, " : ");
+	exists = need_exists(p, ls->div);
+	if (exists < 0)
+		p = isl_printer_free(p);
+	if (exists >= 0 && exists)
+		p = open_exists(p, space, ls->div, 0);
+	p = print_affine_of_len(space, ls->div, p, c->v->el, c->v->size);
+	if (isl_constraint_is_equality(c))
+		p = isl_printer_print_str(p, " = 0");
+	else
+		p = isl_printer_print_str(p, " >= 0");
+	if (exists >= 0 && exists)
+		p = isl_printer_print_str(p, s_close_exists[0]);
+	p = isl_printer_print_str(p, " }");
+	isl_space_free(space);
+	isl_local_space_free(ls);
+
 	return p;
 error:
 	isl_printer_free(p);
@@ -2257,10 +2347,7 @@ static __isl_give isl_printer *isl_printer_print_space_isl(
 	if (!space)
 		goto error;
 
-	if (isl_space_dim(space, isl_dim_param) > 0) {
-		p = print_tuple(space, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, space, &data);
 
 	p = isl_printer_print_str(p, "{ ");
 	if (isl_space_is_params(space))
@@ -2299,10 +2386,7 @@ __isl_give isl_printer *isl_printer_print_local_space(__isl_take isl_printer *p,
 	if (!ls)
 		goto error;
 
-	if (isl_local_space_dim(ls, isl_dim_param) > 0) {
-		p = print_tuple(ls->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, ls->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	p = isl_print_space(ls->dim, p, 0, &data);
 	n_div = isl_local_space_dim(ls, isl_dim_div);
@@ -2368,10 +2452,7 @@ static __isl_give isl_printer *print_aff_isl(__isl_take isl_printer *p,
 	if (!aff)
 		goto error;
 
-	if (isl_local_space_dim(aff->ls, isl_dim_param) > 0) {
-		p = print_tuple(aff->ls->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, aff->ls->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	p = print_aff(p, aff);
 	p = isl_printer_print_str(p, " }");
@@ -2399,7 +2480,7 @@ static __isl_give isl_printer *print_pw_aff_body(
 			p = isl_printer_print_str(p, "; ");
 		p = print_aff(p, pa->p[i].aff);
 		space = isl_aff_get_domain_space(pa->p[i].aff);
-		p = print_disjuncts((isl_map *)pa->p[i].set, space, p, 0);
+		p = print_disjuncts(set_to_map(pa->p[i].set), space, p, 0);
 		isl_space_free(space);
 	}
 
@@ -2414,10 +2495,7 @@ static __isl_give isl_printer *print_pw_aff_isl(__isl_take isl_printer *p,
 	if (!pwaff)
 		goto error;
 
-	if (isl_space_dim(pwaff->dim, isl_dim_param) > 0) {
-		p = print_tuple(pwaff->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, pwaff->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	p = print_pw_aff_body(p, pwaff);
 	p = isl_printer_print_str(p, " }");
@@ -2637,10 +2715,7 @@ static __isl_give isl_printer *print_union_pw_aff_isl(
 	isl_space *space;
 
 	space = isl_union_pw_aff_get_space(upa);
-	if (isl_space_dim(space, isl_dim_param) > 0) {
-		p = print_tuple(space, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, s_to[0]);
-	}
+	p = print_param_tuple(p, space, &data);
 	isl_space_free(space);
 	p = print_union_pw_aff_body(p, upa);
 	return p;
@@ -2700,10 +2775,7 @@ static __isl_give isl_printer *print_multi_aff_isl(__isl_take isl_printer *p,
 	if (!maff)
 		goto error;
 
-	if (isl_space_dim(maff->space, isl_dim_param) > 0) {
-		p = print_tuple(maff->space, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, maff->space, &data);
 	p = isl_printer_print_str(p, "{ ");
 	p = print_multi_aff(p, maff);
 	p = isl_printer_print_str(p, " }");
@@ -2743,7 +2815,7 @@ static __isl_give isl_printer *print_pw_multi_aff_body(
 			p = isl_printer_print_str(p, "; ");
 		p = print_multi_aff(p, pma->p[i].maff);
 		space = isl_multi_aff_get_domain_space(pma->p[i].maff);
-		p = print_disjuncts((isl_map *)pma->p[i].set, space, p, 0);
+		p = print_disjuncts(set_to_map(pma->p[i].set), space, p, 0);
 		isl_space_free(space);
 	}
 	return p;
@@ -2760,10 +2832,7 @@ static __isl_give isl_printer *print_pw_multi_aff_isl(__isl_take isl_printer *p,
 	if (!pma)
 		goto error;
 
-	if (isl_space_dim(pma->dim, isl_dim_param) > 0) {
-		p = print_tuple(pma->dim, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, pma->dim, &data);
 	p = isl_printer_print_str(p, "{ ");
 	p = print_pw_multi_aff_body(p, pma);
 	p = isl_printer_print_str(p, " }");
@@ -2773,18 +2842,24 @@ error:
 	return NULL;
 }
 
+/* Print the unnamed, single-dimensional piecewise multi affine expression "pma"
+ * to "p".
+ */
 static __isl_give isl_printer *print_unnamed_pw_multi_aff_c(
 	__isl_take isl_printer *p, __isl_keep isl_pw_multi_aff *pma)
 {
 	int i;
+	isl_space *space;
 
+	space = isl_pw_multi_aff_get_domain_space(pma);
 	for (i = 0; i < pma->n - 1; ++i) {
 		p = isl_printer_print_str(p, "(");
-		p = print_set_c(p, pma->dim, pma->p[i].set);
+		p = print_set_c(p, space, pma->p[i].set);
 		p = isl_printer_print_str(p, ") ? (");
 		p = print_aff_c(p, pma->p[i].maff->p[0]);
 		p = isl_printer_print_str(p, ") : ");
 	}
+	isl_space_free(space);
 
 	return print_aff_c(p, pma->p[pma->n - 1].maff->p[0]);
 }
@@ -2862,10 +2937,7 @@ static __isl_give isl_printer *print_union_pw_multi_aff_isl(
 	isl_space *space;
 
 	space = isl_union_pw_multi_aff_get_space(upma);
-	if (isl_space_dim(space, isl_dim_param) > 0) {
-		p = print_tuple(space, p, isl_dim_param, &space_data);
-		p = isl_printer_print_str(p, s_to[0]);
-	}
+	p = print_param_tuple(p, space, &space_data);
 	isl_space_free(space);
 	p = isl_printer_print_str(p, s_open_set[0]);
 	data.p = p;
@@ -2944,10 +3016,7 @@ static __isl_give isl_printer *print_multi_pw_aff_isl(__isl_take isl_printer *p,
 	if (!mpa)
 		return isl_printer_free(p);
 
-	if (isl_space_dim(mpa->space, isl_dim_param) > 0) {
-		p = print_tuple(mpa->space, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, mpa->space, &data);
 	p = isl_printer_print_str(p, "{ ");
 	data.print_dim = &print_dim_mpa;
 	data.user = mpa;
@@ -2996,10 +3065,7 @@ static __isl_give isl_printer *print_multi_val_isl(__isl_take isl_printer *p,
 	if (!mv)
 		return isl_printer_free(p);
 
-	if (isl_space_dim(mv->space, isl_dim_param) > 0) {
-		p = print_tuple(mv->space, p, isl_dim_param, &data);
-		p = isl_printer_print_str(p, " -> ");
-	}
+	p = print_param_tuple(p, mv->space, &data);
 	p = isl_printer_print_str(p, "{ ");
 	data.print_dim = &print_dim_mv;
 	data.user = mv;
@@ -3054,11 +3120,7 @@ static __isl_give isl_printer *print_multi_union_pw_aff_isl(
 	isl_space *space;
 
 	space = isl_multi_union_pw_aff_get_space(mupa);
-	if (isl_space_dim(space, isl_dim_param) > 0) {
-		struct isl_print_space_data space_data = { 0 };
-		p = print_tuple(space, p, isl_dim_param, &space_data);
-		p = isl_printer_print_str(p, s_to[0]);
-	}
+	p = print_param_tuple(p, space, &data);
 
 	data.print_dim = &print_union_pw_aff_dim;
 	data.user = mupa;
diff --git a/lib/Analysis/isl/isl_point.c b/lib/Analysis/isl/isl_point.c
index 3e832a8..48534ed 100644
--- a/lib/Analysis/isl/isl_point.c
+++ b/lib/Analysis/isl/isl_point.c
@@ -11,6 +11,8 @@
 #include <isl_output_private.h>
 #include <isl/deprecated/point_int.h>
 
+#include <set_to_map.c>
+
 isl_ctx *isl_point_get_ctx(__isl_keep isl_point *pnt)
 {
 	return pnt ? isl_space_get_ctx(pnt->dim) : NULL;
@@ -101,17 +103,18 @@ __isl_give isl_point *isl_point_copy(__isl_keep isl_point *pnt)
 	return pnt;
 }
 
-void isl_point_free(__isl_take isl_point *pnt)
+__isl_null isl_point *isl_point_free(__isl_take isl_point *pnt)
 {
 	if (!pnt)
-		return;
+		return NULL;
 
 	if (--pnt->ref > 0)
-		return;
+		return NULL;
 
 	isl_space_free(pnt->dim);
 	isl_vec_free(pnt->vec);
 	free(pnt);
+	return NULL;
 }
 
 __isl_give isl_point *isl_point_void(__isl_take isl_space *dim)
@@ -390,18 +393,19 @@ isl_bool isl_basic_map_contains_point(__isl_keep isl_basic_map *bmap,
 	return contains;
 }
 
-int isl_map_contains_point(__isl_keep isl_map *map, __isl_keep isl_point *point)
+isl_bool isl_map_contains_point(__isl_keep isl_map *map,
+	__isl_keep isl_point *point)
 {
 	int i;
-	int found = 0;
+	isl_bool found = isl_bool_false;
 
 	if (!map || !point)
-		return -1;
+		return isl_bool_error;
 
 	map = isl_map_copy(map);
 	map = isl_map_compute_divs(map);
 	if (!map)
-		return -1;
+		return isl_bool_error;
 
 	for (i = 0; i < map->n; ++i) {
 		found = isl_basic_map_contains_point(map->p[i], point);
@@ -415,13 +419,13 @@ int isl_map_contains_point(__isl_keep isl_map *map, __isl_keep isl_point *point)
 	return found;
 error:
 	isl_map_free(map);
-	return -1;
+	return isl_bool_error;
 }
 
 isl_bool isl_set_contains_point(__isl_keep isl_set *set,
 	__isl_keep isl_point *point)
 {
-	return isl_map_contains_point((isl_map *)set, point);
+	return isl_map_contains_point(set_to_map(set), point);
 }
 
 __isl_give isl_basic_set *isl_basic_set_from_point(__isl_take isl_point *pnt)
@@ -468,7 +472,7 @@ __isl_give isl_union_set *isl_union_set_from_point(__isl_take isl_point *pnt)
 __isl_give isl_basic_set *isl_basic_set_box_from_points(
 	__isl_take isl_point *pnt1, __isl_take isl_point *pnt2)
 {
-	isl_basic_set *bset;
+	isl_basic_set *bset = NULL;
 	unsigned total;
 	int i;
 	int k;
@@ -546,6 +550,7 @@ error:
 	isl_point_free(pnt1);
 	isl_point_free(pnt2);
 	isl_int_clear(t);
+	isl_basic_set_free(bset);
 	return NULL;
 }
 
@@ -579,7 +584,6 @@ __isl_give isl_printer *isl_printer_print_point(
 	struct isl_print_space_data data = { 0 };
 	int i;
 	unsigned nparam;
-	unsigned dim;
 
 	if (!pnt)
 		return p;
@@ -589,7 +593,6 @@ __isl_give isl_printer *isl_printer_print_point(
 	}
 
 	nparam = isl_space_dim(pnt->dim, isl_dim_param);
-	dim = isl_space_dim(pnt->dim, isl_dim_set);
 	if (nparam > 0) {
 		p = isl_printer_print_str(p, "[");
 		for (i = 0; i < nparam; ++i) {
diff --git a/lib/Analysis/isl/isl_polynomial.c b/lib/Analysis/isl/isl_polynomial.c
index 3772abf..2f4ba43 100644
--- a/lib/Analysis/isl/isl_polynomial.c
+++ b/lib/Analysis/isl/isl_polynomial.c
@@ -449,6 +449,21 @@ __isl_give isl_space *isl_qpolynomial_get_space(__isl_keep isl_qpolynomial *qp)
 	return space;
 }
 
+/* Return the number of variables of the given type in the domain of "qp".
+ */
+unsigned isl_qpolynomial_domain_dim(__isl_keep isl_qpolynomial *qp,
+	enum isl_dim_type type)
+{
+	if (!qp)
+		return 0;
+	if (type == isl_dim_div)
+		return qp->div->n_row;
+	if (type == isl_dim_all)
+		return isl_space_dim(qp->dim, isl_dim_all) +
+				    isl_qpolynomial_domain_dim(qp, isl_dim_div);
+	return isl_space_dim(qp->dim, type);
+}
+
 /* Externally, an isl_qpolynomial has a map space, but internally, the
  * ls field corresponds to the domain of that space.
  */
@@ -461,7 +476,28 @@ unsigned isl_qpolynomial_dim(__isl_keep isl_qpolynomial *qp,
 		return 1;
 	if (type == isl_dim_in)
 		type = isl_dim_set;
-	return isl_space_dim(qp->dim, type);
+	return isl_qpolynomial_domain_dim(qp, type);
+}
+
+/* Return the offset of the first coefficient of type "type" in
+ * the domain of "qp".
+ */
+unsigned isl_qpolynomial_domain_offset(__isl_keep isl_qpolynomial *qp,
+	enum isl_dim_type type)
+{
+	if (!qp)
+		return 0;
+	switch (type) {
+	case isl_dim_cst:
+		return 0;
+	case isl_dim_param:
+	case isl_dim_set:
+		return 1 + isl_space_offset(qp->dim, type);
+	case isl_dim_div:
+		return 1 + isl_space_dim(qp->dim, isl_dim_all);
+	default:
+		return 0;
+	}
 }
 
 isl_bool isl_qpolynomial_is_zero(__isl_keep isl_qpolynomial *qp)
@@ -584,13 +620,13 @@ __isl_give struct isl_upoly *isl_upoly_cow(__isl_take struct isl_upoly *up)
 	return isl_upoly_dup(up);
 }
 
-void isl_upoly_free(__isl_take struct isl_upoly *up)
+__isl_null struct isl_upoly *isl_upoly_free(__isl_take struct isl_upoly *up)
 {
 	if (!up)
-		return;
+		return NULL;
 
 	if (--up->ref > 0)
-		return;
+		return NULL;
 
 	if (up->var < 0)
 		upoly_free_cst((struct isl_upoly_cst *)up);
@@ -599,6 +635,7 @@ void isl_upoly_free(__isl_take struct isl_upoly *up)
 
 	isl_ctx_deref(up->ctx);
 	free(up);
+	return NULL;
 }
 
 static void isl_upoly_cst_reduce(__isl_keep struct isl_upoly_cst *cst)
@@ -1241,13 +1278,15 @@ error:
 	return NULL;
 }
 
-static int compatible_divs(__isl_keep isl_mat *div1, __isl_keep isl_mat *div2)
+static isl_bool compatible_divs(__isl_keep isl_mat *div1,
+	__isl_keep isl_mat *div2)
 {
 	int n_row, n_col;
-	int equal;
+	isl_bool equal;
 
 	isl_assert(div1->ctx, div1->n_row >= div2->n_row &&
-				div1->n_col >= div2->n_col, return -1);
+				div1->n_col >= div2->n_col,
+		    return isl_bool_error);
 
 	if (div1->n_row == div2->n_row)
 		return isl_mat_is_equal(div1, div2);
@@ -1473,6 +1512,8 @@ error:
 __isl_give isl_qpolynomial *isl_qpolynomial_add(__isl_take isl_qpolynomial *qp1,
 	__isl_take isl_qpolynomial *qp2)
 {
+	isl_bool compatible;
+
 	qp1 = isl_qpolynomial_cow(qp1);
 
 	if (!qp1 || !qp2)
@@ -1482,7 +1523,10 @@ __isl_give isl_qpolynomial *isl_qpolynomial_add(__isl_take isl_qpolynomial *qp1,
 		return isl_qpolynomial_add(qp2, qp1);
 
 	isl_assert(qp1->dim->ctx, isl_space_is_equal(qp1->dim, qp2->dim), goto error);
-	if (!compatible_divs(qp1->div, qp2->div))
+	compatible = compatible_divs(qp1->div, qp2->div);
+	if (compatible < 0)
+		goto error;
+	if (!compatible)
 		return with_merged_divs(isl_qpolynomial_add, qp1, qp2);
 
 	qp1->upoly = isl_upoly_sum(qp1->upoly, isl_upoly_copy(qp2->upoly));
@@ -1643,6 +1687,8 @@ error:
 __isl_give isl_qpolynomial *isl_qpolynomial_mul(__isl_take isl_qpolynomial *qp1,
 	__isl_take isl_qpolynomial *qp2)
 {
+	isl_bool compatible;
+
 	qp1 = isl_qpolynomial_cow(qp1);
 
 	if (!qp1 || !qp2)
@@ -1652,7 +1698,10 @@ __isl_give isl_qpolynomial *isl_qpolynomial_mul(__isl_take isl_qpolynomial *qp1,
 		return isl_qpolynomial_mul(qp2, qp1);
 
 	isl_assert(qp1->dim->ctx, isl_space_is_equal(qp1->dim, qp2->dim), goto error);
-	if (!compatible_divs(qp1->div, qp2->div))
+	compatible = compatible_divs(qp1->div, qp2->div);
+	if (compatible < 0)
+		goto error;
+	if (!compatible)
 		return with_merged_divs(isl_qpolynomial_mul, qp1, qp2);
 
 	qp1->upoly = isl_upoly_mul(qp1->upoly, isl_upoly_copy(qp2->upoly));
@@ -2238,11 +2287,11 @@ static __isl_give isl_qpolynomial *substitute_non_divs(
  * inside the division, so we need to add floor(e/d) * x outside.
  * That is, we replace q by q' + floor(e/d) * x and we therefore need
  * to adjust the coefficient of x in each later div that depends on the
- * current div "div" and also in the affine expression "aff"
- * (if it too depends on "div").
+ * current div "div" and also in the affine expressions in the rows of "mat"
+ * (if they too depend on "div").
  */
 static void reduce_div(__isl_keep isl_qpolynomial *qp, int div,
-	__isl_keep isl_vec *aff)
+	__isl_keep isl_mat **mat)
 {
 	int i, j;
 	isl_int v;
@@ -2256,8 +2305,7 @@ static void reduce_div(__isl_keep isl_qpolynomial *qp, int div,
 		isl_int_fdiv_q(v, qp->div->row[div][1 + i], qp->div->row[div][0]);
 		isl_int_fdiv_r(qp->div->row[div][1 + i],
 				qp->div->row[div][1 + i], qp->div->row[div][0]);
-		if (!isl_int_is_zero(aff->el[1 + total + div]))
-			isl_int_addmul(aff->el[i], v, aff->el[1 + total + div]);
+		*mat = isl_mat_col_addmul(*mat, i, v, 1 + total + div);
 		for (j = div + 1; j < qp->div->n_row; ++j) {
 			if (isl_int_is_zero(qp->div->row[j][2 + total + div]))
 				continue;
@@ -2297,11 +2345,11 @@ static int needs_invert(__isl_keep isl_mat *div, int row)
 
 /* Replace div "div" q = [e/d] by -[(-e+(d-1))/d].
  * We only invert the coefficients of e (and the coefficient of q in
- * later divs and in "aff").  After calling this function, the
+ * later divs and in the rows of "mat").  After calling this function, the
  * coefficients of e should be reduced again.
  */
 static void invert_div(__isl_keep isl_qpolynomial *qp, int div,
-	__isl_keep isl_vec *aff)
+	__isl_keep isl_mat **mat)
 {
 	unsigned total = qp->div->n_col - qp->div->n_row - 2;
 
@@ -2310,15 +2358,18 @@ static void invert_div(__isl_keep isl_qpolynomial *qp, int div,
 	isl_int_sub_ui(qp->div->row[div][1], qp->div->row[div][1], 1);
 	isl_int_add(qp->div->row[div][1],
 		    qp->div->row[div][1], qp->div->row[div][0]);
-	if (!isl_int_is_zero(aff->el[1 + total + div]))
-		isl_int_neg(aff->el[1 + total + div], aff->el[1 + total + div]);
+	*mat = isl_mat_col_neg(*mat, 1 + total + div);
 	isl_mat_col_mul(qp->div, 2 + total + div,
 			qp->div->ctx->negone, 2 + total + div);
 }
 
-/* Assuming "qp" is a monomial, reduce all its divs to have coefficients
+/* Reduce all divs of "qp" to have coefficients
  * in the interval [0, d-1], with d the denominator and such that the
  * last non-zero coefficient that is not equal to d/2 is smaller than d/2.
+ * The modifications to the integer divisions need to be reflected
+ * in the factors of the polynomial that refer to the original
+ * integer divisions.  To this end, the modifications are collected
+ * as a set of affine expressions and then plugged into the polynomial.
  *
  * After the reduction, some divs may have become redundant or identical,
  * so we call substitute_non_divs and sort_divs.  If these functions
@@ -2329,48 +2380,58 @@ static void invert_div(__isl_keep isl_qpolynomial *qp, int div,
 static __isl_give isl_qpolynomial *reduce_divs(__isl_take isl_qpolynomial *qp)
 {
 	int i;
-	isl_vec *aff = NULL;
-	struct isl_upoly *s;
-	unsigned n_div;
+	isl_ctx *ctx;
+	isl_mat *mat;
+	struct isl_upoly **s;
+	unsigned o_div, n_div, total;
 
 	if (!qp)
 		return NULL;
 
-	aff = isl_vec_alloc(qp->div->ctx, qp->div->n_col - 1);
-	aff = isl_vec_clr(aff);
-	if (!aff)
-		goto error;
+	total = isl_qpolynomial_domain_dim(qp, isl_dim_all);
+	n_div = isl_qpolynomial_domain_dim(qp, isl_dim_div);
+	o_div = isl_qpolynomial_domain_offset(qp, isl_dim_div);
+	ctx = isl_qpolynomial_get_ctx(qp);
+	mat = isl_mat_zero(ctx, n_div, 1 + total);
 
-	isl_int_set_si(aff->el[1 + qp->upoly->var], 1);
+	for (i = 0; i < n_div; ++i)
+		mat = isl_mat_set_element_si(mat, i, o_div + i, 1);
 
 	for (i = 0; i < qp->div->n_row; ++i) {
 		normalize_div(qp, i);
-		reduce_div(qp, i, aff);
+		reduce_div(qp, i, &mat);
 		if (needs_invert(qp->div, i)) {
-			invert_div(qp, i, aff);
-			reduce_div(qp, i, aff);
+			invert_div(qp, i, &mat);
+			reduce_div(qp, i, &mat);
 		}
 	}
+	if (!mat)
+		goto error;
 
-	s = isl_upoly_from_affine(qp->div->ctx, aff->el,
-				  qp->div->ctx->one, aff->size);
-	qp->upoly = isl_upoly_subs(qp->upoly, qp->upoly->var, 1, &s);
-	isl_upoly_free(s);
+	s = isl_alloc_array(ctx, struct isl_upoly *, n_div);
+	if (n_div && !s)
+		goto error;
+	for (i = 0; i < n_div; ++i)
+		s[i] = isl_upoly_from_affine(ctx, mat->row[i], ctx->one,
+					    1 + total);
+	qp->upoly = isl_upoly_subs(qp->upoly, o_div - 1, n_div, s);
+	for (i = 0; i < n_div; ++i)
+		isl_upoly_free(s[i]);
+	free(s);
 	if (!qp->upoly)
 		goto error;
 
-	isl_vec_free(aff);
+	isl_mat_free(mat);
 
-	n_div = qp->div->n_row;
 	qp = substitute_non_divs(qp);
 	qp = sort_divs(qp);
-	if (qp && qp->div->n_row < n_div)
+	if (qp && isl_qpolynomial_domain_dim(qp, isl_dim_div) < n_div)
 		return reduce_divs(qp);
 
 	return qp;
 error:
 	isl_qpolynomial_free(qp);
-	isl_vec_free(aff);
+	isl_mat_free(mat);
 	return NULL;
 }
 
@@ -2628,6 +2689,12 @@ __isl_give isl_qpolynomial *isl_qpolynomial_set_dim_name(
 	qp = isl_qpolynomial_cow(qp);
 	if (!qp)
 		return NULL;
+	if (type == isl_dim_out)
+		isl_die(isl_qpolynomial_get_ctx(qp), isl_error_invalid,
+			"cannot set name of output/set dimension",
+			return isl_qpolynomial_free(qp));
+	if (type == isl_dim_in)
+		type = isl_dim_set;
 	qp->dim = isl_space_set_dim_name(qp->dim, type, pos, s);
 	if (!qp->dim)
 		goto error;
@@ -2871,6 +2938,8 @@ __isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_from_qpolynomial(
 	return isl_pw_qpolynomial_alloc(dom, qp);
 }
 
+#define isl_qpolynomial_involves_nan isl_qpolynomial_is_nan
+
 #undef PW
 #define PW isl_pw_qpolynomial
 #undef EL
@@ -3031,15 +3100,35 @@ error:
 	return NULL;
 }
 
+/* Evaluate "qp" in the void point "pnt".
+ * In particular, return the value NaN.
+ */
+static __isl_give isl_val *eval_void(__isl_take isl_qpolynomial *qp,
+	__isl_take isl_point *pnt)
+{
+	isl_ctx *ctx;
+
+	ctx = isl_point_get_ctx(pnt);
+	isl_qpolynomial_free(qp);
+	isl_point_free(pnt);
+	return isl_val_nan(ctx);
+}
+
 __isl_give isl_val *isl_qpolynomial_eval(__isl_take isl_qpolynomial *qp,
 	__isl_take isl_point *pnt)
 {
+	isl_bool is_void;
 	isl_vec *ext;
 	isl_val *v;
 
 	if (!qp || !pnt)
 		goto error;
 	isl_assert(pnt->dim->ctx, isl_space_is_equal(pnt->dim, qp->dim), goto error);
+	is_void = isl_point_is_void(pnt);
+	if (is_void < 0)
+		goto error;
+	if (is_void)
+		return eval_void(qp, pnt);
 
 	if (qp->div->n_row == 0)
 		ext = isl_vec_copy(pnt->vec);
@@ -3203,10 +3292,6 @@ __isl_give isl_qpolynomial *isl_qpolynomial_move_dims(
 	unsigned g_src_pos;
 	int *reordering;
 
-	if (n == 0)
-		return qp;
-
-	qp = isl_qpolynomial_cow(qp);
 	if (!qp)
 		return NULL;
 
@@ -3219,6 +3304,15 @@ __isl_give isl_qpolynomial *isl_qpolynomial_move_dims(
 	if (src_type == isl_dim_in)
 		src_type = isl_dim_set;
 
+	if (n == 0 &&
+	    !isl_space_is_named_or_nested(qp->dim, src_type) &&
+	    !isl_space_is_named_or_nested(qp->dim, dst_type))
+		return qp;
+
+	qp = isl_qpolynomial_cow(qp);
+	if (!qp)
+		return NULL;
+
 	isl_assert(qp->dim->ctx, src_pos + n <= isl_space_dim(qp->dim, src_type),
 		goto error);
 
@@ -3403,9 +3497,9 @@ error:
  * that results from replacing each of the integer divisions by the
  * corresponding extra set dimension.
  */
-int isl_qpolynomial_as_polynomial_on_domain(__isl_keep isl_qpolynomial *qp,
+isl_stat isl_qpolynomial_as_polynomial_on_domain(__isl_keep isl_qpolynomial *qp,
 	__isl_keep isl_basic_set *bset,
-	int (*fn)(__isl_take isl_basic_set *bset,
+	isl_stat (*fn)(__isl_take isl_basic_set *bset,
 		  __isl_take isl_qpolynomial *poly, void *user), void *user)
 {
 	isl_space *dim;
@@ -3413,7 +3507,7 @@ int isl_qpolynomial_as_polynomial_on_domain(__isl_keep isl_qpolynomial *qp,
 	isl_qpolynomial *poly;
 
 	if (!qp || !bset)
-		goto error;
+		return isl_stat_error;
 	if (qp->div->n_row == 0)
 		return fn(isl_basic_set_copy(bset), isl_qpolynomial_copy(qp),
 			  user);
@@ -3427,8 +3521,6 @@ int isl_qpolynomial_as_polynomial_on_domain(__isl_keep isl_qpolynomial *qp,
 	bset = add_div_constraints(bset, div);
 
 	return fn(bset, poly, user);
-error:
-	return -1;
 }
 
 /* Return total degree in variables first (inclusive) up to last (exclusive).
@@ -4226,10 +4318,15 @@ error:
 __isl_give isl_qpolynomial *isl_qpolynomial_align_params(
 	__isl_take isl_qpolynomial *qp, __isl_take isl_space *model)
 {
+	isl_bool equal_params;
+
 	if (!qp || !model)
 		goto error;
 
-	if (!isl_space_match(qp->dim, isl_dim_param, model, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(qp->dim, model);
+	if (equal_params < 0)
+		goto error;
+	if (!equal_params) {
 		isl_reordering *exp;
 
 		model = isl_space_drop_dims(model, isl_dim_in,
@@ -4475,6 +4572,9 @@ error:
  *	0	if cst == 0
  *	1	if cst == 1
  *  infinity	if cst == -1
+ *
+ * If cst == -1, then explicitly check whether the domain is empty and,
+ * if so, return 0 instead.
  */
 static __isl_give isl_pw_qpolynomial *constant_on_domain(
 	__isl_take isl_basic_set *bset, int cst)
@@ -4482,6 +4582,8 @@ static __isl_give isl_pw_qpolynomial *constant_on_domain(
 	isl_space *dim;
 	isl_qpolynomial *qp;
 
+	if (cst < 0 && isl_basic_set_is_empty(bset) == isl_bool_true)
+		cst = 0;
 	if (!bset)
 		return NULL;
 
@@ -4507,7 +4609,7 @@ static __isl_give isl_pw_qpolynomial *compressed_multiplicative_call(
 	__isl_give isl_pw_qpolynomial *(*fn)(__isl_take isl_basic_set *bset))
 {
 	int i, n;
-	isl_space *dim;
+	isl_space *space;
 	isl_set *set;
 	isl_factorizer *f;
 	isl_qpolynomial *qp;
@@ -4526,10 +4628,10 @@ static __isl_give isl_pw_qpolynomial *compressed_multiplicative_call(
 	nparam = isl_basic_set_dim(bset, isl_dim_param);
 	nvar = isl_basic_set_dim(bset, isl_dim_set);
 
-	dim = isl_basic_set_get_space(bset);
-	dim = isl_space_domain(dim);
-	set = isl_set_universe(isl_space_copy(dim));
-	qp = isl_qpolynomial_one_on_domain(dim);
+	space = isl_basic_set_get_space(bset);
+	space = isl_space_params(space);
+	set = isl_set_universe(isl_space_copy(space));
+	qp = isl_qpolynomial_one_on_domain(space);
 	pwqp = isl_pw_qpolynomial_alloc(set, qp);
 
 	bset = isl_morph_basic_set(isl_morph_copy(f->morph), bset);
@@ -4574,7 +4676,7 @@ __isl_give isl_pw_qpolynomial *isl_basic_set_multiplicative_call(
 	__isl_take isl_basic_set *bset,
 	__isl_give isl_pw_qpolynomial *(*fn)(__isl_take isl_basic_set *bset))
 {
-	int bounded;
+	isl_bool bounded;
 	isl_morph *morph;
 	isl_pw_qpolynomial *pwqp;
 
@@ -4777,8 +4879,8 @@ struct isl_to_poly_data {
  * overapproximated by a/m, while in the second it is underapproximated
  * by (a-(m-1))/m.
  */
-static int to_polynomial_on_orthant(__isl_take isl_set *orthant, int *signs,
-	void *user)
+static isl_stat to_polynomial_on_orthant(__isl_take isl_set *orthant,
+	int *signs, void *user)
 {
 	struct isl_to_poly_data *data = user;
 	isl_pw_qpolynomial *t;
@@ -4798,7 +4900,7 @@ static int to_polynomial_on_orthant(__isl_take isl_set *orthant, int *signs,
 	t = isl_pw_qpolynomial_alloc(orthant, qp);
 	data->res = isl_pw_qpolynomial_add_disjoint(data->res, t);
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Approximate each quasipolynomial by a polynomial.  If "sign" is positive,
diff --git a/lib/Analysis/isl/isl_polynomial_private.h b/lib/Analysis/isl/isl_polynomial_private.h
index 17b1a2d..b615b24 100644
--- a/lib/Analysis/isl/isl_polynomial_private.h
+++ b/lib/Analysis/isl/isl_polynomial_private.h
@@ -102,7 +102,7 @@ __isl_give struct isl_upoly *isl_upoly_zero(struct isl_ctx *ctx);
 __isl_give struct isl_upoly *isl_upoly_copy(__isl_keep struct isl_upoly *up);
 __isl_give struct isl_upoly *isl_upoly_cow(__isl_take struct isl_upoly *up);
 __isl_give struct isl_upoly *isl_upoly_dup(__isl_keep struct isl_upoly *up);
-void isl_upoly_free(__isl_take struct isl_upoly *up);
+__isl_null struct isl_upoly *isl_upoly_free(__isl_take struct isl_upoly *up);
 __isl_give struct isl_upoly *isl_upoly_mul(__isl_take struct isl_upoly *up1,
 	__isl_take struct isl_upoly *up2);
 
@@ -134,6 +134,9 @@ int isl_qpolynomial_is_affine(__isl_keep isl_qpolynomial *qp);
 int isl_qpolynomial_is_cst(__isl_keep isl_qpolynomial *qp,
 	isl_int *n, isl_int *d);
 
+unsigned isl_qpolynomial_domain_offset(__isl_keep isl_qpolynomial *qp,
+	enum isl_dim_type type);
+
 __isl_give isl_qpolynomial *isl_qpolynomial_add_on_domain(
 	__isl_keep isl_set *dom,
 	__isl_take isl_qpolynomial *qp1,
diff --git a/lib/Analysis/isl/isl_printer.c b/lib/Analysis/isl/isl_printer.c
index 47cf3cc..05860da 100644
--- a/lib/Analysis/isl/isl_printer.c
+++ b/lib/Analysis/isl/isl_printer.c
@@ -669,9 +669,17 @@ __isl_give isl_printer *isl_printer_end_line(__isl_take isl_printer *p)
 	return p->ops->end_line(p);
 }
 
-char *isl_printer_get_str(__isl_keep isl_printer *printer)
+/* Return a copy of the string constructed by the string printer "printer".
+ */
+__isl_give char *isl_printer_get_str(__isl_keep isl_printer *printer)
 {
-	if (!printer || !printer->buf)
+	if (!printer)
+		return NULL;
+	if (printer->ops != &str_ops)
+		isl_die(isl_printer_get_ctx(printer), isl_error_invalid,
+			"isl_printer_get_str can only be called on a string "
+			"printer", return NULL);
+	if (!printer->buf)
 		return NULL;
 	return strdup(printer->buf);
 }
diff --git a/lib/Analysis/isl/isl_pw_templ.c b/lib/Analysis/isl/isl_pw_templ.c
index a9b4404..124ff34 100644
--- a/lib/Analysis/isl/isl_pw_templ.c
+++ b/lib/Analysis/isl/isl_pw_templ.c
@@ -269,6 +269,7 @@ error:
 __isl_give PW *FN(PW,align_params)(__isl_take PW *pw, __isl_take isl_space *model)
 {
 	isl_ctx *ctx;
+	isl_bool equal_params;
 
 	if (!pw || !model)
 		goto error;
@@ -280,7 +281,10 @@ __isl_give PW *FN(PW,align_params)(__isl_take PW *pw, __isl_take isl_space *mode
 	if (!isl_space_has_named_params(pw->dim))
 		isl_die(ctx, isl_error_invalid,
 			"input has unnamed parameters", goto error);
-	if (!isl_space_match(pw->dim, isl_dim_param, model, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(pw->dim, model);
+	if (equal_params < 0)
+		goto error;
+	if (!equal_params) {
 		isl_reordering *exp;
 
 		model = isl_space_drop_dims(model, isl_dim_in,
@@ -306,10 +310,14 @@ static __isl_give PW *FN(PW,align_params_pw_pw_and)(__isl_take PW *pw1,
 	__isl_give PW *(*fn)(__isl_take PW *pw1, __isl_take PW *pw2))
 {
 	isl_ctx *ctx;
+	isl_bool equal_params;
 
 	if (!pw1 || !pw2)
 		goto error;
-	if (isl_space_match(pw1->dim, isl_dim_param, pw2->dim, isl_dim_param))
+	equal_params = isl_space_has_equal_params(pw1->dim, pw2->dim);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params)
 		return fn(pw1, pw2);
 	ctx = FN(PW,get_ctx)(pw1);
 	if (!isl_space_has_named_params(pw1->dim) ||
@@ -330,10 +338,14 @@ static __isl_give PW *FN(PW,align_params_pw_set_and)(__isl_take PW *pw,
 	__isl_give PW *(*fn)(__isl_take PW *pw, __isl_take isl_set *set))
 {
 	isl_ctx *ctx;
+	isl_bool aligned;
 
 	if (!pw || !set)
 		goto error;
-	if (isl_space_match(pw->dim, isl_dim_param, set->dim, isl_dim_param))
+	aligned = isl_set_space_has_equal_params(set, pw->dim);
+	if (aligned < 0)
+		goto error;
+	if (aligned)
 		return fn(pw, set);
 	ctx = FN(PW,get_ctx)(pw);
 	if (!isl_space_has_named_params(pw->dim) ||
@@ -935,6 +947,7 @@ static __isl_give PW *FN(PW,gist_aligned)(__isl_take PW *pw,
 {
 	int i;
 	int is_universe;
+	isl_bool aligned;
 	isl_basic_set *hull = NULL;
 
 	if (!pw || !context)
@@ -953,8 +966,10 @@ static __isl_give PW *FN(PW,gist_aligned)(__isl_take PW *pw,
 		return pw;
 	}
 
-	if (!isl_space_match(pw->dim, isl_dim_param,
-				context->dim, isl_dim_param)) {
+	aligned = isl_set_space_has_equal_params(context, pw->dim);
+	if (aligned < 0)
+		goto error;
+	if (!aligned) {
 		pw = FN(PW,align_params)(pw, isl_set_get_space(context));
 		context = isl_set_align_params(context, FN(PW,get_space)(pw));
 	}
@@ -1593,10 +1608,10 @@ __isl_give PW *FN(PW,reset_user)(__isl_take PW *pw)
 	return FN(PW,reset_space)(pw, space);
 }
 
-int FN(PW,has_equal_space)(__isl_keep PW *pw1, __isl_keep PW *pw2)
+isl_bool FN(PW,has_equal_space)(__isl_keep PW *pw1, __isl_keep PW *pw2)
 {
 	if (!pw1 || !pw2)
-		return -1;
+		return isl_bool_error;
 
 	return isl_space_is_equal(pw1->dim, pw2->dim);
 }
@@ -1666,18 +1681,18 @@ isl_stat FN(PW,foreach_piece)(__isl_keep PW *pw,
 }
 
 #ifndef NO_LIFT
-static int any_divs(__isl_keep isl_set *set)
+static isl_bool any_divs(__isl_keep isl_set *set)
 {
 	int i;
 
 	if (!set)
-		return -1;
+		return isl_bool_error;
 
 	for (i = 0; i < set->n; ++i)
 		if (set->p[i]->n_div > 0)
-			return 1;
+			return isl_bool_true;
 
-	return 0;
+	return isl_bool_false;
 }
 
 static isl_stat foreach_lifted_subset(__isl_take isl_set *set,
@@ -1724,12 +1739,16 @@ isl_stat FN(PW,foreach_lifted_piece)(__isl_keep PW *pw,
 		return isl_stat_error;
 
 	for (i = 0; i < pw->n; ++i) {
+		isl_bool any;
 		isl_set *set;
 		EL *el;
 
+		any = any_divs(pw->p[i].set);
+		if (any < 0)
+			return isl_stat_error;
 		set = isl_set_copy(pw->p[i].set);
 		el = FN(EL,copy)(pw->p[i].FIELD);
-		if (!any_divs(set)) {
+		if (!any) {
 			if (fn(set, el, user) < 0)
 				return isl_stat_error;
 			continue;
@@ -1959,15 +1978,25 @@ __isl_give PW *FN(PW,normalize)(__isl_take PW *pw)
 /* Is pw1 obviously equal to pw2?
  * That is, do they have obviously identical cells and obviously identical
  * elements on each cell?
+ *
+ * If "pw1" or "pw2" contain any NaNs, then they are considered
+ * not to be the same.  A NaN is not equal to anything, not even
+ * to another NaN.
  */
 isl_bool FN(PW,plain_is_equal)(__isl_keep PW *pw1, __isl_keep PW *pw2)
 {
 	int i;
-	isl_bool equal;
+	isl_bool equal, has_nan;
 
 	if (!pw1 || !pw2)
 		return isl_bool_error;
 
+	has_nan = FN(PW,involves_nan)(pw1);
+	if (has_nan >= 0 && !has_nan)
+		has_nan = FN(PW,involves_nan)(pw2);
+	if (has_nan < 0 || has_nan)
+		return isl_bool_not(has_nan);
+
 	if (pw1 == pw2)
 		return isl_bool_true;
 	if (!isl_space_is_equal(pw1->dim, pw2->dim))
@@ -2001,18 +2030,42 @@ error:
 	return isl_bool_error;
 }
 
+/* Does "pw" involve any NaNs?
+ */
+isl_bool FN(PW,involves_nan)(__isl_keep PW *pw)
+{
+	int i;
+
+	if (!pw)
+		return isl_bool_error;
+	if (pw->n == 0)
+		return isl_bool_false;
+
+	for (i = 0; i < pw->n; ++i) {
+		isl_bool has_nan = FN(EL,involves_nan)(pw->p[i].FIELD);
+		if (has_nan < 0 || has_nan)
+			return has_nan;
+	}
+
+	return isl_bool_false;
+}
+
 #ifndef NO_PULLBACK
 static __isl_give PW *FN(PW,align_params_pw_multi_aff_and)(__isl_take PW *pw,
 	__isl_take isl_multi_aff *ma,
 	__isl_give PW *(*fn)(__isl_take PW *pw, __isl_take isl_multi_aff *ma))
 {
 	isl_ctx *ctx;
+	isl_bool equal_params;
 	isl_space *ma_space;
 
 	ma_space = isl_multi_aff_get_space(ma);
 	if (!pw || !ma || !ma_space)
 		goto error;
-	if (isl_space_match(pw->dim, isl_dim_param, ma_space, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(pw->dim, ma_space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params) {
 		isl_space_free(ma_space);
 		return fn(pw, ma);
 	}
@@ -2037,12 +2090,16 @@ static __isl_give PW *FN(PW,align_params_pw_pw_multi_aff_and)(__isl_take PW *pw,
 		__isl_take isl_pw_multi_aff *ma))
 {
 	isl_ctx *ctx;
+	isl_bool equal_params;
 	isl_space *pma_space;
 
 	pma_space = isl_pw_multi_aff_get_space(pma);
 	if (!pw || !pma || !pma_space)
 		goto error;
-	if (isl_space_match(pw->dim, isl_dim_param, pma_space, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(pw->dim, pma_space);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params) {
 		isl_space_free(pma_space);
 		return fn(pw, pma);
 	}
diff --git a/lib/Analysis/isl/isl_range.c b/lib/Analysis/isl/isl_range.c
index a23a633..d63ce58 100644
--- a/lib/Analysis/isl/isl_range.c
+++ b/lib/Analysis/isl/isl_range.c
@@ -483,8 +483,9 @@ error:
 	return isl_stat_error;
 }
 
-static int qpolynomial_bound_on_domain_range(__isl_take isl_basic_set *bset,
-	__isl_take isl_qpolynomial *poly, struct range_data *data)
+static isl_stat qpolynomial_bound_on_domain_range(
+	__isl_take isl_basic_set *bset, __isl_take isl_qpolynomial *poly,
+	struct range_data *data)
 {
 	unsigned nparam = isl_basic_set_dim(bset, isl_dim_param);
 	unsigned nvar = isl_basic_set_dim(bset, isl_dim_set);
@@ -509,18 +510,18 @@ static int qpolynomial_bound_on_domain_range(__isl_take isl_basic_set *bset,
 	isl_set_free(set);
 	isl_qpolynomial_free(poly);
 
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_set_free(set);
 	isl_qpolynomial_free(poly);
-	return -1;
+	return isl_stat_error;
 }
 
-int isl_qpolynomial_bound_on_domain_range(__isl_take isl_basic_set *bset,
+isl_stat isl_qpolynomial_bound_on_domain_range(__isl_take isl_basic_set *bset,
 	__isl_take isl_qpolynomial *poly, struct isl_bound *bound)
 {
 	struct range_data data;
-	int r;
+	isl_stat r;
 
 	data.pwf = bound->pwf;
 	data.pwf_tight = bound->pwf_tight;
diff --git a/lib/Analysis/isl/isl_range.h b/lib/Analysis/isl/isl_range.h
index c097079..6a5dd4a 100644
--- a/lib/Analysis/isl/isl_range.h
+++ b/lib/Analysis/isl/isl_range.h
@@ -1,6 +1,6 @@
 #include <isl_bound.h>
 
-int isl_qpolynomial_bound_on_domain_range(__isl_take isl_basic_set *bset,
+isl_stat isl_qpolynomial_bound_on_domain_range(__isl_take isl_basic_set *bset,
 	__isl_take isl_qpolynomial *poly, struct isl_bound *bound);
 __isl_give isl_qpolynomial *isl_qpolynomial_terms_of_sign(
 	__isl_keep isl_qpolynomial *poly, int *signs, int sign);
diff --git a/lib/Analysis/isl/isl_sample.c b/lib/Analysis/isl/isl_sample.c
index 5098ce6..058d689 100644
--- a/lib/Analysis/isl/isl_sample.c
+++ b/lib/Analysis/isl/isl_sample.c
@@ -21,7 +21,10 @@
 #include <isl_options_private.h>
 #include <isl_vec_private.h>
 
-static struct isl_vec *empty_sample(struct isl_basic_set *bset)
+#include <bset_from_bmap.c>
+#include <set_to_map.c>
+
+static __isl_give isl_vec *empty_sample(__isl_take isl_basic_set *bset)
 {
 	struct isl_vec *vec;
 
@@ -34,7 +37,7 @@ static struct isl_vec *empty_sample(struct isl_basic_set *bset)
  * As a special case, if bset is zero-dimensional, this
  * function creates a zero-dimensional sample point.
  */
-static struct isl_vec *zero_sample(struct isl_basic_set *bset)
+static __isl_give isl_vec *zero_sample(__isl_take isl_basic_set *bset)
 {
 	unsigned dim;
 	struct isl_vec *sample;
@@ -49,7 +52,7 @@ static struct isl_vec *zero_sample(struct isl_basic_set *bset)
 	return sample;
 }
 
-static struct isl_vec *interval_sample(struct isl_basic_set *bset)
+static __isl_give isl_vec *interval_sample(__isl_take isl_basic_set *bset)
 {
 	int i;
 	isl_int t;
@@ -116,8 +119,8 @@ error:
  * in the resulting bset, using the specified recurse function,
  * and then transform the sample back to the original space.
  */
-static struct isl_vec *sample_eq(struct isl_basic_set *bset,
-	struct isl_vec *(*recurse)(struct isl_basic_set *))
+static __isl_give isl_vec *sample_eq(__isl_take isl_basic_set *bset,
+	__isl_give isl_vec *(*recurse)(__isl_take isl_basic_set *))
 {
 	struct isl_mat *T;
 	struct isl_vec *sample;
@@ -521,7 +524,7 @@ error:
 	return NULL;
 }
 
-static struct isl_vec *sample_bounded(struct isl_basic_set *bset);
+static __isl_give isl_vec *sample_bounded(__isl_take isl_basic_set *bset);
 
 /* Compute a sample point of the given basic set, based on the given,
  * non-trivial factorization.
@@ -598,7 +601,7 @@ error:
  * and then use isl_tab_sample to find a sample, passing it
  * the identity matrix as initial basis.
  */ 
-static struct isl_vec *sample_bounded(struct isl_basic_set *bset)
+static __isl_give isl_vec *sample_bounded(__isl_take isl_basic_set *bset)
 {
 	unsigned dim;
 	struct isl_vec *sample;
@@ -669,8 +672,8 @@ error:
  * where [1 s] is the sample value and I is the identity matrix of the
  * appropriate dimension.
  */
-static struct isl_basic_set *plug_in(struct isl_basic_set *bset,
-	struct isl_vec *sample)
+static __isl_give isl_basic_set *plug_in(__isl_take isl_basic_set *bset,
+	__isl_take isl_vec *sample)
 {
 	int i;
 	unsigned total;
@@ -705,7 +708,7 @@ error:
 /* Given a basic set "bset", return any (possibly non-integer) point
  * in the basic set.
  */
-static struct isl_vec *rational_sample(struct isl_basic_set *bset)
+static __isl_give isl_vec *rational_sample(__isl_take isl_basic_set *bset)
 {
 	struct isl_tab *tab;
 	struct isl_vec *sample;
@@ -755,8 +758,8 @@ static struct isl_vec *rational_sample(struct isl_basic_set *bset)
  * and we only have to add the smallest negative a_i (if any)
  * instead of the sum of all negative a_i.
  */
-static struct isl_basic_set *shift_cone(struct isl_basic_set *cone,
-	struct isl_vec *vec)
+static __isl_give isl_basic_set *shift_cone(__isl_take isl_basic_set *cone,
+	__isl_take isl_vec *vec)
 {
 	int i, j, k;
 	unsigned total;
@@ -813,8 +816,8 @@ error:
  * Then we simply round up the coordinates of x and return the
  * resulting integer point.
  */
-static struct isl_vec *round_up_in_cone(struct isl_vec *vec,
-	struct isl_basic_set *cone, struct isl_mat *U)
+static __isl_give isl_vec *round_up_in_cone(__isl_take isl_vec *vec,
+	__isl_take isl_basic_set *cone, __isl_take isl_mat *U)
 {
 	unsigned total;
 
@@ -848,7 +851,8 @@ error:
 /* Concatenate two integer vectors, i.e., two vectors with denominator
  * (stored in element 0) equal to 1.
  */
-static struct isl_vec *vec_concat(struct isl_vec *vec1, struct isl_vec *vec2)
+static __isl_give isl_vec *vec_concat(__isl_take isl_vec *vec1,
+	__isl_take isl_vec *vec2)
 {
 	struct isl_vec *vec;
 
@@ -1097,7 +1101,7 @@ int isl_tab_set_initial_basis_with_cone(struct isl_tab *tab,
  * sample_with_cone.  Otherwise, we directly perform generalized basis
  * reduction.
  */
-static struct isl_vec *gbr_sample(struct isl_basic_set *bset)
+static __isl_give isl_vec *gbr_sample(__isl_take isl_basic_set *bset)
 {
 	unsigned dim;
 	struct isl_basic_set *cone;
@@ -1118,7 +1122,8 @@ error:
 	return NULL;
 }
 
-static struct isl_vec *basic_set_sample(struct isl_basic_set *bset, int bounded)
+static __isl_give isl_vec *basic_set_sample(__isl_take isl_basic_set *bset,
+	int bounded)
 {
 	struct isl_ctx *ctx;
 	unsigned dim;
@@ -1168,7 +1173,7 @@ __isl_give isl_vec *isl_basic_set_sample_vec(__isl_take isl_basic_set *bset)
 /* Compute an integer sample in "bset", where the caller guarantees
  * that "bset" is bounded.
  */
-struct isl_vec *isl_basic_set_sample_bounded(struct isl_basic_set *bset)
+__isl_give isl_vec *isl_basic_set_sample_bounded(__isl_take isl_basic_set *bset)
 {
 	return basic_set_sample(bset, 1);
 }
@@ -1261,7 +1266,7 @@ error:
 
 __isl_give isl_basic_set *isl_set_sample(__isl_take isl_set *set)
 {
-	return (isl_basic_set *) isl_map_sample((isl_map *)set);
+	return bset_from_bmap(isl_map_sample(set_to_map(set)));
 }
 
 __isl_give isl_point *isl_basic_set_sample_point(__isl_take isl_basic_set *bset)
diff --git a/lib/Analysis/isl/isl_sample.h b/lib/Analysis/isl/isl_sample.h
index 57898b2..1357946 100644
--- a/lib/Analysis/isl/isl_sample.h
+++ b/lib/Analysis/isl/isl_sample.h
@@ -18,7 +18,8 @@ extern "C" {
 #endif
 
 __isl_give isl_vec *isl_basic_set_sample_vec(__isl_take isl_basic_set *bset);
-struct isl_vec *isl_basic_set_sample_bounded(struct isl_basic_set *bset);
+__isl_give isl_vec *isl_basic_set_sample_bounded(
+	__isl_take isl_basic_set *bset);
 __isl_give isl_vec *isl_basic_set_sample_with_cone(
 	__isl_take isl_basic_set *bset, __isl_take isl_basic_set *cone);
 
diff --git a/lib/Analysis/isl/isl_scan.c b/lib/Analysis/isl/isl_scan.c
index e8cd0c0..fea42f1 100644
--- a/lib/Analysis/isl/isl_scan.c
+++ b/lib/Analysis/isl/isl_scan.c
@@ -65,7 +65,7 @@ static int add_solution(struct isl_tab *tab, struct isl_scan_callback *callback)
 	return callback->add(callback, sample);
 }
 
-static int scan_0D(struct isl_basic_set *bset,
+static isl_stat scan_0D(__isl_take isl_basic_set *bset,
 	struct isl_scan_callback *callback)
 {
 	struct isl_vec *sample;
@@ -74,7 +74,7 @@ static int scan_0D(struct isl_basic_set *bset,
 	isl_basic_set_free(bset);
 
 	if (!sample)
-		return -1;
+		return isl_stat_error;
 
 	isl_int_set_si(sample->el[0], 1);
 
@@ -99,7 +99,7 @@ static int scan_0D(struct isl_basic_set *bset,
  * Solutions are added in the leaves of the search tree, i.e., after
  * we have fixed a value in each direction of the basis.
  */
-int isl_basic_set_scan(struct isl_basic_set *bset,
+isl_stat isl_basic_set_scan(__isl_take isl_basic_set *bset,
 	struct isl_scan_callback *callback)
 {
 	unsigned dim;
@@ -113,7 +113,7 @@ int isl_basic_set_scan(struct isl_basic_set *bset,
 	enum isl_lp_result res;
 
 	if (!bset)
-		return -1;
+		return isl_stat_error;
 
 	dim = isl_basic_set_total_dim(bset);
 	if (dim == 0)
@@ -209,7 +209,7 @@ int isl_basic_set_scan(struct isl_basic_set *bset,
 	isl_vec_free(max);
 	isl_basic_set_free(bset);
 	isl_mat_free(B);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_tab_free(tab);
 	free(snap);
@@ -217,10 +217,11 @@ error:
 	isl_vec_free(max);
 	isl_basic_set_free(bset);
 	isl_mat_free(B);
-	return -1;
+	return isl_stat_error;
 }
 
-int isl_set_scan(__isl_take isl_set *set, struct isl_scan_callback *callback)
+isl_stat isl_set_scan(__isl_take isl_set *set,
+	struct isl_scan_callback *callback)
 {
 	int i;
 
@@ -239,10 +240,10 @@ int isl_set_scan(__isl_take isl_set *set, struct isl_scan_callback *callback)
 			goto error;
 
 	isl_set_free(set);
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_set_free(set);
-	return -1;
+	return isl_stat_error;
 }
 
 int isl_basic_set_count_upto(__isl_keep isl_basic_set *bset,
diff --git a/lib/Analysis/isl/isl_scan.h b/lib/Analysis/isl/isl_scan.h
index 5d31d1b..f2a5100 100644
--- a/lib/Analysis/isl/isl_scan.h
+++ b/lib/Analysis/isl/isl_scan.h
@@ -18,8 +18,9 @@ struct isl_scan_callback {
 		__isl_take isl_vec *sample);
 };
 
-int isl_basic_set_scan(struct isl_basic_set *bset,
+isl_stat isl_basic_set_scan(__isl_take isl_basic_set *bset,
+	struct isl_scan_callback *callback);
+isl_stat isl_set_scan(__isl_take isl_set *set,
 	struct isl_scan_callback *callback);
-int isl_set_scan(__isl_take isl_set *set, struct isl_scan_callback *callback);
 
 #endif
diff --git a/lib/Analysis/isl/isl_schedule.c b/lib/Analysis/isl/isl_schedule.c
index f37e428..90d8d5d 100644
--- a/lib/Analysis/isl/isl_schedule.c
+++ b/lib/Analysis/isl/isl_schedule.c
@@ -1150,36 +1150,6 @@ __isl_give isl_printer *isl_printer_print_schedule(__isl_take isl_printer *p,
 	return p;
 }
 
-void isl_schedule_dump(__isl_keep isl_schedule *schedule)
-{
-	isl_printer *printer;
-
-	if (!schedule)
-		return;
-
-	printer = isl_printer_to_file(isl_schedule_get_ctx(schedule), stderr);
-	printer = isl_printer_set_yaml_style(printer, ISL_YAML_STYLE_BLOCK);
-	printer = isl_printer_print_schedule(printer, schedule);
-
-	isl_printer_free(printer);
-}
-
-/* Return a string representation of "schedule".
- * Print the schedule in flow format.
- */
-__isl_give char *isl_schedule_to_str(__isl_keep isl_schedule *schedule)
-{
-	isl_printer *printer;
-	char *s;
-
-	if (!schedule)
-		return NULL;
-
-	printer = isl_printer_to_str(isl_schedule_get_ctx(schedule));
-	printer = isl_printer_set_yaml_style(printer, ISL_YAML_STYLE_FLOW);
-	printer = isl_printer_print_schedule(printer, schedule);
-	s = isl_printer_get_str(printer);
-	isl_printer_free(printer);
-
-	return s;
-}
+#undef BASE
+#define BASE schedule
+#include <print_templ_yaml.c>
diff --git a/lib/Analysis/isl/isl_schedule_band.c b/lib/Analysis/isl/isl_schedule_band.c
index f0d9121..ed20961 100644
--- a/lib/Analysis/isl/isl_schedule_band.c
+++ b/lib/Analysis/isl/isl_schedule_band.c
@@ -257,7 +257,7 @@ __isl_give isl_schedule_band *isl_schedule_band_member_set_coincident(
 	if (pos < 0 || pos >= band->n)
 		isl_die(isl_schedule_band_get_ctx(band), isl_error_invalid,
 			"invalid member position",
-			isl_schedule_band_free(band));
+			return isl_schedule_band_free(band));
 
 	band->coincident[pos] = coincident;
 
@@ -392,7 +392,7 @@ __isl_give isl_schedule_band *isl_schedule_band_member_set_ast_loop_type(
 	if (pos < 0 || pos >= band->n)
 		isl_die(isl_schedule_band_get_ctx(band), isl_error_invalid,
 			"invalid member position",
-			isl_schedule_band_free(band));
+			return isl_schedule_band_free(band));
 
 	band = isl_schedule_band_cow(band);
 	if (!band)
@@ -450,7 +450,7 @@ isl_schedule_band_member_set_isolate_ast_loop_type(
 	if (pos < 0 || pos >= band->n)
 		isl_die(isl_schedule_band_get_ctx(band), isl_error_invalid,
 			"invalid member position",
-			isl_schedule_band_free(band));
+			return isl_schedule_band_free(band));
 
 	band = isl_schedule_band_cow(band);
 	if (!band)
@@ -523,14 +523,12 @@ static __isl_give isl_union_set *add_loop_types(
 	int isolate)
 {
 	int i;
-	isl_ctx *ctx;
 
 	if (!type)
 		return options;
 	if (!options)
 		return NULL;
 
-	ctx = isl_union_set_get_ctx(options);
 	for (i = 0; i < n; ++i) {
 		int first;
 		isl_space *space;
@@ -945,7 +943,7 @@ __isl_give isl_schedule_band *isl_schedule_band_replace_ast_build_option(
 
 	band = isl_schedule_band_cow(band);
 	if (!band)
-		return NULL;
+		goto error;
 
 	options = band->ast_build_options;
 	options = isl_union_set_subtract(options, isl_union_set_from_set(drop));
@@ -956,6 +954,11 @@ __isl_give isl_schedule_band *isl_schedule_band_replace_ast_build_option(
 		return isl_schedule_band_free(band);
 
 	return band;
+error:
+	isl_schedule_band_free(band);
+	isl_set_free(drop);
+	isl_set_free(add);
+	return NULL;
 }
 
 /* Multiply the partial schedule of "band" with the factors in "mv".
diff --git a/lib/Analysis/isl/isl_schedule_constraints.c b/lib/Analysis/isl/isl_schedule_constraints.c
new file mode 100644
index 0000000..af7ca29
--- /dev/null
+++ b/lib/Analysis/isl/isl_schedule_constraints.c
@@ -0,0 +1,725 @@
+/*
+ * Copyright 2012      Ecole Normale Superieure
+ * Copyright 2015-2016 Sven Verdoolaege
+ *
+ * Use of this software is governed by the MIT license
+ *
+ * Written by Sven Verdoolaege,
+ * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
+ */
+
+#include <isl_schedule_constraints.h>
+#include <isl/schedule.h>
+#include <isl/set.h>
+#include <isl/map.h>
+#include <isl/union_set.h>
+#include <isl/union_map.h>
+#include <isl/stream.h>
+
+/* The constraints that need to be satisfied by a schedule on "domain".
+ *
+ * "context" specifies extra constraints on the parameters.
+ *
+ * "validity" constraints map domain elements i to domain elements
+ * that should be scheduled after i.  (Hard constraint)
+ * "proximity" constraints map domain elements i to domains elements
+ * that should be scheduled as early as possible after i (or before i).
+ * (Soft constraint)
+ *
+ * "condition" and "conditional_validity" constraints map possibly "tagged"
+ * domain elements i -> s to "tagged" domain elements j -> t.
+ * The elements of the "conditional_validity" constraints, but without the
+ * tags (i.e., the elements i -> j) are treated as validity constraints,
+ * except that during the construction of a tilable band,
+ * the elements of the "conditional_validity" constraints may be violated
+ * provided that all adjacent elements of the "condition" constraints
+ * are local within the band.
+ * A dependence is local within a band if domain and range are mapped
+ * to the same schedule point by the band.
+ */
+struct isl_schedule_constraints {
+	isl_union_set *domain;
+	isl_set *context;
+
+	isl_union_map *constraint[isl_edge_last + 1];
+};
+
+__isl_give isl_schedule_constraints *isl_schedule_constraints_copy(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	isl_ctx *ctx;
+	isl_schedule_constraints *sc_copy;
+	enum isl_edge_type i;
+
+	ctx = isl_union_set_get_ctx(sc->domain);
+	sc_copy = isl_calloc_type(ctx, struct isl_schedule_constraints);
+	if (!sc_copy)
+		return NULL;
+
+	sc_copy->domain = isl_union_set_copy(sc->domain);
+	sc_copy->context = isl_set_copy(sc->context);
+	if (!sc_copy->domain || !sc_copy->context)
+		return isl_schedule_constraints_free(sc_copy);
+
+	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
+		sc_copy->constraint[i] = isl_union_map_copy(sc->constraint[i]);
+		if (!sc_copy->constraint[i])
+			return isl_schedule_constraints_free(sc_copy);
+	}
+
+	return sc_copy;
+}
+
+/* Construct an empty (invalid) isl_schedule_constraints object.
+ * The caller is responsible for setting the domain and initializing
+ * all the other fields, e.g., by calling isl_schedule_constraints_init.
+ */
+static __isl_give isl_schedule_constraints *isl_schedule_constraints_alloc(
+	isl_ctx *ctx)
+{
+	return isl_calloc_type(ctx, struct isl_schedule_constraints);
+}
+
+/* Initialize all the fields of "sc", except domain, which is assumed
+ * to have been set by the caller.
+ */
+static __isl_give isl_schedule_constraints *isl_schedule_constraints_init(
+	__isl_take isl_schedule_constraints *sc)
+{
+	isl_space *space;
+	isl_union_map *empty;
+	enum isl_edge_type i;
+
+	if (!sc)
+		return NULL;
+	if (!sc->domain)
+		return isl_schedule_constraints_free(sc);
+	space = isl_union_set_get_space(sc->domain);
+	if (!sc->context)
+		sc->context = isl_set_universe(isl_space_copy(space));
+	empty = isl_union_map_empty(space);
+	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
+		if (sc->constraint[i])
+			continue;
+		sc->constraint[i] = isl_union_map_copy(empty);
+		if (!sc->constraint[i])
+			sc->domain = isl_union_set_free(sc->domain);
+	}
+	isl_union_map_free(empty);
+
+	if (!sc->domain || !sc->context)
+		return isl_schedule_constraints_free(sc);
+
+	return sc;
+}
+
+/* Construct an isl_schedule_constraints object for computing a schedule
+ * on "domain".  The initial object does not impose any constraints.
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_on_domain(
+	__isl_take isl_union_set *domain)
+{
+	isl_ctx *ctx;
+	isl_schedule_constraints *sc;
+
+	if (!domain)
+		return NULL;
+
+	ctx = isl_union_set_get_ctx(domain);
+	sc = isl_schedule_constraints_alloc(ctx);
+	if (!sc)
+		goto error;
+
+	sc->domain = domain;
+	return isl_schedule_constraints_init(sc);
+error:
+	isl_union_set_free(domain);
+	return NULL;
+}
+
+/* Replace the domain of "sc" by "domain".
+ */
+static __isl_give isl_schedule_constraints *isl_schedule_constraints_set_domain(
+	__isl_take isl_schedule_constraints *sc,
+	__isl_take isl_union_set *domain)
+{
+	if (!sc || !domain)
+		goto error;
+
+	isl_union_set_free(sc->domain);
+	sc->domain = domain;
+
+	return sc;
+error:
+	isl_schedule_constraints_free(sc);
+	isl_union_set_free(domain);
+	return NULL;
+}
+
+/* Replace the context of "sc" by "context".
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_set_context(
+	__isl_take isl_schedule_constraints *sc, __isl_take isl_set *context)
+{
+	if (!sc || !context)
+		goto error;
+
+	isl_set_free(sc->context);
+	sc->context = context;
+
+	return sc;
+error:
+	isl_schedule_constraints_free(sc);
+	isl_set_free(context);
+	return NULL;
+}
+
+/* Replace the constraints of type "type" in "sc" by "c".
+ */
+static __isl_give isl_schedule_constraints *isl_schedule_constraints_set(
+	__isl_take isl_schedule_constraints *sc, enum isl_edge_type type,
+	__isl_take isl_union_map *c)
+{
+	if (!sc || !c)
+		goto error;
+
+	isl_union_map_free(sc->constraint[type]);
+	sc->constraint[type] = c;
+
+	return sc;
+error:
+	isl_schedule_constraints_free(sc);
+	isl_union_map_free(c);
+	return NULL;
+}
+
+/* Replace the validity constraints of "sc" by "validity".
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_set_validity(
+	__isl_take isl_schedule_constraints *sc,
+	__isl_take isl_union_map *validity)
+{
+	return isl_schedule_constraints_set(sc, isl_edge_validity, validity);
+}
+
+/* Replace the coincidence constraints of "sc" by "coincidence".
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_set_coincidence(
+	__isl_take isl_schedule_constraints *sc,
+	__isl_take isl_union_map *coincidence)
+{
+	return isl_schedule_constraints_set(sc, isl_edge_coincidence,
+						coincidence);
+}
+
+/* Replace the proximity constraints of "sc" by "proximity".
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_set_proximity(
+	__isl_take isl_schedule_constraints *sc,
+	__isl_take isl_union_map *proximity)
+{
+	return isl_schedule_constraints_set(sc, isl_edge_proximity, proximity);
+}
+
+/* Replace the conditional validity constraints of "sc" by "condition"
+ * and "validity".
+ */
+__isl_give isl_schedule_constraints *
+isl_schedule_constraints_set_conditional_validity(
+	__isl_take isl_schedule_constraints *sc,
+	__isl_take isl_union_map *condition,
+	__isl_take isl_union_map *validity)
+{
+	sc = isl_schedule_constraints_set(sc, isl_edge_condition, condition);
+	sc = isl_schedule_constraints_set(sc, isl_edge_conditional_validity,
+						validity);
+	return sc;
+}
+
+__isl_null isl_schedule_constraints *isl_schedule_constraints_free(
+	__isl_take isl_schedule_constraints *sc)
+{
+	enum isl_edge_type i;
+
+	if (!sc)
+		return NULL;
+
+	isl_union_set_free(sc->domain);
+	isl_set_free(sc->context);
+	for (i = isl_edge_first; i <= isl_edge_last; ++i)
+		isl_union_map_free(sc->constraint[i]);
+
+	free(sc);
+
+	return NULL;
+}
+
+isl_ctx *isl_schedule_constraints_get_ctx(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	return sc ? isl_union_set_get_ctx(sc->domain) : NULL;
+}
+
+/* Return the domain of "sc".
+ */
+__isl_give isl_union_set *isl_schedule_constraints_get_domain(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	if (!sc)
+		return NULL;
+
+	return isl_union_set_copy(sc->domain);
+}
+
+/* Return the context of "sc".
+ */
+__isl_give isl_set *isl_schedule_constraints_get_context(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	if (!sc)
+		return NULL;
+
+	return isl_set_copy(sc->context);
+}
+
+/* Return the constraints of type "type" in "sc".
+ */
+__isl_give isl_union_map *isl_schedule_constraints_get(
+	__isl_keep isl_schedule_constraints *sc, enum isl_edge_type type)
+{
+	if (!sc)
+		return NULL;
+
+	return isl_union_map_copy(sc->constraint[type]);
+}
+
+/* Return the validity constraints of "sc".
+ */
+__isl_give isl_union_map *isl_schedule_constraints_get_validity(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	return isl_schedule_constraints_get(sc, isl_edge_validity);
+}
+
+/* Return the coincidence constraints of "sc".
+ */
+__isl_give isl_union_map *isl_schedule_constraints_get_coincidence(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	return isl_schedule_constraints_get(sc, isl_edge_coincidence);
+}
+
+/* Return the proximity constraints of "sc".
+ */
+__isl_give isl_union_map *isl_schedule_constraints_get_proximity(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	return isl_schedule_constraints_get(sc, isl_edge_proximity);
+}
+
+/* Return the conditional validity constraints of "sc".
+ */
+__isl_give isl_union_map *isl_schedule_constraints_get_conditional_validity(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	return isl_schedule_constraints_get(sc, isl_edge_conditional_validity);
+}
+
+/* Return the conditions for the conditional validity constraints of "sc".
+ */
+__isl_give isl_union_map *
+isl_schedule_constraints_get_conditional_validity_condition(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	return isl_schedule_constraints_get(sc, isl_edge_condition);
+}
+
+/* Add "c" to the constraints of type "type" in "sc".
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_add(
+	__isl_take isl_schedule_constraints *sc, enum isl_edge_type type,
+	__isl_take isl_union_map *c)
+{
+	if (!sc || !c)
+		goto error;
+
+	c = isl_union_map_union(sc->constraint[type], c);
+	sc->constraint[type] = c;
+	if (!c)
+		return isl_schedule_constraints_free(sc);
+
+	return sc;
+error:
+	isl_schedule_constraints_free(sc);
+	isl_union_map_free(c);
+	return NULL;
+}
+
+/* Can a schedule constraint of type "type" be tagged?
+ */
+static int may_be_tagged(enum isl_edge_type type)
+{
+	if (type == isl_edge_condition || type == isl_edge_conditional_validity)
+		return 1;
+	return 0;
+}
+
+/* Apply "umap" to the domains of the wrapped relations
+ * inside the domain and range of "c".
+ *
+ * That is, for each map of the form
+ *
+ *	[D -> S] -> [E -> T]
+ *
+ * in "c", apply "umap" to D and E.
+ *
+ * D is exposed by currying the relation to
+ *
+ *	D -> [S -> [E -> T]]
+ *
+ * E is exposed by doing the same to the inverse of "c".
+ */
+static __isl_give isl_union_map *apply_factor_domain(
+	__isl_take isl_union_map *c, __isl_keep isl_union_map *umap)
+{
+	c = isl_union_map_curry(c);
+	c = isl_union_map_apply_domain(c, isl_union_map_copy(umap));
+	c = isl_union_map_uncurry(c);
+
+	c = isl_union_map_reverse(c);
+	c = isl_union_map_curry(c);
+	c = isl_union_map_apply_domain(c, isl_union_map_copy(umap));
+	c = isl_union_map_uncurry(c);
+	c = isl_union_map_reverse(c);
+
+	return c;
+}
+
+/* Apply "umap" to domain and range of "c".
+ * If "tag" is set, then "c" may contain tags and then "umap"
+ * needs to be applied to the domains of the wrapped relations
+ * inside the domain and range of "c".
+ */
+static __isl_give isl_union_map *apply(__isl_take isl_union_map *c,
+	__isl_keep isl_union_map *umap, int tag)
+{
+	isl_union_map *t;
+
+	if (tag)
+		t = isl_union_map_copy(c);
+	c = isl_union_map_apply_domain(c, isl_union_map_copy(umap));
+	c = isl_union_map_apply_range(c, isl_union_map_copy(umap));
+	if (!tag)
+		return c;
+	t = apply_factor_domain(t, umap);
+	c = isl_union_map_union(c, t);
+	return c;
+}
+
+/* Apply "umap" to the domain of the schedule constraints "sc".
+ *
+ * The two sides of the various schedule constraints are adjusted
+ * accordingly.
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_apply(
+	__isl_take isl_schedule_constraints *sc,
+	__isl_take isl_union_map *umap)
+{
+	enum isl_edge_type i;
+
+	if (!sc || !umap)
+		goto error;
+
+	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
+		int tag = may_be_tagged(i);
+
+		sc->constraint[i] = apply(sc->constraint[i], umap, tag);
+		if (!sc->constraint[i])
+			goto error;
+	}
+	sc->domain = isl_union_set_apply(sc->domain, umap);
+	if (!sc->domain)
+		return isl_schedule_constraints_free(sc);
+
+	return sc;
+error:
+	isl_schedule_constraints_free(sc);
+	isl_union_map_free(umap);
+	return NULL;
+}
+
+/* An enumeration of the various keys that may appear in a YAML mapping
+ * of an isl_schedule_constraints object.
+ * The keys for the edge types are assumed to have the same values
+ * as the edge types in isl_edge_type.
+ */
+enum isl_sc_key {
+	isl_sc_key_error = -1,
+	isl_sc_key_validity = isl_edge_validity,
+	isl_sc_key_coincidence = isl_edge_coincidence,
+	isl_sc_key_condition = isl_edge_condition,
+	isl_sc_key_conditional_validity = isl_edge_conditional_validity,
+	isl_sc_key_proximity = isl_edge_proximity,
+	isl_sc_key_domain,
+	isl_sc_key_context,
+	isl_sc_key_end
+};
+
+/* Textual representations of the YAML keys for an isl_schedule_constraints
+ * object.
+ */
+static char *key_str[] = {
+	[isl_sc_key_validity] = "validity",
+	[isl_sc_key_coincidence] = "coincidence",
+	[isl_sc_key_condition] = "condition",
+	[isl_sc_key_conditional_validity] = "conditional_validity",
+	[isl_sc_key_proximity] = "proximity",
+	[isl_sc_key_domain] = "domain",
+	[isl_sc_key_context] = "context",
+};
+
+/* Print a key, value pair for the edge of type "type" in "sc" to "p".
+ */
+static __isl_give isl_printer *print_constraint(__isl_take isl_printer *p,
+	__isl_keep isl_schedule_constraints *sc, enum isl_edge_type type)
+{
+	p = isl_printer_print_str(p, key_str[type]);
+	p = isl_printer_yaml_next(p);
+	p = isl_printer_print_union_map(p, sc->constraint[type]);
+	p = isl_printer_yaml_next(p);
+
+	return p;
+}
+
+/* Print "sc" to "p"
+ *
+ * In particular, print the isl_schedule_constraints object as a YAML document.
+ */
+__isl_give isl_printer *isl_printer_print_schedule_constraints(
+	__isl_take isl_printer *p, __isl_keep isl_schedule_constraints *sc)
+{
+	if (!sc)
+		return isl_printer_free(p);
+
+	p = isl_printer_yaml_start_mapping(p);
+	p = isl_printer_print_str(p, key_str[isl_sc_key_domain]);
+	p = isl_printer_yaml_next(p);
+	p = isl_printer_print_union_set(p, sc->domain);
+	p = isl_printer_yaml_next(p);
+	p = isl_printer_print_str(p, key_str[isl_sc_key_context]);
+	p = isl_printer_yaml_next(p);
+	p = isl_printer_print_set(p, sc->context);
+	p = isl_printer_yaml_next(p);
+	p = print_constraint(p, sc, isl_edge_validity);
+	p = print_constraint(p, sc, isl_edge_proximity);
+	p = print_constraint(p, sc, isl_edge_coincidence);
+	p = print_constraint(p, sc, isl_edge_condition);
+	p = print_constraint(p, sc, isl_edge_conditional_validity);
+	p = isl_printer_yaml_end_mapping(p);
+
+	return p;
+}
+
+#undef BASE
+#define BASE schedule_constraints
+#include <print_templ_yaml.c>
+
+#undef KEY
+#define KEY enum isl_sc_key
+#undef KEY_ERROR
+#define KEY_ERROR isl_sc_key_error
+#undef KEY_END
+#define KEY_END isl_sc_key_end
+#include "extract_key.c"
+
+#undef BASE
+#define BASE set
+#include "read_in_string_templ.c"
+
+#undef BASE
+#define BASE union_set
+#include "read_in_string_templ.c"
+
+#undef BASE
+#define BASE union_map
+#include "read_in_string_templ.c"
+
+/* Read an isl_schedule_constraints object from "s".
+ *
+ * Start off with an empty (invalid) isl_schedule_constraints object and
+ * then fill up the fields based on the input.
+ * The input needs to contain at least a description of the domain.
+ * The other fields are set to defaults by isl_schedule_constraints_init
+ * if they are not specified in the input.
+ */
+__isl_give isl_schedule_constraints *isl_stream_read_schedule_constraints(
+	isl_stream *s)
+{
+	isl_ctx *ctx;
+	isl_schedule_constraints *sc;
+	int more;
+	int domain_set = 0;
+
+	if (isl_stream_yaml_read_start_mapping(s))
+		return NULL;
+
+	ctx = isl_stream_get_ctx(s);
+	sc = isl_schedule_constraints_alloc(ctx);
+	while ((more = isl_stream_yaml_next(s)) > 0) {
+		enum isl_sc_key key;
+		isl_set *context;
+		isl_union_set *domain;
+		isl_union_map *constraints;
+
+		key = get_key(s);
+		if (isl_stream_yaml_next(s) < 0)
+			return isl_schedule_constraints_free(sc);
+		switch (key) {
+		case isl_sc_key_end:
+		case isl_sc_key_error:
+			return isl_schedule_constraints_free(sc);
+		case isl_sc_key_domain:
+			domain_set = 1;
+			domain = read_union_set(s);
+			sc = isl_schedule_constraints_set_domain(sc, domain);
+			if (!sc)
+				return NULL;
+			break;
+		case isl_sc_key_context:
+			context = read_set(s);
+			sc = isl_schedule_constraints_set_context(sc, context);
+			if (!sc)
+				return NULL;
+			break;
+		default:
+			constraints = read_union_map(s);
+			sc = isl_schedule_constraints_set(sc, key, constraints);
+			if (!sc)
+				return NULL;
+			break;
+		}
+	}
+	if (more < 0)
+		return isl_schedule_constraints_free(sc);
+
+	if (isl_stream_yaml_read_end_mapping(s) < 0) {
+		isl_stream_error(s, NULL, "unexpected extra elements");
+		return isl_schedule_constraints_free(sc);
+	}
+
+	if (!domain_set) {
+		isl_stream_error(s, NULL, "no domain specified");
+		return isl_schedule_constraints_free(sc);
+	}
+
+	return isl_schedule_constraints_init(sc);
+}
+
+/* Read an isl_schedule_constraints object from the file "input".
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_read_from_file(
+	isl_ctx *ctx, FILE *input)
+{
+	struct isl_stream *s;
+	isl_schedule_constraints *sc;
+
+	s = isl_stream_new_file(ctx, input);
+	if (!s)
+		return NULL;
+	sc = isl_stream_read_schedule_constraints(s);
+	isl_stream_free(s);
+
+	return sc;
+}
+
+/* Read an isl_schedule_constraints object from the string "str".
+ */
+__isl_give isl_schedule_constraints *isl_schedule_constraints_read_from_str(
+	isl_ctx *ctx, const char *str)
+{
+	struct isl_stream *s;
+	isl_schedule_constraints *sc;
+
+	s = isl_stream_new_str(ctx, str);
+	if (!s)
+		return NULL;
+	sc = isl_stream_read_schedule_constraints(s);
+	isl_stream_free(s);
+
+	return sc;
+}
+
+/* Align the parameters of the fields of "sc".
+ */
+__isl_give isl_schedule_constraints *
+isl_schedule_constraints_align_params(__isl_take isl_schedule_constraints *sc)
+{
+	isl_space *space;
+	enum isl_edge_type i;
+
+	if (!sc)
+		return NULL;
+
+	space = isl_union_set_get_space(sc->domain);
+	space = isl_space_align_params(space, isl_set_get_space(sc->context));
+	for (i = isl_edge_first; i <= isl_edge_last; ++i)
+		space = isl_space_align_params(space,
+				    isl_union_map_get_space(sc->constraint[i]));
+
+	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
+		sc->constraint[i] = isl_union_map_align_params(
+				    sc->constraint[i], isl_space_copy(space));
+		if (!sc->constraint[i])
+			space = isl_space_free(space);
+	}
+	sc->context = isl_set_align_params(sc->context, isl_space_copy(space));
+	sc->domain = isl_union_set_align_params(sc->domain, space);
+	if (!sc->context || !sc->domain)
+		return isl_schedule_constraints_free(sc);
+
+	return sc;
+}
+
+/* Add the number of basic maps in "map" to *n.
+ */
+static isl_stat add_n_basic_map(__isl_take isl_map *map, void *user)
+{
+	int *n = user;
+
+	*n += isl_map_n_basic_map(map);
+	isl_map_free(map);
+
+	return isl_stat_ok;
+}
+
+/* Return the total number of isl_basic_maps in the constraints of "sc".
+ * Return -1 on error.
+ */
+int isl_schedule_constraints_n_basic_map(
+	__isl_keep isl_schedule_constraints *sc)
+{
+	enum isl_edge_type i;
+	int n = 0;
+
+	if (!sc)
+		return -1;
+	for (i = isl_edge_first; i <= isl_edge_last; ++i)
+		if (isl_union_map_foreach_map(sc->constraint[i],
+						&add_n_basic_map, &n) < 0)
+			return -1;
+
+	return n;
+}
+
+/* Return the total number of isl_maps in the constraints of "sc".
+ */
+int isl_schedule_constraints_n_map(__isl_keep isl_schedule_constraints *sc)
+{
+	enum isl_edge_type i;
+	int n = 0;
+
+	for (i = isl_edge_first; i <= isl_edge_last; ++i)
+		n += isl_union_map_n_map(sc->constraint[i]);
+
+	return n;
+}
diff --git a/lib/Analysis/isl/isl_schedule_constraints.h b/lib/Analysis/isl/isl_schedule_constraints.h
new file mode 100644
index 0000000..a50ec62
--- /dev/null
+++ b/lib/Analysis/isl/isl_schedule_constraints.h
@@ -0,0 +1,30 @@
+#ifndef ISL_SCHEDULE_CONSTRAINTS_H
+#define ISL_SCHEDULE_CONSTRAINTS_H
+
+#include <isl/schedule.h>
+
+enum isl_edge_type {
+	isl_edge_validity = 0,
+	isl_edge_first = isl_edge_validity,
+	isl_edge_coincidence,
+	isl_edge_condition,
+	isl_edge_conditional_validity,
+	isl_edge_proximity,
+	isl_edge_last = isl_edge_proximity,
+	isl_edge_local
+};
+
+__isl_give isl_schedule_constraints *
+isl_schedule_constraints_align_params(__isl_take isl_schedule_constraints *sc);
+
+__isl_give isl_union_map *isl_schedule_constraints_get(
+	__isl_keep isl_schedule_constraints *sc, enum isl_edge_type type);
+__isl_give isl_schedule_constraints *isl_schedule_constraints_add(
+	__isl_take isl_schedule_constraints *sc, enum isl_edge_type type,
+	__isl_take isl_union_map *c);
+
+int isl_schedule_constraints_n_basic_map(
+	__isl_keep isl_schedule_constraints *sc);
+int isl_schedule_constraints_n_map(__isl_keep isl_schedule_constraints *sc);
+
+#endif
diff --git a/lib/Analysis/isl/isl_schedule_node.c b/lib/Analysis/isl/isl_schedule_node.c
index a636d74..3a53dfe 100644
--- a/lib/Analysis/isl/isl_schedule_node.c
+++ b/lib/Analysis/isl/isl_schedule_node.c
@@ -1934,14 +1934,14 @@ __isl_give isl_schedule_node *isl_schedule_node_band_sink(
 	type = isl_schedule_node_get_type(node);
 	if (type != isl_schedule_node_band)
 		isl_die(isl_schedule_node_get_ctx(node), isl_error_invalid,
-			"not a band node", isl_schedule_node_free(node));
+			"not a band node", return isl_schedule_node_free(node));
 	anchored = isl_schedule_node_is_subtree_anchored(node);
 	if (anchored < 0)
 		return isl_schedule_node_free(node);
 	if (anchored)
 		isl_die(isl_schedule_node_get_ctx(node), isl_error_invalid,
 			"cannot sink band node in anchored subtree",
-			isl_schedule_node_free(node));
+			return isl_schedule_node_free(node));
 	if (isl_schedule_tree_n_children(node->tree) == 0)
 		return node;
 
@@ -2205,12 +2205,14 @@ __isl_give isl_schedule_node *isl_schedule_node_sequence_splice_child(
 		return NULL;
 	if (isl_schedule_node_get_type(node) != isl_schedule_node_sequence)
 		isl_die(isl_schedule_node_get_ctx(node), isl_error_invalid,
-			"not a sequence node", isl_schedule_node_free(node));
+			"not a sequence node",
+			return isl_schedule_node_free(node));
 	node = isl_schedule_node_child(node, pos);
 	node = isl_schedule_node_child(node, 0);
 	if (isl_schedule_node_get_type(node) != isl_schedule_node_sequence)
 		isl_die(isl_schedule_node_get_ctx(node), isl_error_invalid,
-			"not a sequence node", isl_schedule_node_free(node));
+			"not a sequence node",
+			return isl_schedule_node_free(node));
 	child = isl_schedule_node_copy(node);
 	node = isl_schedule_node_parent(node);
 	filter = isl_schedule_node_filter_get_filter(node);
@@ -2252,7 +2254,6 @@ static __isl_give isl_schedule_node *update_ancestors(
 {
 	int i, n;
 	int is_leaf;
-	isl_ctx *ctx;
 	isl_schedule_tree *tree;
 	isl_schedule_node *pos = NULL;
 
@@ -2263,7 +2264,6 @@ static __isl_give isl_schedule_node *update_ancestors(
 	if (!node)
 		return isl_schedule_node_free(pos);
 
-	ctx = isl_schedule_node_get_ctx(node);
 	n = isl_schedule_tree_list_n_schedule_tree(node->ancestors);
 	tree = isl_schedule_tree_copy(node->tree);
 
@@ -3137,7 +3137,7 @@ __isl_give isl_schedule_node *isl_schedule_node_group(
 	if (!disjoint)
 		isl_die(isl_schedule_node_get_ctx(node), isl_error_invalid,
 			"group instances already reach node",
-			isl_schedule_node_free(node));
+			return isl_schedule_node_free(node));
 
 	return node;
 error:
diff --git a/lib/Analysis/isl/isl_schedule_read.c b/lib/Analysis/isl/isl_schedule_read.c
index 5409a49..e3ea8c5 100644
--- a/lib/Analysis/isl/isl_schedule_read.c
+++ b/lib/Analysis/isl/isl_schedule_read.c
@@ -1,5 +1,3 @@
-#include <string.h>
-
 #include <isl/schedule.h>
 #include <isl/stream.h>
 #include <isl_schedule_private.h>
@@ -25,82 +23,38 @@ enum isl_schedule_key {
 	isl_schedule_key_permutable,
 	isl_schedule_key_schedule,
 	isl_schedule_key_sequence,
-	isl_schedule_key_set
+	isl_schedule_key_set,
+	isl_schedule_key_end
 };
 
-/* Extract a mapping key from the token "tok".
- * Return isl_schedule_key_error on error, i.e., if "tok" does not
- * correspond to any known key.
- */
-static enum isl_schedule_key extract_key(__isl_keep isl_stream *s,
-	struct isl_token *tok)
-{
-	int type;
-	char *name;
-	enum isl_schedule_key key;
-	isl_ctx *ctx;
-
-	ctx = isl_stream_get_ctx(s);
-	type = isl_token_get_type(tok);
-	if (type != ISL_TOKEN_IDENT && type != ISL_TOKEN_STRING) {
-		isl_stream_error(s, tok, "expecting key");
-		return isl_schedule_key_error;
-	}
-	name = isl_token_get_str(ctx, tok);
-	if (!strcmp(name, "child"))
-		key = isl_schedule_key_child;
-	else if (!strcmp(name, "coincident"))
-		key = isl_schedule_key_coincident;
-	else if (!strcmp(name, "context"))
-		key = isl_schedule_key_context;
-	else if (!strcmp(name, "contraction"))
-		key = isl_schedule_key_contraction;
-	else if (!strcmp(name, "domain"))
-		key = isl_schedule_key_domain;
-	else if (!strcmp(name, "expansion"))
-		key = isl_schedule_key_expansion;
-	else if (!strcmp(name, "extension"))
-		key = isl_schedule_key_extension;
-	else if (!strcmp(name, "filter"))
-		key = isl_schedule_key_filter;
-	else if (!strcmp(name, "guard"))
-		key = isl_schedule_key_guard;
-	else if (!strcmp(name, "leaf"))
-		key = isl_schedule_key_leaf;
-	else if (!strcmp(name, "mark"))
-		key = isl_schedule_key_mark;
-	else if (!strcmp(name, "options"))
-		key = isl_schedule_key_options;
-	else if (!strcmp(name, "schedule"))
-		key = isl_schedule_key_schedule;
-	else if (!strcmp(name, "sequence"))
-		key = isl_schedule_key_sequence;
-	else if (!strcmp(name, "set"))
-		key = isl_schedule_key_set;
-	else if (!strcmp(name, "permutable"))
-		key = isl_schedule_key_permutable;
-	else
-		isl_die(ctx, isl_error_invalid, "unknown key",
-			key = isl_schedule_key_error);
-	free(name);
-	return key;
-}
-
-/* Read a key from "s" and return the corresponding enum.
- * Return isl_schedule_key_error on error, i.e., if the first token
- * on the stream does not correspond to any known key.
+/* Textual representations of the YAML keys for an isl_schedule object.
  */
-static enum isl_schedule_key get_key(__isl_keep isl_stream *s)
-{
-	struct isl_token *tok;
-	enum isl_schedule_key key;
-
-	tok = isl_stream_next_token(s);
-	key = extract_key(s, tok);
-	isl_token_free(tok);
+static char *key_str[] = {
+	[isl_schedule_key_child] = "child",
+	[isl_schedule_key_coincident] = "coincident",
+	[isl_schedule_key_context] = "context",
+	[isl_schedule_key_contraction] = "contraction",
+	[isl_schedule_key_domain] = "domain",
+	[isl_schedule_key_expansion] = "expansion",
+	[isl_schedule_key_extension] = "extension",
+	[isl_schedule_key_filter] = "filter",
+	[isl_schedule_key_guard] = "guard",
+	[isl_schedule_key_leaf] = "leaf",
+	[isl_schedule_key_mark] = "mark",
+	[isl_schedule_key_options] = "options",
+	[isl_schedule_key_permutable] = "permutable",
+	[isl_schedule_key_schedule] = "schedule",
+	[isl_schedule_key_sequence] = "sequence",
+	[isl_schedule_key_set] = "set",
+};
 
-	return key;
-}
+#undef KEY
+#define KEY enum isl_schedule_key
+#undef KEY_ERROR
+#define KEY_ERROR isl_schedule_key_error
+#undef KEY_END
+#define KEY_END isl_schedule_key_end
+#include "extract_key.c"
 
 static __isl_give isl_schedule_tree *isl_stream_read_schedule_tree(
 	__isl_keep isl_stream *s);
@@ -568,7 +522,7 @@ static __isl_give isl_schedule_tree *read_band(isl_stream *s)
 
 		switch (key) {
 		case isl_schedule_key_schedule:
-			isl_multi_union_pw_aff_free(schedule);
+			schedule = isl_multi_union_pw_aff_free(schedule);
 			tok = isl_stream_next_token(s);
 			if (!tok) {
 				isl_stream_error(s, NULL, "unexpected EOF");
@@ -759,6 +713,7 @@ static __isl_give isl_schedule_tree *isl_stream_read_schedule_tree(
 	case isl_schedule_key_child:
 		isl_die(isl_stream_get_ctx(s), isl_error_unsupported,
 			"cannot identity node type", return NULL);
+	case isl_schedule_key_end:
 	case isl_schedule_key_error:
 		return NULL;
 	}
diff --git a/lib/Analysis/isl/isl_schedule_tree.c b/lib/Analysis/isl/isl_schedule_tree.c
index b764edd..6dbadfc 100644
--- a/lib/Analysis/isl/isl_schedule_tree.c
+++ b/lib/Analysis/isl/isl_schedule_tree.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2013-2014 Ecole Normale Superieure
  * Copyright 2014      INRIA Rocquencourt
+ * Copyright 2016      INRIA Paris
  *
  * Use of this software is governed by the MIT license
  *
@@ -8,6 +9,8 @@
  * Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
  * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,
  * B.P. 105 - 78153 Le Chesnay, France
+ * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
+ * CS 42112, 75589 Paris Cedex 12, France
  */
 
 #include <isl/map.h>
@@ -79,7 +82,7 @@ __isl_take isl_schedule_tree *isl_schedule_tree_dup(
 	case isl_schedule_node_error:
 		isl_die(ctx, isl_error_internal,
 			"allocation should have failed",
-			isl_schedule_tree_free(dup));
+			return isl_schedule_tree_free(dup));
 	case isl_schedule_node_band:
 		dup->band = isl_schedule_band_copy(tree->band);
 		if (!dup->band)
diff --git a/lib/Analysis/isl/isl_scheduler.c b/lib/Analysis/isl/isl_scheduler.c
index 034580a..9a93c30 100644
--- a/lib/Analysis/isl/isl_scheduler.c
+++ b/lib/Analysis/isl/isl_scheduler.c
@@ -2,6 +2,8 @@
  * Copyright 2011      INRIA Saclay
  * Copyright 2012-2014 Ecole Normale Superieure
  * Copyright 2015-2016 Sven Verdoolaege
+ * Copyright 2016      INRIA Paris
+ * Copyright 2017      Sven Verdoolaege
  *
  * Use of this software is governed by the MIT license
  *
@@ -9,6 +11,8 @@
  * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,
  * 91893 Orsay, France
  * and Ecole Normale Superieure, 45 rue d'Ulm, 75230 Paris, France
+ * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,
+ * CS 42112, 75589 Paris Cedex 12, France
  */
 
 #include <isl_ctx_private.h>
@@ -18,11 +22,12 @@
 #include <isl/hash.h>
 #include <isl/constraint.h>
 #include <isl/schedule.h>
+#include <isl_schedule_constraints.h>
 #include <isl/schedule_node.h>
 #include <isl_mat_private.h>
 #include <isl_vec_private.h>
 #include <isl/set.h>
-#include <isl/union_set.h>
+#include <isl_union_set_private.h>
 #include <isl_seq.h>
 #include <isl_tab.h>
 #include <isl_dim_map.h>
@@ -40,466 +45,11 @@
  * Parallelization and Locality Optimization in the Polyhedral Model".
  */
 
-enum isl_edge_type {
-	isl_edge_validity = 0,
-	isl_edge_first = isl_edge_validity,
-	isl_edge_coincidence,
-	isl_edge_condition,
-	isl_edge_conditional_validity,
-	isl_edge_proximity,
-	isl_edge_last = isl_edge_proximity,
-	isl_edge_local
-};
-
-/* The constraints that need to be satisfied by a schedule on "domain".
- *
- * "context" specifies extra constraints on the parameters.
- *
- * "validity" constraints map domain elements i to domain elements
- * that should be scheduled after i.  (Hard constraint)
- * "proximity" constraints map domain elements i to domains elements
- * that should be scheduled as early as possible after i (or before i).
- * (Soft constraint)
- *
- * "condition" and "conditional_validity" constraints map possibly "tagged"
- * domain elements i -> s to "tagged" domain elements j -> t.
- * The elements of the "conditional_validity" constraints, but without the
- * tags (i.e., the elements i -> j) are treated as validity constraints,
- * except that during the construction of a tilable band,
- * the elements of the "conditional_validity" constraints may be violated
- * provided that all adjacent elements of the "condition" constraints
- * are local within the band.
- * A dependence is local within a band if domain and range are mapped
- * to the same schedule point by the band.
- */
-struct isl_schedule_constraints {
-	isl_union_set *domain;
-	isl_set *context;
-
-	isl_union_map *constraint[isl_edge_last + 1];
-};
-
-__isl_give isl_schedule_constraints *isl_schedule_constraints_copy(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	isl_ctx *ctx;
-	isl_schedule_constraints *sc_copy;
-	enum isl_edge_type i;
-
-	ctx = isl_union_set_get_ctx(sc->domain);
-	sc_copy = isl_calloc_type(ctx, struct isl_schedule_constraints);
-	if (!sc_copy)
-		return NULL;
-
-	sc_copy->domain = isl_union_set_copy(sc->domain);
-	sc_copy->context = isl_set_copy(sc->context);
-	if (!sc_copy->domain || !sc_copy->context)
-		return isl_schedule_constraints_free(sc_copy);
-
-	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
-		sc_copy->constraint[i] = isl_union_map_copy(sc->constraint[i]);
-		if (!sc_copy->constraint[i])
-			return isl_schedule_constraints_free(sc_copy);
-	}
-
-	return sc_copy;
-}
-
-
-/* Construct an isl_schedule_constraints object for computing a schedule
- * on "domain".  The initial object does not impose any constraints.
- */
-__isl_give isl_schedule_constraints *isl_schedule_constraints_on_domain(
-	__isl_take isl_union_set *domain)
-{
-	isl_ctx *ctx;
-	isl_space *space;
-	isl_schedule_constraints *sc;
-	isl_union_map *empty;
-	enum isl_edge_type i;
-
-	if (!domain)
-		return NULL;
-
-	ctx = isl_union_set_get_ctx(domain);
-	sc = isl_calloc_type(ctx, struct isl_schedule_constraints);
-	if (!sc)
-		goto error;
-
-	space = isl_union_set_get_space(domain);
-	sc->domain = domain;
-	sc->context = isl_set_universe(isl_space_copy(space));
-	empty = isl_union_map_empty(space);
-	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
-		sc->constraint[i] = isl_union_map_copy(empty);
-		if (!sc->constraint[i])
-			sc->domain = isl_union_set_free(sc->domain);
-	}
-	isl_union_map_free(empty);
-
-	if (!sc->domain || !sc->context)
-		return isl_schedule_constraints_free(sc);
-
-	return sc;
-error:
-	isl_union_set_free(domain);
-	return NULL;
-}
-
-/* Replace the context of "sc" by "context".
- */
-__isl_give isl_schedule_constraints *isl_schedule_constraints_set_context(
-	__isl_take isl_schedule_constraints *sc, __isl_take isl_set *context)
-{
-	if (!sc || !context)
-		goto error;
-
-	isl_set_free(sc->context);
-	sc->context = context;
-
-	return sc;
-error:
-	isl_schedule_constraints_free(sc);
-	isl_set_free(context);
-	return NULL;
-}
-
-/* Replace the validity constraints of "sc" by "validity".
- */
-__isl_give isl_schedule_constraints *isl_schedule_constraints_set_validity(
-	__isl_take isl_schedule_constraints *sc,
-	__isl_take isl_union_map *validity)
-{
-	if (!sc || !validity)
-		goto error;
-
-	isl_union_map_free(sc->constraint[isl_edge_validity]);
-	sc->constraint[isl_edge_validity] = validity;
-
-	return sc;
-error:
-	isl_schedule_constraints_free(sc);
-	isl_union_map_free(validity);
-	return NULL;
-}
-
-/* Replace the coincidence constraints of "sc" by "coincidence".
- */
-__isl_give isl_schedule_constraints *isl_schedule_constraints_set_coincidence(
-	__isl_take isl_schedule_constraints *sc,
-	__isl_take isl_union_map *coincidence)
-{
-	if (!sc || !coincidence)
-		goto error;
-
-	isl_union_map_free(sc->constraint[isl_edge_coincidence]);
-	sc->constraint[isl_edge_coincidence] = coincidence;
-
-	return sc;
-error:
-	isl_schedule_constraints_free(sc);
-	isl_union_map_free(coincidence);
-	return NULL;
-}
-
-/* Replace the proximity constraints of "sc" by "proximity".
- */
-__isl_give isl_schedule_constraints *isl_schedule_constraints_set_proximity(
-	__isl_take isl_schedule_constraints *sc,
-	__isl_take isl_union_map *proximity)
-{
-	if (!sc || !proximity)
-		goto error;
-
-	isl_union_map_free(sc->constraint[isl_edge_proximity]);
-	sc->constraint[isl_edge_proximity] = proximity;
-
-	return sc;
-error:
-	isl_schedule_constraints_free(sc);
-	isl_union_map_free(proximity);
-	return NULL;
-}
-
-/* Replace the conditional validity constraints of "sc" by "condition"
- * and "validity".
- */
-__isl_give isl_schedule_constraints *
-isl_schedule_constraints_set_conditional_validity(
-	__isl_take isl_schedule_constraints *sc,
-	__isl_take isl_union_map *condition,
-	__isl_take isl_union_map *validity)
-{
-	if (!sc || !condition || !validity)
-		goto error;
-
-	isl_union_map_free(sc->constraint[isl_edge_condition]);
-	sc->constraint[isl_edge_condition] = condition;
-	isl_union_map_free(sc->constraint[isl_edge_conditional_validity]);
-	sc->constraint[isl_edge_conditional_validity] = validity;
-
-	return sc;
-error:
-	isl_schedule_constraints_free(sc);
-	isl_union_map_free(condition);
-	isl_union_map_free(validity);
-	return NULL;
-}
-
-__isl_null isl_schedule_constraints *isl_schedule_constraints_free(
-	__isl_take isl_schedule_constraints *sc)
-{
-	enum isl_edge_type i;
-
-	if (!sc)
-		return NULL;
-
-	isl_union_set_free(sc->domain);
-	isl_set_free(sc->context);
-	for (i = isl_edge_first; i <= isl_edge_last; ++i)
-		isl_union_map_free(sc->constraint[i]);
-
-	free(sc);
-
-	return NULL;
-}
-
-isl_ctx *isl_schedule_constraints_get_ctx(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	return sc ? isl_union_set_get_ctx(sc->domain) : NULL;
-}
-
-/* Return the domain of "sc".
- */
-__isl_give isl_union_set *isl_schedule_constraints_get_domain(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	if (!sc)
-		return NULL;
-
-	return isl_union_set_copy(sc->domain);
-}
-
-/* Return the validity constraints of "sc".
- */
-__isl_give isl_union_map *isl_schedule_constraints_get_validity(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	if (!sc)
-		return NULL;
-
-	return isl_union_map_copy(sc->constraint[isl_edge_validity]);
-}
-
-/* Return the coincidence constraints of "sc".
- */
-__isl_give isl_union_map *isl_schedule_constraints_get_coincidence(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	if (!sc)
-		return NULL;
-
-	return isl_union_map_copy(sc->constraint[isl_edge_coincidence]);
-}
-
-/* Return the proximity constraints of "sc".
- */
-__isl_give isl_union_map *isl_schedule_constraints_get_proximity(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	if (!sc)
-		return NULL;
-
-	return isl_union_map_copy(sc->constraint[isl_edge_proximity]);
-}
-
-/* Return the conditional validity constraints of "sc".
- */
-__isl_give isl_union_map *isl_schedule_constraints_get_conditional_validity(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	if (!sc)
-		return NULL;
-
-	return
-	    isl_union_map_copy(sc->constraint[isl_edge_conditional_validity]);
-}
-
-/* Return the conditions for the conditional validity constraints of "sc".
- */
-__isl_give isl_union_map *
-isl_schedule_constraints_get_conditional_validity_condition(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	if (!sc)
-		return NULL;
-
-	return isl_union_map_copy(sc->constraint[isl_edge_condition]);
-}
-
-/* Can a schedule constraint of type "type" be tagged?
- */
-static int may_be_tagged(enum isl_edge_type type)
-{
-	if (type == isl_edge_condition || type == isl_edge_conditional_validity)
-		return 1;
-	return 0;
-}
-
-/* Apply "umap" to the domains of the wrapped relations
- * inside the domain and range of "c".
- *
- * That is, for each map of the form
- *
- *	[D -> S] -> [E -> T]
- *
- * in "c", apply "umap" to D and E.
- *
- * D is exposed by currying the relation to
- *
- *	D -> [S -> [E -> T]]
- *
- * E is exposed by doing the same to the inverse of "c".
- */
-static __isl_give isl_union_map *apply_factor_domain(
-	__isl_take isl_union_map *c, __isl_keep isl_union_map *umap)
-{
-	c = isl_union_map_curry(c);
-	c = isl_union_map_apply_domain(c, isl_union_map_copy(umap));
-	c = isl_union_map_uncurry(c);
-
-	c = isl_union_map_reverse(c);
-	c = isl_union_map_curry(c);
-	c = isl_union_map_apply_domain(c, isl_union_map_copy(umap));
-	c = isl_union_map_uncurry(c);
-	c = isl_union_map_reverse(c);
-
-	return c;
-}
-
-/* Apply "umap" to domain and range of "c".
- * If "tag" is set, then "c" may contain tags and then "umap"
- * needs to be applied to the domains of the wrapped relations
- * inside the domain and range of "c".
- */
-static __isl_give isl_union_map *apply(__isl_take isl_union_map *c,
-	__isl_keep isl_union_map *umap, int tag)
-{
-	isl_union_map *t;
-
-	if (tag)
-		t = isl_union_map_copy(c);
-	c = isl_union_map_apply_domain(c, isl_union_map_copy(umap));
-	c = isl_union_map_apply_range(c, isl_union_map_copy(umap));
-	if (!tag)
-		return c;
-	t = apply_factor_domain(t, umap);
-	c = isl_union_map_union(c, t);
-	return c;
-}
-
-/* Apply "umap" to the domain of the schedule constraints "sc".
- *
- * The two sides of the various schedule constraints are adjusted
- * accordingly.
- */
-__isl_give isl_schedule_constraints *isl_schedule_constraints_apply(
-	__isl_take isl_schedule_constraints *sc,
-	__isl_take isl_union_map *umap)
-{
-	enum isl_edge_type i;
-
-	if (!sc || !umap)
-		goto error;
-
-	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
-		int tag = may_be_tagged(i);
-
-		sc->constraint[i] = apply(sc->constraint[i], umap, tag);
-		if (!sc->constraint[i])
-			goto error;
-	}
-	sc->domain = isl_union_set_apply(sc->domain, umap);
-	if (!sc->domain)
-		return isl_schedule_constraints_free(sc);
-
-	return sc;
-error:
-	isl_schedule_constraints_free(sc);
-	isl_union_map_free(umap);
-	return NULL;
-}
-
-void isl_schedule_constraints_dump(__isl_keep isl_schedule_constraints *sc)
-{
-	if (!sc)
-		return;
-
-	fprintf(stderr, "domain: ");
-	isl_union_set_dump(sc->domain);
-	fprintf(stderr, "context: ");
-	isl_set_dump(sc->context);
-	fprintf(stderr, "validity: ");
-	isl_union_map_dump(sc->constraint[isl_edge_validity]);
-	fprintf(stderr, "proximity: ");
-	isl_union_map_dump(sc->constraint[isl_edge_proximity]);
-	fprintf(stderr, "coincidence: ");
-	isl_union_map_dump(sc->constraint[isl_edge_coincidence]);
-	fprintf(stderr, "condition: ");
-	isl_union_map_dump(sc->constraint[isl_edge_condition]);
-	fprintf(stderr, "conditional_validity: ");
-	isl_union_map_dump(sc->constraint[isl_edge_conditional_validity]);
-}
-
-/* Align the parameters of the fields of "sc".
- */
-static __isl_give isl_schedule_constraints *
-isl_schedule_constraints_align_params(__isl_take isl_schedule_constraints *sc)
-{
-	isl_space *space;
-	enum isl_edge_type i;
-
-	if (!sc)
-		return NULL;
-
-	space = isl_union_set_get_space(sc->domain);
-	space = isl_space_align_params(space, isl_set_get_space(sc->context));
-	for (i = isl_edge_first; i <= isl_edge_last; ++i)
-		space = isl_space_align_params(space,
-				    isl_union_map_get_space(sc->constraint[i]));
-
-	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
-		sc->constraint[i] = isl_union_map_align_params(
-				    sc->constraint[i], isl_space_copy(space));
-		if (!sc->constraint[i])
-			space = isl_space_free(space);
-	}
-	sc->context = isl_set_align_params(sc->context, isl_space_copy(space));
-	sc->domain = isl_union_set_align_params(sc->domain, space);
-	if (!sc->context || !sc->domain)
-		return isl_schedule_constraints_free(sc);
-
-	return sc;
-}
-
-/* Return the total number of isl_maps in the constraints of "sc".
- */
-static __isl_give int isl_schedule_constraints_n_map(
-	__isl_keep isl_schedule_constraints *sc)
-{
-	enum isl_edge_type i;
-	int n = 0;
-
-	for (i = isl_edge_first; i <= isl_edge_last; ++i)
-		n += isl_union_map_n_map(sc->constraint[i]);
-
-	return n;
-}
 
 /* Internal information about a node that is used during the construction
  * of a schedule.
- * space represents the space in which the domain lives
+ * space represents the original space in which the domain lives;
+ *	that is, the space is not affected by compression
  * sched is a matrix representation of the schedule being constructed
  *	for this node; if compressed is set, then this schedule is
  *	defined over the compressed domain space
@@ -508,11 +58,12 @@ static __isl_give int isl_schedule_constraints_n_map(
  *	is defined over the uncompressed domain space
  * rank is the number of linearly independent rows in the linear part
  *	of sched
- * the columns of cmap represent a change of basis for the schedule
- *	coefficients; the first rank columns span the linear part of
- *	the schedule rows
- * cinv is the inverse of cmap.
- * ctrans is the transpose of cmap.
+ * the rows of "vmap" represent a change of basis for the node
+ *	variables; the first rank rows span the linear part of
+ *	the schedule rows; the remaining rows are linearly independent
+ * the rows of "indep" represent linear combinations of the schedule
+ * coefficients that are non-zero when the schedule coefficients are
+ * linearly independent of previously computed schedule rows.
  * start is the first variable in the LP problem in the sequences that
  *	represents the schedule coefficients of this node
  * nvar is the dimension of the domain
@@ -543,6 +94,8 @@ static __isl_give int isl_schedule_constraints_n_map(
  * schedule coefficients of the (compressed) variables.  If no bound
  * needs to be imposed on a particular variable, then the corresponding
  * value is negative.
+ * If not NULL, then "bounds" contains a non-parametric set
+ * in the compressed space that is bounded by the size in each direction.
  */
 struct isl_sched_node {
 	isl_space *space;
@@ -553,9 +106,8 @@ struct isl_sched_node {
 	isl_mat *sched;
 	isl_map *sched_map;
 	int	 rank;
-	isl_mat *cmap;
-	isl_mat *cinv;
-	isl_mat *ctrans;
+	isl_mat *indep;
+	isl_mat *vmap;
 	int	 start;
 	int	 nvar;
 	int	 nparam;
@@ -566,15 +118,16 @@ struct isl_sched_node {
 	int	*coincident;
 
 	isl_multi_val *sizes;
+	isl_basic_set *bounds;
 	isl_vec *max;
 };
 
-static int node_has_space(const void *entry, const void *val)
+static int node_has_tuples(const void *entry, const void *val)
 {
 	struct isl_sched_node *node = (struct isl_sched_node *)entry;
-	isl_space *dim = (isl_space *)val;
+	isl_space *space = (isl_space *) val;
 
-	return isl_space_is_equal(node->space, dim);
+	return isl_space_has_equal_tuples(node->space, space);
 }
 
 static int node_scc_exactly(struct isl_sched_node *node, int scc)
@@ -736,7 +289,11 @@ static int is_conditional_validity(struct isl_sched_edge *edge)
  * the construction of the schedule.
  *
  * intra_hmap is a cache, mapping dependence relations to their dual,
- *	for dependences from a node to itself
+ *	for dependences from a node to itself, possibly without
+ *	coefficients for the parameters
+ * intra_hmap_param is a cache, mapping dependence relations to their dual,
+ *	for dependences from a node to itself, including coefficients
+ *	for the parameters
  * inter_hmap is a cache, mapping dependence relations to their dual,
  *	for dependences between distinct nodes
  * if compression is involved then the key for these maps
@@ -751,8 +308,9 @@ static int is_conditional_validity(struct isl_sched_edge *edge)
  *	rows in the node schedules
  * n_total_row is the current number of rows in the node schedules
  * band_start is the starting row in the node schedules of the current band
- * root is set if this graph is the original dependence graph,
- *	without any splitting
+ * root is set to the the original dependence graph from which this graph
+ *	is derived through splitting.  If this graph is not the result of
+ *	splitting, then the root field points to the graph itself.
  *
  * sorted contains a list of node indices sorted according to the
  *	SCC to which a node belongs
@@ -769,7 +327,7 @@ static int is_conditional_validity(struct isl_sched_edge *edge)
  *	a single edge between a given pair of source and sink space
  *	in the entire graph
  *
- * node_table contains pointers into the node array, hashed on the space
+ * node_table contains pointers into the node array, hashed on the space tuples
  *
  * region contains a list of variable sequences that should be non-trivial
  *
@@ -786,6 +344,7 @@ static int is_conditional_validity(struct isl_sched_edge *edge)
  */
 struct isl_sched_graph {
 	isl_map_to_basic_set *intra_hmap;
+	isl_map_to_basic_set *intra_hmap_param;
 	isl_map_to_basic_set *inter_hmap;
 
 	struct isl_sched_node *node;
@@ -799,7 +358,7 @@ struct isl_sched_graph {
 	int n_total_row;
 	int band_start;
 
-	int root;
+	struct isl_sched_graph *root;
 
 	struct isl_sched_edge *edge;
 	int n_edge;
@@ -807,7 +366,7 @@ struct isl_sched_graph {
 	struct isl_hash_table *edge_table[isl_edge_last + 1];
 
 	struct isl_hash_table *node_table;
-	struct isl_region *region;
+	struct isl_trivial_region *region;
 
 	isl_basic_set *lp;
 
@@ -834,9 +393,9 @@ static int graph_init_table(isl_ctx *ctx, struct isl_sched_graph *graph)
 		struct isl_hash_table_entry *entry;
 		uint32_t hash;
 
-		hash = isl_space_get_hash(graph->node[i].space);
+		hash = isl_space_get_tuple_hash(graph->node[i].space);
 		entry = isl_hash_table_find(ctx, graph->node_table, hash,
-					    &node_has_space,
+					    &node_has_tuples,
 					    graph->node[i].space, 1);
 		if (!entry)
 			return -1;
@@ -850,18 +409,26 @@ static int graph_init_table(isl_ctx *ctx, struct isl_sched_graph *graph)
  * or NULL if there is no such node.
  */
 static struct isl_sched_node *graph_find_node(isl_ctx *ctx,
-	struct isl_sched_graph *graph, __isl_keep isl_space *dim)
+	struct isl_sched_graph *graph, __isl_keep isl_space *space)
 {
 	struct isl_hash_table_entry *entry;
 	uint32_t hash;
 
-	hash = isl_space_get_hash(dim);
+	hash = isl_space_get_tuple_hash(space);
 	entry = isl_hash_table_find(ctx, graph->node_table, hash,
-				    &node_has_space, dim, 0);
+				    &node_has_tuples, space, 0);
 
 	return entry ? entry->data : NULL;
 }
 
+/* Is "node" a node in "graph"?
+ */
+static int is_node(struct isl_sched_graph *graph,
+	struct isl_sched_node *node)
+{
+	return node && node >= &graph->node[0] && node < &graph->node[graph->n];
+}
+
 static int edge_has_src_and_dst(const void *entry, const void *val)
 {
 	const struct isl_sched_edge *edge = entry;
@@ -1065,11 +632,13 @@ static int graph_alloc(isl_ctx *ctx, struct isl_sched_graph *graph,
 	graph->n_edge = n_edge;
 	graph->node = isl_calloc_array(ctx, struct isl_sched_node, graph->n);
 	graph->sorted = isl_calloc_array(ctx, int, graph->n);
-	graph->region = isl_alloc_array(ctx, struct isl_region, graph->n);
+	graph->region = isl_alloc_array(ctx,
+					struct isl_trivial_region, graph->n);
 	graph->edge = isl_calloc_array(ctx,
 					struct isl_sched_edge, graph->n_edge);
 
 	graph->intra_hmap = isl_map_to_basic_set_alloc(ctx, 2 * n_edge);
+	graph->intra_hmap_param = isl_map_to_basic_set_alloc(ctx, 2 * n_edge);
 	graph->inter_hmap = isl_map_to_basic_set_alloc(ctx, 2 * n_edge);
 
 	if (!graph->node || !graph->region || (graph->n_edge && !graph->edge) ||
@@ -1087,6 +656,7 @@ static void graph_free(isl_ctx *ctx, struct isl_sched_graph *graph)
 	int i;
 
 	isl_map_to_basic_set_free(graph->intra_hmap);
+	isl_map_to_basic_set_free(graph->intra_hmap_param);
 	isl_map_to_basic_set_free(graph->inter_hmap);
 
 	if (graph->node)
@@ -1097,12 +667,12 @@ static void graph_free(isl_ctx *ctx, struct isl_sched_graph *graph)
 			isl_multi_aff_free(graph->node[i].decompress);
 			isl_mat_free(graph->node[i].sched);
 			isl_map_free(graph->node[i].sched_map);
-			isl_mat_free(graph->node[i].cmap);
-			isl_mat_free(graph->node[i].cinv);
-			isl_mat_free(graph->node[i].ctrans);
-			if (graph->root)
+			isl_mat_free(graph->node[i].indep);
+			isl_mat_free(graph->node[i].vmap);
+			if (graph->root == graph)
 				free(graph->node[i].coincident);
 			isl_multi_val_free(graph->node[i].sizes);
+			isl_basic_set_free(graph->node[i].bounds);
 			isl_vec_free(graph->node[i].max);
 		}
 	free(graph->node);
@@ -1138,56 +708,46 @@ static isl_stat init_n_maxvar(__isl_take isl_set *set, void *user)
 	return isl_stat_ok;
 }
 
-/* Add the number of basic maps in "map" to *n.
- */
-static isl_stat add_n_basic_map(__isl_take isl_map *map, void *user)
-{
-	int *n = user;
-
-	*n += isl_map_n_basic_map(map);
-	isl_map_free(map);
-
-	return isl_stat_ok;
-}
-
 /* Compute the number of rows that should be allocated for the schedule.
  * In particular, we need one row for each variable or one row
  * for each basic map in the dependences.
  * Note that it is practically impossible to exhaust both
  * the number of dependences and the number of variables.
  */
-static int compute_max_row(struct isl_sched_graph *graph,
+static isl_stat compute_max_row(struct isl_sched_graph *graph,
 	__isl_keep isl_schedule_constraints *sc)
 {
-	enum isl_edge_type i;
 	int n_edge;
+	isl_stat r;
+	isl_union_set *domain;
 
 	graph->n = 0;
 	graph->maxvar = 0;
-	if (isl_union_set_foreach_set(sc->domain, &init_n_maxvar, graph) < 0)
-		return -1;
-	n_edge = 0;
-	for (i = isl_edge_first; i <= isl_edge_last; ++i)
-		if (isl_union_map_foreach_map(sc->constraint[i],
-						&add_n_basic_map, &n_edge) < 0)
-			return -1;
+	domain = isl_schedule_constraints_get_domain(sc);
+	r = isl_union_set_foreach_set(domain, &init_n_maxvar, graph);
+	isl_union_set_free(domain);
+	if (r < 0)
+		return isl_stat_error;
+	n_edge = isl_schedule_constraints_n_basic_map(sc);
+	if (n_edge < 0)
+		return isl_stat_error;
 	graph->max_row = n_edge + graph->maxvar;
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Does "bset" have any defining equalities for its set variables?
  */
-static int has_any_defining_equality(__isl_keep isl_basic_set *bset)
+static isl_bool has_any_defining_equality(__isl_keep isl_basic_set *bset)
 {
 	int i, n;
 
 	if (!bset)
-		return -1;
+		return isl_bool_error;
 
 	n = isl_basic_set_dim(bset, isl_dim_set);
 	for (i = 0; i < n; ++i) {
-		int has;
+		isl_bool has;
 
 		has = isl_basic_set_has_defining_equality(bset, isl_dim_set, i,
 							NULL);
@@ -1195,7 +755,7 @@ static int has_any_defining_equality(__isl_keep isl_basic_set *bset)
 			return has;
 	}
 
-	return 0;
+	return isl_bool_false;
 }
 
 /* Set the entries of node->max to the value of the schedule_max_coefficient
@@ -1219,8 +779,9 @@ static isl_stat set_max_coefficient(isl_ctx *ctx, struct isl_sched_node *node)
 
 /* Set the entries of node->max to the minimum of the schedule_max_coefficient
  * option (if set) and half of the minimum of the sizes in the other
- * dimensions.  If the minimum of the sizes is one, half of the size
- * is zero and this value is reset to one.
+ * dimensions.  Round up when computing the half such that
+ * if the minimum of the sizes is one, half of the size is taken to be one
+ * rather than zero.
  * If the global minimum is unbounded (i.e., if both
  * the schedule_max_coefficient is not set and the sizes in the other
  * dimensions are unbounded), then store a negative value.
@@ -1268,11 +829,8 @@ static isl_stat compute_max_coefficient(isl_ctx *ctx,
 		isl_val_free(size);
 	}
 
-	for (i = 0; i < node->nvar; ++i) {
-		isl_int_fdiv_q_ui(v->el[i], v->el[i], 2);
-		if (isl_int_is_zero(v->el[i]))
-			isl_int_set_si(v->el[i], 1);
-	}
+	for (i = 0; i < node->nvar; ++i)
+		isl_int_cdiv_q_ui(v->el[i], v->el[i], 2);
 
 	node->max = v;
 	return isl_stat_ok;
@@ -1419,16 +977,56 @@ static isl_stat add_node(struct isl_sched_graph *graph,
 	return isl_stat_ok;
 }
 
+/* Construct an identifier for node "node", which will represent "set".
+ * The name of the identifier is either "compressed" or
+ * "compressed_<name>", with <name> the name of the space of "set".
+ * The user pointer of the identifier points to "node".
+ */
+static __isl_give isl_id *construct_compressed_id(__isl_keep isl_set *set,
+	struct isl_sched_node *node)
+{
+	isl_bool has_name;
+	isl_ctx *ctx;
+	isl_id *id;
+	isl_printer *p;
+	const char *name;
+	char *id_name;
+
+	has_name = isl_set_has_tuple_name(set);
+	if (has_name < 0)
+		return NULL;
+
+	ctx = isl_set_get_ctx(set);
+	if (!has_name)
+		return isl_id_alloc(ctx, "compressed", node);
+
+	p = isl_printer_to_str(ctx);
+	name = isl_set_get_tuple_name(set);
+	p = isl_printer_print_str(p, "compressed_");
+	p = isl_printer_print_str(p, name);
+	id_name = isl_printer_get_str(p);
+	isl_printer_free(p);
+
+	id = isl_id_alloc(ctx, id_name, node);
+	free(id_name);
+
+	return id;
+}
+
 /* Add a new node to the graph representing the given set.
  *
  * If any of the set variables is defined by an equality, then
  * we perform variable compression such that we can perform
  * the scheduling on the compressed domain.
+ * In this case, an identifier is used that references the new node
+ * such that each compressed space is unique and
+ * such that the node can be recovered from the compressed space.
  */
 static isl_stat extract_node(__isl_take isl_set *set, void *user)
 {
 	int nvar;
-	int has_equality;
+	isl_bool has_equality;
+	isl_id *id;
 	isl_basic_set *hull;
 	isl_set *hull_set;
 	isl_morph *morph;
@@ -1447,7 +1045,10 @@ static isl_stat extract_node(__isl_take isl_set *set, void *user)
 		return add_node(graph, set, nvar, 0, NULL, NULL, NULL);
 	}
 
-	morph = isl_basic_set_variable_compression(hull, isl_dim_set);
+	id = construct_compressed_id(set, &graph->node[graph->n]);
+	morph = isl_basic_set_variable_compression_with_id(hull,
+							    isl_dim_set, id);
+	isl_id_free(id);
 	nvar = isl_morph_ran_dim(morph, isl_dim_set);
 	compress = isl_morph_get_var_multi_aff(morph);
 	morph = isl_morph_inverse(morph);
@@ -1709,6 +1310,7 @@ static isl_stat graph_init(struct isl_sched_graph *graph,
 {
 	isl_ctx *ctx;
 	isl_union_set *domain;
+	isl_union_map *c;
 	struct isl_extract_edge_data data;
 	enum isl_edge_type i;
 	isl_stat r;
@@ -1728,27 +1330,36 @@ static isl_stat graph_init(struct isl_sched_graph *graph,
 
 	if (compute_max_row(graph, sc) < 0)
 		return isl_stat_error;
-	graph->root = 1;
+	graph->root = graph;
 	graph->n = 0;
 	domain = isl_schedule_constraints_get_domain(sc);
 	domain = isl_union_set_intersect_params(domain,
-						isl_set_copy(sc->context));
+				    isl_schedule_constraints_get_context(sc));
 	r = isl_union_set_foreach_set(domain, &extract_node, graph);
 	isl_union_set_free(domain);
 	if (r < 0)
 		return isl_stat_error;
 	if (graph_init_table(ctx, graph) < 0)
 		return isl_stat_error;
-	for (i = isl_edge_first; i <= isl_edge_last; ++i)
-		graph->max_edge[i] = isl_union_map_n_map(sc->constraint[i]);
+	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
+		c = isl_schedule_constraints_get(sc, i);
+		graph->max_edge[i] = isl_union_map_n_map(c);
+		isl_union_map_free(c);
+		if (!c)
+			return isl_stat_error;
+	}
 	if (graph_init_edge_tables(ctx, graph) < 0)
 		return isl_stat_error;
 	graph->n_edge = 0;
 	data.graph = graph;
 	for (i = isl_edge_first; i <= isl_edge_last; ++i) {
+		isl_stat r;
+
 		data.type = i;
-		if (isl_union_map_foreach_map(sc->constraint[i],
-						&extract_edge, &data) < 0)
+		c = isl_schedule_constraints_get(sc, i);
+		r = isl_union_map_foreach_map(c, &extract_edge, &data);
+		isl_union_map_free(c);
+		if (r < 0)
 			return isl_stat_error;
 	}
 
@@ -1846,6 +1457,75 @@ static int sort_sccs(struct isl_sched_graph *graph)
 	return isl_sort(graph->sorted, graph->n, sizeof(int), &cmp_scc, graph);
 }
 
+/* Return a non-parametric set in the compressed space of "node" that is
+ * bounded by the size in each direction
+ *
+ *	{ [x] : -S_i <= x_i <= S_i }
+ *
+ * If S_i is infinity in direction i, then there are no constraints
+ * in that direction.
+ *
+ * Cache the result in node->bounds.
+ */
+static __isl_give isl_basic_set *get_size_bounds(struct isl_sched_node *node)
+{
+	isl_space *space;
+	isl_basic_set *bounds;
+	int i;
+	unsigned nparam;
+
+	if (node->bounds)
+		return isl_basic_set_copy(node->bounds);
+
+	if (node->compressed)
+		space = isl_multi_aff_get_domain_space(node->decompress);
+	else
+		space = isl_space_copy(node->space);
+	nparam = isl_space_dim(space, isl_dim_param);
+	space = isl_space_drop_dims(space, isl_dim_param, 0, nparam);
+	bounds = isl_basic_set_universe(space);
+
+	for (i = 0; i < node->nvar; ++i) {
+		isl_val *size;
+
+		size = isl_multi_val_get_val(node->sizes, i);
+		if (!size)
+			return isl_basic_set_free(bounds);
+		if (!isl_val_is_int(size)) {
+			isl_val_free(size);
+			continue;
+		}
+		bounds = isl_basic_set_upper_bound_val(bounds, isl_dim_set, i,
+							isl_val_copy(size));
+		bounds = isl_basic_set_lower_bound_val(bounds, isl_dim_set, i,
+							isl_val_neg(size));
+	}
+
+	node->bounds = isl_basic_set_copy(bounds);
+	return bounds;
+}
+
+/* Drop some constraints from "delta" that could be exploited
+ * to construct loop coalescing schedules.
+ * In particular, drop those constraint that bound the difference
+ * to the size of the domain.
+ * First project out the parameters to improve the effectiveness.
+ */
+static __isl_give isl_set *drop_coalescing_constraints(
+	__isl_take isl_set *delta, struct isl_sched_node *node)
+{
+	unsigned nparam;
+	isl_basic_set *bounds;
+
+	bounds = get_size_bounds(node);
+
+	nparam = isl_set_dim(delta, isl_dim_param);
+	delta = isl_set_project_out(delta, isl_dim_param, 0, nparam);
+	delta = isl_set_remove_divs(delta);
+	delta = isl_set_plain_gist_basic_set(delta, bounds);
+	return delta;
+}
+
 /* Given a dependence relation R from "node" to itself,
  * construct the set of coefficients of valid constraints for elements
  * in that dependence relation.
@@ -1863,19 +1543,40 @@ static int sort_sccs(struct isl_sched_graph *graph)
  * in a set of tuples c_0, c_n, c_x, c_y, and then
  * plugged in (c_0, c_n, c_x, -c_x).
  *
+ * If "need_param" is set, then the resulting coefficients effectively
+ * include coefficients for the parameters c_n.  Otherwise, they may
+ * have been projected out already.
+ * Since the constraints may be different for these two cases,
+ * they are stored in separate caches.
+ * In particular, if no parameter coefficients are required and
+ * the schedule_treat_coalescing option is set, then the parameters
+ * are projected out and some constraints that could be exploited
+ * to construct coalescing schedules are removed before the dual
+ * is computed.
+ *
  * If "node" has been compressed, then the dependence relation
  * is also compressed before the set of coefficients is computed.
  */
 static __isl_give isl_basic_set *intra_coefficients(
 	struct isl_sched_graph *graph, struct isl_sched_node *node,
-	__isl_take isl_map *map)
+	__isl_take isl_map *map, int need_param)
 {
+	isl_ctx *ctx;
 	isl_set *delta;
 	isl_map *key;
 	isl_basic_set *coef;
 	isl_maybe_isl_basic_set m;
+	isl_map_to_basic_set **hmap = &graph->intra_hmap;
+	int treat;
 
-	m = isl_map_to_basic_set_try_get(graph->intra_hmap, map);
+	if (!map)
+		return NULL;
+
+	ctx = isl_map_get_ctx(map);
+	treat = !need_param && isl_options_get_schedule_treat_coalescing(ctx);
+	if (!treat)
+		hmap = &graph->intra_hmap_param;
+	m = isl_map_to_basic_set_try_get(*hmap, map);
 	if (m.valid < 0 || m.valid) {
 		isl_map_free(map);
 		return m.value;
@@ -1888,10 +1589,12 @@ static __isl_give isl_basic_set *intra_coefficients(
 		map = isl_map_preimage_range_multi_aff(map,
 				    isl_multi_aff_copy(node->decompress));
 	}
-	delta = isl_set_remove_divs(isl_map_deltas(map));
+	delta = isl_map_deltas(map);
+	if (treat)
+		delta = drop_coalescing_constraints(delta, node);
+	delta = isl_set_remove_divs(delta);
 	coef = isl_set_coefficients(delta);
-	graph->intra_hmap = isl_map_to_basic_set_set(graph->intra_hmap, key,
-					isl_basic_set_copy(coef));
+	*hmap = isl_map_to_basic_set_set(*hmap, key, isl_basic_set_copy(coef));
 
 	return coef;
 }
@@ -1958,17 +1661,54 @@ static int coef_var_offset(__isl_keep isl_basic_set *coef)
 	return offset;
 }
 
-/* Return the offset of the coefficients of the variables of "node"
+/* Return the offset of the coefficient of the constant term of "node"
  * within the (I)LP.
  *
  * Within each node, the coefficients have the following order:
+ *	- positive and negative parts of c_i_x
+ *	- c_i_n (if parametric)
  *	- c_i_0
+ */
+static int node_cst_coef_offset(struct isl_sched_node *node)
+{
+	return node->start + 2 * node->nvar + node->nparam;
+}
+
+/* Return the offset of the coefficients of the parameters of "node"
+ * within the (I)LP.
+ *
+ * Within each node, the coefficients have the following order:
+ *	- positive and negative parts of c_i_x
  *	- c_i_n (if parametric)
+ *	- c_i_0
+ */
+static int node_par_coef_offset(struct isl_sched_node *node)
+{
+	return node->start + 2 * node->nvar;
+}
+
+/* Return the offset of the coefficients of the variables of "node"
+ * within the (I)LP.
+ *
+ * Within each node, the coefficients have the following order:
  *	- positive and negative parts of c_i_x
+ *	- c_i_n (if parametric)
+ *	- c_i_0
  */
 static int node_var_coef_offset(struct isl_sched_node *node)
 {
-	return node->start + 1 + node->nparam;
+	return node->start;
+}
+
+/* Return the position of the pair of variables encoding
+ * coefficient "i" of "node".
+ *
+ * The order of these variable pairs is the opposite of
+ * that of the coefficients, with 2 variables per coefficient.
+ */
+static int node_var_coef_pos(struct isl_sched_node *node, int i)
+{
+	return node_var_coef_offset(node) + 2 * (node->nvar - 1 - i);
 }
 
 /* Construct an isl_dim_map for mapping constraints on coefficients
@@ -1977,11 +1717,16 @@ static int node_var_coef_offset(struct isl_sched_node *node)
  * in the input constraints.
  * "s" is the sign of the mapping.
  *
- * The input constraints are given in terms of the coefficients (c_0, c_n, c_x).
+ * The input constraints are given in terms of the coefficients
+ * (c_0, c_x) or (c_0, c_n, c_x).
  * The mapping produced by this function essentially plugs in
+ * (0, c_i_x^+ - c_i_x^-) if s = 1 and
+ * (0, -c_i_x^+ + c_i_x^-) if s = -1 or
  * (0, 0, c_i_x^+ - c_i_x^-) if s = 1 and
  * (0, 0, -c_i_x^+ + c_i_x^-) if s = -1.
  * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
+ * Furthermore, the order of these pairs is the opposite of that
+ * of the corresponding coefficients.
  *
  * The caller can extend the mapping to also map the other coefficients
  * (and therefore not plug in 0).
@@ -1994,11 +1739,14 @@ static __isl_give isl_dim_map *intra_dim_map(isl_ctx *ctx,
 	unsigned total;
 	isl_dim_map *dim_map;
 
+	if (!node)
+		return NULL;
+
 	total = isl_basic_set_total_dim(graph->lp);
-	pos = node_var_coef_offset(node);
+	pos = node_var_coef_pos(node, 0);
 	dim_map = isl_dim_map_alloc(ctx, total);
-	isl_dim_map_range(dim_map, pos, 2, offset, 1, node->nvar, -s);
-	isl_dim_map_range(dim_map, pos + 1, 2, offset, 1, node->nvar, s);
+	isl_dim_map_range(dim_map, pos, -2, offset, 1, node->nvar, -s);
+	isl_dim_map_range(dim_map, pos + 1, -2, offset, 1, node->nvar, s);
 
 	return dim_map;
 }
@@ -2014,10 +1762,12 @@ static __isl_give isl_dim_map *intra_dim_map(isl_ctx *ctx,
  * (c_0, c_n, c_x, c_y).
  * The mapping produced by this function essentially plugs in
  * (c_j_0 - c_i_0, c_j_n - c_i_n,
- *  c_j_x^+ - c_j_x^-, -(c_i_x^+ - c_i_x^-)) if s = 1 and
+ *  -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-) if s = 1 and
  * (-c_j_0 + c_i_0, -c_j_n + c_i_n,
- *  - (c_j_x^+ - c_j_x^-), c_i_x^+ - c_i_x^-) if s = -1.
+ *  c_i_x^+ - c_i_x^-, -(c_j_x^+ - c_j_x^-)) if s = -1.
  * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
+ * Furthermore, the order of these pairs is the opposite of that
+ * of the corresponding coefficients.
  *
  * The caller can further extend the mapping.
  */
@@ -2029,26 +1779,49 @@ static __isl_give isl_dim_map *inter_dim_map(isl_ctx *ctx,
 	unsigned total;
 	isl_dim_map *dim_map;
 
+	if (!src || !dst)
+		return NULL;
+
 	total = isl_basic_set_total_dim(graph->lp);
 	dim_map = isl_dim_map_alloc(ctx, total);
 
-	isl_dim_map_range(dim_map, dst->start, 0, 0, 0, 1, s);
-	isl_dim_map_range(dim_map, dst->start + 1, 1, 1, 1, dst->nparam, s);
-	pos = node_var_coef_offset(dst);
-	isl_dim_map_range(dim_map, pos, 2, offset + src->nvar, 1,
+	pos = node_cst_coef_offset(dst);
+	isl_dim_map_range(dim_map, pos, 0, 0, 0, 1, s);
+	pos = node_par_coef_offset(dst);
+	isl_dim_map_range(dim_map, pos, 1, 1, 1, dst->nparam, s);
+	pos = node_var_coef_pos(dst, 0);
+	isl_dim_map_range(dim_map, pos, -2, offset + src->nvar, 1,
 			  dst->nvar, -s);
-	isl_dim_map_range(dim_map, pos + 1, 2, offset + src->nvar, 1,
+	isl_dim_map_range(dim_map, pos + 1, -2, offset + src->nvar, 1,
 			  dst->nvar, s);
 
-	isl_dim_map_range(dim_map, src->start, 0, 0, 0, 1, -s);
-	isl_dim_map_range(dim_map, src->start + 1, 1, 1, 1, src->nparam, -s);
-	pos = node_var_coef_offset(src);
-	isl_dim_map_range(dim_map, pos, 2, offset, 1, src->nvar, s);
-	isl_dim_map_range(dim_map, pos + 1, 2, offset, 1, src->nvar, -s);
+	pos = node_cst_coef_offset(src);
+	isl_dim_map_range(dim_map, pos, 0, 0, 0, 1, -s);
+	pos = node_par_coef_offset(src);
+	isl_dim_map_range(dim_map, pos, 1, 1, 1, src->nparam, -s);
+	pos = node_var_coef_pos(src, 0);
+	isl_dim_map_range(dim_map, pos, -2, offset, 1, src->nvar, s);
+	isl_dim_map_range(dim_map, pos + 1, -2, offset, 1, src->nvar, -s);
 
 	return dim_map;
 }
 
+/* Add the constraints from "src" to "dst" using "dim_map",
+ * after making sure there is enough room in "dst" for the extra constraints.
+ */
+static __isl_give isl_basic_set *add_constraints_dim_map(
+	__isl_take isl_basic_set *dst, __isl_take isl_basic_set *src,
+	__isl_take isl_dim_map *dim_map)
+{
+	int n_eq, n_ineq;
+
+	n_eq = isl_basic_set_n_equality(src);
+	n_ineq = isl_basic_set_n_inequality(src);
+	dst = isl_basic_set_extend_constraints(dst, n_eq, n_ineq);
+	dst = isl_basic_set_add_constraints_dim_map(dst, src, dim_map);
+	return dst;
+}
+
 /* Add constraints to graph->lp that force validity for the given
  * dependence from a node i to itself.
  * That is, add constraints that enforce
@@ -2057,14 +1830,12 @@ static __isl_give isl_dim_map *inter_dim_map(isl_ctx *ctx,
  *	= c_i_x (y - x) >= 0
  *
  * for each (x,y) in R.
- * We obtain general constraints on coefficients (c_0, c_n, c_x)
- * of valid constraints for (y - x) and then plug in (0, 0, c_i_x^+ - c_i_x^-),
+ * We obtain general constraints on coefficients (c_0, c_x)
+ * of valid constraints for (y - x) and then plug in (0, c_i_x^+ - c_i_x^-),
  * where c_i_x = c_i_x^+ - c_i_x^-, with c_i_x^+ and c_i_x^- non-negative.
  * In graph->lp, the c_i_x^- appear before their c_i_x^+ counterpart.
- *
- * Actually, we do not construct constraints for the c_i_x themselves,
- * but for the coefficients of c_i_x written as a linear combination
- * of the columns in node->cmap.
+ * Note that the result of intra_coefficients may also contain
+ * parameter coefficients c_n, in which case 0 is plugged in for them as well.
  */
 static isl_stat add_intra_validity_constraints(struct isl_sched_graph *graph,
 	struct isl_sched_edge *edge)
@@ -2076,20 +1847,15 @@ static isl_stat add_intra_validity_constraints(struct isl_sched_graph *graph,
 	isl_basic_set *coef;
 	struct isl_sched_node *node = edge->src;
 
-	coef = intra_coefficients(graph, node, map);
+	coef = intra_coefficients(graph, node, map, 0);
 
 	offset = coef_var_offset(coef);
 
-	coef = isl_basic_set_transform_dims(coef, isl_dim_set,
-					    offset, isl_mat_copy(node->cmap));
 	if (!coef)
 		return isl_stat_error;
 
 	dim_map = intra_dim_map(ctx, graph, node, offset, 1);
-	graph->lp = isl_basic_set_extend_constraints(graph->lp,
-			coef->n_eq, coef->n_ineq);
-	graph->lp = isl_basic_set_add_constraints_dim_map(graph->lp,
-							   coef, dim_map);
+	graph->lp = add_constraints_dim_map(graph->lp, coef, dim_map);
 
 	return isl_stat_ok;
 }
@@ -2103,43 +1869,37 @@ static isl_stat add_intra_validity_constraints(struct isl_sched_graph *graph,
  * for each (x,y) in R.
  * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
  * of valid constraints for R and then plug in
- * (c_j_0 - c_i_0, c_j_n - c_i_n, c_j_x^+ - c_j_x^- - (c_i_x^+ - c_i_x^-)),
+ * (c_j_0 - c_i_0, c_j_n - c_i_n, -(c_i_x^+ - c_i_x^-), c_j_x^+ - c_j_x^-),
  * where c_* = c_*^+ - c_*^-, with c_*^+ and c_*^- non-negative.
  * In graph->lp, the c_*^- appear before their c_*^+ counterpart.
- *
- * Actually, we do not construct constraints for the c_*_x themselves,
- * but for the coefficients of c_*_x written as a linear combination
- * of the columns in node->cmap.
  */
 static isl_stat add_inter_validity_constraints(struct isl_sched_graph *graph,
 	struct isl_sched_edge *edge)
 {
 	int offset;
-	isl_map *map = isl_map_copy(edge->map);
-	isl_ctx *ctx = isl_map_get_ctx(map);
+	isl_map *map;
+	isl_ctx *ctx;
 	isl_dim_map *dim_map;
 	isl_basic_set *coef;
 	struct isl_sched_node *src = edge->src;
 	struct isl_sched_node *dst = edge->dst;
 
+	if (!graph->lp)
+		return isl_stat_error;
+
+	map = isl_map_copy(edge->map);
+	ctx = isl_map_get_ctx(map);
 	coef = inter_coefficients(graph, edge, map);
 
 	offset = coef_var_offset(coef);
 
-	coef = isl_basic_set_transform_dims(coef, isl_dim_set,
-				offset, isl_mat_copy(src->cmap));
-	coef = isl_basic_set_transform_dims(coef, isl_dim_set,
-				offset + src->nvar, isl_mat_copy(dst->cmap));
 	if (!coef)
 		return isl_stat_error;
 
 	dim_map = inter_dim_map(ctx, graph, src, dst, offset, 1);
 
 	edge->start = graph->lp->n_ineq;
-	graph->lp = isl_basic_set_extend_constraints(graph->lp,
-			coef->n_eq, coef->n_ineq);
-	graph->lp = isl_basic_set_add_constraints_dim_map(graph->lp,
-							   coef, dim_map);
+	graph->lp = add_constraints_dim_map(graph->lp, coef, dim_map);
 	if (!graph->lp)
 		return isl_stat_error;
 	edge->end = graph->lp->n_ineq;
@@ -2172,10 +1932,6 @@ static isl_stat add_inter_validity_constraints(struct isl_sched_graph *graph,
  * with each coefficient (except m_0) represented as a pair of non-negative
  * coefficients.
  *
- * Actually, we do not construct constraints for the c_i_x themselves,
- * but for the coefficients of c_i_x written as a linear combination
- * of the columns in node->cmap.
- *
  *
  * If "local" is set, then we add constraints
  *
@@ -2187,6 +1943,8 @@ static isl_stat add_inter_validity_constraints(struct isl_sched_graph *graph,
  *
  * instead, forcing the dependence distance to be (less than or) equal to 0.
  * That is, we plug in (0, 0, -s * c_i_x),
+ * intra_coefficients is not required to have c_n in its result when
+ * "local" is set.  If they are missing, then (0, -s * c_i_x) is plugged in.
  * Note that dependences marked local are treated as validity constraints
  * by add_all_validity_constraints and therefore also have
  * their distances bounded by 0 from below.
@@ -2202,12 +1960,10 @@ static isl_stat add_intra_proximity_constraints(struct isl_sched_graph *graph,
 	isl_basic_set *coef;
 	struct isl_sched_node *node = edge->src;
 
-	coef = intra_coefficients(graph, node, map);
+	coef = intra_coefficients(graph, node, map, !local);
 
 	offset = coef_var_offset(coef);
 
-	coef = isl_basic_set_transform_dims(coef, isl_dim_set,
-					    offset, isl_mat_copy(node->cmap));
 	if (!coef)
 		return isl_stat_error;
 
@@ -2219,10 +1975,7 @@ static isl_stat add_intra_proximity_constraints(struct isl_sched_graph *graph,
 		isl_dim_map_range(dim_map, 4, 2, 1, 1, nparam, -1);
 		isl_dim_map_range(dim_map, 5, 2, 1, 1, nparam, 1);
 	}
-	graph->lp = isl_basic_set_extend_constraints(graph->lp,
-			coef->n_eq, coef->n_ineq);
-	graph->lp = isl_basic_set_add_constraints_dim_map(graph->lp,
-							   coef, dim_map);
+	graph->lp = add_constraints_dim_map(graph->lp, coef, dim_map);
 
 	return isl_stat_ok;
 }
@@ -2254,26 +2007,22 @@ static isl_stat add_intra_proximity_constraints(struct isl_sched_graph *graph,
  * We obtain general constraints on coefficients (c_0, c_n, c_x, c_y)
  * of valid constraints for R and then plug in
  * (m_0 - s*c_j_0 + s*c_i_0, m_n - s*c_j_n + s*c_i_n,
- *  -s*c_j_x+s*c_i_x)
+ *  s*c_i_x, -s*c_j_x)
  * with each coefficient (except m_0, c_*_0 and c_*_n)
  * represented as a pair of non-negative coefficients.
  *
- * Actually, we do not construct constraints for the c_*_x themselves,
- * but for the coefficients of c_*_x written as a linear combination
- * of the columns in node->cmap.
  *
- *
- * If "local" is set, then we add constraints
+ * If "local" is set (and s = 1), then we add constraints
  *
  *	(c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x) <= 0
  *
  * or
  *
- *	-((c_j_0 + c_j_n n + c_j_x y) - (c_i_0 + c_i_n n + c_i_x x)) <= 0
+ *	-((c_j_0 + c_j_n n + c_j_x y) + (c_i_0 + c_i_n n + c_i_x x)) >= 0
  *
  * instead, forcing the dependence distance to be (less than or) equal to 0.
  * That is, we plug in
- * (-s*c_j_0 + s*c_i_0, -s*c_j_n + s*c_i_n, -s*c_j_x+s*c_i_x).
+ * (-s*c_j_0 + s*c_i_0, -s*c_j_n + s*c_i_n, s*c_i_x, -s*c_j_x).
  * Note that dependences marked local are treated as validity constraints
  * by add_all_validity_constraints and therefore also have
  * their distances bounded by 0 from below.
@@ -2294,10 +2043,6 @@ static isl_stat add_inter_proximity_constraints(struct isl_sched_graph *graph,
 
 	offset = coef_var_offset(coef);
 
-	coef = isl_basic_set_transform_dims(coef, isl_dim_set,
-				offset, isl_mat_copy(src->cmap));
-	coef = isl_basic_set_transform_dims(coef, isl_dim_set,
-				offset + src->nvar, isl_mat_copy(dst->cmap));
 	if (!coef)
 		return isl_stat_error;
 
@@ -2310,14 +2055,21 @@ static isl_stat add_inter_proximity_constraints(struct isl_sched_graph *graph,
 		isl_dim_map_range(dim_map, 5, 2, 1, 1, nparam, 1);
 	}
 
-	graph->lp = isl_basic_set_extend_constraints(graph->lp,
-			coef->n_eq, coef->n_ineq);
-	graph->lp = isl_basic_set_add_constraints_dim_map(graph->lp,
-							   coef, dim_map);
+	graph->lp = add_constraints_dim_map(graph->lp, coef, dim_map);
 
 	return isl_stat_ok;
 }
 
+/* Should the distance over "edge" be forced to zero?
+ * That is, is it marked as a local edge?
+ * If "use_coincidence" is set, then coincidence edges are treated
+ * as local edges.
+ */
+static int force_zero(struct isl_sched_edge *edge, int use_coincidence)
+{
+	return is_local(edge) || (use_coincidence && is_coincidence(edge));
+}
+
 /* Add all validity constraints to graph->lp.
  *
  * An edge that is forced to be local needs to have its dependence
@@ -2334,12 +2086,11 @@ static int add_all_validity_constraints(struct isl_sched_graph *graph,
 	int i;
 
 	for (i = 0; i < graph->n_edge; ++i) {
-		struct isl_sched_edge *edge= &graph->edge[i];
-		int local;
+		struct isl_sched_edge *edge = &graph->edge[i];
+		int zero;
 
-		local = is_local(edge) ||
-			(is_coincidence(edge) && use_coincidence);
-		if (!is_validity(edge) && !local)
+		zero = force_zero(edge, use_coincidence);
+		if (!is_validity(edge) && !zero)
 			continue;
 		if (edge->src != edge->dst)
 			continue;
@@ -2349,11 +2100,10 @@ static int add_all_validity_constraints(struct isl_sched_graph *graph,
 
 	for (i = 0; i < graph->n_edge; ++i) {
 		struct isl_sched_edge *edge = &graph->edge[i];
-		int local;
+		int zero;
 
-		local = is_local(edge) ||
-			(is_coincidence(edge) && use_coincidence);
-		if (!is_validity(edge) && !local)
+		zero = force_zero(edge, use_coincidence);
+		if (!is_validity(edge) && !zero)
 			continue;
 		if (edge->src == edge->dst)
 			continue;
@@ -2382,20 +2132,19 @@ static int add_all_proximity_constraints(struct isl_sched_graph *graph,
 	int i;
 
 	for (i = 0; i < graph->n_edge; ++i) {
-		struct isl_sched_edge *edge= &graph->edge[i];
-		int local;
+		struct isl_sched_edge *edge = &graph->edge[i];
+		int zero;
 
-		local = is_local(edge) ||
-			(is_coincidence(edge) && use_coincidence);
-		if (!is_proximity(edge) && !local)
+		zero = force_zero(edge, use_coincidence);
+		if (!is_proximity(edge) && !zero)
 			continue;
 		if (edge->src == edge->dst &&
-		    add_intra_proximity_constraints(graph, edge, 1, local) < 0)
+		    add_intra_proximity_constraints(graph, edge, 1, zero) < 0)
 			return -1;
 		if (edge->src != edge->dst &&
-		    add_inter_proximity_constraints(graph, edge, 1, local) < 0)
+		    add_inter_proximity_constraints(graph, edge, 1, zero) < 0)
 			return -1;
-		if (is_validity(edge) || local)
+		if (is_validity(edge) || zero)
 			continue;
 		if (edge->src == edge->dst &&
 		    add_intra_proximity_constraints(graph, edge, -1, 0) < 0)
@@ -2408,6 +2157,18 @@ static int add_all_proximity_constraints(struct isl_sched_graph *graph,
 	return 0;
 }
 
+/* Normalize the rows of "indep" such that all rows are lexicographically
+ * positive and such that each row contains as many final zeros as possible,
+ * given the choice for the previous rows.
+ * Do this by performing elementary row operations.
+ */
+static __isl_give isl_mat *normalize_independent(__isl_take isl_mat *indep)
+{
+	indep = isl_mat_reverse_gauss(indep);
+	indep = isl_mat_lexnonneg_rows(indep);
+	return indep;
+}
+
 /* Compute a basis for the rows in the linear part of the schedule
  * and extend this basis to a full basis.  The remaining rows
  * can then be used to force linear independence from the rows
@@ -2421,14 +2182,22 @@ static int add_all_proximity_constraints(struct isl_sched_graph *graph,
  * with H the Hermite normal form of S.  That is, all but the
  * first rank columns of H are zero and so each row in S is
  * a linear combination of the first rank rows of Q.
- * The matrix Q is then transposed because we will write the
- * coefficients of the next schedule row as a column vector s
- * and express this s as a linear combination s = Q c of the
- * computed basis.
- * Similarly, the matrix U is transposed such that we can
- * compute the coefficients c = U s from a schedule row s.
+ * The matrix Q can be used as a variable transformation
+ * that isolates the directions of S in the first rank rows.
+ * Transposing S U = H yields
+ *
+ *	U^T S^T = H^T
+ *
+ * with all but the first rank rows of H^T zero.
+ * The last rows of U^T are therefore linear combinations
+ * of schedule coefficients that are all zero on schedule
+ * coefficients that are linearly dependent on the rows of S.
+ * At least one of these combinations is non-zero on
+ * linearly independent schedule coefficients.
+ * The rows are normalized to involve as few of the last
+ * coefficients as possible and to have a positive initial value.
  */
-static int node_update_cmap(struct isl_sched_node *node)
+static int node_update_vmap(struct isl_sched_node *node)
 {
 	isl_mat *H, *U, *Q;
 	int n_row = isl_mat_rows(node->sched);
@@ -2437,16 +2206,16 @@ static int node_update_cmap(struct isl_sched_node *node)
 			      1 + node->nparam, node->nvar);
 
 	H = isl_mat_left_hermite(H, 0, &U, &Q);
-	isl_mat_free(node->cmap);
-	isl_mat_free(node->cinv);
-	isl_mat_free(node->ctrans);
-	node->ctrans = isl_mat_copy(Q);
-	node->cmap = isl_mat_transpose(Q);
-	node->cinv = isl_mat_transpose(U);
+	isl_mat_free(node->indep);
+	isl_mat_free(node->vmap);
+	node->vmap = Q;
+	node->indep = isl_mat_transpose(U);
 	node->rank = isl_mat_initial_non_zero_cols(H);
+	node->indep = isl_mat_drop_rows(node->indep, 0, node->rank);
+	node->indep = normalize_independent(node->indep);
 	isl_mat_free(H);
 
-	if (!node->cmap || !node->cinv || !node->ctrans || node->rank < 0)
+	if (!node->indep || !node->vmap || node->rank < 0)
 		return -1;
 	return 0;
 }
@@ -2460,11 +2229,7 @@ static int is_any_validity(struct isl_sched_edge *edge)
 
 /* How many times should we count the constraints in "edge"?
  *
- * If carry is set, then we are counting the number of
- * (validity or conditional validity) constraints that will be added
- * in setup_carry_lp and we count each edge exactly once.
- *
- * Otherwise, we count as follows
+ * We count as follows
  * validity		-> 1 (>= 0)
  * validity+proximity	-> 2 (>= 0 and upper bound)
  * proximity		-> 2 (lower and upper bound)
@@ -2476,48 +2241,100 @@ static int is_any_validity(struct isl_sched_edge *edge)
  * If "use_coincidence" is set, then we treat coincidence edges as local edges.
  * Otherwise, we ignore them.
  */
-static int edge_multiplicity(struct isl_sched_edge *edge, int carry,
-	int use_coincidence)
+static int edge_multiplicity(struct isl_sched_edge *edge, int use_coincidence)
 {
-	if (carry)
-		return 1;
-	if (is_proximity(edge) || is_local(edge))
-		return 2;
-	if (use_coincidence && is_coincidence(edge))
+	if (is_proximity(edge) || force_zero(edge, use_coincidence))
 		return 2;
 	if (is_validity(edge))
 		return 1;
 	return 0;
 }
 
+/* How many times should the constraints in "edge" be counted
+ * as a parametric intra-node constraint?
+ *
+ * Only proximity edges that are not forced zero need
+ * coefficient constraints that include coefficients for parameters.
+ * If the edge is also a validity edge, then only
+ * an upper bound is introduced.  Otherwise, both lower and upper bounds
+ * are introduced.
+ */
+static int parametric_intra_edge_multiplicity(struct isl_sched_edge *edge,
+	int use_coincidence)
+{
+	if (edge->src != edge->dst)
+		return 0;
+	if (!is_proximity(edge))
+		return 0;
+	if (force_zero(edge, use_coincidence))
+		return 0;
+	if (is_validity(edge))
+		return 1;
+	else
+		return 2;
+}
+
+/* Add "f" times the number of equality and inequality constraints of "bset"
+ * to "n_eq" and "n_ineq" and free "bset".
+ */
+static isl_stat update_count(__isl_take isl_basic_set *bset,
+	int f, int *n_eq, int *n_ineq)
+{
+	if (!bset)
+		return isl_stat_error;
+
+	*n_eq += isl_basic_set_n_equality(bset);
+	*n_ineq += isl_basic_set_n_inequality(bset);
+	isl_basic_set_free(bset);
+
+	return isl_stat_ok;
+}
+
 /* Count the number of equality and inequality constraints
  * that will be added for the given map.
  *
+ * The edges that require parameter coefficients are counted separately.
+ *
  * "use_coincidence" is set if we should take into account coincidence edges.
  */
-static int count_map_constraints(struct isl_sched_graph *graph,
+static isl_stat count_map_constraints(struct isl_sched_graph *graph,
 	struct isl_sched_edge *edge, __isl_take isl_map *map,
-	int *n_eq, int *n_ineq, int carry, int use_coincidence)
+	int *n_eq, int *n_ineq, int use_coincidence)
 {
+	isl_map *copy;
 	isl_basic_set *coef;
-	int f = edge_multiplicity(edge, carry, use_coincidence);
+	int f = edge_multiplicity(edge, use_coincidence);
+	int fp = parametric_intra_edge_multiplicity(edge, use_coincidence);
 
 	if (f == 0) {
 		isl_map_free(map);
-		return 0;
+		return isl_stat_ok;
 	}
 
-	if (edge->src == edge->dst)
-		coef = intra_coefficients(graph, edge->src, map);
-	else
+	if (edge->src != edge->dst) {
 		coef = inter_coefficients(graph, edge, map);
-	if (!coef)
-		return -1;
-	*n_eq += f * coef->n_eq;
-	*n_ineq += f * coef->n_ineq;
-	isl_basic_set_free(coef);
+		return update_count(coef, f, n_eq, n_ineq);
+	}
 
-	return 0;
+	if (fp > 0) {
+		copy = isl_map_copy(map);
+		coef = intra_coefficients(graph, edge->src, copy, 1);
+		if (update_count(coef, fp, n_eq, n_ineq) < 0)
+			goto error;
+	}
+
+	if (f > fp) {
+		copy = isl_map_copy(map);
+		coef = intra_coefficients(graph, edge->src, copy, 0);
+		if (update_count(coef, f - fp, n_eq, n_ineq) < 0)
+			goto error;
+	}
+
+	isl_map_free(map);
+	return isl_stat_ok;
+error:
+	isl_map_free(map);
+	return isl_stat_error;
 }
 
 /* Count the number of equality and inequality constraints
@@ -2538,11 +2355,11 @@ static int count_constraints(struct isl_sched_graph *graph,
 
 	*n_eq = *n_ineq = 0;
 	for (i = 0; i < graph->n_edge; ++i) {
-		struct isl_sched_edge *edge= &graph->edge[i];
+		struct isl_sched_edge *edge = &graph->edge[i];
 		isl_map *map = isl_map_copy(edge->map);
 
 		if (count_map_constraints(graph, edge, map, n_eq, n_ineq,
-					    0, use_coincidence) < 0)
+					    use_coincidence) < 0)
 			return -1;
 	}
 
@@ -2571,11 +2388,6 @@ static isl_stat count_bound_constant_constraints(isl_ctx *ctx,
  *
  * The maximal value of the constant terms is defined by the option
  * "schedule_max_constant_term".
- *
- * Within each node, the coefficients have the following order:
- *	- c_i_0
- *	- c_i_n (if parametric)
- *	- positive and negative parts of c_i_x
  */
 static isl_stat add_bound_constant_constraints(isl_ctx *ctx,
 	struct isl_sched_graph *graph)
@@ -2592,11 +2404,14 @@ static isl_stat add_bound_constant_constraints(isl_ctx *ctx,
 
 	for (i = 0; i < graph->n; ++i) {
 		struct isl_sched_node *node = &graph->node[i];
+		int pos;
+
 		k = isl_basic_set_alloc_inequality(graph->lp);
 		if (k < 0)
 			return isl_stat_error;
-		isl_seq_clr(graph->lp->ineq[k], 1 +  total);
-		isl_int_set_si(graph->lp->ineq[k][1 + node->start], -1);
+		isl_seq_clr(graph->lp->ineq[k], 1 + total);
+		pos = node_cst_coef_offset(node);
+		isl_int_set_si(graph->lp->ineq[k][1 + pos], -1);
 		isl_int_set_si(graph->lp->ineq[k][0], max);
 	}
 
@@ -2639,21 +2454,20 @@ static int count_bound_coefficient_constraints(isl_ctx *ctx,
  *	-c_n + max >= 0
  *
  * The variables coefficients are, however, not represented directly.
- * Instead, the variables coefficients c_x are written as a linear
- * combination c_x = cmap c_z of some other coefficients c_z,
- * which are in turn encoded as c_z = c_z^+ - c_z^-.
- * Let a_j be the elements of row i of node->cmap, then
+ * Instead, the variable coefficients c_x are written as differences
+ * c_x = c_x^+ - c_x^-.
+ * That is,
  *
  *	-max_i <= c_x_i <= max_i
  *
  * is encoded as
  *
- *	-max_i <= \sum_j a_j (c_z_j^+ - c_z_j^-) <= max_i
+ *	-max_i <= c_x_i^+ - c_x_i^- <= max_i
  *
  * or
  *
- *	-\sum_j a_j (c_z_j^+ - c_z_j^-) + max_i >= 0
- *	\sum_j a_j (c_z_j^+ - c_z_j^-) + max_i >= 0
+ *	-(c_x_i^+ - c_x_i^-) + max_i >= 0
+ *	c_x_i^+ - c_x_i^- + max_i >= 0
  */
 static isl_stat node_add_coefficient_constraints(isl_ctx *ctx,
 	struct isl_sched_graph *graph, struct isl_sched_node *node, int max)
@@ -2673,7 +2487,7 @@ static isl_stat node_add_coefficient_constraints(isl_ctx *ctx,
 		k = isl_basic_set_alloc_inequality(graph->lp);
 		if (k < 0)
 			return isl_stat_error;
-		dim = 1 + node->start + 1 + j;
+		dim = 1 + node_par_coef_offset(node) + j;
 		isl_seq_clr(graph->lp->ineq[k], 1 + total);
 		isl_int_set_si(graph->lp->ineq[k][dim], -1);
 		isl_int_set_si(graph->lp->ineq[k][0], max);
@@ -2684,17 +2498,13 @@ static isl_stat node_add_coefficient_constraints(isl_ctx *ctx,
 	if (!ineq)
 		return isl_stat_error;
 	for (i = 0; i < node->nvar; ++i) {
-		int pos = 1 + node_var_coef_offset(node);
+		int pos = 1 + node_var_coef_pos(node, i);
 
 		if (isl_int_is_neg(node->max->el[i]))
 			continue;
 
-		for (j = 0; j < node->nvar; ++j) {
-			isl_int_set(ineq->el[pos + 2 * j],
-					node->cmap->row[i][j]);
-			isl_int_neg(ineq->el[pos + 2 * j + 1],
-					node->cmap->row[i][j]);
-		}
+		isl_int_set_si(ineq->el[pos], 1);
+		isl_int_set_si(ineq->el[pos + 1], -1);
 		isl_int_set(ineq->el[0], node->max->el[i]);
 
 		k = isl_basic_set_alloc_inequality(graph->lp);
@@ -2702,11 +2512,13 @@ static isl_stat node_add_coefficient_constraints(isl_ctx *ctx,
 			goto error;
 		isl_seq_cpy(graph->lp->ineq[k], ineq->el, 1 + total);
 
-		isl_seq_neg(ineq->el + pos, ineq->el + pos, 2 * node->nvar);
+		isl_seq_neg(ineq->el + pos, ineq->el + pos, 2);
 		k = isl_basic_set_alloc_inequality(graph->lp);
 		if (k < 0)
 			goto error;
 		isl_seq_cpy(graph->lp->ineq[k], ineq->el, 1 + total);
+
+		isl_seq_clr(ineq->el + pos, 2);
 	}
 	isl_vec_free(ineq);
 
@@ -2759,7 +2571,7 @@ static isl_stat add_sum_constraint(struct isl_sched_graph *graph,
 	k = isl_basic_set_alloc_equality(graph->lp);
 	if (k < 0)
 		return isl_stat_error;
-	isl_seq_clr(graph->lp->eq[k], 1 +  total);
+	isl_seq_clr(graph->lp->eq[k], 1 + total);
 	isl_int_set_si(graph->lp->eq[k][1 + sum_pos], -1);
 	for (i = 0; i < n; ++i)
 		isl_int_set_si(graph->lp->eq[k][1 + first + i], 1);
@@ -2769,11 +2581,6 @@ static isl_stat add_sum_constraint(struct isl_sched_graph *graph,
 
 /* Add a constraint to graph->lp that equates the value at position
  * "sum_pos" to the sum of the parameter coefficients of all nodes.
- *
- * Within each node, the coefficients have the following order:
- *	- c_i_0
- *	- c_i_n (if parametric)
- *	- positive and negative parts of c_i_x
  */
 static isl_stat add_param_sum_constraint(struct isl_sched_graph *graph,
 	int sum_pos)
@@ -2786,10 +2593,10 @@ static isl_stat add_param_sum_constraint(struct isl_sched_graph *graph,
 	k = isl_basic_set_alloc_equality(graph->lp);
 	if (k < 0)
 		return isl_stat_error;
-	isl_seq_clr(graph->lp->eq[k], 1 +  total);
+	isl_seq_clr(graph->lp->eq[k], 1 + total);
 	isl_int_set_si(graph->lp->eq[k][1 + sum_pos], -1);
 	for (i = 0; i < graph->n; ++i) {
-		int pos = 1 + graph->node[i].start + 1;
+		int pos = 1 + node_par_coef_offset(&graph->node[i]);
 
 		for (j = 0; j < graph->node[i].nparam; ++j)
 			isl_int_set_si(graph->lp->eq[k][pos + j], 1);
@@ -2800,11 +2607,6 @@ static isl_stat add_param_sum_constraint(struct isl_sched_graph *graph,
 
 /* Add a constraint to graph->lp that equates the value at position
  * "sum_pos" to the sum of the variable coefficients of all nodes.
- *
- * Within each node, the coefficients have the following order:
- *	- c_i_0
- *	- c_i_n (if parametric)
- *	- positive and negative parts of c_i_x
  */
 static isl_stat add_var_sum_constraint(struct isl_sched_graph *graph,
 	int sum_pos)
@@ -2817,7 +2619,7 @@ static isl_stat add_var_sum_constraint(struct isl_sched_graph *graph,
 	k = isl_basic_set_alloc_equality(graph->lp);
 	if (k < 0)
 		return isl_stat_error;
-	isl_seq_clr(graph->lp->eq[k], 1 +  total);
+	isl_seq_clr(graph->lp->eq[k], 1 + total);
 	isl_int_set_si(graph->lp->eq[k][1 + sum_pos], -1);
 	for (i = 0; i < graph->n; ++i) {
 		struct isl_sched_node *node = &graph->node[i];
@@ -2850,13 +2652,9 @@ static isl_stat add_var_sum_constraint(struct isl_sched_graph *graph,
  *	- sum of positive and negative parts of all c_x coefficients
  *	- positive and negative parts of m_n coefficients
  *	- for each node
- *		- c_i_0
+ *		- positive and negative parts of c_i_x, in opposite order
  *		- c_i_n (if parametric)
- *		- positive and negative parts of c_i_x
- *
- * The c_i_x are not represented directly, but through the columns of
- * node->cmap.  That is, the computed values are for variable t_i_x
- * such that c_i_x = Q t_i_x with Q equal to node->cmap.
+ *		- c_i_0
  *
  * The constraints are those from the edges plus two or three equalities
  * to express the sums.
@@ -2881,7 +2679,7 @@ static isl_stat setup_lp(isl_ctx *ctx, struct isl_sched_graph *graph,
 	total = param_pos + 2 * nparam;
 	for (i = 0; i < graph->n; ++i) {
 		struct isl_sched_node *node = &graph->node[graph->sorted[i]];
-		if (node_update_cmap(node) < 0)
+		if (node_update_vmap(node) < 0)
 			return isl_stat_error;
 		node->start = total;
 		total += 1 + node->nparam + 2 * node->nvar;
@@ -2966,19 +2764,49 @@ static int needs_row(struct isl_sched_graph *graph, struct isl_sched_node *node)
 	return node->nvar - node->rank >= graph->maxvar - graph->n_row;
 }
 
+/* Construct a non-triviality region with triviality directions
+ * corresponding to the rows of "indep".
+ * The rows of "indep" are expressed in terms of the schedule coefficients c_i,
+ * while the triviality directions are expressed in terms of
+ * pairs of non-negative variables c^+_i - c^-_i, with c^-_i appearing
+ * before c^+_i.  Furthermore,
+ * the pairs of non-negative variables representing the coefficients
+ * are stored in the opposite order.
+ */
+static __isl_give isl_mat *construct_trivial(__isl_keep isl_mat *indep)
+{
+	isl_ctx *ctx;
+	isl_mat *mat;
+	int i, j, n, n_var;
+
+	if (!indep)
+		return NULL;
+
+	ctx = isl_mat_get_ctx(indep);
+	n = isl_mat_rows(indep);
+	n_var = isl_mat_cols(indep);
+	mat = isl_mat_alloc(ctx, n, 2 * n_var);
+	if (!mat)
+		return NULL;
+	for (i = 0; i < n; ++i) {
+		for (j = 0; j < n_var; ++j) {
+			int nj = n_var - 1 - j;
+			isl_int_neg(mat->row[i][2 * nj], indep->row[i][j]);
+			isl_int_set(mat->row[i][2 * nj + 1], indep->row[i][j]);
+		}
+	}
+
+	return mat;
+}
+
 /* Solve the ILP problem constructed in setup_lp.
  * For each node such that all the remaining rows of its schedule
  * need to be non-trivial, we construct a non-triviality region.
  * This region imposes that the next row is independent of previous rows.
- * In particular the coefficients c_i_x are represented by t_i_x
- * variables with c_i_x = Q t_i_x and Q a unimodular matrix such that
- * its first columns span the rows of the previously computed part
- * of the schedule.  The non-triviality region enforces that at least
- * one of the remaining components of t_i_x is non-zero, i.e.,
- * that the new schedule row depends on at least one of the remaining
- * columns of Q.
+ * In particular, the non-triviality region enforces that at least
+ * one of the linear combinations in the rows of node->indep is non-zero.
  */
-static __isl_give isl_vec *solve_lp(struct isl_sched_graph *graph)
+static __isl_give isl_vec *solve_lp(isl_ctx *ctx, struct isl_sched_graph *graph)
 {
 	int i;
 	isl_vec *sol;
@@ -2986,27 +2814,30 @@ static __isl_give isl_vec *solve_lp(struct isl_sched_graph *graph)
 
 	for (i = 0; i < graph->n; ++i) {
 		struct isl_sched_node *node = &graph->node[i];
-		int skip = node->rank;
-		graph->region[i].pos = node_var_coef_offset(node) + 2 * skip;
+		isl_mat *trivial;
+
+		graph->region[i].pos = node_var_coef_offset(node);
 		if (needs_row(graph, node))
-			graph->region[i].len = 2 * (node->nvar - skip);
+			trivial = construct_trivial(node->indep);
 		else
-			graph->region[i].len = 0;
+			trivial = isl_mat_zero(ctx, 0, 0);
+		graph->region[i].trivial = trivial;
 	}
 	lp = isl_basic_set_copy(graph->lp);
 	sol = isl_tab_basic_set_non_trivial_lexmin(lp, 2, graph->n,
 				       graph->region, &check_conflict, graph);
+	for (i = 0; i < graph->n; ++i)
+		isl_mat_free(graph->region[i].trivial);
 	return sol;
 }
 
 /* Extract the coefficients for the variables of "node" from "sol".
  *
- * Within each node, the coefficients have the following order:
- *	- c_i_0
- *	- c_i_n (if parametric)
- *	- positive and negative parts of c_i_x
- *
+ * Each schedule coefficient c_i_x is represented as the difference
+ * between two non-negative variables c_i_x^+ - c_i_x^-.
  * The c_i_x^- appear before their c_i_x^+ counterpart.
+ * Furthermore, the order of these pairs is the opposite of that
+ * of the corresponding coefficients.
  *
  * Return c_i_x = c_i_x^+ - c_i_x^-
  */
@@ -3025,7 +2856,7 @@ static __isl_give isl_vec *extract_var_coef(struct isl_sched_node *node,
 
 	pos = 1 + node_var_coef_offset(node);
 	for (i = 0; i < node->nvar; ++i)
-		isl_int_sub(csol->el[i],
+		isl_int_sub(csol->el[node->nvar - 1 - i],
 			    sol->el[pos + 2 * i + 1], sol->el[pos + 2 * i]);
 
 	return csol;
@@ -3036,17 +2867,13 @@ static __isl_give isl_vec *extract_var_coef(struct isl_sched_node *node,
  * The new row is added to the current band.
  * All possibly negative coefficients are encoded as a difference
  * of two non-negative variables, so we need to perform the subtraction
- * here.  Moreover, if use_cmap is set, then the solution does
- * not refer to the actual coefficients c_i_x, but instead to variables
- * t_i_x such that c_i_x = Q t_i_x and Q is equal to node->cmap.
- * In this case, we then also need to perform this multiplication
- * to obtain the values of c_i_x.
+ * here.
  *
  * If coincident is set, then the caller guarantees that the new
  * row satisfies the coincidence constraints.
  */
 static int update_schedule(struct isl_sched_graph *graph,
-	__isl_take isl_vec *sol, int use_cmap, int coincident)
+	__isl_take isl_vec *sol, int coincident)
 {
 	int i, j;
 	isl_vec *csol = NULL;
@@ -3062,7 +2889,7 @@ static int update_schedule(struct isl_sched_graph *graph,
 
 	for (i = 0; i < graph->n; ++i) {
 		struct isl_sched_node *node = &graph->node[i];
-		int pos = node->start;
+		int pos;
 		int row = isl_mat_rows(node->sched);
 
 		isl_vec_free(csol);
@@ -3075,14 +2902,13 @@ static int update_schedule(struct isl_sched_graph *graph,
 		node->sched = isl_mat_add_rows(node->sched, 1);
 		if (!node->sched)
 			goto error;
-		for (j = 0; j < 1 + node->nparam; ++j)
+		pos = node_cst_coef_offset(node);
+		node->sched = isl_mat_set_element(node->sched,
+					row, 0, sol->el[1 + pos]);
+		pos = node_par_coef_offset(node);
+		for (j = 0; j < node->nparam; ++j)
 			node->sched = isl_mat_set_element(node->sched,
-						row, j, sol->el[1 + pos + j]);
-		if (use_cmap)
-			csol = isl_mat_vec_product(isl_mat_copy(node->cmap),
-						   csol);
-		if (!csol)
-			goto error;
+					row, 1 + j, sol->el[1 + pos + j]);
 		for (j = 0; j < node->nvar; ++j)
 			node->sched = isl_mat_set_element(node->sched,
 					row, 1 + node->nparam + j, csol->el[j]);
@@ -3557,6 +3383,7 @@ static int copy_nodes(struct isl_sched_graph *dst, struct isl_sched_graph *src,
 		dst->node[j].sched_map = isl_map_copy(src->node[i].sched_map);
 		dst->node[j].coincident = src->node[i].coincident;
 		dst->node[j].sizes = isl_multi_val_copy(src->node[i].sizes);
+		dst->node[j].bounds = isl_basic_set_copy(src->node[i].bounds);
 		dst->node[j].max = isl_vec_copy(src->node[i].max);
 		dst->n++;
 
@@ -3654,7 +3481,7 @@ static int compute_maxvar(struct isl_sched_graph *graph)
 		struct isl_sched_node *node = &graph->node[i];
 		int nvar;
 
-		if (node_update_cmap(node) < 0)
+		if (node_update_vmap(node) < 0)
 			return -1;
 		nvar = node->nvar + graph->n_row - node->rank;
 		if (nvar > graph->maxvar)
@@ -3684,6 +3511,7 @@ static int extract_sub_graph(isl_ctx *ctx, struct isl_sched_graph *graph,
 			++n_edge;
 	if (graph_alloc(ctx, sub, n, n_edge) < 0)
 		return -1;
+	sub->root = graph->root;
 	if (copy_nodes(sub, graph, node_pred, data) < 0)
 		return -1;
 	if (graph_init_table(ctx, sub) < 0)
@@ -3920,163 +3748,309 @@ static __isl_give isl_schedule_node *compute_next_band(
 	return node;
 }
 
-/* Add constraints to graph->lp that force the dependence "map" (which
- * is part of the dependence relation of "edge")
- * to be respected and attempt to carry it, where the edge is one from
- * a node j to itself.  "pos" is the sequence number of the given map.
- * That is, add constraints that enforce
+/* Add the constraints "coef" derived from an edge from "node" to itself
+ * to graph->lp in order to respect the dependences and to try and carry them.
+ * "pos" is the sequence number of the edge that needs to be carried.
+ * "coef" represents general constraints on coefficients (c_0, c_x)
+ * of valid constraints for (y - x) with x and y instances of the node.
  *
- *	(c_j_0 + c_j_n n + c_j_x y) - (c_j_0 + c_j_n n + c_j_x x)
+ * The constraints added to graph->lp need to enforce
+ *
+ *	(c_j_0 + c_j_x y) - (c_j_0 + c_j_x x)
  *	= c_j_x (y - x) >= e_i
  *
- * for each (x,y) in R.
- * We obtain general constraints on coefficients (c_0, c_n, c_x)
- * of valid constraints for (y - x) and then plug in (-e_i, 0, c_j_x),
- * with each coefficient in c_j_x represented as a pair of non-negative
- * coefficients.
+ * for each (x,y) in the dependence relation of the edge.
+ * That is, (-e_i, c_j_x) needs to be plugged in for (c_0, c_x),
+ * taking into account that each coefficient in c_j_x is represented
+ * as a pair of non-negative coefficients.
  */
-static int add_intra_constraints(struct isl_sched_graph *graph,
-	struct isl_sched_edge *edge, __isl_take isl_map *map, int pos)
+static isl_stat add_intra_constraints(struct isl_sched_graph *graph,
+	struct isl_sched_node *node, __isl_take isl_basic_set *coef, int pos)
 {
 	int offset;
-	isl_ctx *ctx = isl_map_get_ctx(map);
+	isl_ctx *ctx;
 	isl_dim_map *dim_map;
-	isl_basic_set *coef;
-	struct isl_sched_node *node = edge->src;
 
-	coef = intra_coefficients(graph, node, map);
 	if (!coef)
-		return -1;
+		return isl_stat_error;
 
+	ctx = isl_basic_set_get_ctx(coef);
 	offset = coef_var_offset(coef);
 	dim_map = intra_dim_map(ctx, graph, node, offset, 1);
 	isl_dim_map_range(dim_map, 3 + pos, 0, 0, 0, 1, -1);
-	graph->lp = isl_basic_set_extend_constraints(graph->lp,
-			coef->n_eq, coef->n_ineq);
-	graph->lp = isl_basic_set_add_constraints_dim_map(graph->lp,
-							   coef, dim_map);
+	graph->lp = add_constraints_dim_map(graph->lp, coef, dim_map);
 
-	return 0;
+	return isl_stat_ok;
 }
 
-/* Add constraints to graph->lp that force the dependence "map" (which
- * is part of the dependence relation of "edge")
- * to be respected and attempt to carry it, where the edge is one from
- * node j to node k.  "pos" is the sequence number of the given map.
- * That is, add constraints that enforce
+/* Add the constraints "coef" derived from an edge from "src" to "dst"
+ * to graph->lp in order to respect the dependences and to try and carry them.
+ * "pos" is the sequence number of the edge that needs to be carried or
+ * -1 if no attempt should be made to carry the dependences.
+ * "coef" represents general constraints on coefficients (c_0, c_n, c_x, c_y)
+ * of valid constraints for (x, y) with x and y instances of "src" and "dst".
+ *
+ * The constraints added to graph->lp need to enforce
  *
  *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= e_i
  *
- * for each (x,y) in R.
- * We obtain general constraints on coefficients (c_0, c_n, c_x)
- * of valid constraints for R and then plug in
- * (-e_i + c_k_0 - c_j_0, c_k_n - c_j_n, c_k_x - c_j_x)
- * with each coefficient (except e_i, c_*_0 and c_*_n)
- * represented as a pair of non-negative coefficients.
+ * for each (x,y) in the dependence relation of the edge or
+ *
+ *	(c_k_0 + c_k_n n + c_k_x y) - (c_j_0 + c_j_n n + c_j_x x) >= 0
+ *
+ * if pos is -1.
+ * That is,
+ * (-e_i + c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
+ * or
+ * (c_k_0 - c_j_0, c_k_n - c_j_n, -c_j_x, c_k_x)
+ * needs to be plugged in for (c_0, c_n, c_x, c_y),
+ * taking into account that each coefficient in c_j_x and c_k_x is represented
+ * as a pair of non-negative coefficients.
  */
-static int add_inter_constraints(struct isl_sched_graph *graph,
-	struct isl_sched_edge *edge, __isl_take isl_map *map, int pos)
+static isl_stat add_inter_constraints(struct isl_sched_graph *graph,
+	struct isl_sched_node *src, struct isl_sched_node *dst,
+	__isl_take isl_basic_set *coef, int pos)
 {
 	int offset;
-	isl_ctx *ctx = isl_map_get_ctx(map);
+	isl_ctx *ctx;
 	isl_dim_map *dim_map;
-	isl_basic_set *coef;
-	struct isl_sched_node *src = edge->src;
-	struct isl_sched_node *dst = edge->dst;
 
-	coef = inter_coefficients(graph, edge, map);
 	if (!coef)
-		return -1;
+		return isl_stat_error;
 
+	ctx = isl_basic_set_get_ctx(coef);
 	offset = coef_var_offset(coef);
 	dim_map = inter_dim_map(ctx, graph, src, dst, offset, 1);
-	isl_dim_map_range(dim_map, 3 + pos, 0, 0, 0, 1, -1);
-	graph->lp = isl_basic_set_extend_constraints(graph->lp,
-			coef->n_eq, coef->n_ineq);
-	graph->lp = isl_basic_set_add_constraints_dim_map(graph->lp,
-							   coef, dim_map);
+	if (pos >= 0)
+		isl_dim_map_range(dim_map, 3 + pos, 0, 0, 0, 1, -1);
+	graph->lp = add_constraints_dim_map(graph->lp, coef, dim_map);
 
-	return 0;
+	return isl_stat_ok;
 }
 
-/* Add constraints to graph->lp that force all (conditional) validity
- * dependences to be respected and attempt to carry them.
+/* Data structure for keeping track of the data needed
+ * to exploit non-trivial lineality spaces.
+ *
+ * "any_non_trivial" is true if there are any non-trivial lineality spaces.
+ * If "any_non_trivial" is not true, then "equivalent" and "mask" may be NULL.
+ * "equivalent" connects instances to other instances on the same line(s).
+ * "mask" contains the domain spaces of "equivalent".
+ * Any instance set not in "mask" does not have a non-trivial lineality space.
+ */
+struct isl_exploit_lineality_data {
+	isl_bool any_non_trivial;
+	isl_union_map *equivalent;
+	isl_union_set *mask;
+};
+
+/* Data structure collecting information used during the construction
+ * of an LP for carrying dependences.
+ *
+ * "intra" is a sequence of coefficient constraints for intra-node edges.
+ * "inter" is a sequence of coefficient constraints for inter-node edges.
+ * "lineality" contains data used to exploit non-trivial lineality spaces.
+ */
+struct isl_carry {
+	isl_basic_set_list *intra;
+	isl_basic_set_list *inter;
+	struct isl_exploit_lineality_data lineality;
+};
+
+/* Free all the data stored in "carry".
  */
-static int add_all_constraints(struct isl_sched_graph *graph)
+static void isl_carry_clear(struct isl_carry *carry)
 {
-	int i, j;
+	isl_basic_set_list_free(carry->intra);
+	isl_basic_set_list_free(carry->inter);
+	isl_union_map_free(carry->lineality.equivalent);
+	isl_union_set_free(carry->lineality.mask);
+}
+
+/* Return a pointer to the node in "graph" that lives in "space".
+ * If the requested node has been compressed, then "space"
+ * corresponds to the compressed space.
+ *
+ * First try and see if "space" is the space of an uncompressed node.
+ * If so, return that node.
+ * Otherwise, "space" was constructed by construct_compressed_id and
+ * contains a user pointer pointing to the node in the tuple id.
+ * However, this node belongs to the original dependence graph.
+ * If "graph" is a subgraph of this original dependence graph,
+ * then the node with the same space still needs to be looked up
+ * in the current graph.
+ */
+static struct isl_sched_node *graph_find_compressed_node(isl_ctx *ctx,
+	struct isl_sched_graph *graph, __isl_keep isl_space *space)
+{
+	isl_id *id;
+	struct isl_sched_node *node;
+
+	if (!space)
+		return NULL;
+
+	node = graph_find_node(ctx, graph, space);
+	if (node)
+		return node;
+
+	id = isl_space_get_tuple_id(space, isl_dim_set);
+	node = isl_id_get_user(id);
+	isl_id_free(id);
+
+	if (!node)
+		return NULL;
+
+	if (!is_node(graph->root, node))
+		isl_die(ctx, isl_error_internal,
+			"space points to invalid node", return NULL);
+	if (graph != graph->root)
+		node = graph_find_node(ctx, graph, node->space);
+
+	return node;
+}
+
+/* Internal data structure for add_all_constraints.
+ *
+ * "graph" is the schedule constraint graph for which an LP problem
+ * is being constructed.
+ * "carry_inter" indicates whether inter-node edges should be carried.
+ * "pos" is the position of the next edge that needs to be carried.
+ */
+struct isl_add_all_constraints_data {
+	isl_ctx *ctx;
+	struct isl_sched_graph *graph;
+	int carry_inter;
 	int pos;
+};
 
-	pos = 0;
-	for (i = 0; i < graph->n_edge; ++i) {
-		struct isl_sched_edge *edge= &graph->edge[i];
+/* Add the constraints "coef" derived from an edge from a node to itself
+ * to data->graph->lp in order to respect the dependences and
+ * to try and carry them.
+ *
+ * The space of "coef" is of the form
+ *
+ *	coefficients[[c_cst] -> S[c_x]]
+ *
+ * with S[c_x] the (compressed) space of the node.
+ * Extract the node from the space and call add_intra_constraints.
+ */
+static isl_stat lp_add_intra(__isl_take isl_basic_set *coef, void *user)
+{
+	struct isl_add_all_constraints_data *data = user;
+	isl_space *space;
+	struct isl_sched_node *node;
 
-		if (!is_any_validity(edge))
-			continue;
+	space = isl_basic_set_get_space(coef);
+	space = isl_space_range(isl_space_unwrap(space));
+	node = graph_find_compressed_node(data->ctx, data->graph, space);
+	isl_space_free(space);
+	return add_intra_constraints(data->graph, node, coef, data->pos++);
+}
 
-		for (j = 0; j < edge->map->n; ++j) {
-			isl_basic_map *bmap;
-			isl_map *map;
+/* Add the constraints "coef" derived from an edge from a node j
+ * to a node k to data->graph->lp in order to respect the dependences and
+ * to try and carry them (provided data->carry_inter is set).
+ *
+ * The space of "coef" is of the form
+ *
+ *	coefficients[[c_cst, c_n] -> [S_j[c_x] -> S_k[c_y]]]
+ *
+ * with S_j[c_x] and S_k[c_y] the (compressed) spaces of the nodes.
+ * Extract the nodes from the space and call add_inter_constraints.
+ */
+static isl_stat lp_add_inter(__isl_take isl_basic_set *coef, void *user)
+{
+	struct isl_add_all_constraints_data *data = user;
+	isl_space *space, *dom;
+	struct isl_sched_node *src, *dst;
+	int pos;
 
-			bmap = isl_basic_map_copy(edge->map->p[j]);
-			map = isl_map_from_basic_map(bmap);
+	space = isl_basic_set_get_space(coef);
+	space = isl_space_unwrap(isl_space_range(isl_space_unwrap(space)));
+	dom = isl_space_domain(isl_space_copy(space));
+	src = graph_find_compressed_node(data->ctx, data->graph, dom);
+	isl_space_free(dom);
+	space = isl_space_range(space);
+	dst = graph_find_compressed_node(data->ctx, data->graph, space);
+	isl_space_free(space);
 
-			if (edge->src == edge->dst &&
-			    add_intra_constraints(graph, edge, map, pos) < 0)
-				return -1;
-			if (edge->src != edge->dst &&
-			    add_inter_constraints(graph, edge, map, pos) < 0)
-				return -1;
-			++pos;
-		}
-	}
+	pos = data->carry_inter ? data->pos++ : -1;
+	return add_inter_constraints(data->graph, src, dst, coef, pos);
+}
 
-	return 0;
+/* Add constraints to graph->lp that force all (conditional) validity
+ * dependences to be respected and attempt to carry them.
+ * "intra" is the sequence of coefficient constraints for intra-node edges.
+ * "inter" is the sequence of coefficient constraints for inter-node edges.
+ * "carry_inter" indicates whether inter-node edges should be carried or
+ * only respected.
+ */
+static isl_stat add_all_constraints(isl_ctx *ctx, struct isl_sched_graph *graph,
+	__isl_keep isl_basic_set_list *intra,
+	__isl_keep isl_basic_set_list *inter, int carry_inter)
+{
+	struct isl_add_all_constraints_data data = { ctx, graph, carry_inter };
+
+	data.pos = 0;
+	if (isl_basic_set_list_foreach(intra, &lp_add_intra, &data) < 0)
+		return isl_stat_error;
+	if (isl_basic_set_list_foreach(inter, &lp_add_inter, &data) < 0)
+		return isl_stat_error;
+	return isl_stat_ok;
+}
+
+/* Internal data structure for count_all_constraints
+ * for keeping track of the number of equality and inequality constraints.
+ */
+struct isl_sched_count {
+	int n_eq;
+	int n_ineq;
+};
+
+/* Add the number of equality and inequality constraints of "bset"
+ * to data->n_eq and data->n_ineq.
+ */
+static isl_stat bset_update_count(__isl_take isl_basic_set *bset, void *user)
+{
+	struct isl_sched_count *data = user;
+
+	return update_count(bset, 1, &data->n_eq, &data->n_ineq);
 }
 
 /* Count the number of equality and inequality constraints
  * that will be added to the carry_lp problem.
  * We count each edge exactly once.
+ * "intra" is the sequence of coefficient constraints for intra-node edges.
+ * "inter" is the sequence of coefficient constraints for inter-node edges.
  */
-static int count_all_constraints(struct isl_sched_graph *graph,
-	int *n_eq, int *n_ineq)
+static isl_stat count_all_constraints(__isl_keep isl_basic_set_list *intra,
+	__isl_keep isl_basic_set_list *inter, int *n_eq, int *n_ineq)
 {
-	int i, j;
-
-	*n_eq = *n_ineq = 0;
-	for (i = 0; i < graph->n_edge; ++i) {
-		struct isl_sched_edge *edge= &graph->edge[i];
-
-		if (!is_any_validity(edge))
-			continue;
-
-		for (j = 0; j < edge->map->n; ++j) {
-			isl_basic_map *bmap;
-			isl_map *map;
+	struct isl_sched_count data;
 
-			bmap = isl_basic_map_copy(edge->map->p[j]);
-			map = isl_map_from_basic_map(bmap);
+	data.n_eq = data.n_ineq = 0;
+	if (isl_basic_set_list_foreach(inter, &bset_update_count, &data) < 0)
+		return isl_stat_error;
+	if (isl_basic_set_list_foreach(intra, &bset_update_count, &data) < 0)
+		return isl_stat_error;
 
-			if (count_map_constraints(graph, edge, map,
-						  n_eq, n_ineq, 1, 0) < 0)
-				    return -1;
-		}
-	}
+	*n_eq = data.n_eq;
+	*n_ineq = data.n_ineq;
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Construct an LP problem for finding schedule coefficients
- * such that the schedule carries as many dependences as possible.
+ * such that the schedule carries as many validity dependences as possible.
  * In particular, for each dependence i, we bound the dependence distance
  * from below by e_i, with 0 <= e_i <= 1 and then maximize the sum
  * of all e_i's.  Dependences with e_i = 0 in the solution are simply
  * respected, while those with e_i > 0 (in practice e_i = 1) are carried.
- * Note that if the dependence relation is a union of basic maps,
- * then we have to consider each basic map individually as it may only
- * be possible to carry the dependences expressed by some of those
- * basic maps and not all of them.
- * Below, we consider each of those basic maps as a separate "edge".
+ * "intra" is the sequence of coefficient constraints for intra-node edges.
+ * "inter" is the sequence of coefficient constraints for inter-node edges.
+ * "n_edge" is the total number of edges.
+ * "carry_inter" indicates whether inter-node edges should be carried or
+ * only respected.  That is, if "carry_inter" is not set, then
+ * no e_i variables are introduced for the inter-node edges.
  *
  * All variables of the LP are non-negative.  The actual coefficients
  * may be negative, so each coefficient is represented as the difference
@@ -4091,25 +4065,22 @@ static int count_all_constraints(struct isl_sched_graph *graph,
  *	- for each edge
  *		- e_i
  *	- for each node
- *		- c_i_0
+ *		- positive and negative parts of c_i_x, in opposite order
  *		- c_i_n (if parametric)
- *		- positive and negative parts of c_i_x
+ *		- c_i_0
  *
  * The constraints are those from the (validity) edges plus three equalities
  * to express the sums and n_edge inequalities to express e_i <= 1.
  */
-static isl_stat setup_carry_lp(isl_ctx *ctx, struct isl_sched_graph *graph)
+static isl_stat setup_carry_lp(isl_ctx *ctx, struct isl_sched_graph *graph,
+	int n_edge, __isl_keep isl_basic_set_list *intra,
+	__isl_keep isl_basic_set_list *inter, int carry_inter)
 {
 	int i;
 	int k;
 	isl_space *dim;
 	unsigned total;
 	int n_eq, n_ineq;
-	int n_edge;
-
-	n_edge = 0;
-	for (i = 0; i < graph->n_edge; ++i)
-		n_edge += graph->edge[i].map->n;
 
 	total = 3 + n_edge;
 	for (i = 0; i < graph->n; ++i) {
@@ -4118,7 +4089,7 @@ static isl_stat setup_carry_lp(isl_ctx *ctx, struct isl_sched_graph *graph)
 		total += 1 + node->nparam + 2 * node->nvar;
 	}
 
-	if (count_all_constraints(graph, &n_eq, &n_ineq) < 0)
+	if (count_all_constraints(intra, inter, &n_eq, &n_ineq) < 0)
 		return isl_stat_error;
 
 	dim = isl_space_set_alloc(ctx, 0, total);
@@ -4131,7 +4102,7 @@ static isl_stat setup_carry_lp(isl_ctx *ctx, struct isl_sched_graph *graph)
 	k = isl_basic_set_alloc_equality(graph->lp);
 	if (k < 0)
 		return isl_stat_error;
-	isl_seq_clr(graph->lp->eq[k], 1 +  total);
+	isl_seq_clr(graph->lp->eq[k], 1 + total);
 	isl_int_set_si(graph->lp->eq[k][0], -n_edge);
 	isl_int_set_si(graph->lp->eq[k][1], 1);
 	for (i = 0; i < n_edge; ++i)
@@ -4146,12 +4117,12 @@ static isl_stat setup_carry_lp(isl_ctx *ctx, struct isl_sched_graph *graph)
 		k = isl_basic_set_alloc_inequality(graph->lp);
 		if (k < 0)
 			return isl_stat_error;
-		isl_seq_clr(graph->lp->ineq[k], 1 +  total);
+		isl_seq_clr(graph->lp->ineq[k], 1 + total);
 		isl_int_set_si(graph->lp->ineq[k][4 + i], -1);
 		isl_int_set_si(graph->lp->ineq[k][0], 1);
 	}
 
-	if (add_all_constraints(graph) < 0)
+	if (add_all_constraints(ctx, graph, intra, inter, carry_inter) < 0)
 		return isl_stat_error;
 
 	return isl_stat_ok;
@@ -4161,43 +4132,29 @@ static __isl_give isl_schedule_node *compute_component_schedule(
 	__isl_take isl_schedule_node *node, struct isl_sched_graph *graph,
 	int wcc);
 
-/* Comparison function for sorting the statements based on
- * the corresponding value in "r".
- */
-static int smaller_value(const void *a, const void *b, void *data)
-{
-	isl_vec *r = data;
-	const int *i1 = a;
-	const int *i2 = b;
-
-	return isl_int_cmp(r->el[*i1], r->el[*i2]);
-}
-
 /* If the schedule_split_scaled option is set and if the linear
  * parts of the scheduling rows for all nodes in the graphs have
- * a non-trivial common divisor, then split off the remainder of the
- * constant term modulo this common divisor from the linear part.
+ * a non-trivial common divisor, then remove this
+ * common divisor from the linear part.
  * Otherwise, insert a band node directly and continue with
  * the construction of the schedule.
  *
  * If a non-trivial common divisor is found, then
- * the linear part is reduced and the remainder is enforced
- * by a sequence node with the children placed in the order
- * of this remainder.
- * In particular, we assign an scc index based on the remainder and
- * then rely on compute_component_schedule to insert the sequence and
- * to continue the schedule construction on each part.
+ * the linear part is reduced and the remainder is ignored.
+ * The pieces of the graph that are assigned different remainders
+ * form (groups of) strongly connected components within
+ * the scaled down band.  If needed, they can therefore
+ * be ordered along this remainder in a sequence node.
+ * However, this ordering is not enforced here in order to allow
+ * the scheduler to combine some of the strongly connected components.
  */
 static __isl_give isl_schedule_node *split_scaled(
 	__isl_take isl_schedule_node *node, struct isl_sched_graph *graph)
 {
 	int i;
 	int row;
-	int scc;
 	isl_ctx *ctx;
 	isl_int gcd, gcd_i;
-	isl_vec *r;
-	int *order;
 
 	if (!node)
 		return NULL;
@@ -4230,16 +4187,9 @@ static __isl_give isl_schedule_node *split_scaled(
 		return compute_next_band(node, graph, 0);
 	}
 
-	r = isl_vec_alloc(ctx, graph->n);
-	order = isl_calloc_array(ctx, int, graph->n);
-	if (!r || !order)
-		goto error;
-
 	for (i = 0; i < graph->n; ++i) {
 		struct isl_sched_node *node = &graph->node[i];
 
-		order[i] = i;
-		isl_int_fdiv_r(r->el[i], node->sched->row[row][0], gcd);
 		isl_int_fdiv_q(node->sched->row[row][0],
 			       node->sched->row[row][0], gcd);
 		isl_int_mul(node->sched->row[row][0],
@@ -4249,51 +4199,26 @@ static __isl_give isl_schedule_node *split_scaled(
 			goto error;
 	}
 
-	if (isl_sort(order, graph->n, sizeof(order[0]), &smaller_value, r) < 0)
-		goto error;
-
-	scc = 0;
-	for (i = 0; i < graph->n; ++i) {
-		if (i > 0 && isl_int_ne(r->el[order[i - 1]], r->el[order[i]]))
-			++scc;
-		graph->node[order[i]].scc = scc;
-	}
-	graph->scc = ++scc;
-	graph->weak = 0;
-
-	isl_int_clear(gcd);
-	isl_vec_free(r);
-	free(order);
-
-	if (update_edges(ctx, graph) < 0)
-		return isl_schedule_node_free(node);
-	node = insert_current_band(node, graph, 0);
-	next_band(graph);
-
-	node = isl_schedule_node_child(node, 0);
-	node = compute_component_schedule(node, graph, 0);
-	node = isl_schedule_node_parent(node);
-
-	return node;
+	isl_int_clear(gcd);
+
+	return compute_next_band(node, graph, 0);
 error:
-	isl_vec_free(r);
-	free(order);
 	isl_int_clear(gcd);
 	return isl_schedule_node_free(node);
 }
 
 /* Is the schedule row "sol" trivial on node "node"?
- * That is, is the solution zero on the dimensions orthogonal to
+ * That is, is the solution zero on the dimensions linearly independent of
  * the previously found solutions?
  * Return 1 if the solution is trivial, 0 if it is not and -1 on error.
  *
  * Each coefficient is represented as the difference between
- * two non-negative values in "sol".  "sol" has been computed
- * in terms of the original iterators (i.e., without use of cmap).
- * We construct the schedule row s and write it as a linear
- * combination of (linear combinations of) previously computed schedule rows.
- * s = Q c or c = U s.
- * If the final entries of c are all zero, then the solution is trivial.
+ * two non-negative values in "sol".
+ * We construct the schedule row s and check if it is linearly
+ * independent of previously computed schedule rows
+ * by computing T s, with T the linear combinations that are zero
+ * on linearly dependent schedule rows.
+ * If the result consists of all zeros, then the solution is trivial.
  */
 static int is_trivial(struct isl_sched_node *node, __isl_keep isl_vec *sol)
 {
@@ -4306,11 +4231,11 @@ static int is_trivial(struct isl_sched_node *node, __isl_keep isl_vec *sol)
 		return 0;
 
 	node_sol = extract_var_coef(node, sol);
-	node_sol = isl_mat_vec_product(isl_mat_copy(node->cinv), node_sol);
+	node_sol = isl_mat_vec_product(isl_mat_copy(node->indep), node_sol);
 	if (!node_sol)
 		return -1;
 
-	trivial = isl_seq_first_non_zero(node_sol->el + node->rank,
+	trivial = isl_seq_first_non_zero(node_sol->el,
 					node->nvar - node->rank) == -1;
 
 	isl_vec_free(node_sol);
@@ -4320,8 +4245,6 @@ static int is_trivial(struct isl_sched_node *node, __isl_keep isl_vec *sol)
 
 /* Is the schedule row "sol" trivial on any node where it should
  * not be trivial?
- * "sol" has been computed in terms of the original iterators
- * (i.e., without use of cmap).
  * Return 1 if any solution is trivial, 0 if they are not and -1 on error.
  */
 static int is_any_trivial(struct isl_sched_graph *graph,
@@ -4348,7 +4271,7 @@ static int is_any_trivial(struct isl_sched_graph *graph,
  * Otherwise, return node->nvar or -1 on error.
  *
  * In particular, look for pairs of coefficients c_i and c_j such that
- * |c_j/c_i| >= size_i, i.e., |c_j| >= |c_i * size_i|.
+ * |c_j/c_i| > ceil(size_i/2), i.e., |c_j| > |c_i * ceil(size_i/2)|.
  * If any such pair is found, then return i.
  * If size_i is infinity, then no check on c_i needs to be performed.
  */
@@ -4378,13 +4301,17 @@ static int find_node_coalescing(struct isl_sched_node *node,
 			isl_val_free(v);
 			continue;
 		}
+		v = isl_val_div_ui(v, 2);
+		v = isl_val_ceil(v);
+		if (!v)
+			goto error;
 		isl_int_mul(max, v->n, csol->el[i]);
 		isl_val_free(v);
 
 		for (j = 0; j < node->nvar; ++j) {
 			if (j == i)
 				continue;
-			if (isl_int_abs_ge(csol->el[j], max))
+			if (isl_int_abs_gt(csol->el[j], max))
 				break;
 		}
 		if (j < node->nvar)
@@ -4421,7 +4348,7 @@ static __isl_give isl_tab_lexmin *zero_out_node_coef(
 	if (!eq)
 		return isl_tab_lexmin_free(tl);
 
-	pos = 1 + node_var_coef_offset(node) + 2 * pos;
+	pos = 1 + node_var_coef_pos(node, pos);
 	isl_int_set_si(eq->el[pos], 1);
 	isl_int_set_si(eq->el[pos + 1], -1);
 	tl = isl_tab_lexmin_add_eq(tl, eq->el);
@@ -4479,12 +4406,15 @@ static int carries_dependences(__isl_keep isl_vec *sol, int n_edge)
 /* Return the lexicographically smallest rational point in "lp",
  * assuming that all variables are non-negative and performing some
  * additional sanity checks.
+ * If "want_integral" is set, then compute the lexicographically smallest
+ * integer point instead.
  * In particular, "lp" should not be empty by construction.
  * Double check that this is the case.
- * Also, check that dependences are carried for at least one of
- * the "n_edge" edges.
+ * If dependences are not carried for any of the "n_edge" edges,
+ * then return an empty vector.
  *
- * If the computed schedule performs loop coalescing on a given node,
+ * If the schedule_treat_coalescing option is set and
+ * if the computed schedule performs loop coalescing on a given node,
  * i.e., if it is of the form
  *
  *	c_i i + c_j j + ...
@@ -4493,11 +4423,22 @@ static int carries_dependences(__isl_keep isl_vec *sol, int n_edge)
  * to cut out this solution.  Repeat this process until no more loop
  * coalescing occurs or until no more dependences can be carried.
  * In the latter case, revert to the previously computed solution.
+ *
+ * If the caller requests an integral solution and if coalescing should
+ * be treated, then perform the coalescing treatment first as
+ * an integral solution computed before coalescing treatment
+ * would carry the same number of edges and would therefore probably
+ * also be coalescing.
+ *
+ * To allow the coalescing treatment to be performed first,
+ * the initial solution is allowed to be rational and it is only
+ * cut out (if needed) in the next iteration, if no coalescing measures
+ * were taken.
  */
 static __isl_give isl_vec *non_neg_lexmin(struct isl_sched_graph *graph,
-	__isl_take isl_basic_set *lp, int n_edge)
+	__isl_take isl_basic_set *lp, int n_edge, int want_integral)
 {
-	int i, pos;
+	int i, pos, cut;
 	isl_ctx *ctx;
 	isl_tab_lexmin *tl;
 	isl_vec *sol, *prev = NULL;
@@ -4509,23 +4450,30 @@ static __isl_give isl_vec *non_neg_lexmin(struct isl_sched_graph *graph,
 	treat_coalescing = isl_options_get_schedule_treat_coalescing(ctx);
 	tl = isl_tab_lexmin_from_basic_set(lp);
 
+	cut = 0;
 	do {
+		int integral;
+
+		if (cut)
+			tl = isl_tab_lexmin_cut_to_integer(tl);
 		sol = non_empty_solution(tl);
 		if (!sol)
 			goto error;
 
+		integral = isl_int_is_one(sol->el[0]);
 		if (!carries_dependences(sol, n_edge)) {
 			if (!prev)
-				isl_die(ctx, isl_error_unknown,
-					"unable to carry dependences",
-					goto error);
+				prev = isl_vec_alloc(ctx, 0);
 			isl_vec_free(sol);
 			sol = prev;
 			break;
 		}
 		prev = isl_vec_free(prev);
+		cut = want_integral && !integral;
+		if (cut)
+			prev = sol;
 		if (!treat_coalescing)
-			break;
+			continue;
 		for (i = 0; i < graph->n; ++i) {
 			struct isl_sched_node *node = &graph->node[i];
 
@@ -4538,8 +4486,9 @@ static __isl_give isl_vec *non_neg_lexmin(struct isl_sched_graph *graph,
 		if (i < graph->n) {
 			prev = sol;
 			tl = zero_out_node_coef(tl, &graph->node[i], pos);
+			cut = 0;
 		}
-	} while (i < graph->n);
+	} while (prev);
 
 	isl_tab_lexmin_free(tl);
 
@@ -4551,8 +4500,539 @@ error:
 	return NULL;
 }
 
-/* Construct a schedule row for each node such that as many dependences
+/* If "edge" is an edge from a node to itself, then add the corresponding
+ * dependence relation to "umap".
+ * If "node" has been compressed, then the dependence relation
+ * is also compressed first.
+ */
+static __isl_give isl_union_map *add_intra(__isl_take isl_union_map *umap,
+	struct isl_sched_edge *edge)
+{
+	isl_map *map;
+	struct isl_sched_node *node = edge->src;
+
+	if (edge->src != edge->dst)
+		return umap;
+
+	map = isl_map_copy(edge->map);
+	if (node->compressed) {
+		map = isl_map_preimage_domain_multi_aff(map,
+				    isl_multi_aff_copy(node->decompress));
+		map = isl_map_preimage_range_multi_aff(map,
+				    isl_multi_aff_copy(node->decompress));
+	}
+	umap = isl_union_map_add_map(umap, map);
+	return umap;
+}
+
+/* If "edge" is an edge from a node to another node, then add the corresponding
+ * dependence relation to "umap".
+ * If the source or destination nodes of "edge" have been compressed,
+ * then the dependence relation is also compressed first.
+ */
+static __isl_give isl_union_map *add_inter(__isl_take isl_union_map *umap,
+	struct isl_sched_edge *edge)
+{
+	isl_map *map;
+
+	if (edge->src == edge->dst)
+		return umap;
+
+	map = isl_map_copy(edge->map);
+	if (edge->src->compressed)
+		map = isl_map_preimage_domain_multi_aff(map,
+				    isl_multi_aff_copy(edge->src->decompress));
+	if (edge->dst->compressed)
+		map = isl_map_preimage_range_multi_aff(map,
+				    isl_multi_aff_copy(edge->dst->decompress));
+	umap = isl_union_map_add_map(umap, map);
+	return umap;
+}
+
+/* Internal data structure used by union_drop_coalescing_constraints
+ * to collect bounds on all relevant statements.
+ *
+ * "graph" is the schedule constraint graph for which an LP problem
+ * is being constructed.
+ * "bounds" collects the bounds.
+ */
+struct isl_collect_bounds_data {
+	isl_ctx *ctx;
+	struct isl_sched_graph *graph;
+	isl_union_set *bounds;
+};
+
+/* Add the size bounds for the node with instance deltas in "set"
+ * to data->bounds.
+ */
+static isl_stat collect_bounds(__isl_take isl_set *set, void *user)
+{
+	struct isl_collect_bounds_data *data = user;
+	struct isl_sched_node *node;
+	isl_space *space;
+	isl_set *bounds;
+
+	space = isl_set_get_space(set);
+	isl_set_free(set);
+
+	node = graph_find_compressed_node(data->ctx, data->graph, space);
+	isl_space_free(space);
+
+	bounds = isl_set_from_basic_set(get_size_bounds(node));
+	data->bounds = isl_union_set_add_set(data->bounds, bounds);
+
+	return isl_stat_ok;
+}
+
+/* Drop some constraints from "delta" that could be exploited
+ * to construct loop coalescing schedules.
+ * In particular, drop those constraint that bound the difference
+ * to the size of the domain.
+ * Do this for each set/node in "delta" separately.
+ * The parameters are assumed to have been projected out by the caller.
+ */
+static __isl_give isl_union_set *union_drop_coalescing_constraints(isl_ctx *ctx,
+	struct isl_sched_graph *graph, __isl_take isl_union_set *delta)
+{
+	struct isl_collect_bounds_data data = { ctx, graph };
+
+	data.bounds = isl_union_set_empty(isl_space_params_alloc(ctx, 0));
+	if (isl_union_set_foreach_set(delta, &collect_bounds, &data) < 0)
+		data.bounds = isl_union_set_free(data.bounds);
+	delta = isl_union_set_plain_gist(delta, data.bounds);
+
+	return delta;
+}
+
+/* Given a non-trivial lineality space "lineality", add the corresponding
+ * universe set to data->mask and add a map from elements to
+ * other elements along the lines in "lineality" to data->equivalent.
+ * If this is the first time this function gets called
+ * (data->any_non_trivial is still false), then set data->any_non_trivial and
+ * initialize data->mask and data->equivalent.
+ *
+ * In particular, if the lineality space is defined by equality constraints
+ *
+ *	E x = 0
+ *
+ * then construct an affine mapping
+ *
+ *	f : x -> E x
+ *
+ * and compute the equivalence relation of having the same image under f:
+ *
+ *	{ x -> x' : E x = E x' }
+ */
+static isl_stat add_non_trivial_lineality(__isl_take isl_basic_set *lineality,
+	struct isl_exploit_lineality_data *data)
+{
+	isl_mat *eq;
+	isl_space *space;
+	isl_set *univ;
+	isl_multi_aff *ma;
+	isl_multi_pw_aff *mpa;
+	isl_map *map;
+	int n;
+
+	if (!lineality)
+		return isl_stat_error;
+	if (isl_basic_set_dim(lineality, isl_dim_div) != 0)
+		isl_die(isl_basic_set_get_ctx(lineality), isl_error_internal,
+			"local variables not allowed", goto error);
+
+	space = isl_basic_set_get_space(lineality);
+	if (!data->any_non_trivial) {
+		data->equivalent = isl_union_map_empty(isl_space_copy(space));
+		data->mask = isl_union_set_empty(isl_space_copy(space));
+	}
+	data->any_non_trivial = isl_bool_true;
+
+	univ = isl_set_universe(isl_space_copy(space));
+	data->mask = isl_union_set_add_set(data->mask, univ);
+
+	eq = isl_basic_set_extract_equalities(lineality);
+	n = isl_mat_rows(eq);
+	eq = isl_mat_insert_zero_rows(eq, 0, 1);
+	eq = isl_mat_set_element_si(eq, 0, 0, 1);
+	space = isl_space_from_domain(space);
+	space = isl_space_add_dims(space, isl_dim_out, n);
+	ma = isl_multi_aff_from_aff_mat(space, eq);
+	mpa = isl_multi_pw_aff_from_multi_aff(ma);
+	map = isl_multi_pw_aff_eq_map(mpa, isl_multi_pw_aff_copy(mpa));
+	data->equivalent = isl_union_map_add_map(data->equivalent, map);
+
+	isl_basic_set_free(lineality);
+	return isl_stat_ok;
+error:
+	isl_basic_set_free(lineality);
+	return isl_stat_error;
+}
+
+/* Check if the lineality space "set" is non-trivial (i.e., is not just
+ * the origin or, in other words, satisfies a number of equality constraints
+ * that is smaller than the dimension of the set).
+ * If so, extend data->mask and data->equivalent accordingly.
+ *
+ * The input should not have any local variables already, but
+ * isl_set_remove_divs is called to make sure it does not.
+ */
+static isl_stat add_lineality(__isl_take isl_set *set, void *user)
+{
+	struct isl_exploit_lineality_data *data = user;
+	isl_basic_set *hull;
+	int dim, n_eq;
+
+	set = isl_set_remove_divs(set);
+	hull = isl_set_unshifted_simple_hull(set);
+	dim = isl_basic_set_dim(hull, isl_dim_set);
+	n_eq = isl_basic_set_n_equality(hull);
+	if (!hull)
+		return isl_stat_error;
+	if (dim != n_eq)
+		return add_non_trivial_lineality(hull, data);
+	isl_basic_set_free(hull);
+	return isl_stat_ok;
+}
+
+/* Check if the difference set on intra-node schedule constraints "intra"
+ * has any non-trivial lineality space.
+ * If so, then extend the difference set to a difference set
+ * on equivalent elements.  That is, if "intra" is
+ *
+ *	{ y - x : (x,y) \in V }
+ *
+ * and elements are equivalent if they have the same image under f,
+ * then return
+ *
+ *	{ y' - x' : (x,y) \in V and f(x) = f(x') and f(y) = f(y') }
+ *
+ * or, since f is linear,
+ *
+ *	{ y' - x' : (x,y) \in V and f(y - x) = f(y' - x') }
+ *
+ * The results of the search for non-trivial lineality spaces is stored
+ * in "data".
+ */
+static __isl_give isl_union_set *exploit_intra_lineality(
+	__isl_take isl_union_set *intra,
+	struct isl_exploit_lineality_data *data)
+{
+	isl_union_set *lineality;
+	isl_union_set *uset;
+
+	data->any_non_trivial = isl_bool_false;
+	lineality = isl_union_set_copy(intra);
+	lineality = isl_union_set_combined_lineality_space(lineality);
+	if (isl_union_set_foreach_set(lineality, &add_lineality, data) < 0)
+		data->any_non_trivial = isl_bool_error;
+	isl_union_set_free(lineality);
+
+	if (data->any_non_trivial < 0)
+		return isl_union_set_free(intra);
+	if (!data->any_non_trivial)
+		return intra;
+
+	uset = isl_union_set_copy(intra);
+	intra = isl_union_set_subtract(intra, isl_union_set_copy(data->mask));
+	uset = isl_union_set_apply(uset, isl_union_map_copy(data->equivalent));
+	intra = isl_union_set_union(intra, uset);
+
+	intra = isl_union_set_remove_divs(intra);
+
+	return intra;
+}
+
+/* If the difference set on intra-node schedule constraints was found to have
+ * any non-trivial lineality space by exploit_intra_lineality,
+ * as recorded in "data", then extend the inter-node
+ * schedule constraints "inter" to schedule constraints on equivalent elements.
+ * That is, if "inter" is V and
+ * elements are equivalent if they have the same image under f, then return
+ *
+ *	{ (x', y') : (x,y) \in V and f(x) = f(x') and f(y) = f(y') }
+ */
+static __isl_give isl_union_map *exploit_inter_lineality(
+	__isl_take isl_union_map *inter,
+	struct isl_exploit_lineality_data *data)
+{
+	isl_union_map *umap;
+
+	if (data->any_non_trivial < 0)
+		return isl_union_map_free(inter);
+	if (!data->any_non_trivial)
+		return inter;
+
+	umap = isl_union_map_copy(inter);
+	inter = isl_union_map_subtract_range(inter,
+				isl_union_set_copy(data->mask));
+	umap = isl_union_map_apply_range(umap,
+				isl_union_map_copy(data->equivalent));
+	inter = isl_union_map_union(inter, umap);
+	umap = isl_union_map_copy(inter);
+	inter = isl_union_map_subtract_domain(inter,
+				isl_union_set_copy(data->mask));
+	umap = isl_union_map_apply_range(isl_union_map_copy(data->equivalent),
+				umap);
+	inter = isl_union_map_union(inter, umap);
+
+	inter = isl_union_map_remove_divs(inter);
+
+	return inter;
+}
+
+/* For each (conditional) validity edge in "graph",
+ * add the corresponding dependence relation using "add"
+ * to a collection of dependence relations and return the result.
+ * If "coincidence" is set, then coincidence edges are considered as well.
+ */
+static __isl_give isl_union_map *collect_validity(struct isl_sched_graph *graph,
+	__isl_give isl_union_map *(*add)(__isl_take isl_union_map *umap,
+		struct isl_sched_edge *edge), int coincidence)
+{
+	int i;
+	isl_space *space;
+	isl_union_map *umap;
+
+	space = isl_space_copy(graph->node[0].space);
+	umap = isl_union_map_empty(space);
+
+	for (i = 0; i < graph->n_edge; ++i) {
+		struct isl_sched_edge *edge = &graph->edge[i];
+
+		if (!is_any_validity(edge) &&
+		    (!coincidence || !is_coincidence(edge)))
+			continue;
+
+		umap = add(umap, edge);
+	}
+
+	return umap;
+}
+
+/* Project out all parameters from "uset" and return the result.
+ */
+static __isl_give isl_union_set *union_set_drop_parameters(
+	__isl_take isl_union_set *uset)
+{
+	unsigned nparam;
+
+	nparam = isl_union_set_dim(uset, isl_dim_param);
+	return isl_union_set_project_out(uset, isl_dim_param, 0, nparam);
+}
+
+/* For each dependence relation on a (conditional) validity edge
+ * from a node to itself,
+ * construct the set of coefficients of valid constraints for elements
+ * in that dependence relation and collect the results.
+ * If "coincidence" is set, then coincidence edges are considered as well.
+ *
+ * In particular, for each dependence relation R, constraints
+ * on coefficients (c_0, c_x) are constructed such that
+ *
+ *	c_0 + c_x d >= 0 for each d in delta R = { y - x | (x,y) in R }
+ *
+ * If the schedule_treat_coalescing option is set, then some constraints
+ * that could be exploited to construct coalescing schedules
+ * are removed before the dual is computed, but after the parameters
+ * have been projected out.
+ * The entire computation is essentially the same as that performed
+ * by intra_coefficients, except that it operates on multiple
+ * edges together and that the parameters are always projected out.
+ *
+ * Additionally, exploit any non-trivial lineality space
+ * in the difference set after removing coalescing constraints and
+ * store the results of the non-trivial lineality space detection in "data".
+ * The procedure is currently run unconditionally, but it is unlikely
+ * to find any non-trivial lineality spaces if no coalescing constraints
+ * have been removed.
+ *
+ * Note that if a dependence relation is a union of basic maps,
+ * then each basic map needs to be treated individually as it may only
+ * be possible to carry the dependences expressed by some of those
+ * basic maps and not all of them.
+ * The collected validity constraints are therefore not coalesced and
+ * it is assumed that they are not coalesced automatically.
+ * Duplicate basic maps can be removed, however.
+ * In particular, if the same basic map appears as a disjunct
+ * in multiple edges, then it only needs to be carried once.
+ */
+static __isl_give isl_basic_set_list *collect_intra_validity(isl_ctx *ctx,
+	struct isl_sched_graph *graph, int coincidence,
+	struct isl_exploit_lineality_data *data)
+{
+	isl_union_map *intra;
+	isl_union_set *delta;
+	isl_basic_set_list *list;
+
+	intra = collect_validity(graph, &add_intra, coincidence);
+	delta = isl_union_map_deltas(intra);
+	delta = union_set_drop_parameters(delta);
+	delta = isl_union_set_remove_divs(delta);
+	if (isl_options_get_schedule_treat_coalescing(ctx))
+		delta = union_drop_coalescing_constraints(ctx, graph, delta);
+	delta = exploit_intra_lineality(delta, data);
+	list = isl_union_set_get_basic_set_list(delta);
+	isl_union_set_free(delta);
+
+	return isl_basic_set_list_coefficients(list);
+}
+
+/* For each dependence relation on a (conditional) validity edge
+ * from a node to some other node,
+ * construct the set of coefficients of valid constraints for elements
+ * in that dependence relation and collect the results.
+ * If "coincidence" is set, then coincidence edges are considered as well.
+ *
+ * In particular, for each dependence relation R, constraints
+ * on coefficients (c_0, c_n, c_x, c_y) are constructed such that
+ *
+ *	c_0 + c_n n + c_x x + c_y y >= 0 for each (x,y) in R
+ *
+ * This computation is essentially the same as that performed
+ * by inter_coefficients, except that it operates on multiple
+ * edges together.
+ *
+ * Additionally, exploit any non-trivial lineality space
+ * that may have been discovered by collect_intra_validity
+ * (as stored in "data").
+ *
+ * Note that if a dependence relation is a union of basic maps,
+ * then each basic map needs to be treated individually as it may only
+ * be possible to carry the dependences expressed by some of those
+ * basic maps and not all of them.
+ * The collected validity constraints are therefore not coalesced and
+ * it is assumed that they are not coalesced automatically.
+ * Duplicate basic maps can be removed, however.
+ * In particular, if the same basic map appears as a disjunct
+ * in multiple edges, then it only needs to be carried once.
+ */
+static __isl_give isl_basic_set_list *collect_inter_validity(
+	struct isl_sched_graph *graph, int coincidence,
+	struct isl_exploit_lineality_data *data)
+{
+	isl_union_map *inter;
+	isl_union_set *wrap;
+	isl_basic_set_list *list;
+
+	inter = collect_validity(graph, &add_inter, coincidence);
+	inter = exploit_inter_lineality(inter, data);
+	inter = isl_union_map_remove_divs(inter);
+	wrap = isl_union_map_wrap(inter);
+	list = isl_union_set_get_basic_set_list(wrap);
+	isl_union_set_free(wrap);
+	return isl_basic_set_list_coefficients(list);
+}
+
+/* Construct an LP problem for finding schedule coefficients
+ * such that the schedule carries as many of the "n_edge" groups of
+ * dependences as possible based on the corresponding coefficient
+ * constraints and return the lexicographically smallest non-trivial solution.
+ * "intra" is the sequence of coefficient constraints for intra-node edges.
+ * "inter" is the sequence of coefficient constraints for inter-node edges.
+ * If "want_integral" is set, then compute an integral solution
+ * for the coefficients rather than using the numerators
+ * of a rational solution.
+ * "carry_inter" indicates whether inter-node edges should be carried or
+ * only respected.
+ *
+ * If none of the "n_edge" groups can be carried
+ * then return an empty vector.
+ */
+static __isl_give isl_vec *compute_carrying_sol_coef(isl_ctx *ctx,
+	struct isl_sched_graph *graph, int n_edge,
+	__isl_keep isl_basic_set_list *intra,
+	__isl_keep isl_basic_set_list *inter, int want_integral,
+	int carry_inter)
+{
+	isl_basic_set *lp;
+
+	if (setup_carry_lp(ctx, graph, n_edge, intra, inter, carry_inter) < 0)
+		return NULL;
+
+	lp = isl_basic_set_copy(graph->lp);
+	return non_neg_lexmin(graph, lp, n_edge, want_integral);
+}
+
+/* Construct an LP problem for finding schedule coefficients
+ * such that the schedule carries as many of the validity dependences
+ * as possible and
+ * return the lexicographically smallest non-trivial solution.
+ * If "fallback" is set, then the carrying is performed as a fallback
+ * for the Pluto-like scheduler.
+ * If "coincidence" is set, then try and carry coincidence edges as well.
+ *
+ * The variable "n_edge" stores the number of groups that should be carried.
+ * If none of the "n_edge" groups can be carried
+ * then return an empty vector.
+ * If, moreover, "n_edge" is zero, then the LP problem does not even
+ * need to be constructed.
+ *
+ * If a fallback solution is being computed, then compute an integral solution
+ * for the coefficients rather than using the numerators
+ * of a rational solution.
+ *
+ * If a fallback solution is being computed, if there are any intra-node
+ * dependences, and if requested by the user, then first try
+ * to only carry those intra-node dependences.
+ * If this fails to carry any dependences, then try again
+ * with the inter-node dependences included.
+ */
+static __isl_give isl_vec *compute_carrying_sol(isl_ctx *ctx,
+	struct isl_sched_graph *graph, int fallback, int coincidence)
+{
+	int n_intra, n_inter;
+	int n_edge;
+	struct isl_carry carry = { 0 };
+	isl_vec *sol;
+
+	carry.intra = collect_intra_validity(ctx, graph, coincidence,
+						&carry.lineality);
+	carry.inter = collect_inter_validity(graph, coincidence,
+						&carry.lineality);
+	if (!carry.intra || !carry.inter)
+		goto error;
+	n_intra = isl_basic_set_list_n_basic_set(carry.intra);
+	n_inter = isl_basic_set_list_n_basic_set(carry.inter);
+
+	if (fallback && n_intra > 0 &&
+	    isl_options_get_schedule_carry_self_first(ctx)) {
+		sol = compute_carrying_sol_coef(ctx, graph, n_intra,
+				carry.intra, carry.inter, fallback, 0);
+		if (!sol || sol->size != 0 || n_inter == 0) {
+			isl_carry_clear(&carry);
+			return sol;
+		}
+		isl_vec_free(sol);
+	}
+
+	n_edge = n_intra + n_inter;
+	if (n_edge == 0) {
+		isl_carry_clear(&carry);
+		return isl_vec_alloc(ctx, 0);
+	}
+
+	sol = compute_carrying_sol_coef(ctx, graph, n_edge,
+				carry.intra, carry.inter, fallback, 1);
+	isl_carry_clear(&carry);
+	return sol;
+error:
+	isl_carry_clear(&carry);
+	return NULL;
+}
+
+/* Construct a schedule row for each node such that as many validity dependences
  * as possible are carried and then continue with the next band.
+ * If "fallback" is set, then the carrying is performed as a fallback
+ * for the Pluto-like scheduler.
+ * If "coincidence" is set, then try and carry coincidence edges as well.
+ *
+ * If there are no validity dependences, then no dependence can be carried and
+ * the procedure is guaranteed to fail.  If there is more than one component,
+ * then try computing a schedule on each component separately
+ * to prevent or at least postpone this failure.
+ *
+ * If a schedule row is computed, then check that dependences are carried
+ * for at least one of the edges.
  *
  * If the computed schedule row turns out to be trivial on one or
  * more nodes where it should not be trivial, then we throw it away
@@ -4571,31 +5051,27 @@ error:
  * This insertion and the continued construction is performed by split_scaled
  * after optionally checking for non-trivial common divisors.
  */
-static __isl_give isl_schedule_node *carry_dependences(
-	__isl_take isl_schedule_node *node, struct isl_sched_graph *graph)
+static __isl_give isl_schedule_node *carry(__isl_take isl_schedule_node *node,
+	struct isl_sched_graph *graph, int fallback, int coincidence)
 {
-	int i;
-	int n_edge;
 	int trivial;
 	isl_ctx *ctx;
 	isl_vec *sol;
-	isl_basic_set *lp;
 
 	if (!node)
 		return NULL;
 
-	n_edge = 0;
-	for (i = 0; i < graph->n_edge; ++i)
-		n_edge += graph->edge[i].map->n;
-
 	ctx = isl_schedule_node_get_ctx(node);
-	if (setup_carry_lp(ctx, graph) < 0)
-		return isl_schedule_node_free(node);
-
-	lp = isl_basic_set_copy(graph->lp);
-	sol = non_neg_lexmin(graph, lp, n_edge);
+	sol = compute_carrying_sol(ctx, graph, fallback, coincidence);
 	if (!sol)
 		return isl_schedule_node_free(node);
+	if (sol->size == 0) {
+		isl_vec_free(sol);
+		if (graph->scc > 1)
+			return compute_component_schedule(node, graph, 1);
+		isl_die(ctx, isl_error_unknown, "unable to carry dependences",
+			return isl_schedule_node_free(node));
+	}
 
 	trivial = is_any_trivial(graph, sol);
 	if (trivial < 0) {
@@ -4605,7 +5081,7 @@ static __isl_give isl_schedule_node *carry_dependences(
 		return compute_component_schedule(node, graph, 1);
 	}
 
-	if (update_schedule(graph, sol, 0, 0) < 0)
+	if (update_schedule(graph, sol, 0) < 0)
 		return isl_schedule_node_free(node);
 	if (trivial)
 		graph->n_row--;
@@ -4613,6 +5089,50 @@ static __isl_give isl_schedule_node *carry_dependences(
 	return split_scaled(node, graph);
 }
 
+/* Construct a schedule row for each node such that as many validity dependences
+ * as possible are carried and then continue with the next band.
+ * Do so as a fallback for the Pluto-like scheduler.
+ * If "coincidence" is set, then try and carry coincidence edges as well.
+ */
+static __isl_give isl_schedule_node *carry_fallback(
+	__isl_take isl_schedule_node *node, struct isl_sched_graph *graph,
+	int coincidence)
+{
+	return carry(node, graph, 1, coincidence);
+}
+
+/* Construct a schedule row for each node such that as many validity dependences
+ * as possible are carried and then continue with the next band.
+ * Do so for the case where the Feautrier scheduler was selected
+ * by the user.
+ */
+static __isl_give isl_schedule_node *carry_feautrier(
+	__isl_take isl_schedule_node *node, struct isl_sched_graph *graph)
+{
+	return carry(node, graph, 0, 0);
+}
+
+/* Construct a schedule row for each node such that as many validity dependences
+ * as possible are carried and then continue with the next band.
+ * Do so as a fallback for the Pluto-like scheduler.
+ */
+static __isl_give isl_schedule_node *carry_dependences(
+	__isl_take isl_schedule_node *node, struct isl_sched_graph *graph)
+{
+	return carry_fallback(node, graph, 0);
+}
+
+/* Construct a schedule row for each node such that as many validity or
+ * coincidence dependences as possible are carried and
+ * then continue with the next band.
+ * Do so as a fallback for the Pluto-like scheduler.
+ */
+static __isl_give isl_schedule_node *carry_coincidence(
+	__isl_take isl_schedule_node *node, struct isl_sched_graph *graph)
+{
+	return carry_fallback(node, graph, 1);
+}
+
 /* Topologically sort statements mapped to the same schedule iteration
  * and add insert a sequence node in front of "node"
  * corresponding to this order.
@@ -4713,7 +5233,7 @@ static int need_feautrier_step(isl_ctx *ctx, struct isl_sched_graph *graph)
 static __isl_give isl_schedule_node *compute_schedule_wcc_feautrier(
 	isl_schedule_node *node, struct isl_sched_graph *graph)
 {
-	return carry_dependences(node, graph);
+	return carry_feautrier(node, graph);
 }
 
 /* Turn off the "local" bit on all (condition) edges.
@@ -4763,14 +5283,12 @@ static int has_any_coincidence(struct isl_sched_graph *graph)
  */
 static __isl_give isl_map *final_row(struct isl_sched_node *node)
 {
-	isl_local_space *ls;
-	isl_aff *aff;
+	isl_multi_aff *ma;
 	int row;
 
 	row = isl_mat_rows(node->sched) - 1;
-	ls = isl_local_space_from_space(isl_space_copy(node->space));
-	aff = extract_schedule_row(ls, node, row);
-	return isl_map_from_aff(aff);
+	ma = node_extract_partial_schedule_multi_aff(node, row, 1);
+	return isl_map_from_multi_aff(ma);
 }
 
 /* Is the conditional validity dependence in the edge with index "edge_index"
@@ -4924,8 +5442,12 @@ error:
  *	pair of SCCs between which to split)
  * - continue with the next band (assuming the current band has at least
  *	one row)
- * - try to carry as many dependences as possible and continue with the next
- *	band
+ * - if there is more than one SCC left, then split along all SCCs
+ * - if outer coincidence needs to be enforced, then try to carry as many
+ *	validity or coincidence dependences as possible and
+ *	continue with the next band
+ * - try to carry as many validity dependences as possible and
+ *	continue with the next band
  * In each case, we first insert a band node in the schedule tree
  * if any rows have been computed.
  *
@@ -4953,8 +5475,12 @@ static __isl_give isl_schedule_node *compute_schedule_finish_band(
 			return compute_split_schedule(node, graph);
 		if (!empty)
 			return compute_next_band(node, graph, 1);
+		if (graph->scc > 1)
+			return compute_component_schedule(node, graph, 1);
 		if (!initialized && compute_maxvar(graph) < 0)
 			return isl_schedule_node_free(node);
+		if (isl_options_get_schedule_outer_coincidence(ctx))
+			return carry_coincidence(node, graph);
 		return carry_dependences(node, graph);
 	}
 
@@ -5031,7 +5557,7 @@ static isl_stat compute_schedule_wcc_band(isl_ctx *ctx,
 
 		if (setup_lp(ctx, graph, use_coincidence) < 0)
 			return isl_stat_error;
-		sol = solve_lp(graph);
+		sol = solve_lp(ctx, graph);
 		if (!sol)
 			return isl_stat_error;
 		if (sol->size == 0) {
@@ -5045,7 +5571,7 @@ static isl_stat compute_schedule_wcc_band(isl_ctx *ctx,
 			return isl_stat_ok;
 		}
 		coincident = !has_coincidence || use_coincidence;
-		if (update_schedule(graph, sol, 1, coincident) < 0)
+		if (update_schedule(graph, sol, coincident) < 0)
 			return isl_stat_error;
 
 		if (!check_conditional)
@@ -5183,6 +5709,15 @@ static int bad_cluster(struct isl_sched_graph *graph)
 		graph->n_total_row == graph->band_start;
 }
 
+/* Is "edge" a proximity edge with a non-empty dependence relation?
+ */
+static isl_bool is_non_empty_proximity(struct isl_sched_edge *edge)
+{
+	if (!is_proximity(edge))
+		return isl_bool_false;
+	return isl_bool_not(isl_map_plain_is_empty(edge->map));
+}
+
 /* Return the index of an edge in "graph" that can be used to merge
  * two clusters in "c".
  * Return graph->n_edge if no such edge can be found.
@@ -5206,8 +5741,12 @@ static int find_proximity(struct isl_sched_graph *graph,
 	for (i = 0; i < graph->n_edge; ++i) {
 		struct isl_sched_edge *edge = &graph->edge[i];
 		int dist, weight;
+		isl_bool prox;
 
-		if (!is_proximity(edge))
+		prox = is_non_empty_proximity(edge);
+		if (prox < 0)
+			return -1;
+		if (!prox)
 			continue;
 		if (edge->no_merge)
 			continue;
@@ -5456,10 +5995,8 @@ static __isl_give isl_schedule_constraints *add_non_conditional_constraints(
 			continue;
 		if (!is_type(edge, t))
 			continue;
-		sc->constraint[t] = isl_union_map_union(sc->constraint[t],
+		sc = isl_schedule_constraints_add(sc, t,
 						    isl_union_map_copy(umap));
-		if (!sc->constraint[t])
-			return isl_schedule_constraints_free(sc);
 	}
 
 	return sc;
@@ -5488,10 +6025,9 @@ static __isl_give isl_schedule_constraints *add_conditional_constraints(
 		tagged = isl_union_map_apply_domain(tagged,
 					isl_union_map_copy(umap));
 		tagged = isl_union_map_zip(tagged);
-		sc->constraint[t] = isl_union_map_union(sc->constraint[t],
-						    tagged);
-		if (!sc->constraint[t])
-			return isl_schedule_constraints_free(sc);
+		sc = isl_schedule_constraints_add(sc, t, tagged);
+		if (!sc)
+			return NULL;
 	}
 
 	return sc;
@@ -5637,7 +6173,7 @@ static int compute_maxvar_max_slack(int maxvar, struct isl_clustering *c)
 			struct isl_sched_node *node = &scc->node[j];
 			int slack;
 
-			if (node_update_cmap(node) < 0)
+			if (node_update_vmap(node) < 0)
 				return -1;
 			slack = node->nvar - node->rank;
 			if (slack > max_slack)
@@ -5677,7 +6213,7 @@ static int limit_maxvar_to_slack(int maxvar, int max_slack,
 			struct isl_sched_node *node = &scc->node[j];
 			int slack;
 
-			if (node_update_cmap(node) < 0)
+			if (node_update_vmap(node) < 0)
 				return -1;
 			slack = node->nvar - node->rank;
 			if (slack > max_slack) {
@@ -6452,9 +6988,13 @@ static isl_stat compute_weights(struct isl_sched_graph *graph,
 		struct isl_sched_node *src = edge->src;
 		struct isl_sched_node *dst = edge->dst;
 		isl_basic_map *hull;
+		isl_bool prox;
 		int n_in, n_out;
 
-		if (!is_proximity(edge))
+		prox = is_non_empty_proximity(edge);
+		if (prox < 0)
+			return isl_stat_error;
+		if (!prox)
 			continue;
 		if (bad_cluster(&c->scc[edge->src->scc]) ||
 		    bad_cluster(&c->scc[edge->dst->scc]))
@@ -6465,9 +7005,9 @@ static isl_stat compute_weights(struct isl_sched_graph *graph,
 
 		hull = isl_map_affine_hull(isl_map_copy(edge->map));
 		hull = isl_basic_map_transform_dims(hull, isl_dim_in, 0,
-						    isl_mat_copy(src->ctrans));
+						    isl_mat_copy(src->vmap));
 		hull = isl_basic_map_transform_dims(hull, isl_dim_out, 0,
-						    isl_mat_copy(dst->ctrans));
+						    isl_mat_copy(dst->vmap));
 		hull = isl_basic_map_project_out(hull,
 						isl_dim_in, 0, src->rank);
 		hull = isl_basic_map_project_out(hull,
@@ -6481,7 +7021,7 @@ static isl_stat compute_weights(struct isl_sched_graph *graph,
 							isl_dim_out, 0, n_out);
 		if (!hull)
 			return isl_stat_error;
-		edge->weight = hull->n_eq;
+		edge->weight = isl_basic_map_n_equality(hull);
 		isl_basic_map_free(hull);
 
 		if (edge->weight > graph->max_weight)
diff --git a/lib/Analysis/isl/isl_seq.c b/lib/Analysis/isl/isl_seq.c
index 2159464..8e6c84c 100644
--- a/lib/Analysis/isl/isl_seq.c
+++ b/lib/Analysis/isl/isl_seq.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2008-2009 Katholieke Universiteit Leuven
+ * Copyright 2011      INRIA Saclay
  *
  * Use of this software is governed by the MIT license
  *
@@ -301,6 +302,36 @@ uint32_t isl_seq_hash(isl_int *p, unsigned len, uint32_t hash)
 	return hash;
 }
 
+/* Given two affine expressions "p" of length p_len (including the
+ * denominator and the constant term) and "subs" of length subs_len,
+ * plug in "subs" for the variable at position "pos".
+ * The variables of "subs" and "p" are assumed to match up to subs_len,
+ * but "p" may have additional variables.
+ * "v" is an initialized isl_int that can be used internally.
+ *
+ * In particular, if "p" represents the expression
+ *
+ *	(a i + g)/m
+ *
+ * with i the variable at position "pos" and "subs" represents the expression
+ *
+ *	f/d
+ *
+ * then the result represents the expression
+ *
+ *	(a f + d g)/(m d)
+ *
+ */
+void isl_seq_substitute(isl_int *p, int pos, isl_int *subs,
+	int p_len, int subs_len, isl_int v)
+{
+	isl_int_set(v, p[1 + pos]);
+	isl_int_set_si(p[1 + pos], 0);
+	isl_seq_combine(p + 1, subs[0], p + 1, v, subs + 1, subs_len - 1);
+	isl_seq_scale(p + subs_len, p + subs_len, subs[0], p_len - subs_len);
+	isl_int_mul(p[0], p[0], subs[0]);
+}
+
 uint32_t isl_seq_get_hash(isl_int *p, unsigned len)
 {
 	uint32_t hash = isl_hash_init();
diff --git a/lib/Analysis/isl/isl_seq.h b/lib/Analysis/isl/isl_seq.h
index 05825f2..de0d2e6 100644
--- a/lib/Analysis/isl/isl_seq.h
+++ b/lib/Analysis/isl/isl_seq.h
@@ -50,6 +50,9 @@ int isl_seq_eq(isl_int *p1, isl_int *p2, unsigned len);
 int isl_seq_cmp(isl_int *p1, isl_int *p2, unsigned len);
 int isl_seq_is_neg(isl_int *p1, isl_int *p2, unsigned len);
 
+void isl_seq_substitute(isl_int *p, int pos, isl_int *subs,
+	int p_len, int subs_len, isl_int v);
+
 uint32_t isl_seq_get_hash(isl_int *p, unsigned len);
 uint32_t isl_seq_get_hash_bits(isl_int *p, unsigned len, unsigned bits);
 
diff --git a/lib/Analysis/isl/isl_space.c b/lib/Analysis/isl/isl_space.c
index 2e1b1e1..0ddacc2 100644
--- a/lib/Analysis/isl/isl_space.c
+++ b/lib/Analysis/isl/isl_space.c
@@ -590,7 +590,7 @@ isl_bool isl_space_has_tuple_name(__isl_keep isl_space *space,
 	return id && id->name;
 }
 
-const char *isl_space_get_tuple_name(__isl_keep isl_space *dim,
+__isl_keep const char *isl_space_get_tuple_name(__isl_keep isl_space *dim,
 	 enum isl_dim_type type)
 {
 	isl_id *id;
@@ -672,10 +672,11 @@ int isl_space_find_dim_by_name(__isl_keep isl_space *space,
 
 	offset = isl_space_offset(space, type);
 	n = isl_space_dim(space, type);
-	for (i = 0; i < n && offset + i < space->n_id; ++i)
-		if (space->ids[offset + i]->name &&
-		    !strcmp(space->ids[offset + i]->name, name))
+	for (i = 0; i < n && offset + i < space->n_id; ++i) {
+		isl_id *id = get_id(space, type, i);
+		if (id && id->name && !strcmp(id->name, name))
 			return i;
+	}
 
 	return -1;
 }
@@ -765,13 +766,13 @@ static __isl_keep isl_space *nested(__isl_keep isl_space *dim,
 
 /* Are the two spaces the same, apart from positions and names of parameters?
  */
-static int isl_space_has_equal_tuples(__isl_keep isl_space *space1,
+isl_bool isl_space_has_equal_tuples(__isl_keep isl_space *space1,
 	__isl_keep isl_space *space2)
 {
 	if (!space1 || !space2)
-		return -1;
+		return isl_bool_error;
 	if (space1 == space2)
-		return 1;
+		return isl_bool_true;
 	return isl_space_tuple_is_equal(space1, isl_dim_in,
 					space2, isl_dim_in) &&
 	       isl_space_tuple_is_equal(space1, isl_dim_out,
@@ -829,34 +830,62 @@ int isl_space_tuple_match(__isl_keep isl_space *space1, enum isl_dim_type type1,
 	return isl_space_tuple_is_equal(space1, type1, space2, type2);
 }
 
-static int match(__isl_keep isl_space *dim1, enum isl_dim_type dim1_type,
-	__isl_keep isl_space *dim2, enum isl_dim_type dim2_type)
+static isl_bool match(__isl_keep isl_space *space1, enum isl_dim_type type1,
+	__isl_keep isl_space *space2, enum isl_dim_type type2)
 {
 	int i;
 
-	if (dim1 == dim2 && dim1_type == dim2_type)
-		return 1;
+	if (space1 == space2 && type1 == type2)
+		return isl_bool_true;
 
-	if (!isl_space_tuple_is_equal(dim1, dim1_type, dim2, dim2_type))
-		return 0;
+	if (!isl_space_tuple_is_equal(space1, type1, space2, type2))
+		return isl_bool_false;
 
-	if (!dim1->ids && !dim2->ids)
-		return 1;
+	if (!space1->ids && !space2->ids)
+		return isl_bool_true;
 
-	for (i = 0; i < n(dim1, dim1_type); ++i) {
-		if (get_id(dim1, dim1_type, i) != get_id(dim2, dim2_type, i))
-			return 0;
+	for (i = 0; i < n(space1, type1); ++i) {
+		if (get_id(space1, type1, i) != get_id(space2, type2, i))
+			return isl_bool_false;
 	}
-	return 1;
+	return isl_bool_true;
 }
 
-int isl_space_match(__isl_keep isl_space *dim1, enum isl_dim_type dim1_type,
-	__isl_keep isl_space *dim2, enum isl_dim_type dim2_type)
+/* Do "space1" and "space2" have the same parameters?
+ */
+isl_bool isl_space_has_equal_params(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2)
 {
-	if (!dim1 || !dim2)
-		return -1;
+	if (!space1 || !space2)
+		return isl_bool_error;
+
+	return match(space1, isl_dim_param, space2, isl_dim_param);
+}
+
+/* Do "space1" and "space2" have the same identifiers for all
+ * the tuple variables?
+ */
+isl_bool isl_space_has_equal_ids(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2)
+{
+	isl_bool equal;
+
+	if (!space1 || !space2)
+		return isl_bool_error;
+
+	equal = match(space1, isl_dim_in, space2, isl_dim_in);
+	if (equal < 0 || !equal)
+		return equal;
+	return match(space1, isl_dim_out, space2, isl_dim_out);
+}
+
+isl_bool isl_space_match(__isl_keep isl_space *space1, enum isl_dim_type type1,
+	__isl_keep isl_space *space2, enum isl_dim_type type2)
+{
+	if (!space1 || !space2)
+		return isl_bool_error;
 
-	return match(dim1, dim1_type, dim2, dim2_type);
+	return match(space1, type1, space2, type2);
 }
 
 static void get_ids(__isl_keep isl_space *dim, enum isl_dim_type type,
@@ -868,7 +897,7 @@ static void get_ids(__isl_keep isl_space *dim, enum isl_dim_type type,
 		ids[i] = get_id(dim, type, first + i);
 }
 
-__isl_give isl_space *isl_space_extend(__isl_take isl_space *space,
+static __isl_give isl_space *space_extend(__isl_take isl_space *space,
 			unsigned nparam, unsigned n_in, unsigned n_out)
 {
 	isl_id **ids = NULL;
@@ -916,37 +945,43 @@ error:
 	return NULL;
 }
 
-__isl_give isl_space *isl_space_add_dims(__isl_take isl_space *dim,
+__isl_give isl_space *isl_space_extend(__isl_take isl_space *space,
+	unsigned nparam, unsigned n_in, unsigned n_out)
+{
+	return space_extend(space, nparam, n_in, n_out);
+}
+
+__isl_give isl_space *isl_space_add_dims(__isl_take isl_space *space,
 	enum isl_dim_type type, unsigned n)
 {
-	dim = isl_space_reset(dim, type);
-	if (!dim)
+	space = isl_space_reset(space, type);
+	if (!space)
 		return NULL;
 	switch (type) {
 	case isl_dim_param:
-		dim = isl_space_extend(dim,
-					dim->nparam + n, dim->n_in, dim->n_out);
-		if (dim && dim->nested[0] &&
-		    !(dim->nested[0] = isl_space_add_dims(dim->nested[0],
+		space = space_extend(space,
+				space->nparam + n, space->n_in, space->n_out);
+		if (space && space->nested[0] &&
+		    !(space->nested[0] = isl_space_add_dims(space->nested[0],
 						    isl_dim_param, n)))
 			goto error;
-		if (dim && dim->nested[1] &&
-		    !(dim->nested[1] = isl_space_add_dims(dim->nested[1],
+		if (space && space->nested[1] &&
+		    !(space->nested[1] = isl_space_add_dims(space->nested[1],
 						    isl_dim_param, n)))
 			goto error;
-		return dim;
+		return space;
 	case isl_dim_in:
-		return isl_space_extend(dim,
-					dim->nparam, dim->n_in + n, dim->n_out);
+		return space_extend(space,
+				space->nparam, space->n_in + n, space->n_out);
 	case isl_dim_out:
-		return isl_space_extend(dim,
-					dim->nparam, dim->n_in, dim->n_out + n);
+		return space_extend(space,
+				space->nparam, space->n_in, space->n_out + n);
 	default:
-		isl_die(dim->ctx, isl_error_invalid,
+		isl_die(space->ctx, isl_error_invalid,
 			"cannot add dimensions of specified type", goto error);
 	}
 error:
-	isl_space_free(dim);
+	isl_space_free(space);
 	return NULL;
 }
 
@@ -1039,114 +1074,126 @@ error:
 	return NULL;
 }
 
-__isl_give isl_space *isl_space_move_dims(__isl_take isl_space *dim,
+__isl_give isl_space *isl_space_move_dims(__isl_take isl_space *space,
 	enum isl_dim_type dst_type, unsigned dst_pos,
 	enum isl_dim_type src_type, unsigned src_pos, unsigned n)
 {
 	int i;
 
-	if (!dim)
+	space = isl_space_reset(space, src_type);
+	space = isl_space_reset(space, dst_type);
+	if (!space)
 		return NULL;
-	if (n == 0) {
-		dim = isl_space_reset(dim, src_type);
-		return isl_space_reset(dim, dst_type);
-	}
+	if (n == 0)
+		return space;
 
-	isl_assert(dim->ctx, src_pos + n <= isl_space_dim(dim, src_type),
+	isl_assert(space->ctx, src_pos + n <= isl_space_dim(space, src_type),
 		goto error);
 
 	if (dst_type == src_type && dst_pos == src_pos)
-		return dim;
-
-	isl_assert(dim->ctx, dst_type != src_type, goto error);
+		return space;
 
-	dim = isl_space_reset(dim, src_type);
-	dim = isl_space_reset(dim, dst_type);
+	isl_assert(space->ctx, dst_type != src_type, goto error);
 
-	dim = isl_space_cow(dim);
-	if (!dim)
+	space = isl_space_cow(space);
+	if (!space)
 		return NULL;
 
-	if (dim->ids) {
+	if (space->ids) {
 		isl_id **ids;
 		enum isl_dim_type t, o = isl_dim_param;
 		int off;
 		int s[3];
-		ids = isl_calloc_array(dim->ctx, isl_id *,
-					 dim->nparam + dim->n_in + dim->n_out);
+		ids = isl_calloc_array(space->ctx, isl_id *,
+				 space->nparam + space->n_in + space->n_out);
 		if (!ids)
 			goto error;
 		off = 0;
-		s[isl_dim_param - o] = dim->nparam;
-		s[isl_dim_in - o] = dim->n_in;
-		s[isl_dim_out - o] = dim->n_out;
+		s[isl_dim_param - o] = space->nparam;
+		s[isl_dim_in - o] = space->n_in;
+		s[isl_dim_out - o] = space->n_out;
 		for (t = isl_dim_param; t <= isl_dim_out; ++t) {
 			if (t == dst_type) {
-				get_ids(dim, t, 0, dst_pos, ids + off);
+				get_ids(space, t, 0, dst_pos, ids + off);
 				off += dst_pos;
-				get_ids(dim, src_type, src_pos, n, ids + off);
+				get_ids(space, src_type, src_pos, n, ids + off);
 				off += n;
-				get_ids(dim, t, dst_pos, s[t - o] - dst_pos,
+				get_ids(space, t, dst_pos, s[t - o] - dst_pos,
 						ids + off);
 				off += s[t - o] - dst_pos;
 			} else if (t == src_type) {
-				get_ids(dim, t, 0, src_pos, ids + off);
+				get_ids(space, t, 0, src_pos, ids + off);
 				off += src_pos;
-				get_ids(dim, t, src_pos + n,
+				get_ids(space, t, src_pos + n,
 					    s[t - o] - src_pos - n, ids + off);
 				off += s[t - o] - src_pos - n;
 			} else {
-				get_ids(dim, t, 0, s[t - o], ids + off);
+				get_ids(space, t, 0, s[t - o], ids + off);
 				off += s[t - o];
 			}
 		}
-		free(dim->ids);
-		dim->ids = ids;
-		dim->n_id = dim->nparam + dim->n_in + dim->n_out;
+		free(space->ids);
+		space->ids = ids;
+		space->n_id = space->nparam + space->n_in + space->n_out;
 	}
 
 	switch (dst_type) {
-	case isl_dim_param:	dim->nparam += n; break;
-	case isl_dim_in:	dim->n_in += n; break;
-	case isl_dim_out:	dim->n_out += n; break;
+	case isl_dim_param:	space->nparam += n; break;
+	case isl_dim_in:	space->n_in += n; break;
+	case isl_dim_out:	space->n_out += n; break;
 	default:		;
 	}
 
 	switch (src_type) {
-	case isl_dim_param:	dim->nparam -= n; break;
-	case isl_dim_in:	dim->n_in -= n; break;
-	case isl_dim_out:	dim->n_out -= n; break;
+	case isl_dim_param:	space->nparam -= n; break;
+	case isl_dim_in:	space->n_in -= n; break;
+	case isl_dim_out:	space->n_out -= n; break;
 	default:		;
 	}
 
 	if (dst_type != isl_dim_param && src_type != isl_dim_param)
-		return dim;
+		return space;
 
 	for (i = 0; i < 2; ++i) {
-		if (!dim->nested[i])
+		if (!space->nested[i])
 			continue;
-		dim->nested[i] = isl_space_replace(dim->nested[i],
-						 isl_dim_param, dim);
-		if (!dim->nested[i])
+		space->nested[i] = isl_space_replace(space->nested[i],
+						 isl_dim_param, space);
+		if (!space->nested[i])
 			goto error;
 	}
 
-	return dim;
+	return space;
 error:
-	isl_space_free(dim);
+	isl_space_free(space);
 	return NULL;
 }
 
+/* Check that "space1" and "space2" have the same parameters,
+ * reporting an error if they do not.
+ */
+isl_stat isl_space_check_equal_params(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2)
+{
+	isl_bool equal;
+
+	equal = isl_space_has_equal_params(space1, space2);
+	if (equal < 0)
+		return isl_stat_error;
+	if (!equal)
+		isl_die(isl_space_get_ctx(space1), isl_error_invalid,
+			"parameters need to match", return isl_stat_error);
+	return isl_stat_ok;
+}
+
 __isl_give isl_space *isl_space_join(__isl_take isl_space *left,
 	__isl_take isl_space *right)
 {
 	isl_space *dim;
 
-	if (!left || !right)
+	if (isl_space_check_equal_params(left, right) < 0)
 		goto error;
 
-	isl_assert(left->ctx, match(left, isl_dim_param, right, isl_dim_param),
-			goto error);
 	isl_assert(left->ctx,
 		isl_space_tuple_is_equal(left, isl_dim_out, right, isl_dim_in),
 		goto error);
@@ -1203,8 +1250,8 @@ __isl_give isl_space *isl_space_product(__isl_take isl_space *left,
 	if (is_set)
 		return isl_space_range_product(left, right);
 
-	isl_assert(left->ctx, match(left, isl_dim_param, right, isl_dim_param),
-			goto error);
+	if (isl_space_check_equal_params(left, right) < 0)
+		goto error;
 
 	dom1 = isl_space_domain(isl_space_copy(left));
 	dom2 = isl_space_domain(isl_space_copy(right));
@@ -1229,12 +1276,9 @@ __isl_give isl_space *isl_space_domain_product(__isl_take isl_space *left,
 {
 	isl_space *ran, *dom1, *dom2, *nest;
 
-	if (!left || !right)
+	if (isl_space_check_equal_params(left, right) < 0)
 		goto error;
 
-	if (!match(left, isl_dim_param, right, isl_dim_param))
-		isl_die(left->ctx, isl_error_invalid,
-			"parameters need to match", goto error);
 	if (!isl_space_tuple_is_equal(left, isl_dim_out, right, isl_dim_out))
 		isl_die(left->ctx, isl_error_invalid,
 			"ranges need to match", goto error);
@@ -1257,11 +1301,9 @@ __isl_give isl_space *isl_space_range_product(__isl_take isl_space *left,
 {
 	isl_space *dom, *ran1, *ran2, *nest;
 
-	if (!left || !right)
+	if (isl_space_check_equal_params(left, right) < 0)
 		goto error;
 
-	isl_assert(left->ctx, match(left, isl_dim_param, right, isl_dim_param),
-			goto error);
 	if (!isl_space_tuple_is_equal(left, isl_dim_in, right, isl_dim_in))
 		isl_die(left->ctx, isl_error_invalid,
 			"domains need to match", goto error);
@@ -1482,41 +1524,43 @@ __isl_give isl_space *isl_space_factor_range(__isl_take isl_space *space)
 	return space;
 }
 
-__isl_give isl_space *isl_space_map_from_set(__isl_take isl_space *dim)
+__isl_give isl_space *isl_space_map_from_set(__isl_take isl_space *space)
 {
 	isl_ctx *ctx;
 	isl_id **ids = NULL;
+	int n_id;
 
-	if (!dim)
+	if (!space)
 		return NULL;
-	ctx = isl_space_get_ctx(dim);
-	if (!isl_space_is_set(dim))
+	ctx = isl_space_get_ctx(space);
+	if (!isl_space_is_set(space))
 		isl_die(ctx, isl_error_invalid, "not a set space", goto error);
-	dim = isl_space_cow(dim);
-	if (!dim)
+	space = isl_space_cow(space);
+	if (!space)
 		return NULL;
-	if (dim->ids) {
-		ids = isl_calloc_array(dim->ctx, isl_id *,
-					dim->nparam + dim->n_out + dim->n_out);
+	n_id = space->nparam + space->n_out + space->n_out;
+	if (n_id > 0 && space->ids) {
+		ids = isl_calloc_array(space->ctx, isl_id *, n_id);
 		if (!ids)
 			goto error;
-		get_ids(dim, isl_dim_param, 0, dim->nparam, ids);
-		get_ids(dim, isl_dim_out, 0, dim->n_out, ids + dim->nparam);
+		get_ids(space, isl_dim_param, 0, space->nparam, ids);
+		get_ids(space, isl_dim_out, 0, space->n_out,
+			ids + space->nparam);
 	}
-	dim->n_in = dim->n_out;
+	space->n_in = space->n_out;
 	if (ids) {
-		free(dim->ids);
-		dim->ids = ids;
-		dim->n_id = dim->nparam + dim->n_out + dim->n_out;
-		dim = copy_ids(dim, isl_dim_out, 0, dim, isl_dim_in);
+		free(space->ids);
+		space->ids = ids;
+		space->n_id = n_id;
+		space = copy_ids(space, isl_dim_out, 0, space, isl_dim_in);
 	}
-	isl_id_free(dim->tuple_id[0]);
-	dim->tuple_id[0] = isl_id_copy(dim->tuple_id[1]);
-	isl_space_free(dim->nested[0]);
-	dim->nested[0] = isl_space_copy(dim->nested[1]);
-	return dim;
+	isl_id_free(space->tuple_id[0]);
+	space->tuple_id[0] = isl_id_copy(space->tuple_id[1]);
+	isl_space_free(space->nested[0]);
+	space->nested[0] = isl_space_copy(space->nested[1]);
+	return space;
 error:
-	isl_space_free(dim);
+	isl_space_free(space);
 	return NULL;
 }
 
@@ -1680,14 +1724,14 @@ __isl_give isl_space *isl_space_drop_outputs(__isl_take isl_space *dim,
 	return isl_space_drop_dims(dim, isl_dim_out, first, n);
 }
 
-__isl_give isl_space *isl_space_domain(__isl_take isl_space *dim)
+__isl_give isl_space *isl_space_domain(__isl_take isl_space *space)
 {
-	if (!dim)
+	if (!space)
 		return NULL;
-	dim = isl_space_drop_outputs(dim, 0, dim->n_out);
-	dim = isl_space_reverse(dim);
-	dim = mark_as_set(dim);
-	return dim;
+	space = isl_space_drop_dims(space, isl_dim_out, 0, space->n_out);
+	space = isl_space_reverse(space);
+	space = mark_as_set(space);
+	return space;
 }
 
 __isl_give isl_space *isl_space_from_domain(__isl_take isl_space *dim)
@@ -1705,13 +1749,13 @@ error:
 	return NULL;
 }
 
-__isl_give isl_space *isl_space_range(__isl_take isl_space *dim)
+__isl_give isl_space *isl_space_range(__isl_take isl_space *space)
 {
-	if (!dim)
+	if (!space)
 		return NULL;
-	dim = isl_space_drop_inputs(dim, 0, dim->n_in);
-	dim = mark_as_set(dim);
-	return dim;
+	space = isl_space_drop_dims(space, isl_dim_in, 0, space->n_in);
+	space = mark_as_set(space);
+	return space;
 }
 
 __isl_give isl_space *isl_space_from_range(__isl_take isl_space *dim)
@@ -1778,20 +1822,6 @@ error:
 	return NULL;
 }
 
-__isl_give isl_space *isl_space_as_set_space(__isl_take isl_space *dim)
-{
-	dim = isl_space_cow(dim);
-	if (!dim)
-		return NULL;
-
-	dim->n_out += dim->n_in;
-	dim->n_in = 0;
-	dim = isl_space_reset(dim, isl_dim_in);
-	dim = isl_space_reset(dim, isl_dim_out);
-
-	return dim;
-}
-
 __isl_give isl_space *isl_space_underlying(__isl_take isl_space *dim,
 	unsigned n_div)
 {
@@ -1820,16 +1850,19 @@ __isl_give isl_space *isl_space_underlying(__isl_take isl_space *dim,
 
 /* Are the two spaces the same, including positions and names of parameters?
  */
-isl_bool isl_space_is_equal(__isl_keep isl_space *dim1,
-	__isl_keep isl_space *dim2)
+isl_bool isl_space_is_equal(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2)
 {
-	if (!dim1 || !dim2)
+	isl_bool equal;
+
+	if (!space1 || !space2)
 		return isl_bool_error;
-	if (dim1 == dim2)
+	if (space1 == space2)
 		return isl_bool_true;
-	return match(dim1, isl_dim_param, dim2, isl_dim_param) &&
-	       isl_space_tuple_is_equal(dim1, isl_dim_in, dim2, isl_dim_in) &&
-	       isl_space_tuple_is_equal(dim1, isl_dim_out, dim2, isl_dim_out);
+	equal = isl_space_has_equal_params(space1, space2);
+	if (equal < 0 || !equal)
+		return equal;
+	return isl_space_has_equal_tuples(space1, space2);
 }
 
 /* Is space1 equal to the domain of space2?
@@ -1840,12 +1873,16 @@ isl_bool isl_space_is_equal(__isl_keep isl_space *dim1,
 isl_bool isl_space_is_domain_internal(__isl_keep isl_space *space1,
 	__isl_keep isl_space *space2)
 {
+	isl_bool equal_params;
+
 	if (!space1 || !space2)
 		return isl_bool_error;
 	if (!isl_space_is_set(space1))
 		return isl_bool_false;
-	return match(space1, isl_dim_param, space2, isl_dim_param) &&
-	       isl_space_tuple_is_equal(space1, isl_dim_set,
+	equal_params = isl_space_has_equal_params(space1, space2);
+	if (equal_params < 0 || !equal_params)
+		return equal_params;
+	return isl_space_tuple_is_equal(space1, isl_dim_set,
 					space2, isl_dim_in);
 }
 
@@ -1869,12 +1906,16 @@ isl_bool isl_space_is_domain(__isl_keep isl_space *space1,
 isl_bool isl_space_is_range_internal(__isl_keep isl_space *space1,
 	__isl_keep isl_space *space2)
 {
+	isl_bool equal_params;
+
 	if (!space1 || !space2)
 		return isl_bool_error;
 	if (!isl_space_is_set(space1))
 		return isl_bool_false;
-	return match(space1, isl_dim_param, space2, isl_dim_param) &&
-	       isl_space_tuple_is_equal(space1, isl_dim_set,
+	equal_params = isl_space_has_equal_params(space1, space2);
+	if (equal_params < 0 || !equal_params)
+		return equal_params;
+	return isl_space_tuple_is_equal(space1, isl_dim_set,
 					space2, isl_dim_out);
 }
 
@@ -1890,17 +1931,9 @@ isl_bool isl_space_is_range(__isl_keep isl_space *space1,
 	return isl_space_is_range_internal(space1, space2);
 }
 
-int isl_space_compatible(__isl_keep isl_space *dim1,
-	__isl_keep isl_space *dim2)
-{
-	return dim1->nparam == dim2->nparam &&
-	       dim1->n_in + dim1->n_out == dim2->n_in + dim2->n_out;
-}
-
-/* Update "hash" by hashing in "space".
- * Changes in this function should be reflected in isl_hash_space_domain.
+/* Update "hash" by hashing in the parameters of "space".
  */
-static uint32_t isl_hash_space(uint32_t hash, __isl_keep isl_space *space)
+static uint32_t isl_hash_params(uint32_t hash, __isl_keep isl_space *space)
 {
 	int i;
 	isl_id *id;
@@ -1909,65 +1942,89 @@ static uint32_t isl_hash_space(uint32_t hash, __isl_keep isl_space *space)
 		return hash;
 
 	isl_hash_byte(hash, space->nparam % 256);
-	isl_hash_byte(hash, space->n_in % 256);
-	isl_hash_byte(hash, space->n_out % 256);
 
 	for (i = 0; i < space->nparam; ++i) {
 		id = get_id(space, isl_dim_param, i);
 		hash = isl_hash_id(hash, id);
 	}
 
+	return hash;
+}
+
+/* Update "hash" by hashing in the tuples of "space".
+ * Changes in this function should be reflected in isl_hash_tuples_domain.
+ */
+static uint32_t isl_hash_tuples(uint32_t hash, __isl_keep isl_space *space)
+{
+	isl_id *id;
+
+	if (!space)
+		return hash;
+
+	isl_hash_byte(hash, space->n_in % 256);
+	isl_hash_byte(hash, space->n_out % 256);
+
 	id = tuple_id(space, isl_dim_in);
 	hash = isl_hash_id(hash, id);
 	id = tuple_id(space, isl_dim_out);
 	hash = isl_hash_id(hash, id);
 
-	hash = isl_hash_space(hash, space->nested[0]);
-	hash = isl_hash_space(hash, space->nested[1]);
+	hash = isl_hash_tuples(hash, space->nested[0]);
+	hash = isl_hash_tuples(hash, space->nested[1]);
 
 	return hash;
 }
 
-/* Update "hash" by hashing in the domain of "space".
+/* Update "hash" by hashing in the domain tuple of "space".
  * The result of this function is equal to the result of applying
- * isl_hash_space to the domain of "space".
+ * isl_hash_tuples to the domain of "space".
  */
-static uint32_t isl_hash_space_domain(uint32_t hash,
+static uint32_t isl_hash_tuples_domain(uint32_t hash,
 	__isl_keep isl_space *space)
 {
-	int i;
 	isl_id *id;
 
 	if (!space)
 		return hash;
 
-	isl_hash_byte(hash, space->nparam % 256);
 	isl_hash_byte(hash, 0);
 	isl_hash_byte(hash, space->n_in % 256);
 
-	for (i = 0; i < space->nparam; ++i) {
-		id = get_id(space, isl_dim_param, i);
-		hash = isl_hash_id(hash, id);
-	}
-
 	hash = isl_hash_id(hash, &isl_id_none);
 	id = tuple_id(space, isl_dim_in);
 	hash = isl_hash_id(hash, id);
 
-	hash = isl_hash_space(hash, space->nested[0]);
+	hash = isl_hash_tuples(hash, space->nested[0]);
 
 	return hash;
 }
 
-uint32_t isl_space_get_hash(__isl_keep isl_space *dim)
+/* Return a hash value that digests the tuples of "space",
+ * i.e., that ignores the parameters.
+ */
+uint32_t isl_space_get_tuple_hash(__isl_keep isl_space *space)
 {
 	uint32_t hash;
 
-	if (!dim)
+	if (!space)
 		return 0;
 
 	hash = isl_hash_init();
-	hash = isl_hash_space(hash, dim);
+	hash = isl_hash_tuples(hash, space);
+
+	return hash;
+}
+
+uint32_t isl_space_get_hash(__isl_keep isl_space *space)
+{
+	uint32_t hash;
+
+	if (!space)
+		return 0;
+
+	hash = isl_hash_init();
+	hash = isl_hash_params(hash, space);
+	hash = isl_hash_tuples(hash, space);
 
 	return hash;
 }
@@ -1984,7 +2041,8 @@ uint32_t isl_space_get_domain_hash(__isl_keep isl_space *space)
 		return 0;
 
 	hash = isl_hash_init();
-	hash = isl_hash_space_domain(hash, space);
+	hash = isl_hash_params(hash, space);
+	hash = isl_hash_tuples_domain(hash, space);
 
 	return hash;
 }
@@ -2026,6 +2084,26 @@ isl_bool isl_space_range_is_wrapping(__isl_keep isl_space *space)
 	return space->nested[1] != NULL;
 }
 
+/* Is "space" a product of two spaces?
+ * That is, is it a wrapping set space or a map space
+ * with wrapping domain and range?
+ */
+isl_bool isl_space_is_product(__isl_keep isl_space *space)
+{
+	isl_bool is_set;
+	isl_bool is_product;
+
+	is_set = isl_space_is_set(space);
+	if (is_set < 0)
+		return isl_bool_error;
+	if (is_set)
+		return isl_space_is_wrapping(space);
+	is_product = isl_space_domain_is_wrapping(space);
+	if (is_product < 0 || !is_product)
+		return is_product;
+	return isl_space_range_is_wrapping(space);
+}
+
 __isl_give isl_space *isl_space_wrap(__isl_take isl_space *dim)
 {
 	isl_space *wrap;
@@ -2071,30 +2149,34 @@ error:
 	return NULL;
 }
 
-int isl_space_is_named_or_nested(__isl_keep isl_space *dim, enum isl_dim_type type)
+isl_bool isl_space_is_named_or_nested(__isl_keep isl_space *space,
+	enum isl_dim_type type)
 {
 	if (type != isl_dim_in && type != isl_dim_out)
-		return 0;
-	if (!dim)
-		return -1;
-	if (dim->tuple_id[type - isl_dim_in])
-		return 1;
-	if (dim->nested[type - isl_dim_in])
-		return 1;
-	return 0;
+		return isl_bool_false;
+	if (!space)
+		return isl_bool_error;
+	if (space->tuple_id[type - isl_dim_in])
+		return isl_bool_true;
+	if (space->nested[type - isl_dim_in])
+		return isl_bool_true;
+	return isl_bool_false;
 }
 
-int isl_space_may_be_set(__isl_keep isl_space *dim)
+isl_bool isl_space_may_be_set(__isl_keep isl_space *space)
 {
-	if (!dim)
-		return -1;
-	if (isl_space_is_set(dim))
-		return 1;
-	if (isl_space_dim(dim, isl_dim_in) != 0)
-		return 0;
-	if (isl_space_is_named_or_nested(dim, isl_dim_in))
-		return 0;
-	return 1;
+	isl_bool nested;
+
+	if (!space)
+		return isl_bool_error;
+	if (isl_space_is_set(space))
+		return isl_bool_true;
+	if (isl_space_dim(space, isl_dim_in) != 0)
+		return isl_bool_false;
+	nested = isl_space_is_named_or_nested(space, isl_dim_in);
+	if (nested < 0 || nested)
+		return isl_bool_not(nested);
+	return isl_bool_true;
 }
 
 __isl_give isl_space *isl_space_reset(__isl_take isl_space *dim,
@@ -2206,12 +2288,16 @@ __isl_give isl_space *isl_space_lift(__isl_take isl_space *dim, unsigned n_local
 	return dim;
 }
 
-isl_bool isl_space_can_zip(__isl_keep isl_space *dim)
+isl_bool isl_space_can_zip(__isl_keep isl_space *space)
 {
-	if (!dim)
-		return isl_bool_error;
+	isl_bool is_set;
 
-	return dim->nested[0] && dim->nested[1];
+	is_set = isl_space_is_set(space);
+	if (is_set < 0)
+		return isl_bool_error;
+	if (is_set)
+		return isl_bool_false;
+	return isl_space_is_product(space);
 }
 
 __isl_give isl_space *isl_space_zip(__isl_take isl_space *dim)
@@ -2357,22 +2443,39 @@ __isl_give isl_space *isl_space_uncurry(__isl_take isl_space *space)
 			    isl_space_from_range(ran_ran));
 }
 
-int isl_space_has_named_params(__isl_keep isl_space *dim)
+isl_bool isl_space_has_named_params(__isl_keep isl_space *space)
 {
 	int i;
 	unsigned off;
 
-	if (!dim)
-		return -1;
-	if (dim->nparam == 0)
-		return 1;
-	off = isl_space_offset(dim, isl_dim_param);
-	if (off + dim->nparam > dim->n_id)
-		return 0;
-	for (i = 0; i < dim->nparam; ++i)
-		if (!dim->ids[off + i])
-			return 0;
-	return 1;
+	if (!space)
+		return isl_bool_error;
+	if (space->nparam == 0)
+		return isl_bool_true;
+	off = isl_space_offset(space, isl_dim_param);
+	if (off + space->nparam > space->n_id)
+		return isl_bool_false;
+	for (i = 0; i < space->nparam; ++i)
+		if (!space->ids[off + i])
+			return isl_bool_false;
+	return isl_bool_true;
+}
+
+/* Check that "space" has only named parameters, reporting an error
+ * if it does not.
+ */
+isl_stat isl_space_check_named_params(__isl_keep isl_space *space)
+{
+	isl_bool named;
+
+	named = isl_space_has_named_params(space);
+	if (named < 0)
+		return isl_stat_error;
+	if (!named)
+		isl_die(isl_space_get_ctx(space), isl_error_invalid,
+			"unaligned unnamed parameters", return isl_stat_error);
+
+	return isl_stat_ok;
 }
 
 /* Align the initial parameters of dim1 to match the order in dim2.
diff --git a/lib/Analysis/isl/isl_space_private.h b/lib/Analysis/isl/isl_space_private.h
index 6ceba07..783ba43 100644
--- a/lib/Analysis/isl/isl_space_private.h
+++ b/lib/Analysis/isl/isl_space_private.h
@@ -27,7 +27,8 @@ __isl_give isl_space *isl_space_cow(__isl_take isl_space *dim);
 __isl_give isl_space *isl_space_underlying(__isl_take isl_space *dim,
 	unsigned n_div);
 
-uint32_t isl_space_get_hash(__isl_keep isl_space *dim);
+uint32_t isl_space_get_tuple_hash(__isl_keep isl_space *space);
+uint32_t isl_space_get_hash(__isl_keep isl_space *space);
 uint32_t isl_space_get_domain_hash(__isl_keep isl_space *space);
 
 isl_bool isl_space_is_domain_internal(__isl_keep isl_space *space1,
@@ -35,13 +36,17 @@ isl_bool isl_space_is_domain_internal(__isl_keep isl_space *space1,
 isl_bool isl_space_is_range_internal(__isl_keep isl_space *space1,
 	__isl_keep isl_space *space2);
 
-__isl_give isl_space *isl_space_as_set_space(__isl_take isl_space *dim);
-
 unsigned isl_space_offset(__isl_keep isl_space *dim, enum isl_dim_type type);
 
-int isl_space_may_be_set(__isl_keep isl_space *dim);
-int isl_space_is_named_or_nested(__isl_keep isl_space *dim, enum isl_dim_type type);
-int isl_space_has_named_params(__isl_keep isl_space *dim);
+isl_bool isl_space_may_be_set(__isl_keep isl_space *space);
+isl_bool isl_space_is_named_or_nested(__isl_keep isl_space *space,
+	enum isl_dim_type type);
+isl_bool isl_space_has_equal_ids(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2);
+isl_bool isl_space_has_named_params(__isl_keep isl_space *space);
+isl_stat isl_space_check_named_params(__isl_keep isl_space *space);
+isl_stat isl_space_check_equal_params(__isl_keep isl_space *space1,
+	__isl_keep isl_space *space2);
 __isl_give isl_space *isl_space_reset(__isl_take isl_space *dim,
 	enum isl_dim_type type);
 __isl_give isl_space *isl_space_flatten(__isl_take isl_space *dim);
diff --git a/lib/Analysis/isl/isl_srcdir.c.cmake b/lib/Analysis/isl/isl_srcdir.c.cmake
new file mode 100644
index 0000000..34ef890
--- /dev/null
+++ b/lib/Analysis/isl/isl_srcdir.c.cmake
@@ -0,0 +1 @@
+static const char *srcdir = "@ISL_SOURCE_DIR@";
diff --git a/lib/Analysis/isl/isl_srcdir.c.in b/lib/Analysis/isl/isl_srcdir.c.in
new file mode 100644
index 0000000..38e30c5
--- /dev/null
+++ b/lib/Analysis/isl/isl_srcdir.c.in
@@ -0,0 +1 @@
+static const char *srcdir = "@srcdir@";
diff --git a/lib/Analysis/isl/isl_tab.c b/lib/Analysis/isl/isl_tab.c
index dbfbd4d..fd184c5 100644
--- a/lib/Analysis/isl/isl_tab.c
+++ b/lib/Analysis/isl/isl_tab.c
@@ -2,6 +2,7 @@
  * Copyright 2008-2009 Katholieke Universiteit Leuven
  * Copyright 2013      Ecole Normale Superieure
  * Copyright 2014      INRIA Rocquencourt
+ * Copyright 2016      Sven Verdoolaege
  *
  * Use of this software is governed by the MIT license
  *
@@ -20,6 +21,9 @@
 #include <isl_seq.h>
 #include <isl_config.h>
 
+#include <bset_to_bmap.c>
+#include <bset_from_bmap.c>
+
 /*
  * The implementation of tableaus in this file was inspired by Section 8
  * of David Detlefs, Greg Nelson and James B. Saxe, "Simplify: a theorem
@@ -976,15 +980,15 @@ int isl_tab_mark_rational(struct isl_tab *tab)
 	return 0;
 }
 
-int isl_tab_mark_empty(struct isl_tab *tab)
+isl_stat isl_tab_mark_empty(struct isl_tab *tab)
 {
 	if (!tab)
-		return -1;
+		return isl_stat_error;
 	if (!tab->empty && tab->need_undo)
 		if (isl_tab_push(tab, isl_tab_undo_empty) < 0)
-			return -1;
+			return isl_stat_error;
 	tab->empty = 1;
-	return 0;
+	return isl_stat_ok;
 }
 
 int isl_tab_freeze_constraint(struct isl_tab *tab, int con)
@@ -1603,36 +1607,52 @@ static int tab_is_manifestly_empty(struct isl_tab *tab)
  * Each of the non-negative variables with a negative coefficient can
  * then also be written as the negative sum of non-negative variables
  * and must therefore also be zero.
+ *
+ * If "temp_var" is set, then "var" is a temporary variable that
+ * will be removed after this function returns and for which
+ * no information is recorded on the undo stack.
+ * Do not add any undo records involving this variable in this case
+ * since the variable will have been removed before any future undo
+ * operations.  Also avoid marking the variable as redundant,
+ * since that either adds an undo record or needlessly removes the row
+ * (the caller will take care of removing the row).
  */
-static int close_row(struct isl_tab *tab, struct isl_tab_var *var) WARN_UNUSED;
-static int close_row(struct isl_tab *tab, struct isl_tab_var *var)
+static isl_stat close_row(struct isl_tab *tab, struct isl_tab_var *var,
+	int temp_var) WARN_UNUSED;
+static isl_stat close_row(struct isl_tab *tab, struct isl_tab_var *var,
+	int temp_var)
 {
 	int j;
 	struct isl_mat *mat = tab->mat;
 	unsigned off = 2 + tab->M;
 
-	isl_assert(tab->mat->ctx, var->is_nonneg, return -1);
+	if (!var->is_nonneg)
+		isl_die(isl_tab_get_ctx(tab), isl_error_internal,
+			"expecting non-negative variable",
+			return isl_stat_error);
 	var->is_zero = 1;
-	if (tab->need_undo)
+	if (!temp_var && tab->need_undo)
 		if (isl_tab_push_var(tab, isl_tab_undo_zero, var) < 0)
-			return -1;
+			return isl_stat_error;
 	for (j = tab->n_dead; j < tab->n_col; ++j) {
 		int recheck;
 		if (isl_int_is_zero(mat->row[var->index][off + j]))
 			continue;
-		isl_assert(tab->mat->ctx,
-		    isl_int_is_neg(mat->row[var->index][off + j]), return -1);
+		if (isl_int_is_pos(mat->row[var->index][off + j]))
+			isl_die(isl_tab_get_ctx(tab), isl_error_internal,
+				"row cannot have positive coefficients",
+				return isl_stat_error);
 		recheck = isl_tab_kill_col(tab, j);
 		if (recheck < 0)
-			return -1;
+			return isl_stat_error;
 		if (recheck)
 			--j;
 	}
-	if (isl_tab_mark_redundant(tab, var->index) < 0)
-		return -1;
+	if (!temp_var && isl_tab_mark_redundant(tab, var->index) < 0)
+		return isl_stat_error;
 	if (tab_is_manifestly_empty(tab) && isl_tab_mark_empty(tab) < 0)
-		return -1;
-	return 0;
+		return isl_stat_error;
+	return isl_stat_ok;
 }
 
 /* Add a constraint to the tableau and allocate a row for it.
@@ -1835,14 +1855,15 @@ int isl_tab_add_row(struct isl_tab *tab, isl_int *line)
 	return r;
 }
 
-static int drop_row(struct isl_tab *tab, int row)
+static isl_stat drop_row(struct isl_tab *tab, int row)
 {
-	isl_assert(tab->mat->ctx, ~tab->row_var[row] == tab->n_con - 1, return -1);
+	isl_assert(tab->mat->ctx, ~tab->row_var[row] == tab->n_con - 1,
+		return isl_stat_error);
 	if (row != tab->n_row - 1)
 		swap_rows(tab, row, tab->n_row - 1);
 	tab->n_row--;
 	tab->n_con--;
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Drop the variable in column "col" along with the column.
@@ -1851,7 +1872,7 @@ static int drop_row(struct isl_tab *tab, int row)
  * the contents of the col_var array in a state
  * before the removal of the variable.
  */
-static int drop_col(struct isl_tab *tab, int col)
+static isl_stat drop_col(struct isl_tab *tab, int col)
 {
 	int var;
 
@@ -1860,8 +1881,8 @@ static int drop_col(struct isl_tab *tab, int col)
 		swap_cols(tab, col, tab->n_col - 1);
 	tab->n_col--;
 	if (var_drop_entry(tab, var) < 0)
-		return -1;
-	return 0;
+		return isl_stat_error;
+	return isl_stat_ok;
 }
 
 /* Add inequality "ineq" and check if it conflicts with the
@@ -1870,25 +1891,27 @@ static int drop_col(struct isl_tab *tab, int col)
  * This function assumes that at least one more row and at least
  * one more element in the constraint array are available in the tableau.
  */
-int isl_tab_add_ineq(struct isl_tab *tab, isl_int *ineq)
+isl_stat isl_tab_add_ineq(struct isl_tab *tab, isl_int *ineq)
 {
 	int r;
 	int sgn;
 	isl_int cst;
 
 	if (!tab)
-		return -1;
+		return isl_stat_error;
 	if (tab->bmap) {
 		struct isl_basic_map *bmap = tab->bmap;
 
-		isl_assert(tab->mat->ctx, tab->n_eq == bmap->n_eq, return -1);
+		isl_assert(tab->mat->ctx, tab->n_eq == bmap->n_eq,
+			return isl_stat_error);
 		isl_assert(tab->mat->ctx,
-			    tab->n_con == bmap->n_eq + bmap->n_ineq, return -1);
+			    tab->n_con == bmap->n_eq + bmap->n_ineq,
+			    return isl_stat_error);
 		tab->bmap = isl_basic_map_add_ineq(tab->bmap, ineq);
 		if (isl_tab_push(tab, isl_tab_undo_bmap_ineq) < 0)
-			return -1;
+			return isl_stat_error;
 		if (!tab->bmap)
-			return -1;
+			return isl_stat_error;
 	}
 	if (tab->cone) {
 		isl_int_init(cst);
@@ -1901,25 +1924,25 @@ int isl_tab_add_ineq(struct isl_tab *tab, isl_int *ineq)
 		isl_int_clear(cst);
 	}
 	if (r < 0)
-		return -1;
+		return isl_stat_error;
 	tab->con[r].is_nonneg = 1;
 	if (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r]) < 0)
-		return -1;
+		return isl_stat_error;
 	if (isl_tab_row_is_redundant(tab, tab->con[r].index)) {
 		if (isl_tab_mark_redundant(tab, tab->con[r].index) < 0)
-			return -1;
-		return 0;
+			return isl_stat_error;
+		return isl_stat_ok;
 	}
 
 	sgn = restore_row(tab, &tab->con[r]);
 	if (sgn < -1)
-		return -1;
+		return isl_stat_error;
 	if (sgn < 0)
 		return isl_tab_mark_empty(tab);
 	if (tab->con[r].is_row && isl_tab_row_is_redundant(tab, tab->con[r].index))
 		if (isl_tab_mark_redundant(tab, tab->con[r].index) < 0)
-			return -1;
-	return 0;
+			return isl_stat_error;
+	return isl_stat_ok;
 }
 
 /* Pivot a non-negative variable down until it reaches the value zero
@@ -1991,13 +2014,21 @@ error:
 	return NULL;
 }
 
+/* Does the sample value of row "row" of "tab" involve the big parameter,
+ * if any?
+ */
+static int row_is_big(struct isl_tab *tab, int row)
+{
+	return tab->M && !isl_int_is_zero(tab->mat->row[row][2]);
+}
+
 static int row_is_manifestly_zero(struct isl_tab *tab, int row)
 {
 	unsigned off = 2 + tab->M;
 
 	if (!isl_int_is_zero(tab->mat->row[row][1]))
 		return 0;
-	if (tab->M && !isl_int_is_zero(tab->mat->row[row][2]))
+	if (row_is_big(tab, row))
 		return 0;
 	return isl_seq_first_non_zero(tab->mat->row[row] + off + tab->n_dead,
 					tab->n_col - tab->n_dead) == -1;
@@ -2200,8 +2231,8 @@ static struct isl_vec *ineq_for_div(struct isl_basic_map *bmap, unsigned div)
  * This function assumes that at least two more rows and at least
  * two more elements in the constraint array are available in the tableau.
  */
-static int add_div_constraints(struct isl_tab *tab, unsigned div,
-	int (*add_ineq)(void *user, isl_int *), void *user)
+static isl_stat add_div_constraints(struct isl_tab *tab, unsigned div,
+	isl_stat (*add_ineq)(void *user, isl_int *), void *user)
 {
 	unsigned total;
 	unsigned div_pos;
@@ -2271,8 +2302,10 @@ static int div_is_nonneg(struct isl_tab *tab, __isl_keep isl_vec *div)
 	return 1;
 }
 
-/* Add an extra div, prescribed by "div" to the tableau and
+/* Insert an extra div, prescribed by "div", to the tableau and
  * the associated bmap (which is assumed to be non-NULL).
+ * The extra integer division is inserted at (tableau) position "pos".
+ * Return "pos" or -1 if an error occurred.
  *
  * If add_ineq is not NULL, then this function is used instead
  * of isl_tab_add_ineq to add the div constraints.
@@ -2280,17 +2313,26 @@ static int div_is_nonneg(struct isl_tab *tab, __isl_keep isl_vec *div)
  * wants to perform some extra processing when an inequality
  * is added to the tableau.
  */
-int isl_tab_add_div(struct isl_tab *tab, __isl_keep isl_vec *div,
-	int (*add_ineq)(void *user, isl_int *), void *user)
+int isl_tab_insert_div(struct isl_tab *tab, int pos, __isl_keep isl_vec *div,
+	isl_stat (*add_ineq)(void *user, isl_int *), void *user)
 {
 	int r;
-	int k;
 	int nonneg;
+	int n_div, o_div;
 
 	if (!tab || !div)
 		return -1;
 
+	if (div->size != 1 + 1 + tab->n_var)
+		isl_die(isl_tab_get_ctx(tab), isl_error_invalid,
+			"unexpected size", return -1);
+
 	isl_assert(tab->mat->ctx, tab->bmap, return -1);
+	n_div = isl_basic_map_dim(tab->bmap, isl_dim_div);
+	o_div = tab->n_var - n_div;
+	if (pos < o_div || pos > tab->n_var)
+		isl_die(isl_tab_get_ctx(tab), isl_error_invalid,
+			"invalid position", return -1);
 
 	nonneg = div_is_nonneg(tab, div);
 
@@ -2298,28 +2340,35 @@ int isl_tab_add_div(struct isl_tab *tab, __isl_keep isl_vec *div,
 		return -1;
 	if (isl_tab_extend_vars(tab, 1) < 0)
 		return -1;
-	r = isl_tab_allocate_var(tab);
+	r = isl_tab_insert_var(tab, pos);
 	if (r < 0)
 		return -1;
 
 	if (nonneg)
 		tab->var[r].is_nonneg = 1;
 
-	tab->bmap = isl_basic_map_extend_space(tab->bmap,
-		isl_basic_map_get_space(tab->bmap), 1, 0, 2);
-	k = isl_basic_map_alloc_div(tab->bmap);
-	if (k < 0)
+	tab->bmap = isl_basic_map_insert_div(tab->bmap, pos - o_div, div);
+	if (!tab->bmap)
 		return -1;
-	isl_seq_cpy(tab->bmap->div[k], div->el, div->size);
-	if (isl_tab_push(tab, isl_tab_undo_bmap_div) < 0)
+	if (isl_tab_push_var(tab, isl_tab_undo_bmap_div, &tab->var[r]) < 0)
 		return -1;
 
-	if (add_div_constraints(tab, k, add_ineq, user) < 0)
+	if (add_div_constraints(tab, pos - o_div, add_ineq, user) < 0)
 		return -1;
 
 	return r;
 }
 
+/* Add an extra div, prescribed by "div", to the tableau and
+ * the associated bmap (which is assumed to be non-NULL).
+ */
+int isl_tab_add_div(struct isl_tab *tab, __isl_keep isl_vec *div)
+{
+	if (!tab)
+		return -1;
+	return isl_tab_insert_div(tab, tab->n_var, div, NULL, NULL);
+}
+
 /* If "track" is set, then we want to keep track of all constraints in tab
  * in its bmap field.  This field is initialized from a copy of "bmap",
  * so we need to make sure that all constraints in "bmap" also appear
@@ -2428,16 +2477,16 @@ error:
 /* Assuming "tab" is the tableau of a cone, check if the cone is
  * bounded, i.e., if it is empty or only contains the origin.
  */
-int isl_tab_cone_is_bounded(struct isl_tab *tab)
+isl_bool isl_tab_cone_is_bounded(struct isl_tab *tab)
 {
 	int i;
 
 	if (!tab)
-		return -1;
+		return isl_bool_error;
 	if (tab->empty)
-		return 1;
+		return isl_bool_true;
 	if (tab->n_dead == tab->n_col)
-		return 1;
+		return isl_bool_true;
 
 	for (;;) {
 		for (i = tab->n_redundant; i < tab->n_row; ++i) {
@@ -2448,17 +2497,17 @@ int isl_tab_cone_is_bounded(struct isl_tab *tab)
 				continue;
 			sgn = sign_of_max(tab, var);
 			if (sgn < -1)
-				return -1;
+				return isl_bool_error;
 			if (sgn != 0)
-				return 0;
-			if (close_row(tab, var) < 0)
-				return -1;
+				return isl_bool_false;
+			if (close_row(tab, var, 0) < 0)
+				return isl_bool_error;
 			break;
 		}
 		if (tab->n_dead == tab->n_col)
-			return 1;
+			return isl_bool_true;
 		if (i == tab->n_row)
-			return 0;
+			return isl_bool_false;
 	}
 }
 
@@ -2539,6 +2588,22 @@ struct isl_vec *isl_tab_get_sample_value(struct isl_tab *tab)
 	return vec;
 }
 
+/* Store the sample value of "var" of "tab" rounded up (if sgn > 0)
+ * or down (if sgn < 0) to the nearest integer in *v.
+ */
+static void get_rounded_sample_value(struct isl_tab *tab,
+	struct isl_tab_var *var, int sgn, isl_int *v)
+{
+	if (!var->is_row)
+		isl_int_set_si(*v, 0);
+	else if (sgn > 0)
+		isl_int_cdiv_q(*v, tab->mat->row[var->index][1],
+				   tab->mat->row[var->index][0]);
+	else
+		isl_int_fdiv_q(*v, tab->mat->row[var->index][1],
+				   tab->mat->row[var->index][0]);
+}
+
 /* Update "bmap" based on the results of the tableau "tab".
  * In particular, implicit equalities are made explicit, redundant constraints
  * are removed and if the sample value happens to be integer, it is stored
@@ -2579,20 +2644,39 @@ struct isl_basic_map *isl_basic_map_update_from_tab(struct isl_basic_map *bmap,
 struct isl_basic_set *isl_basic_set_update_from_tab(struct isl_basic_set *bset,
 	struct isl_tab *tab)
 {
-	return (struct isl_basic_set *)isl_basic_map_update_from_tab(
-		(struct isl_basic_map *)bset, tab);
+	return bset_from_bmap(isl_basic_map_update_from_tab(bset_to_bmap(bset),
+								tab));
+}
+
+/* Drop the last constraint added to "tab" in position "r".
+ * The constraint is expected to have remained in a row.
+ */
+static isl_stat drop_last_con_in_row(struct isl_tab *tab, int r)
+{
+	if (!tab->con[r].is_row)
+		isl_die(isl_tab_get_ctx(tab), isl_error_internal,
+			"row unexpectedly moved to column",
+			return isl_stat_error);
+	if (r + 1 != tab->n_con)
+		isl_die(isl_tab_get_ctx(tab), isl_error_internal,
+			"additional constraints added", return isl_stat_error);
+	if (drop_row(tab, tab->con[r].index) < 0)
+		return isl_stat_error;
+
+	return isl_stat_ok;
 }
 
-/* Given a non-negative variable "var", add a new non-negative variable
- * that is the opposite of "var", ensuring that var can only attain the
- * value zero.
+/* Given a non-negative variable "var", temporarily add a new non-negative
+ * variable that is the opposite of "var", ensuring that "var" can only attain
+ * the value zero.  The new variable is removed again before this function
+ * returns.  However, the effect of forcing "var" to be zero remains.
  * If var = n/d is a row variable, then the new variable = -n/d.
  * If var is a column variables, then the new variable = -var.
  * If the new variable cannot attain non-negative values, then
  * the resulting tableau is empty.
  * Otherwise, we know the value will be zero and we close the row.
  */
-static int cut_to_hyperplane(struct isl_tab *tab, struct isl_tab_var *var)
+static isl_stat cut_to_hyperplane(struct isl_tab *tab, struct isl_tab_var *var)
 {
 	unsigned r;
 	isl_int *row;
@@ -2600,12 +2684,14 @@ static int cut_to_hyperplane(struct isl_tab *tab, struct isl_tab_var *var)
 	unsigned off = 2 + tab->M;
 
 	if (var->is_zero)
-		return 0;
-	isl_assert(tab->mat->ctx, !var->is_redundant, return -1);
-	isl_assert(tab->mat->ctx, var->is_nonneg, return -1);
+		return isl_stat_ok;
+	if (var->is_redundant || !var->is_nonneg)
+		isl_die(isl_tab_get_ctx(tab), isl_error_invalid,
+			"expecting non-redundant non-negative variable",
+			return isl_stat_error);
 
 	if (isl_tab_extend_cons(tab, 1) < 0)
-		return -1;
+		return isl_stat_error;
 
 	r = tab->n_con;
 	tab->con[r].index = tab->n_row;
@@ -2630,25 +2716,25 @@ static int cut_to_hyperplane(struct isl_tab *tab, struct isl_tab_var *var)
 
 	tab->n_row++;
 	tab->n_con++;
-	if (isl_tab_push_var(tab, isl_tab_undo_allocate, &tab->con[r]) < 0)
-		return -1;
 
 	sgn = sign_of_max(tab, &tab->con[r]);
 	if (sgn < -1)
-		return -1;
+		return isl_stat_error;
 	if (sgn < 0) {
+		if (drop_last_con_in_row(tab, r) < 0)
+			return isl_stat_error;
 		if (isl_tab_mark_empty(tab) < 0)
-			return -1;
-		return 0;
+			return isl_stat_error;
+		return isl_stat_ok;
 	}
 	tab->con[r].is_nonneg = 1;
-	if (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r]) < 0)
-		return -1;
 	/* sgn == 0 */
-	if (close_row(tab, &tab->con[r]) < 0)
-		return -1;
+	if (close_row(tab, &tab->con[r], 1) < 0)
+		return isl_stat_error;
+	if (drop_last_con_in_row(tab, r) < 0)
+		return isl_stat_error;
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Given a tableau "tab" and an inequality constraint "con" of the tableau,
@@ -2811,6 +2897,37 @@ static int may_be_equality(struct isl_tab *tab, int row)
 					    tab->mat->row[row][0]);
 }
 
+/* Return an isl_tab_var that has been marked or NULL if no such
+ * variable can be found.
+ * The marked field has only been set for variables that
+ * appear in non-redundant rows or non-dead columns.
+ *
+ * Pick the last constraint variable that is marked and
+ * that appears in either a non-redundant row or a non-dead columns.
+ * Since the returned variable is tested for being a redundant constraint or
+ * an implicit equality, there is no need to return any tab variable that
+ * corresponds to a variable.
+ */
+static struct isl_tab_var *select_marked(struct isl_tab *tab)
+{
+	int i;
+	struct isl_tab_var *var;
+
+	for (i = tab->n_con - 1; i >= 0; --i) {
+		var = &tab->con[i];
+		if (var->index < 0)
+			continue;
+		if (var->is_row && var->index < tab->n_redundant)
+			continue;
+		if (!var->is_row && var->index < tab->n_dead)
+			continue;
+		if (var->marked)
+			return var;
+	}
+
+	return NULL;
+}
+
 /* Check for (near) equalities among the constraints.
  * A constraint is an equality if it is non-negative and if
  * its maximal value is either
@@ -2826,6 +2943,7 @@ static int may_be_equality(struct isl_tab *tab, int row)
  * Otherwise, if the maximal value is strictly less than one (and the
  * tableau is integer), then we restrict the value to being zero
  * by adding an opposite non-negative variable.
+ * The order in which the variables are considered is not important.
  */
 int isl_tab_detect_implicit_equalities(struct isl_tab *tab)
 {
@@ -2856,27 +2974,16 @@ int isl_tab_detect_implicit_equalities(struct isl_tab *tab)
 	while (n_marked) {
 		struct isl_tab_var *var;
 		int sgn;
-		for (i = tab->n_redundant; i < tab->n_row; ++i) {
-			var = isl_tab_var_from_row(tab, i);
-			if (var->marked)
-				break;
-		}
-		if (i == tab->n_row) {
-			for (i = tab->n_dead; i < tab->n_col; ++i) {
-				var = var_from_col(tab, i);
-				if (var->marked)
-					break;
-			}
-			if (i == tab->n_col)
-				break;
-		}
+		var = select_marked(tab);
+		if (!var)
+			break;
 		var->marked = 0;
 		n_marked--;
 		sgn = sign_of_max(tab, var);
 		if (sgn < 0)
 			return -1;
 		if (sgn == 0) {
-			if (close_row(tab, var) < 0)
+			if (close_row(tab, var, 0) < 0)
 				return -1;
 		} else if (!tab->rational && !at_least_one(tab, var)) {
 			if (cut_to_hyperplane(tab, var) < 0)
@@ -3014,36 +3121,6 @@ static int con_is_redundant(struct isl_tab *tab, struct isl_tab_var *var)
 	}
 }
 
-/* Return an isl_tab_var that has been marked or NULL if no such
- * variable can be found.
- * The marked field has only been set for variables that
- * appear in non-redundant rows or non-dead columns.
- *
- * Pick the last constraint variable that is marked and
- * that appears in either a non-redundant row or a non-dead columns.
- * Since the returned variable is tested for being a redundant constraint,
- * there is no need to return any tab variable that corresponds to a variable.
- */
-static struct isl_tab_var *select_marked(struct isl_tab *tab)
-{
-	int i;
-	struct isl_tab_var *var;
-
-	for (i = tab->n_con - 1; i >= 0; --i) {
-		var = &tab->con[i];
-		if (var->index < 0)
-			continue;
-		if (var->is_row && var->index < tab->n_redundant)
-			continue;
-		if (!var->is_row && var->index < tab->n_dead)
-			continue;
-		if (var->marked)
-			return var;
-	}
-
-	return NULL;
-}
-
 /* Check for (near) redundant constraints.
  * A constraint is redundant if it is non-negative and if
  * its minimal value (temporarily ignoring the non-negativity) is either
@@ -3129,7 +3206,7 @@ int isl_tab_is_equality(struct isl_tab *tab, int con)
 
 	off = 2 + tab->M;
 	return isl_int_is_zero(tab->mat->row[row][1]) &&
-		(!tab->M || isl_int_is_zero(tab->mat->row[row][2])) &&
+		!row_is_big(tab, row) &&
 		isl_seq_first_non_zero(tab->mat->row[row] + off + tab->n_dead,
 					tab->n_col - tab->n_dead) == -1;
 }
@@ -3206,8 +3283,7 @@ enum isl_lp_result isl_tab_min(struct isl_tab *tab,
 			isl_int_set(*opt, tab->mat->row[var->index][1]);
 			isl_int_set(*opt_denom, tab->mat->row[var->index][0]);
 		} else
-			isl_int_cdiv_q(*opt, tab->mat->row[var->index][1],
-					     tab->mat->row[var->index][0]);
+			get_rounded_sample_value(tab, var, 1, opt);
 	}
 	if (isl_tab_rollback(tab, snap) < 0)
 		return isl_lp_error;
@@ -3236,7 +3312,242 @@ int isl_tab_is_redundant(struct isl_tab *tab, int con)
 	return tab->con[con].is_row && tab->con[con].index < tab->n_redundant;
 }
 
-/* Take a snapshot of the tableau that can be restored by s call to
+/* Is variable "var" of "tab" fixed to a constant value by its row
+ * in the tableau?
+ * If so and if "value" is not NULL, then store this constant value
+ * in "value".
+ *
+ * That is, is it a row variable that only has non-zero coefficients
+ * for dead columns?
+ */
+static isl_bool is_constant(struct isl_tab *tab, struct isl_tab_var *var,
+	isl_int *value)
+{
+	unsigned off = 2 + tab->M;
+	isl_mat *mat = tab->mat;
+	int n;
+	int row;
+	int pos;
+
+	if (!var->is_row)
+		return isl_bool_false;
+	row = var->index;
+	if (row_is_big(tab, row))
+		return isl_bool_false;
+	n = tab->n_col - tab->n_dead;
+	pos = isl_seq_first_non_zero(mat->row[row] + off + tab->n_dead, n);
+	if (pos != -1)
+		return isl_bool_false;
+	if (value)
+		isl_int_divexact(*value, mat->row[row][1], mat->row[row][0]);
+	return isl_bool_true;
+}
+
+/* Has the variable "var' of "tab" reached a value that is greater than
+ * or equal (if sgn > 0) or smaller than or equal (if sgn < 0) to "target"?
+ * "tmp" has been initialized by the caller and can be used
+ * to perform local computations.
+ *
+ * If the sample value involves the big parameter, then any value
+ * is reached.
+ * Otherwise check if n/d >= t, i.e., n >= d * t (if sgn > 0)
+ * or n/d <= t, i.e., n <= d * t (if sgn < 0).
+ */
+static int reached(struct isl_tab *tab, struct isl_tab_var *var, int sgn,
+	isl_int target, isl_int *tmp)
+{
+	if (row_is_big(tab, var->index))
+		return 1;
+	isl_int_mul(*tmp, tab->mat->row[var->index][0], target);
+	if (sgn > 0)
+		return isl_int_ge(tab->mat->row[var->index][1], *tmp);
+	else
+		return isl_int_le(tab->mat->row[var->index][1], *tmp);
+}
+
+/* Can variable "var" of "tab" attain the value "target" by
+ * pivoting up (if sgn > 0) or down (if sgn < 0)?
+ * If not, then pivot up [down] to the greatest [smallest]
+ * rational value.
+ * "tmp" has been initialized by the caller and can be used
+ * to perform local computations.
+ *
+ * If the variable is manifestly unbounded in the desired direction,
+ * then it can attain any value.
+ * Otherwise, it can be moved to a row.
+ * Continue pivoting until the target is reached.
+ * If no more pivoting can be performed, the maximal [minimal]
+ * rational value has been reached and the target cannot be reached.
+ * If the variable would be pivoted into a manifestly unbounded column,
+ * then the target can be reached.
+ */
+static isl_bool var_reaches(struct isl_tab *tab, struct isl_tab_var *var,
+	int sgn, isl_int target, isl_int *tmp)
+{
+	int row, col;
+
+	if (sgn < 0 && min_is_manifestly_unbounded(tab, var))
+		return isl_bool_true;
+	if (sgn > 0 && max_is_manifestly_unbounded(tab, var))
+		return isl_bool_true;
+	if (to_row(tab, var, sgn) < 0)
+		return isl_bool_error;
+	while (!reached(tab, var, sgn, target, tmp)) {
+		find_pivot(tab, var, var, sgn, &row, &col);
+		if (row == -1)
+			return isl_bool_false;
+		if (row == var->index)
+			return isl_bool_true;
+		if (isl_tab_pivot(tab, row, col) < 0)
+			return isl_bool_error;
+	}
+
+	return isl_bool_true;
+}
+
+/* Check if variable "var" of "tab" can only attain a single (integer)
+ * value, and, if so, add an equality constraint to fix the variable
+ * to this single value and store the result in "target".
+ * "target" and "tmp" have been initialized by the caller.
+ *
+ * Given the current sample value, round it down and check
+ * whether it is possible to attain a strictly smaller integer value.
+ * If so, the variable is not restricted to a single integer value.
+ * Otherwise, the search stops at the smallest rational value.
+ * Round up this value and check whether it is possible to attain
+ * a strictly greater integer value.
+ * If so, the variable is not restricted to a single integer value.
+ * Otherwise, the search stops at the greatest rational value.
+ * If rounding down this value yields a value that is different
+ * from rounding up the smallest rational value, then the variable
+ * cannot attain any integer value.  Mark the tableau empty.
+ * Otherwise, add an equality constraint that fixes the variable
+ * to the single integer value found.
+ */
+static isl_bool detect_constant_with_tmp(struct isl_tab *tab,
+	struct isl_tab_var *var, isl_int *target, isl_int *tmp)
+{
+	isl_bool reached;
+	isl_vec *eq;
+	int pos;
+	isl_stat r;
+
+	get_rounded_sample_value(tab, var, -1, target);
+	isl_int_sub_ui(*target, *target, 1);
+	reached = var_reaches(tab, var, -1, *target, tmp);
+	if (reached < 0 || reached)
+		return isl_bool_not(reached);
+	get_rounded_sample_value(tab, var, 1, target);
+	isl_int_add_ui(*target, *target, 1);
+	reached = var_reaches(tab, var, 1, *target, tmp);
+	if (reached < 0 || reached)
+		return isl_bool_not(reached);
+	get_rounded_sample_value(tab, var, -1, tmp);
+	isl_int_sub_ui(*target, *target, 1);
+	if (isl_int_ne(*target, *tmp)) {
+		if (isl_tab_mark_empty(tab) < 0)
+			return isl_bool_error;
+		return isl_bool_false;
+	}
+
+	if (isl_tab_extend_cons(tab, 1) < 0)
+		return isl_bool_error;
+	eq = isl_vec_alloc(isl_tab_get_ctx(tab), 1 + tab->n_var);
+	if (!eq)
+		return isl_bool_error;
+	pos = var - tab->var;
+	isl_seq_clr(eq->el + 1, tab->n_var);
+	isl_int_set_si(eq->el[1 + pos], -1);
+	isl_int_set(eq->el[0], *target);
+	r = isl_tab_add_eq(tab, eq->el);
+	isl_vec_free(eq);
+
+	return r < 0 ? isl_bool_error : isl_bool_true;
+}
+
+/* Check if variable "var" of "tab" can only attain a single (integer)
+ * value, and, if so, add an equality constraint to fix the variable
+ * to this single value and store the result in "value" (if "value"
+ * is not NULL).
+ *
+ * If the current sample value involves the big parameter,
+ * then the variable cannot have a fixed integer value.
+ * If the variable is already fixed to a single value by its row, then
+ * there is no need to add another equality constraint.
+ *
+ * Otherwise, allocate some temporary variables and continue
+ * with detect_constant_with_tmp.
+ */
+static isl_bool get_constant(struct isl_tab *tab, struct isl_tab_var *var,
+	isl_int *value)
+{
+	isl_int target, tmp;
+	isl_bool is_cst;
+
+	if (var->is_row && row_is_big(tab, var->index))
+		return isl_bool_false;
+	is_cst = is_constant(tab, var, value);
+	if (is_cst < 0 || is_cst)
+		return is_cst;
+
+	if (!value)
+		isl_int_init(target);
+	isl_int_init(tmp);
+
+	is_cst = detect_constant_with_tmp(tab, var,
+					    value ? value : &target, &tmp);
+
+	isl_int_clear(tmp);
+	if (!value)
+		isl_int_clear(target);
+
+	return is_cst;
+}
+
+/* Check if variable "var" of "tab" can only attain a single (integer)
+ * value, and, if so, add an equality constraint to fix the variable
+ * to this single value and store the result in "value" (if "value"
+ * is not NULL).
+ *
+ * For rational tableaus, nothing needs to be done.
+ */
+isl_bool isl_tab_is_constant(struct isl_tab *tab, int var, isl_int *value)
+{
+	if (!tab)
+		return isl_bool_error;
+	if (var < 0 || var >= tab->n_var)
+		isl_die(isl_tab_get_ctx(tab), isl_error_invalid,
+			"position out of bounds", return isl_bool_error);
+	if (tab->rational)
+		return isl_bool_false;
+
+	return get_constant(tab, &tab->var[var], value);
+}
+
+/* Check if any of the variables of "tab" can only attain a single (integer)
+ * value, and, if so, add equality constraints to fix those variables
+ * to these single values.
+ *
+ * For rational tableaus, nothing needs to be done.
+ */
+isl_stat isl_tab_detect_constants(struct isl_tab *tab)
+{
+	int i;
+
+	if (!tab)
+		return isl_stat_error;
+	if (tab->rational)
+		return isl_stat_ok;
+
+	for (i = 0; i < tab->n_var; ++i) {
+		if (get_constant(tab, &tab->var[i], NULL) < 0)
+			return isl_stat_error;
+	}
+
+	return isl_stat_ok;
+}
+
+/* Take a snapshot of the tableau that can be restored by a call to
  * isl_tab_rollback.
  */
 struct isl_tab_undo *isl_tab_snap(struct isl_tab *tab)
@@ -3247,23 +3558,50 @@ struct isl_tab_undo *isl_tab_snap(struct isl_tab *tab)
 	return tab->top;
 }
 
+/* Does "tab" need to keep track of undo information?
+ * That is, was a snapshot taken that may need to be restored?
+ */
+isl_bool isl_tab_need_undo(struct isl_tab *tab)
+{
+	if (!tab)
+		return isl_bool_error;
+
+	return tab->need_undo;
+}
+
+/* Remove all tracking of undo information from "tab", invalidating
+ * any snapshots that may have been taken of the tableau.
+ * Since all snapshots have been invalidated, there is also
+ * no need to start keeping track of undo information again.
+ */
+void isl_tab_clear_undo(struct isl_tab *tab)
+{
+	if (!tab)
+		return;
+
+	free_undo(tab);
+	tab->need_undo = 0;
+}
+
 /* Undo the operation performed by isl_tab_relax.
  */
-static int unrelax(struct isl_tab *tab, struct isl_tab_var *var) WARN_UNUSED;
-static int unrelax(struct isl_tab *tab, struct isl_tab_var *var)
+static isl_stat unrelax(struct isl_tab *tab, struct isl_tab_var *var)
+	WARN_UNUSED;
+static isl_stat unrelax(struct isl_tab *tab, struct isl_tab_var *var)
 {
 	unsigned off = 2 + tab->M;
 
 	if (!var->is_row && !max_is_manifestly_unbounded(tab, var))
 		if (to_row(tab, var, 1) < 0)
-			return -1;
+			return isl_stat_error;
 
 	if (var->is_row) {
 		isl_int_sub(tab->mat->row[var->index][1],
 		    tab->mat->row[var->index][1], tab->mat->row[var->index][0]);
 		if (var->is_nonneg) {
 			int sgn = restore_row(tab, var);
-			isl_assert(tab->mat->ctx, sgn >= 0, return -1);
+			isl_assert(tab->mat->ctx, sgn >= 0,
+				return isl_stat_error);
 		}
 	} else {
 		int i;
@@ -3277,7 +3615,7 @@ static int unrelax(struct isl_tab *tab, struct isl_tab_var *var)
 
 	}
 
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Undo the operation performed by isl_tab_unrestrict.
@@ -3285,18 +3623,42 @@ static int unrelax(struct isl_tab *tab, struct isl_tab_var *var)
  * In particular, mark the variable as being non-negative and make
  * sure the sample value respects this constraint.
  */
-static int ununrestrict(struct isl_tab *tab, struct isl_tab_var *var)
+static isl_stat ununrestrict(struct isl_tab *tab, struct isl_tab_var *var)
 {
 	var->is_nonneg = 1;
 
 	if (var->is_row && restore_row(tab, var) < -1)
-		return -1;
+		return isl_stat_error;
 
-	return 0;
+	return isl_stat_ok;
+}
+
+/* Unmark the last redundant row in "tab" as being redundant.
+ * This undoes part of the modifications performed by isl_tab_mark_redundant.
+ * In particular, remove the redundant mark and make
+ * sure the sample value respects the constraint again.
+ * A variable that is marked non-negative by isl_tab_mark_redundant
+ * is covered by a separate undo record.
+ */
+static isl_stat restore_last_redundant(struct isl_tab *tab)
+{
+	struct isl_tab_var *var;
+
+	if (tab->n_redundant < 1)
+		isl_die(isl_tab_get_ctx(tab), isl_error_internal,
+			"no redundant rows", return isl_stat_error);
+
+	var = isl_tab_var_from_row(tab, tab->n_redundant - 1);
+	var->is_redundant = 0;
+	tab->n_redundant--;
+	restore_row(tab, var);
+
+	return isl_stat_ok;
 }
 
-static int perform_undo_var(struct isl_tab *tab, struct isl_tab_undo *undo) WARN_UNUSED;
-static int perform_undo_var(struct isl_tab *tab, struct isl_tab_undo *undo)
+static isl_stat perform_undo_var(struct isl_tab *tab, struct isl_tab_undo *undo)
+	WARN_UNUSED;
+static isl_stat perform_undo_var(struct isl_tab *tab, struct isl_tab_undo *undo)
 {
 	struct isl_tab_var *var = var_from_index(tab, undo->u.var_index);
 	switch (undo->type) {
@@ -3304,10 +3666,10 @@ static int perform_undo_var(struct isl_tab *tab, struct isl_tab_undo *undo)
 		var->is_nonneg = 0;
 		break;
 	case isl_tab_undo_redundant:
-		var->is_redundant = 0;
-		tab->n_redundant--;
-		restore_row(tab, isl_tab_var_from_row(tab, tab->n_redundant));
-		break;
+		if (!var->is_row || var->index != tab->n_redundant - 1)
+			isl_die(isl_tab_get_ctx(tab), isl_error_internal,
+				"not undoing last redundant row", return -1);
+		return restore_last_redundant(tab);
 	case isl_tab_undo_freeze:
 		var->frozen = 0;
 		break;
@@ -3318,19 +3680,20 @@ static int perform_undo_var(struct isl_tab *tab, struct isl_tab_undo *undo)
 		break;
 	case isl_tab_undo_allocate:
 		if (undo->u.var_index >= 0) {
-			isl_assert(tab->mat->ctx, !var->is_row, return -1);
+			isl_assert(tab->mat->ctx, !var->is_row,
+				return isl_stat_error);
 			return drop_col(tab, var->index);
 		}
 		if (!var->is_row) {
 			if (!max_is_manifestly_unbounded(tab, var)) {
 				if (to_row(tab, var, 1) < 0)
-					return -1;
+					return isl_stat_error;
 			} else if (!min_is_manifestly_unbounded(tab, var)) {
 				if (to_row(tab, var, -1) < 0)
-					return -1;
+					return isl_stat_error;
 			} else
 				if (to_row(tab, var, 0) < 0)
-					return -1;
+					return isl_stat_error;
 		}
 		return drop_row(tab, var->index);
 	case isl_tab_undo_relax:
@@ -3340,10 +3703,59 @@ static int perform_undo_var(struct isl_tab *tab, struct isl_tab_undo *undo)
 	default:
 		isl_die(tab->mat->ctx, isl_error_internal,
 			"perform_undo_var called on invalid undo record",
-			return -1);
+			return isl_stat_error);
 	}
 
-	return 0;
+	return isl_stat_ok;
+}
+
+/* Restore all rows that have been marked redundant by isl_tab_mark_redundant
+ * and that have been preserved in the tableau.
+ * Note that isl_tab_mark_redundant may also have marked some variables
+ * as being non-negative before marking them redundant.  These need
+ * to be removed as well as otherwise some constraints could end up
+ * getting marked redundant with respect to the variable.
+ */
+isl_stat isl_tab_restore_redundant(struct isl_tab *tab)
+{
+	if (!tab)
+		return isl_stat_error;
+
+	if (tab->need_undo)
+		isl_die(isl_tab_get_ctx(tab), isl_error_invalid,
+			"manually restoring redundant constraints "
+			"interferes with undo history",
+			return isl_stat_error);
+
+	while (tab->n_redundant > 0) {
+		if (tab->row_var[tab->n_redundant - 1] >= 0) {
+			struct isl_tab_var *var;
+
+			var = isl_tab_var_from_row(tab, tab->n_redundant - 1);
+			var->is_nonneg = 0;
+		}
+		restore_last_redundant(tab);
+	}
+	return isl_stat_ok;
+}
+
+/* Undo the addition of an integer division to the basic map representation
+ * of "tab" in position "pos".
+ */
+static isl_stat drop_bmap_div(struct isl_tab *tab, int pos)
+{
+	int off;
+
+	off = tab->n_var - isl_basic_map_dim(tab->bmap, isl_dim_div);
+	if (isl_basic_map_drop_div(tab->bmap, pos - off) < 0)
+		return isl_stat_error;
+	if (tab->samples) {
+		tab->samples = isl_mat_drop_cols(tab->samples, 1 + pos, 1);
+		if (!tab->samples)
+			return isl_stat_error;
+	}
+
+	return isl_stat_ok;
 }
 
 /* Restore the tableau to the state where the basic variables
@@ -3424,8 +3836,9 @@ static void drop_samples_since(struct isl_tab *tab, int n)
 	}
 }
 
-static int perform_undo(struct isl_tab *tab, struct isl_tab_undo *undo) WARN_UNUSED;
-static int perform_undo(struct isl_tab *tab, struct isl_tab_undo *undo)
+static isl_stat perform_undo(struct isl_tab *tab, struct isl_tab_undo *undo)
+	WARN_UNUSED;
+static isl_stat perform_undo(struct isl_tab *tab, struct isl_tab_undo *undo)
 {
 	switch (undo->type) {
 	case isl_tab_undo_rational:
@@ -3447,14 +3860,10 @@ static int perform_undo(struct isl_tab *tab, struct isl_tab_undo *undo)
 	case isl_tab_undo_bmap_ineq:
 		return isl_basic_map_free_inequality(tab->bmap, 1);
 	case isl_tab_undo_bmap_div:
-		if (isl_basic_map_free_div(tab->bmap, 1) < 0)
-			return -1;
-		if (tab->samples)
-			tab->samples->n_col--;
-		break;
+		return drop_bmap_div(tab, undo->u.var_index);
 	case isl_tab_undo_saved_basis:
 		if (restore_basis(tab, undo->u.col_var) < 0)
-			return -1;
+			return isl_stat_error;
 		break;
 	case isl_tab_undo_drop_sample:
 		tab->n_outside--;
@@ -3465,9 +3874,9 @@ static int perform_undo(struct isl_tab *tab, struct isl_tab_undo *undo)
 	case isl_tab_undo_callback:
 		return undo->u.callback->run(undo->u.callback);
 	default:
-		isl_assert(tab->mat->ctx, 0, return -1);
+		isl_assert(tab->mat->ctx, 0, return isl_stat_error);
 	}
-	return 0;
+	return isl_stat_ok;
 }
 
 /* Return the tableau to the state it was in when the snapshot "snap"
@@ -3599,7 +4008,7 @@ error:
 	return isl_ineq_error;
 }
 
-int isl_tab_track_bmap(struct isl_tab *tab, __isl_take isl_basic_map *bmap)
+isl_stat isl_tab_track_bmap(struct isl_tab *tab, __isl_take isl_basic_map *bmap)
 {
 	bmap = isl_basic_map_cow(bmap);
 	if (!tab || !bmap)
@@ -3610,7 +4019,7 @@ int isl_tab_track_bmap(struct isl_tab *tab, __isl_take isl_basic_map *bmap)
 		if (!bmap)
 			goto error;
 		tab->bmap = bmap;
-		return 0;
+		return isl_stat_ok;
 	}
 
 	isl_assert(tab->mat->ctx, tab->n_eq == bmap->n_eq, goto error);
@@ -3619,15 +4028,15 @@ int isl_tab_track_bmap(struct isl_tab *tab, __isl_take isl_basic_map *bmap)
 
 	tab->bmap = bmap;
 
-	return 0;
+	return isl_stat_ok;
 error:
 	isl_basic_map_free(bmap);
-	return -1;
+	return isl_stat_error;
 }
 
-int isl_tab_track_bset(struct isl_tab *tab, __isl_take isl_basic_set *bset)
+isl_stat isl_tab_track_bset(struct isl_tab *tab, __isl_take isl_basic_set *bset)
 {
-	return isl_tab_track_bmap(tab, (isl_basic_map *)bset);
+	return isl_tab_track_bmap(tab, bset_to_bmap(bset));
 }
 
 __isl_keep isl_basic_set *isl_tab_peek_bset(struct isl_tab *tab)
@@ -3635,7 +4044,7 @@ __isl_keep isl_basic_set *isl_tab_peek_bset(struct isl_tab *tab)
 	if (!tab)
 		return NULL;
 
-	return (isl_basic_set *)tab->bmap;
+	return bset_from_bmap(tab->bmap);
 }
 
 static void isl_tab_print_internal(__isl_keep struct isl_tab *tab,
diff --git a/lib/Analysis/isl/isl_tab.h b/lib/Analysis/isl/isl_tab.h
index 7dbdd9f..a1dacd9 100644
--- a/lib/Analysis/isl/isl_tab.h
+++ b/lib/Analysis/isl/isl_tab.h
@@ -48,7 +48,7 @@ enum isl_tab_undo_type {
 };
 
 struct isl_tab_callback {
-	int (*run)(struct isl_tab_callback *cb);
+	isl_stat (*run)(struct isl_tab_callback *cb);
 };
 
 union isl_tab_undo_val {
@@ -192,7 +192,7 @@ __isl_give struct isl_tab *isl_tab_from_basic_set(
 	__isl_keep isl_basic_set *bset, int track);
 struct isl_tab *isl_tab_from_recession_cone(struct isl_basic_set *bset,
 	int parametric);
-int isl_tab_cone_is_bounded(struct isl_tab *tab);
+isl_bool isl_tab_cone_is_bounded(struct isl_tab *tab);
 struct isl_basic_map *isl_basic_map_update_from_tab(struct isl_basic_map *bmap,
 	struct isl_tab *tab);
 struct isl_basic_set *isl_basic_set_update_from_tab(struct isl_basic_set *bset,
@@ -201,19 +201,22 @@ int isl_tab_detect_implicit_equalities(struct isl_tab *tab) WARN_UNUSED;
 __isl_give isl_basic_map *isl_tab_make_equalities_explicit(struct isl_tab *tab,
 	__isl_take isl_basic_map *bmap);
 int isl_tab_detect_redundant(struct isl_tab *tab) WARN_UNUSED;
+isl_stat isl_tab_restore_redundant(struct isl_tab *tab);
 #define ISL_TAB_SAVE_DUAL	(1 << 0)
 enum isl_lp_result isl_tab_min(struct isl_tab *tab,
 	isl_int *f, isl_int denom, isl_int *opt, isl_int *opt_denom,
 	unsigned flags) WARN_UNUSED;
 
-int isl_tab_add_ineq(struct isl_tab *tab, isl_int *ineq) WARN_UNUSED;
+isl_stat isl_tab_add_ineq(struct isl_tab *tab, isl_int *ineq) WARN_UNUSED;
 int isl_tab_add_eq(struct isl_tab *tab, isl_int *eq) WARN_UNUSED;
 int isl_tab_add_valid_eq(struct isl_tab *tab, isl_int *eq) WARN_UNUSED;
 
 int isl_tab_freeze_constraint(struct isl_tab *tab, int con) WARN_UNUSED;
 
-int isl_tab_track_bmap(struct isl_tab *tab, __isl_take isl_basic_map *bmap) WARN_UNUSED;
-int isl_tab_track_bset(struct isl_tab *tab, __isl_take isl_basic_set *bset) WARN_UNUSED;
+isl_stat isl_tab_track_bmap(struct isl_tab *tab, __isl_take isl_basic_map *bmap)
+	WARN_UNUSED;
+isl_stat isl_tab_track_bset(struct isl_tab *tab, __isl_take isl_basic_set *bset)
+	WARN_UNUSED;
 __isl_keep isl_basic_set *isl_tab_peek_bset(struct isl_tab *tab);
 
 int isl_tab_is_equality(struct isl_tab *tab, int con);
@@ -235,6 +238,8 @@ enum isl_ineq_type isl_tab_ineq_type(struct isl_tab *tab, isl_int *ineq);
 
 struct isl_tab_undo *isl_tab_snap(struct isl_tab *tab);
 int isl_tab_rollback(struct isl_tab *tab, struct isl_tab_undo *snap) WARN_UNUSED;
+isl_bool isl_tab_need_undo(struct isl_tab *tab);
+void isl_tab_clear_undo(struct isl_tab *tab);
 
 int isl_tab_relax(struct isl_tab *tab, int con) WARN_UNUSED;
 int isl_tab_select_facet(struct isl_tab *tab, int con) WARN_UNUSED;
@@ -242,27 +247,33 @@ int isl_tab_unrestrict(struct isl_tab *tab, int con) WARN_UNUSED;
 
 void isl_tab_dump(__isl_keep struct isl_tab *tab);
 
-struct isl_map *isl_tab_basic_map_partial_lexopt(
-		struct isl_basic_map *bmap, struct isl_basic_set *dom,
-		struct isl_set **empty, int max);
-__isl_give isl_pw_multi_aff *isl_basic_map_partial_lexopt_pw_multi_aff(
+/* Compute maximum instead of minimum. */
+#define ISL_OPT_MAX		(1 << 0)
+/* Compute full instead of partial optimum; also, domain argument is NULL. */
+#define ISL_OPT_FULL		(1 << 1)
+/* Result should be free of (unknown) quantified variables. */
+#define ISL_OPT_QE		(1 << 2)
+__isl_give isl_map *isl_tab_basic_map_partial_lexopt(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty, int max);
+	__isl_give isl_set **empty, unsigned flags);
+__isl_give isl_pw_multi_aff *isl_tab_basic_map_partial_lexopt_pw_multi_aff(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty, unsigned flags);
 
-/* An isl_region represents a sequence of consecutive variables.
+/* An isl_trivial_region represents a non-triviality region.
+ * The region is trivial if applying "trivial" to a given sequence
+ * of variables results in a zero vector.
  * pos is the location (starting at 0) of the first variable in the sequence.
  */
-struct isl_region {
+struct isl_trivial_region {
 	int pos;
-	int len;
+	isl_mat *trivial;
 };
 
 __isl_give isl_vec *isl_tab_basic_set_non_trivial_lexmin(
 	__isl_take isl_basic_set *bset, int n_op, int n_region,
-	struct isl_region *region,
+	struct isl_trivial_region *region,
 	int (*conflict)(int con, void *user), void *user);
-__isl_give isl_vec *isl_tab_basic_set_non_neg_lexmin(
-	__isl_take isl_basic_set *bset);
 
 struct isl_tab_lexmin;
 typedef struct isl_tab_lexmin isl_tab_lexmin;
@@ -272,6 +283,8 @@ __isl_give isl_tab_lexmin *isl_tab_lexmin_from_basic_set(
 int isl_tab_lexmin_dim(__isl_keep isl_tab_lexmin *tl);
 __isl_give isl_tab_lexmin *isl_tab_lexmin_add_eq(__isl_take isl_tab_lexmin *tl,
 	isl_int *eq);
+__isl_give isl_tab_lexmin *isl_tab_lexmin_cut_to_integer(
+	__isl_take isl_tab_lexmin *tl);
 __isl_give isl_vec *isl_tab_lexmin_get_solution(__isl_keep isl_tab_lexmin *tl);
 __isl_null isl_tab_lexmin *isl_tab_lexmin_free(__isl_take isl_tab_lexmin *tl);
 
@@ -280,7 +293,7 @@ __isl_null isl_tab_lexmin *isl_tab_lexmin_free(__isl_take isl_tab_lexmin *tl);
 struct isl_tab_var *isl_tab_var_from_row(struct isl_tab *tab, int i);
 int isl_tab_mark_redundant(struct isl_tab *tab, int row) WARN_UNUSED;
 int isl_tab_mark_rational(struct isl_tab *tab) WARN_UNUSED;
-int isl_tab_mark_empty(struct isl_tab *tab) WARN_UNUSED;
+isl_stat isl_tab_mark_empty(struct isl_tab *tab) WARN_UNUSED;
 struct isl_tab *isl_tab_dup(struct isl_tab *tab);
 struct isl_tab *isl_tab_product(struct isl_tab *tab1, struct isl_tab *tab2);
 int isl_tab_extend_cons(struct isl_tab *tab, unsigned n_new) WARN_UNUSED;
@@ -308,12 +321,15 @@ int isl_tab_save_samples(struct isl_tab *tab) WARN_UNUSED;
 
 struct isl_tab *isl_tab_detect_equalities(struct isl_tab *tab,
 	struct isl_tab *tab_cone) WARN_UNUSED;
+isl_bool isl_tab_is_constant(struct isl_tab *tab, int var, isl_int *value);
+isl_stat isl_tab_detect_constants(struct isl_tab *tab);
 
 int isl_tab_push_callback(struct isl_tab *tab,
 	struct isl_tab_callback *callback) WARN_UNUSED;
 
-int isl_tab_add_div(struct isl_tab *tab, __isl_keep isl_vec *div,
-	int (*add_ineq)(void *user, isl_int *), void *user);
+int isl_tab_insert_div(struct isl_tab *tab, int pos, __isl_keep isl_vec *div,
+	isl_stat (*add_ineq)(void *user, isl_int *), void *user);
+int isl_tab_add_div(struct isl_tab *tab, __isl_keep isl_vec *div);
 
 int isl_tab_shift_var(struct isl_tab *tab, int pos, isl_int shift) WARN_UNUSED;
 
diff --git a/lib/Analysis/isl/isl_tab_lexopt_templ.c b/lib/Analysis/isl/isl_tab_lexopt_templ.c
new file mode 100644
index 0000000..751e7bf
--- /dev/null
+++ b/lib/Analysis/isl/isl_tab_lexopt_templ.c
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2008-2009 Katholieke Universiteit Leuven
+ * Copyright 2010      INRIA Saclay
+ * Copyright 2011      Sven Verdoolaege
+ *
+ * Use of this software is governed by the MIT license
+ *
+ * Written by Sven Verdoolaege, K.U.Leuven, Departement
+ * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium
+ * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,
+ * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France
+ */
+
+#define xSF(TYPE,SUFFIX) TYPE ## SUFFIX
+#define SF(TYPE,SUFFIX) xSF(TYPE,SUFFIX)
+
+/* Given a basic map with at least two parallel constraints (as found
+ * by the function parallel_constraints), first look for more constraints
+ * parallel to the two constraint and replace the found list of parallel
+ * constraints by a single constraint with as "input" part the minimum
+ * of the input parts of the list of constraints.  Then, recursively call
+ * basic_map_partial_lexopt (possibly finding more parallel constraints)
+ * and plug in the definition of the minimum in the result.
+ *
+ * As in parallel_constraints, only inequality constraints that only
+ * involve input variables that do not occur in any other inequality
+ * constraints are considered.
+ *
+ * More specifically, given a set of constraints
+ *
+ *	a x + b_i(p) >= 0
+ *
+ * Replace this set by a single constraint
+ *
+ *	a x + u >= 0
+ *
+ * with u a new parameter with constraints
+ *
+ *	u <= b_i(p)
+ *
+ * Any solution to the new system is also a solution for the original system
+ * since
+ *
+ *	a x >= -u >= -b_i(p)
+ *
+ * Moreover, m = min_i(b_i(p)) satisfies the constraints on u and can
+ * therefore be plugged into the solution.
+ */
+static TYPE *SF(basic_map_partial_lexopt_symm,SUFFIX)(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty, int max, int first, int second)
+{
+	int i, n, k;
+	int *list = NULL;
+	unsigned n_in, n_out, n_div;
+	isl_ctx *ctx;
+	isl_vec *var = NULL;
+	isl_mat *cst = NULL;
+	isl_space *map_space, *set_space;
+
+	map_space = isl_basic_map_get_space(bmap);
+	set_space = empty ? isl_basic_set_get_space(dom) : NULL;
+
+	n_in = isl_basic_map_dim(bmap, isl_dim_param) +
+	       isl_basic_map_dim(bmap, isl_dim_in);
+	n_out = isl_basic_map_dim(bmap, isl_dim_all) - n_in;
+
+	ctx = isl_basic_map_get_ctx(bmap);
+	list = isl_alloc_array(ctx, int, bmap->n_ineq);
+	var = isl_vec_alloc(ctx, n_out);
+	if ((bmap->n_ineq && !list) || (n_out && !var))
+		goto error;
+
+	list[0] = first;
+	list[1] = second;
+	isl_seq_cpy(var->el, bmap->ineq[first] + 1 + n_in, n_out);
+	for (i = second + 1, n = 2; i < bmap->n_ineq; ++i) {
+		if (isl_seq_eq(var->el, bmap->ineq[i] + 1 + n_in, n_out) &&
+		    all_single_occurrence(bmap, i, n_in))
+			list[n++] = i;
+	}
+
+	cst = isl_mat_alloc(ctx, n, 1 + n_in);
+	if (!cst)
+		goto error;
+
+	for (i = 0; i < n; ++i)
+		isl_seq_cpy(cst->row[i], bmap->ineq[list[i]], 1 + n_in);
+
+	bmap = isl_basic_map_cow(bmap);
+	if (!bmap)
+		goto error;
+	for (i = n - 1; i >= 0; --i)
+		if (isl_basic_map_drop_inequality(bmap, list[i]) < 0)
+			goto error;
+
+	bmap = isl_basic_map_add_dims(bmap, isl_dim_in, 1);
+	bmap = isl_basic_map_extend_constraints(bmap, 0, 1);
+	k = isl_basic_map_alloc_inequality(bmap);
+	if (k < 0)
+		goto error;
+	isl_seq_clr(bmap->ineq[k], 1 + n_in);
+	isl_int_set_si(bmap->ineq[k][1 + n_in], 1);
+	isl_seq_cpy(bmap->ineq[k] + 1 + n_in + 1, var->el, n_out);
+	bmap = isl_basic_map_finalize(bmap);
+
+	n_div = isl_basic_set_dim(dom, isl_dim_div);
+	dom = isl_basic_set_add_dims(dom, isl_dim_set, 1);
+	dom = isl_basic_set_extend_constraints(dom, 0, n);
+	for (i = 0; i < n; ++i) {
+		k = isl_basic_set_alloc_inequality(dom);
+		if (k < 0)
+			goto error;
+		isl_seq_cpy(dom->ineq[k], cst->row[i], 1 + n_in);
+		isl_int_set_si(dom->ineq[k][1 + n_in], -1);
+		isl_seq_clr(dom->ineq[k] + 1 + n_in + 1, n_div);
+	}
+
+	isl_vec_free(var);
+	free(list);
+
+	return SF(basic_map_partial_lexopt_symm_core,SUFFIX)(bmap, dom, empty,
+						max, cst, map_space, set_space);
+error:
+	isl_space_free(map_space);
+	isl_space_free(set_space);
+	isl_mat_free(cst);
+	isl_vec_free(var);
+	free(list);
+	isl_basic_set_free(dom);
+	isl_basic_map_free(bmap);
+	return NULL;
+}
+
+/* Recursive part of isl_tab_basic_map_partial_lexopt*, after detecting
+ * equalities and removing redundant constraints.
+ *
+ * We first check if there are any parallel constraints (left).
+ * If not, we are in the base case.
+ * If there are parallel constraints, we replace them by a single
+ * constraint in basic_map_partial_lexopt_symm_pma and then call
+ * this function recursively to look for more parallel constraints.
+ */
+static __isl_give TYPE *SF(basic_map_partial_lexopt,SUFFIX)(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty, int max)
+{
+	isl_bool par = isl_bool_false;
+	int first, second;
+
+	if (!bmap)
+		goto error;
+
+	if (bmap->ctx->opt->pip_symmetry)
+		par = parallel_constraints(bmap, &first, &second);
+	if (par < 0)
+		goto error;
+	if (!par)
+		return SF(basic_map_partial_lexopt_base,SUFFIX)(bmap, dom,
+								empty, max);
+
+	return SF(basic_map_partial_lexopt_symm,SUFFIX)(bmap, dom, empty, max,
+							 first, second);
+error:
+	isl_basic_set_free(dom);
+	isl_basic_map_free(bmap);
+	return NULL;
+}
+
+/* Compute the lexicographic minimum (or maximum if "flags" includes
+ * ISL_OPT_MAX) of "bmap" over the domain "dom" and return the result as
+ * either a map or a piecewise multi-affine expression depending on TYPE.
+ * If "empty" is not NULL, then *empty is assigned a set that
+ * contains those parts of the domain where there is no solution.
+ * If "flags" includes ISL_OPT_FULL, then "dom" is NULL and the optimum
+ * should be computed over the domain of "bmap".  "empty" is also NULL
+ * in this case.
+ * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
+ * then we compute the rational optimum.  Otherwise, we compute
+ * the integral optimum.
+ *
+ * We perform some preprocessing.  As the PILP solver does not
+ * handle implicit equalities very well, we first make sure all
+ * the equalities are explicitly available.
+ *
+ * We also add context constraints to the basic map and remove
+ * redundant constraints.  This is only needed because of the
+ * way we handle simple symmetries.  In particular, we currently look
+ * for symmetries on the constraints, before we set up the main tableau.
+ * It is then no good to look for symmetries on possibly redundant constraints.
+ * If the domain was extracted from the basic map, then there is
+ * no need to add back those constraints again.
+ */
+__isl_give TYPE *SF(isl_tab_basic_map_partial_lexopt,SUFFIX)(
+	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
+	__isl_give isl_set **empty, unsigned flags)
+{
+	int max, full;
+	isl_bool compatible;
+
+	if (empty)
+		*empty = NULL;
+
+	full = ISL_FL_ISSET(flags, ISL_OPT_FULL);
+	if (full)
+		dom = extract_domain(bmap, flags);
+	compatible = isl_basic_map_compatible_domain(bmap, dom);
+	if (compatible < 0)
+		goto error;
+	if (!compatible)
+		isl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,
+			"domain does not match input", goto error);
+
+	max = ISL_FL_ISSET(flags, ISL_OPT_MAX);
+	if (isl_basic_set_dim(dom, isl_dim_all) == 0)
+		return SF(basic_map_partial_lexopt,SUFFIX)(bmap, dom, empty,
+							    max);
+
+	if (!full)
+		bmap = isl_basic_map_intersect_domain(bmap,
+						    isl_basic_set_copy(dom));
+	bmap = isl_basic_map_detect_equalities(bmap);
+	bmap = isl_basic_map_remove_redundancies(bmap);
+
+	return SF(basic_map_partial_lexopt,SUFFIX)(bmap, dom, empty, max);
+error:
+	isl_basic_set_free(dom);
+	isl_basic_map_free(bmap);
+	return NULL;
+}
diff --git a/lib/Analysis/isl/isl_tab_pip.c b/lib/Analysis/isl/isl_tab_pip.c
index 2f3d271..d4747b4 100644
--- a/lib/Analysis/isl/isl_tab_pip.c
+++ b/lib/Analysis/isl/isl_tab_pip.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2008-2009 Katholieke Universiteit Leuven
  * Copyright 2010      INRIA Saclay
+ * Copyright 2016-2017 Sven Verdoolaege
  *
  * Use of this software is governed by the MIT license
  *
@@ -18,9 +19,12 @@
 #include <isl_mat_private.h>
 #include <isl_vec_private.h>
 #include <isl_aff_private.h>
+#include <isl_constraint_private.h>
 #include <isl_options_private.h>
 #include <isl_config.h>
 
+#include <bset_to_bmap.c>
+
 /*
  * The implementation of parametric integer linear programming in this file
  * was inspired by the paper "Parametric Integer Programming" and the
@@ -89,8 +93,9 @@ struct isl_context_op {
 	/* return index of a div that corresponds to "div" */
 	int (*get_div)(struct isl_context *context, struct isl_tab *tab,
 			struct isl_vec *div);
-	/* add div "div" to context and return non-negativity */
-	int (*add_div)(struct isl_context *context, struct isl_vec *div);
+	/* insert div "div" to context at "pos" and return non-negativity */
+	isl_bool (*insert_div)(struct isl_context *context, int pos,
+		__isl_keep isl_vec *div);
 	int (*detect_equalities)(struct isl_context *context,
 			struct isl_tab *tab);
 	/* return row index of "best" split */
@@ -108,11 +113,17 @@ struct isl_context_op {
 	/* invalidate context */
 	void (*invalidate)(struct isl_context *context);
 	/* free context */
-	void (*free)(struct isl_context *context);
+	__isl_null struct isl_context *(*free)(struct isl_context *context);
 };
 
+/* Shared parts of context representation.
+ *
+ * "n_unknown" is the number of final unknown integer divisions
+ * in the input domain.
+ */
 struct isl_context {
 	struct isl_context_op *op;
+	int n_unknown;
 };
 
 struct isl_context_lex {
@@ -122,16 +133,15 @@ struct isl_context_lex {
 
 /* A stack (linked list) of solutions of subtrees of the search space.
  *
- * "M" describes the solution in terms of the dimensions of "dom".
- * The number of columns of "M" is one more than the total number
- * of dimensions of "dom".
+ * "ma" describes the solution as a function of "dom".
+ * In particular, the domain space of "ma" is equal to the space of "dom".
  *
- * If "M" is NULL, then there is no solution on "dom".
+ * If "ma" is NULL, then there is no solution on "dom".
  */
 struct isl_partial_sol {
 	int level;
 	struct isl_basic_set *dom;
-	struct isl_mat *M;
+	isl_multi_aff *ma;
 
 	struct isl_partial_sol *next;
 };
@@ -145,16 +155,29 @@ struct isl_sol_callback {
 /* isl_sol is an interface for constructing a solution to
  * a parametric integer linear programming problem.
  * Every time the algorithm reaches a state where a solution
- * can be read off from the tableau (including cases where the tableau
- * is empty), the function "add" is called on the isl_sol passed
- * to find_solutions_main.
+ * can be read off from the tableau, the function "add" is called
+ * on the isl_sol passed to find_solutions_main.  In a state where
+ * the tableau is empty, "add_empty" is called instead.
+ * "free" is called to free the implementation specific fields, if any.
+ *
+ * "error" is set if some error has occurred.  This flag invalidates
+ * the remainder of the data structure.
+ * If "rational" is set, then a rational optimization is being performed.
+ * "level" is the current level in the tree with nodes for each
+ * split in the context.
+ * If "max" is set, then a maximization problem is being solved, rather than
+ * a minimization problem, which means that the variables in the
+ * tableau have value "M - x" rather than "M + x".
+ * "n_out" is the number of output dimensions in the input.
+ * "space" is the space in which the solution (and also the input) lives.
  *
  * The context tableau is owned by isl_sol and is updated incrementally.
  *
- * There are currently two implementations of this interface,
+ * There are currently three implementations of this interface,
  * isl_sol_map, which simply collects the solutions in an isl_map
  * and (optionally) the parts of the context where there is no solution
- * in an isl_set, and
+ * in an isl_set,
+ * isl_sol_pma, which collects an isl_pw_multi_aff instead, and
  * isl_sol_for, which calls a user-defined function for each part of
  * the solution.
  */
@@ -164,10 +187,11 @@ struct isl_sol {
 	int level;
 	int max;
 	int n_out;
+	isl_space *space;
 	struct isl_context *context;
 	struct isl_partial_sol *partial;
 	void (*add)(struct isl_sol *sol,
-			    struct isl_basic_set *dom, struct isl_mat *M);
+		__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma);
 	void (*add_empty)(struct isl_sol *sol, struct isl_basic_set *bset);
 	void (*free)(struct isl_sol *sol);
 	struct isl_sol_callback	dec_level;
@@ -181,17 +205,23 @@ static void sol_free(struct isl_sol *sol)
 	for (partial = sol->partial; partial; partial = next) {
 		next = partial->next;
 		isl_basic_set_free(partial->dom);
-		isl_mat_free(partial->M);
+		isl_multi_aff_free(partial->ma);
 		free(partial);
 	}
+	isl_space_free(sol->space);
+	if (sol->context)
+		sol->context->op->free(sol->context);
 	sol->free(sol);
+	free(sol);
 }
 
-/* Push a partial solution represented by a domain and mapping M
+/* Push a partial solution represented by a domain and function "ma"
  * onto the stack of partial solutions.
+ * If "ma" is NULL, then "dom" represents a part of the domain
+ * with no solution.
  */
 static void sol_push_sol(struct isl_sol *sol,
-	struct isl_basic_set *dom, struct isl_mat *M)
+	__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)
 {
 	struct isl_partial_sol *partial;
 
@@ -204,7 +234,7 @@ static void sol_push_sol(struct isl_sol *sol,
 
 	partial->level = sol->level;
 	partial->dom = dom;
-	partial->M = M;
+	partial->ma = ma;
 	partial->next = sol->partial;
 
 	sol->partial = partial;
@@ -212,10 +242,110 @@ static void sol_push_sol(struct isl_sol *sol,
 	return;
 error:
 	isl_basic_set_free(dom);
-	isl_mat_free(M);
+	isl_multi_aff_free(ma);
 	sol->error = 1;
 }
 
+/* Check that the final columns of "M", starting at "first", are zero.
+ */
+static isl_stat check_final_columns_are_zero(__isl_keep isl_mat *M,
+	unsigned first)
+{
+	int i;
+	unsigned rows, cols, n;
+
+	if (!M)
+		return isl_stat_error;
+	rows = isl_mat_rows(M);
+	cols = isl_mat_cols(M);
+	n = cols - first;
+	for (i = 0; i < rows; ++i)
+		if (isl_seq_first_non_zero(M->row[i] + first, n) != -1)
+			isl_die(isl_mat_get_ctx(M), isl_error_internal,
+				"final columns should be zero",
+				return isl_stat_error);
+	return isl_stat_ok;
+}
+
+/* Set the affine expressions in "ma" according to the rows in "M", which
+ * are defined over the local space "ls".
+ * The matrix "M" may have extra (zero) columns beyond the number
+ * of variables in "ls".
+ */
+static __isl_give isl_multi_aff *set_from_affine_matrix(
+	__isl_take isl_multi_aff *ma, __isl_take isl_local_space *ls,
+	__isl_take isl_mat *M)
+{
+	int i, dim;
+	isl_aff *aff;
+
+	if (!ma || !ls || !M)
+		goto error;
+
+	dim = isl_local_space_dim(ls, isl_dim_all);
+	if (check_final_columns_are_zero(M, 1 + dim) < 0)
+		goto error;
+	for (i = 1; i < M->n_row; ++i) {
+		aff = isl_aff_alloc(isl_local_space_copy(ls));
+		if (aff) {
+			isl_int_set(aff->v->el[0], M->row[0][0]);
+			isl_seq_cpy(aff->v->el + 1, M->row[i], 1 + dim);
+		}
+		aff = isl_aff_normalize(aff);
+		ma = isl_multi_aff_set_aff(ma, i - 1, aff);
+	}
+	isl_local_space_free(ls);
+	isl_mat_free(M);
+
+	return ma;
+error:
+	isl_local_space_free(ls);
+	isl_mat_free(M);
+	isl_multi_aff_free(ma);
+	return NULL;
+}
+
+/* Push a partial solution represented by a domain and mapping M
+ * onto the stack of partial solutions.
+ *
+ * The affine matrix "M" maps the dimensions of the context
+ * to the output variables.  Convert it into an isl_multi_aff and
+ * then call sol_push_sol.
+ *
+ * Note that the description of the initial context may have involved
+ * existentially quantified variables, in which case they also appear
+ * in "dom".  These need to be removed before creating the affine
+ * expression because an affine expression cannot be defined in terms
+ * of existentially quantified variables without a known representation.
+ * Since newly added integer divisions are inserted before these
+ * existentially quantified variables, they are still in the final
+ * positions and the corresponding final columns of "M" are zero
+ * because align_context_divs adds the existentially quantified
+ * variables of the context to the main tableau without any constraints and
+ * any equality constraints that are added later on can only serve
+ * to eliminate these existentially quantified variables.
+ */
+static void sol_push_sol_mat(struct isl_sol *sol,
+	__isl_take isl_basic_set *dom, __isl_take isl_mat *M)
+{
+	isl_local_space *ls;
+	isl_multi_aff *ma;
+	int n_div, n_known;
+
+	n_div = isl_basic_set_dim(dom, isl_dim_div);
+	n_known = n_div - sol->context->n_unknown;
+
+	ma = isl_multi_aff_alloc(isl_space_copy(sol->space));
+	ls = isl_basic_set_get_local_space(dom);
+	ls = isl_local_space_drop_dims(ls, isl_dim_div,
+					n_known, n_div - n_known);
+	ma = set_from_affine_matrix(ma, ls, M);
+
+	if (!ma)
+		dom = isl_basic_set_free(dom);
+	sol_push_sol(sol, dom, ma);
+}
+
 /* Pop one partial solution from the partial solution stack and
  * pass it on to sol->add or sol->add_empty.
  */
@@ -226,8 +356,8 @@ static void sol_pop_one(struct isl_sol *sol)
 	partial = sol->partial;
 	sol->partial = partial->next;
 
-	if (partial->M)
-		sol->add(sol, partial->dom, partial->M);
+	if (partial->ma)
+		sol->add(sol, partial->dom, partial->ma);
 	else
 		sol->add_empty(sol, partial->dom);
 	free(partial);
@@ -249,33 +379,143 @@ static struct isl_basic_set *sol_domain(struct isl_sol *sol)
 	return bset;
 }
 
-/* Check whether two partial solutions have the same mapping, where n_div
- * is the number of divs that the two partial solutions have in common.
+/* Check whether two partial solutions have the same affine expressions.
  */
-static int same_solution(struct isl_partial_sol *s1, struct isl_partial_sol *s2,
-	unsigned n_div)
+static isl_bool same_solution(struct isl_partial_sol *s1,
+	struct isl_partial_sol *s2)
 {
-	int i;
-	unsigned dim;
+	if (!s1->ma != !s2->ma)
+		return isl_bool_false;
+	if (!s1->ma)
+		return isl_bool_true;
 
-	if (!s1->M != !s2->M)
-		return 0;
-	if (!s1->M)
-		return 1;
+	return isl_multi_aff_plain_is_equal(s1->ma, s2->ma);
+}
 
-	dim = isl_basic_set_total_dim(s1->dom) - s1->dom->n_div;
+/* Swap the initial two partial solutions in "sol".
+ *
+ * That is, go from
+ *
+ *	sol->partial = p1; p1->next = p2; p2->next = p3
+ *
+ * to
+ *
+ *	sol->partial = p2; p2->next = p1; p1->next = p3
+ */
+static void swap_initial(struct isl_sol *sol)
+{
+	struct isl_partial_sol *partial;
 
-	for (i = 0; i < s1->M->n_row; ++i) {
-		if (isl_seq_first_non_zero(s1->M->row[i]+1+dim+n_div,
-					    s1->M->n_col-1-dim-n_div) != -1)
-			return 0;
-		if (isl_seq_first_non_zero(s2->M->row[i]+1+dim+n_div,
-					    s2->M->n_col-1-dim-n_div) != -1)
-			return 0;
-		if (!isl_seq_eq(s1->M->row[i], s2->M->row[i], 1+dim+n_div))
-			return 0;
+	partial = sol->partial;
+	sol->partial = partial->next;
+	partial->next = partial->next->next;
+	sol->partial->next = partial;
+}
+
+/* Combine the initial two partial solution of "sol" into
+ * a partial solution with the current context domain of "sol" and
+ * the function description of the second partial solution in the list.
+ * The level of the new partial solution is set to the current level.
+ *
+ * That is, the first two partial solutions (D1,M1) and (D2,M2) are
+ * replaced by (D,M2), where D is the domain of "sol", which is assumed
+ * to be the union of D1 and D2, while M1 is assumed to be equal to M2
+ * (at least on D1).
+ */
+static isl_stat combine_initial_into_second(struct isl_sol *sol)
+{
+	struct isl_partial_sol *partial;
+	isl_basic_set *bset;
+
+	partial = sol->partial;
+
+	bset = sol_domain(sol);
+	isl_basic_set_free(partial->next->dom);
+	partial->next->dom = bset;
+	partial->next->level = sol->level;
+
+	if (!bset)
+		return isl_stat_error;
+
+	sol->partial = partial->next;
+	isl_basic_set_free(partial->dom);
+	isl_multi_aff_free(partial->ma);
+	free(partial);
+
+	return isl_stat_ok;
+}
+
+/* Are "ma1" and "ma2" equal to each other on "dom"?
+ *
+ * Combine "ma1" and "ma2" with "dom" and check if the results are the same.
+ * "dom" may have existentially quantified variables.  Eliminate them first
+ * as otherwise they would have to be eliminated twice, in a more complicated
+ * context.
+ */
+static isl_bool equal_on_domain(__isl_keep isl_multi_aff *ma1,
+	__isl_keep isl_multi_aff *ma2, __isl_keep isl_basic_set *dom)
+{
+	isl_set *set;
+	isl_pw_multi_aff *pma1, *pma2;
+	isl_bool equal;
+
+	set = isl_basic_set_compute_divs(isl_basic_set_copy(dom));
+	pma1 = isl_pw_multi_aff_alloc(isl_set_copy(set),
+					isl_multi_aff_copy(ma1));
+	pma2 = isl_pw_multi_aff_alloc(set, isl_multi_aff_copy(ma2));
+	equal = isl_pw_multi_aff_is_equal(pma1, pma2);
+	isl_pw_multi_aff_free(pma1);
+	isl_pw_multi_aff_free(pma2);
+
+	return equal;
+}
+
+/* The initial two partial solutions of "sol" are known to be at
+ * the same level.
+ * If they represent the same solution (on different parts of the domain),
+ * then combine them into a single solution at the current level.
+ * Otherwise, pop them both.
+ *
+ * Even if the two partial solution are not obviously the same,
+ * one may still be a simplification of the other over its own domain.
+ * Also check if the two sets of affine functions are equal when
+ * restricted to one of the domains.  If so, combine the two
+ * using the set of affine functions on the other domain.
+ * That is, for two partial solutions (D1,M1) and (D2,M2),
+ * if M1 = M2 on D1, then the pair of partial solutions can
+ * be replaced by (D1+D2,M2) and similarly when M1 = M2 on D2.
+ */
+static isl_stat combine_initial_if_equal(struct isl_sol *sol)
+{
+	struct isl_partial_sol *partial;
+	isl_bool same;
+
+	partial = sol->partial;
+
+	same = same_solution(partial, partial->next);
+	if (same < 0)
+		return isl_stat_error;
+	if (same)
+		return combine_initial_into_second(sol);
+	if (partial->ma && partial->next->ma) {
+		same = equal_on_domain(partial->ma, partial->next->ma,
+					partial->dom);
+		if (same < 0)
+			return isl_stat_error;
+		if (same)
+			return combine_initial_into_second(sol);
+		same = equal_on_domain(partial->ma, partial->next->ma,
+					partial->next->dom);
+		if (same) {
+			swap_initial(sol);
+			return combine_initial_into_second(sol);
+		}
 	}
-	return 1;
+
+	sol_pop_one(sol);
+	sol_pop_one(sol);
+
+	return isl_stat_ok;
 }
 
 /* Pop all solutions from the partial solution stack that were pushed onto
@@ -290,7 +530,6 @@ static int same_solution(struct isl_partial_sol *s1, struct isl_partial_sol *s2,
 static void sol_pop(struct isl_sol *sol)
 {
 	struct isl_partial_sol *partial;
-	unsigned n_div;
 
 	if (sol->error)
 		return;
@@ -309,40 +548,8 @@ static void sol_pop(struct isl_sol *sol)
 		return;
 
 	if (partial->next && partial->next->level == partial->level) {
-		n_div = isl_basic_set_dim(
-				sol->context->op->peek_basic_set(sol->context),
-				isl_dim_div);
-
-		if (!same_solution(partial, partial->next, n_div)) {
-			sol_pop_one(sol);
-			sol_pop_one(sol);
-		} else {
-			struct isl_basic_set *bset;
-			isl_mat *M;
-			unsigned n;
-
-			n = isl_basic_set_dim(partial->next->dom, isl_dim_div);
-			n -= n_div;
-			bset = sol_domain(sol);
-			isl_basic_set_free(partial->next->dom);
-			partial->next->dom = bset;
-			M = partial->next->M;
-			if (M) {
-				M = isl_mat_drop_cols(M, M->n_col - n, n);
-				partial->next->M = M;
-				if (!M)
-					goto error;
-			}
-			partial->next->level = sol->level;
-
-			if (!bset)
-				goto error;
-
-			sol->partial = partial->next;
-			isl_basic_set_free(partial->dom);
-			isl_mat_free(partial->M);
-			free(partial);
-		}
+		if (combine_initial_if_equal(sol) < 0)
+			goto error;
 	} else
 		sol_pop_one(sol);
 
@@ -366,13 +573,13 @@ static void sol_dec_level(struct isl_sol *sol)
 	sol_pop(sol);
 }
 
-static int sol_dec_level_wrap(struct isl_tab_callback *cb)
+static isl_stat sol_dec_level_wrap(struct isl_tab_callback *cb)
 {
 	struct isl_sol_callback *callback = (struct isl_sol_callback *)cb;
 
 	sol_dec_level(callback->sol);
 
-	return callback->sol->error ? -1 : 0;
+	return callback->sol->error ? isl_stat_error : isl_stat_ok;
 }
 
 /* Move down to next level and push callback onto context tableau
@@ -533,7 +740,7 @@ static void sol_add(struct isl_sol *sol, struct isl_tab *tab)
 
 	isl_int_clear(m);
 
-	sol_push_sol(sol, bset, mat);
+	sol_push_sol_mat(sol, bset, mat);
 	return;
 error2:
 	isl_int_clear(m);
@@ -549,20 +756,11 @@ struct isl_sol_map {
 	struct isl_set	*empty;
 };
 
-static void sol_map_free(struct isl_sol_map *sol_map)
+static void sol_map_free(struct isl_sol *sol)
 {
-	if (!sol_map)
-		return;
-	if (sol_map->sol.context)
-		sol_map->sol.context->op->free(sol_map->sol.context);
+	struct isl_sol_map *sol_map = (struct isl_sol_map *) sol;
 	isl_map_free(sol_map->map);
 	isl_set_free(sol_map->empty);
-	free(sol_map);
-}
-
-static void sol_map_free_wrap(struct isl_sol *sol)
-{
-	sol_map_free((struct isl_sol_map *)sol);
 }
 
 /* This function is called for parts of the context where there is
@@ -594,104 +792,35 @@ static void sol_map_add_empty_wrap(struct isl_sol *sol,
 	sol_map_add_empty((struct isl_sol_map *)sol, bset);
 }
 
-/* Given a basic map "dom" that represents the context and an affine
- * matrix "M" that maps the dimensions of the context to the
- * output variables, construct a basic map with the same parameters
- * and divs as the context, the dimensions of the context as input
- * dimensions and a number of output dimensions that is equal to
- * the number of output dimensions in the input map.
- *
- * The constraints and divs of the context are simply copied
- * from "dom".  For each row
- *	x = c + e(y)
- * an equality
- *	c + e(y) - d x = 0
- * is added, with d the common denominator of M.
+/* Given a basic set "dom" that represents the context and a tuple of
+ * affine expressions "ma" defined over this domain, construct a basic map
+ * that expresses this function on the domain.
  */
 static void sol_map_add(struct isl_sol_map *sol,
-	struct isl_basic_set *dom, struct isl_mat *M)
+	__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)
 {
-	int i;
-	struct isl_basic_map *bmap = NULL;
-	unsigned n_eq;
-	unsigned n_ineq;
-	unsigned nparam;
-	unsigned total;
-	unsigned n_div;
-	unsigned n_out;
+	isl_basic_map *bmap;
 
-	if (sol->sol.error || !dom || !M)
+	if (sol->sol.error || !dom || !ma)
 		goto error;
 
-	n_out = sol->sol.n_out;
-	n_eq = dom->n_eq + n_out;
-	n_ineq = dom->n_ineq;
-	n_div = dom->n_div;
-	nparam = isl_basic_set_total_dim(dom) - n_div;
-	total = isl_map_dim(sol->map, isl_dim_all);
-	bmap = isl_basic_map_alloc_space(isl_map_get_space(sol->map),
-					n_div, n_eq, 2 * n_div + n_ineq);
-	if (!bmap)
-		goto error;
-	if (sol->sol.rational)
-		ISL_F_SET(bmap, ISL_BASIC_MAP_RATIONAL);
-	for (i = 0; i < dom->n_div; ++i) {
-		int k = isl_basic_map_alloc_div(bmap);
-		if (k < 0)
-			goto error;
-		isl_seq_cpy(bmap->div[k], dom->div[i], 1 + 1 + nparam);
-		isl_seq_clr(bmap->div[k] + 1 + 1 + nparam, total - nparam);
-		isl_seq_cpy(bmap->div[k] + 1 + 1 + total,
-			    dom->div[i] + 1 + 1 + nparam, i);
-	}
-	for (i = 0; i < dom->n_eq; ++i) {
-		int k = isl_basic_map_alloc_equality(bmap);
-		if (k < 0)
-			goto error;
-		isl_seq_cpy(bmap->eq[k], dom->eq[i], 1 + nparam);
-		isl_seq_clr(bmap->eq[k] + 1 + nparam, total - nparam);
-		isl_seq_cpy(bmap->eq[k] + 1 + total,
-			    dom->eq[i] + 1 + nparam, n_div);
-	}
-	for (i = 0; i < dom->n_ineq; ++i) {
-		int k = isl_basic_map_alloc_inequality(bmap);
-		if (k < 0)
-			goto error;
-		isl_seq_cpy(bmap->ineq[k], dom->ineq[i], 1 + nparam);
-		isl_seq_clr(bmap->ineq[k] + 1 + nparam, total - nparam);
-		isl_seq_cpy(bmap->ineq[k] + 1 + total,
-			dom->ineq[i] + 1 + nparam, n_div);
-	}
-	for (i = 0; i < M->n_row - 1; ++i) {
-		int k = isl_basic_map_alloc_equality(bmap);
-		if (k < 0)
-			goto error;
-		isl_seq_cpy(bmap->eq[k], M->row[1 + i], 1 + nparam);
-		isl_seq_clr(bmap->eq[k] + 1 + nparam, n_out);
-		isl_int_neg(bmap->eq[k][1 + nparam + i], M->row[0][0]);
-		isl_seq_cpy(bmap->eq[k] + 1 + nparam + n_out,
-			    M->row[1 + i] + 1 + nparam, n_div);
-	}
-	bmap = isl_basic_map_simplify(bmap);
-	bmap = isl_basic_map_finalize(bmap);
+	bmap = isl_basic_map_from_multi_aff2(ma, sol->sol.rational);
+	bmap = isl_basic_map_intersect_domain(bmap, dom);
 	sol->map = isl_map_grow(sol->map, 1);
 	sol->map = isl_map_add_basic_map(sol->map, bmap);
-	isl_basic_set_free(dom);
-	isl_mat_free(M);
 	if (!sol->map)
 		sol->sol.error = 1;
 	return;
 error:
 	isl_basic_set_free(dom);
-	isl_mat_free(M);
-	isl_basic_map_free(bmap);
+	isl_multi_aff_free(ma);
 	sol->sol.error = 1;
 }
 
 static void sol_map_add_wrap(struct isl_sol *sol,
-	struct isl_basic_set *dom, struct isl_mat *M)
+	__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)
 {
-	sol_map_add((struct isl_sol_map *)sol, dom, M);
+	sol_map_add((struct isl_sol_map *)sol, dom, ma);
 }
 
 
@@ -804,7 +933,8 @@ static void normalize_div(__isl_keep isl_vec *div)
 	isl_seq_scale_down(div->el + 2, div->el + 2, ctx->normalize_gcd, len);
 }
 
-/* Return a integer division for use in a parametric cut based on the given row.
+/* Return an integer division for use in a parametric cut based
+ * on the given row.
  * In particular, let the parametric constant of the row be
  *
  *		\sum_i a_i y_i
@@ -831,7 +961,7 @@ static struct isl_vec *get_row_parameter_div(struct isl_tab *tab, int row)
 	return div;
 }
 
-/* Return a integer division for use in transferring an integrality constraint
+/* Return an integer division for use in transferring an integrality constraint
  * to the context.
  * In particular, let the parametric constant of the row be
  *
@@ -868,7 +998,8 @@ static struct isl_vec *get_row_split_div(struct isl_tab *tab, int row)
  *
  *	m d <= e
  */
-static struct isl_vec *ineq_for_div(struct isl_basic_set *bset, unsigned div)
+static __isl_give isl_vec *ineq_for_div(__isl_keep isl_basic_set *bset,
+	unsigned div)
 {
 	unsigned total;
 	unsigned div_pos;
@@ -1858,20 +1989,21 @@ static int tab_has_valid_sample(struct isl_tab *tab, isl_int *ineq, int eq)
 	return i < tab->n_sample;
 }
 
-/* Add a div specified by "div" to the tableau "tab" and return
- * 1 if the div is obviously non-negative.
+/* Insert a div specified by "div" to the tableau "tab" at position "pos" and
+ * return isl_bool_true if the div is obviously non-negative.
  */
-static int context_tab_add_div(struct isl_tab *tab, struct isl_vec *div,
-	int (*add_ineq)(void *user, isl_int *), void *user)
+static isl_bool context_tab_insert_div(struct isl_tab *tab, int pos,
+	__isl_keep isl_vec *div,
+	isl_stat (*add_ineq)(void *user, isl_int *), void *user)
 {
 	int i;
 	int r;
 	struct isl_mat *samples;
 	int nonneg;
 
-	r = isl_tab_add_div(tab, div, add_ineq, user);
+	r = isl_tab_insert_div(tab, pos, div, add_ineq, user);
 	if (r < 0)
-		return -1;
+		return isl_bool_error;
 	nonneg = tab->var[r].is_nonneg;
 	tab->var[r].frozen = 1;
 
@@ -1879,13 +2011,17 @@ static int context_tab_add_div(struct isl_tab *tab, struct isl_vec *div,
 			tab->n_sample, 1 + tab->n_var);
 	tab->samples = samples;
 	if (!samples)
-		return -1;
+		return isl_bool_error;
 	for (i = tab->n_outside; i < samples->n_row; ++i) {
 		isl_seq_inner_product(div->el + 1, samples->row[i],
 			div->size - 1, &samples->row[i][samples->n_col - 1]);
 		isl_int_fdiv_q(samples->row[i][samples->n_col - 1],
 			       samples->row[i][samples->n_col - 1], div->el[0]);
 	}
+	tab->samples = isl_mat_move_cols(tab->samples, 1 + pos,
+					1 + tab->n_var - 1, 1);
+	if (!tab->samples)
+		return isl_bool_error;
 
 	return nonneg;
 }
@@ -1895,22 +2031,34 @@ static int context_tab_add_div(struct isl_tab *tab, struct isl_vec *div,
  * need to add an extra div.  In the context tableau, we also
  * need to express the meaning of the div.
  * Return the index of the div or -1 if anything went wrong.
+ *
+ * The new integer division is added before any unknown integer
+ * divisions in the context to ensure that it does not get
+ * equated to some linear combination involving unknown integer
+ * divisions.
  */
 static int add_div(struct isl_tab *tab, struct isl_context *context,
-	struct isl_vec *div)
+	__isl_keep isl_vec *div)
 {
 	int r;
-	int nonneg;
+	int pos;
+	isl_bool nonneg;
+	struct isl_tab *context_tab = context->op->peek_tab(context);
+
+	if (!tab || !context_tab)
+		goto error;
 
-	if ((nonneg = context->op->add_div(context, div)) < 0)
+	pos = context_tab->n_var - context->n_unknown;
+	if ((nonneg = context->op->insert_div(context, pos, div)) < 0)
 		goto error;
 
 	if (!context->op->is_ok(context))
 		goto error;
 
+	pos = tab->n_var - context->n_unknown;
 	if (isl_tab_extend_vars(tab, 1) < 0)
 		goto error;
-	r = isl_tab_allocate_var(tab);
+	r = isl_tab_insert_var(tab, pos);
 	if (r < 0)
 		goto error;
 	if (nonneg)
@@ -1918,7 +2066,7 @@ static int add_div(struct isl_tab *tab, struct isl_context *context,
 	tab->var[r].frozen = 1;
 	tab->n_div++;
 
-	return tab->n_div - 1;
+	return tab->n_div - 1 - context->n_unknown;
 error:
 	context->op->invalidate(context);
 	return -1;
@@ -2000,7 +2148,7 @@ static int add_parametric_cut(struct isl_tab *tab, int row,
 	if (!div)
 		return -1;
 
-	n = tab->n_div;
+	n = tab->n_div - context->n_unknown;
 	d = context->op->get_div(context, tab, div);
 	isl_vec_free(div);
 	if (d < 0)
@@ -2088,8 +2236,8 @@ static int add_parametric_cut(struct isl_tab *tab, int row,
  * of the variables in all constraints are negated prior to adding them
  * to the tableau.
  */
-static struct isl_tab *tab_for_lexmin(struct isl_basic_map *bmap,
-	struct isl_basic_set *dom, unsigned M, int max)
+static __isl_give struct isl_tab *tab_for_lexmin(__isl_keep isl_basic_map *bmap,
+	__isl_keep isl_basic_set *dom, unsigned M, int max)
 {
 	int i;
 	struct isl_tab *tab;
@@ -2304,11 +2452,11 @@ error:
 	clex->tab = NULL;
 }
 
-static int context_lex_add_ineq_wrap(void *user, isl_int *ineq)
+static isl_stat context_lex_add_ineq_wrap(void *user, isl_int *ineq)
 {
 	struct isl_context *context = (struct isl_context *)user;
 	context_lex_add_ineq(context, ineq, 0, 0);
-	return context->op->is_ok(context) ? 0 : -1;
+	return context->op->is_ok(context) ? isl_stat_ok : isl_stat_error;
 }
 
 /* Check which signs can be obtained by "ineq" on all the currently
@@ -2393,24 +2541,25 @@ static int context_lex_get_div(struct isl_context *context, struct isl_tab *tab,
 	return get_div(tab, context, div);
 }
 
-/* Add a div specified by "div" to the context tableau and return
- * 1 if the div is obviously non-negative.
- * context_tab_add_div will always return 1, because all variables
+/* Insert a div specified by "div" to the context tableau at position "pos" and
+ * return isl_bool_true if the div is obviously non-negative.
+ * context_tab_add_div will always return isl_bool_true, because all variables
  * in a isl_context_lex tableau are non-negative.
  * However, if we are using a big parameter in the context, then this only
  * reflects the non-negativity of the variable used to _encode_ the
  * div, i.e., div' = M + div, so we can't draw any conclusions.
  */
-static int context_lex_add_div(struct isl_context *context, struct isl_vec *div)
+static isl_bool context_lex_insert_div(struct isl_context *context, int pos,
+	__isl_keep isl_vec *div)
 {
 	struct isl_context_lex *clex = (struct isl_context_lex *)context;
-	int nonneg;
-	nonneg = context_tab_add_div(clex->tab, div,
+	isl_bool nonneg;
+	nonneg = context_tab_insert_div(clex->tab, pos, div,
 					context_lex_add_ineq_wrap, context);
 	if (nonneg < 0)
-		return -1;
+		return isl_bool_error;
 	if (clex->tab->M)
-		return 0;
+		return isl_bool_false;
 	return nonneg;
 }
 
@@ -2569,11 +2718,14 @@ static void context_lex_invalidate(struct isl_context *context)
 	clex->tab = NULL;
 }
 
-static void context_lex_free(struct isl_context *context)
+static __isl_null struct isl_context *context_lex_free(
+	struct isl_context *context)
 {
 	struct isl_context_lex *clex = (struct isl_context_lex *)context;
 	isl_tab_free(clex->tab);
 	free(clex);
+
+	return NULL;
 }
 
 struct isl_context_op isl_context_lex_op = {
@@ -2585,7 +2737,7 @@ struct isl_context_op isl_context_lex_op = {
 	context_lex_ineq_sign,
 	context_lex_test_ineq,
 	context_lex_get_div,
-	context_lex_add_div,
+	context_lex_insert_div,
 	context_lex_detect_equalities,
 	context_lex_best_split,
 	context_lex_is_empty,
@@ -2597,21 +2749,19 @@ struct isl_context_op isl_context_lex_op = {
 	context_lex_free,
 };
 
-static struct isl_tab *context_tab_for_lexmin(struct isl_basic_set *bset)
+static struct isl_tab *context_tab_for_lexmin(__isl_take isl_basic_set *bset)
 {
 	struct isl_tab *tab;
 
 	if (!bset)
 		return NULL;
-	tab = tab_for_lexmin((struct isl_basic_map *)bset, NULL, 1, 0);
-	if (!tab)
-		goto error;
+	tab = tab_for_lexmin(bset_to_bmap(bset), NULL, 1, 0);
 	if (isl_tab_track_bset(tab, bset) < 0)
 		goto error;
 	tab = isl_tab_init_samples(tab);
 	return tab;
 error:
-	isl_basic_set_free(bset);
+	isl_tab_free(tab);
 	return NULL;
 }
 
@@ -2736,7 +2886,8 @@ static struct isl_vec *gbr_get_shifted_sample(struct isl_context_gbr *cgbr)
 	return sample;
 }
 
-static struct isl_basic_set *drop_constant_terms(struct isl_basic_set *bset)
+static __isl_give isl_basic_set *drop_constant_terms(
+	__isl_take isl_basic_set *bset)
 {
 	int i;
 
@@ -2990,11 +3141,11 @@ error:
 	cgbr->tab = NULL;
 }
 
-static int context_gbr_add_ineq_wrap(void *user, isl_int *ineq)
+static isl_stat context_gbr_add_ineq_wrap(void *user, isl_int *ineq)
 {
 	struct isl_context *context = (struct isl_context *)user;
 	context_gbr_add_ineq(context, ineq, 0, 0);
-	return context->op->is_ok(context) ? 0 : -1;
+	return context->op->is_ok(context) ? isl_stat_ok : isl_stat_error;
 }
 
 static enum isl_tab_row_sign context_gbr_ineq_sign(struct isl_context *context,
@@ -3088,6 +3239,9 @@ static int last_non_zero_var_col(struct isl_tab *tab, isl_int *p)
  * that is one or negative one, we use it to kill a column
  * in the main tableau.  Otherwise, we discard the tentatively
  * added row.
+ * This tentative addition of equality constraints turns
+ * on the undo facility of the tableau.  Turn it off again
+ * at the end, assuming it was turned off to begin with.
  *
  * Return 0 on success and -1 on failure.
  */
@@ -3096,7 +3250,11 @@ static int propagate_equalities(struct isl_context_gbr *cgbr,
 {
 	int i;
 	struct isl_vec *eq = NULL;
+	isl_bool needs_undo;
 
+	needs_undo = isl_tab_need_undo(tab);
+	if (needs_undo < 0)
+		goto error;
 	eq = isl_vec_alloc(tab->mat->ctx, 1 + tab->n_var);
 	if (!eq)
 		goto error;
@@ -3139,6 +3297,8 @@ static int propagate_equalities(struct isl_context_gbr *cgbr,
 			goto error;
 	}
 
+	if (!needs_undo)
+		isl_tab_clear_undo(tab);
 	isl_vec_free(eq);
 
 	return 0;
@@ -3188,29 +3348,32 @@ static int context_gbr_get_div(struct isl_context *context, struct isl_tab *tab,
 	return get_div(tab, context, div);
 }
 
-static int context_gbr_add_div(struct isl_context *context, struct isl_vec *div)
+static isl_bool context_gbr_insert_div(struct isl_context *context, int pos,
+	__isl_keep isl_vec *div)
 {
 	struct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;
 	if (cgbr->cone) {
-		int k;
+		int r, n_div, o_div;
+
+		n_div = isl_basic_map_dim(cgbr->cone->bmap, isl_dim_div);
+		o_div = cgbr->cone->n_var - n_div;
 
 		if (isl_tab_extend_cons(cgbr->cone, 3) < 0)
-			return -1;
+			return isl_bool_error;
 		if (isl_tab_extend_vars(cgbr->cone, 1) < 0)
-			return -1;
-		if (isl_tab_allocate_var(cgbr->cone) <0)
-			return -1;
-
-		cgbr->cone->bmap = isl_basic_map_extend_space(cgbr->cone->bmap,
-			isl_basic_map_get_space(cgbr->cone->bmap), 1, 0, 2);
-		k = isl_basic_map_alloc_div(cgbr->cone->bmap);
-		if (k < 0)
-			return -1;
-		isl_seq_cpy(cgbr->cone->bmap->div[k], div->el, div->size);
-		if (isl_tab_push(cgbr->cone, isl_tab_undo_bmap_div) < 0)
-			return -1;
+			return isl_bool_error;
+		if ((r = isl_tab_insert_var(cgbr->cone, pos)) <0)
+			return isl_bool_error;
+
+		cgbr->cone->bmap = isl_basic_map_insert_div(cgbr->cone->bmap,
+						    r - o_div, div);
+		if (!cgbr->cone->bmap)
+			return isl_bool_error;
+		if (isl_tab_push_var(cgbr->cone, isl_tab_undo_bmap_div,
+				    &cgbr->cone->var[r]) < 0)
+			return isl_bool_error;
 	}
-	return context_tab_add_div(cgbr->tab, div,
+	return context_tab_insert_div(cgbr->tab, pos, div,
 					context_gbr_add_ineq_wrap, context);
 }
 
@@ -3329,13 +3492,16 @@ static void context_gbr_invalidate(struct isl_context *context)
 	cgbr->tab = NULL;
 }
 
-static void context_gbr_free(struct isl_context *context)
+static __isl_null struct isl_context *context_gbr_free(
+	struct isl_context *context)
 {
 	struct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;
 	isl_tab_free(cgbr->tab);
 	isl_tab_free(cgbr->shifted);
 	isl_tab_free(cgbr->cone);
 	free(cgbr);
+
+	return NULL;
 }
 
 struct isl_context_op isl_context_gbr_op = {
@@ -3347,7 +3513,7 @@ struct isl_context_op isl_context_gbr_op = {
 	context_gbr_ineq_sign,
 	context_gbr_test_ineq,
 	context_gbr_get_div,
-	context_gbr_add_div,
+	context_gbr_insert_div,
 	context_gbr_detect_equalities,
 	context_gbr_best_split,
 	context_gbr_is_empty,
@@ -3359,7 +3525,7 @@ struct isl_context_op isl_context_gbr_op = {
 	context_gbr_free,
 };
 
-static struct isl_context *isl_context_gbr_alloc(struct isl_basic_set *dom)
+static struct isl_context *isl_context_gbr_alloc(__isl_keep isl_basic_set *dom)
 {
 	struct isl_context_gbr *cgbr;
 
@@ -3386,15 +3552,58 @@ error:
 	return NULL;
 }
 
-static struct isl_context *isl_context_alloc(struct isl_basic_set *dom)
+/* Allocate a context corresponding to "dom".
+ * The representation specific fields are initialized by
+ * isl_context_lex_alloc or isl_context_gbr_alloc.
+ * The shared "n_unknown" field is initialized to the number
+ * of final unknown integer divisions in "dom".
+ */
+static struct isl_context *isl_context_alloc(__isl_keep isl_basic_set *dom)
 {
+	struct isl_context *context;
+	int first;
+
 	if (!dom)
 		return NULL;
 
 	if (dom->ctx->opt->context == ISL_CONTEXT_LEXMIN)
-		return isl_context_lex_alloc(dom);
+		context = isl_context_lex_alloc(dom);
 	else
-		return isl_context_gbr_alloc(dom);
+		context = isl_context_gbr_alloc(dom);
+
+	if (!context)
+		return NULL;
+
+	first = isl_basic_set_first_unknown_div(dom);
+	if (first < 0)
+		return context->op->free(context);
+	context->n_unknown = isl_basic_set_dim(dom, isl_dim_div) - first;
+
+	return context;
+}
+
+/* Initialize some common fields of "sol", which keeps track
+ * of the solution of an optimization problem on "bmap" over
+ * the domain "dom".
+ * If "max" is set, then a maximization problem is being solved, rather than
+ * a minimization problem, which means that the variables in the
+ * tableau have value "M - x" rather than "M + x".
+ */
+static isl_stat sol_init(struct isl_sol *sol, __isl_keep isl_basic_map *bmap,
+	__isl_keep isl_basic_set *dom, int max)
+{
+	sol->rational = ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);
+	sol->dec_level.callback.run = &sol_dec_level_wrap;
+	sol->dec_level.sol = sol;
+	sol->max = max;
+	sol->n_out = isl_basic_map_dim(bmap, isl_dim_out);
+	sol->space = isl_basic_map_get_space(bmap);
+
+	sol->context = isl_context_alloc(dom);
+	if (!sol->space || !sol->context)
+		return isl_stat_error;
+
+	return isl_stat_ok;
 }
 
 /* Construct an isl_sol_map structure for accumulating the solution.
@@ -3404,10 +3613,11 @@ static struct isl_context *isl_context_alloc(struct isl_basic_set *dom)
  * a minimization problem, which means that the variables in the
  * tableau have value "M - x" rather than "M + x".
  */
-static struct isl_sol *sol_map_init(struct isl_basic_map *bmap,
-	struct isl_basic_set *dom, int track_empty, int max)
+static struct isl_sol *sol_map_init(__isl_keep isl_basic_map *bmap,
+	__isl_take isl_basic_set *dom, int track_empty, int max)
 {
 	struct isl_sol_map *sol_map = NULL;
+	isl_space *space;
 
 	if (!bmap)
 		goto error;
@@ -3416,23 +3626,16 @@ static struct isl_sol *sol_map_init(struct isl_basic_map *bmap,
 	if (!sol_map)
 		goto error;
 
-	sol_map->sol.rational = ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);
-	sol_map->sol.dec_level.callback.run = &sol_dec_level_wrap;
-	sol_map->sol.dec_level.sol = &sol_map->sol;
-	sol_map->sol.max = max;
-	sol_map->sol.n_out = isl_basic_map_dim(bmap, isl_dim_out);
+	sol_map->sol.free = &sol_map_free;
+	if (sol_init(&sol_map->sol, bmap, dom, max) < 0)
+		goto error;
 	sol_map->sol.add = &sol_map_add_wrap;
 	sol_map->sol.add_empty = track_empty ? &sol_map_add_empty_wrap : NULL;
-	sol_map->sol.free = &sol_map_free_wrap;
-	sol_map->map = isl_map_alloc_space(isl_basic_map_get_space(bmap), 1,
-					    ISL_MAP_DISJOINT);
+	space = isl_space_copy(sol_map->sol.space);
+	sol_map->map = isl_map_alloc_space(space, 1, ISL_MAP_DISJOINT);
 	if (!sol_map->map)
 		goto error;
 
-	sol_map->sol.context = isl_context_alloc(dom);
-	if (!sol_map->sol.context)
-		goto error;
-
 	if (track_empty) {
 		sol_map->empty = isl_set_alloc_space(isl_basic_set_get_space(dom),
 							1, ISL_SET_DISJOINT);
@@ -3444,7 +3647,7 @@ static struct isl_sol *sol_map_init(struct isl_basic_map *bmap,
 	return &sol_map->sol;
 error:
 	isl_basic_set_free(dom);
-	sol_map_free(sol_map);
+	sol_free(&sol_map->sol);
 	return NULL;
 }
 
@@ -4066,8 +4269,8 @@ static int find_context_div(struct isl_basic_map *bmap,
  * after any other integer divisions that the map may have.
  * This function performs the required reordering.
  */
-static struct isl_basic_map *align_context_divs(struct isl_basic_map *bmap,
-	struct isl_basic_set *dom)
+static __isl_give isl_basic_map *align_context_divs(
+	__isl_take isl_basic_map *bmap, __isl_keep isl_basic_set *dom)
 {
 	int i;
 	int common = 0;
@@ -4106,8 +4309,13 @@ error:
  * We make sure the divs in the domain are properly ordered,
  * because they will be added one by one in the given order
  * during the construction of the solution map.
+ * Furthermore, make sure that the known integer divisions
+ * appear before any unknown integer division because the solution
+ * may depend on the known integer divisions, while anything that
+ * depends on any variable starting from the first unknown integer
+ * division is ignored in sol_pma_add.
  */
-static struct isl_sol *basic_map_partial_lexopt_base(
+static struct isl_sol *basic_map_partial_lexopt_base_sol(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
 	__isl_give isl_set **empty, int max,
 	struct isl_sol *(*init)(__isl_keep isl_basic_map *bmap,
@@ -4118,7 +4326,7 @@ static struct isl_sol *basic_map_partial_lexopt_base(
 	struct isl_context *context;
 
 	if (dom->n_div) {
-		dom = isl_basic_set_order_divs(dom);
+		dom = isl_basic_set_sort_divs(dom);
 		bmap = align_context_divs(bmap, dom);
 	}
 	sol = init(bmap, dom, !!empty, max);
@@ -4152,9 +4360,9 @@ error:
 /* Base case of isl_tab_basic_map_partial_lexopt, after removing
  * some obvious symmetries.
  *
- * We call basic_map_partial_lexopt_base and extract the results.
+ * We call basic_map_partial_lexopt_base_sol and extract the results.
  */
-static __isl_give isl_map *basic_map_partial_lexopt_base_map(
+static __isl_give isl_map *basic_map_partial_lexopt_base(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
 	__isl_give isl_set **empty, int max)
 {
@@ -4162,8 +4370,8 @@ static __isl_give isl_map *basic_map_partial_lexopt_base_map(
 	struct isl_sol *sol;
 	struct isl_sol_map *sol_map;
 
-	sol = basic_map_partial_lexopt_base(bmap, dom, empty, max,
-					    &sol_map_init);
+	sol = basic_map_partial_lexopt_base_sol(bmap, dom, empty, max,
+						&sol_map_init);
 	if (!sol)
 		return NULL;
 	sol_map = (struct isl_sol_map *) sol;
@@ -4175,13 +4383,80 @@ static __isl_give isl_map *basic_map_partial_lexopt_base_map(
 	return result;
 }
 
+/* Return a count of the number of occurrences of the "n" first
+ * variables in the inequality constraints of "bmap".
+ */
+static __isl_give int *count_occurrences(__isl_keep isl_basic_map *bmap,
+	int n)
+{
+	int i, j;
+	isl_ctx *ctx;
+	int *occurrences;
+
+	if (!bmap)
+		return NULL;
+	ctx = isl_basic_map_get_ctx(bmap);
+	occurrences = isl_calloc_array(ctx, int, n);
+	if (!occurrences)
+		return NULL;
+
+	for (i = 0; i < bmap->n_ineq; ++i) {
+		for (j = 0; j < n; ++j) {
+			if (!isl_int_is_zero(bmap->ineq[i][1 + j]))
+				occurrences[j]++;
+		}
+	}
+
+	return occurrences;
+}
+
+/* Do all of the "n" variables with non-zero coefficients in "c"
+ * occur in exactly a single constraint.
+ * "occurrences" is an array of length "n" containing the number
+ * of occurrences of each of the variables in the inequality constraints.
+ */
+static int single_occurrence(int n, isl_int *c, int *occurrences)
+{
+	int i;
+
+	for (i = 0; i < n; ++i) {
+		if (isl_int_is_zero(c[i]))
+			continue;
+		if (occurrences[i] != 1)
+			return 0;
+	}
+
+	return 1;
+}
+
+/* Do all of the "n" initial variables that occur in inequality constraint
+ * "ineq" of "bmap" only occur in that constraint?
+ */
+static int all_single_occurrence(__isl_keep isl_basic_map *bmap, int ineq,
+	int n)
+{
+	int i, j;
+
+	for (i = 0; i < n; ++i) {
+		if (isl_int_is_zero(bmap->ineq[ineq][1 + i]))
+			continue;
+		for (j = 0; j < bmap->n_ineq; ++j) {
+			if (j == ineq)
+				continue;
+			if (!isl_int_is_zero(bmap->ineq[j][1 + i]))
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
 /* Structure used during detection of parallel constraints.
  * n_in: number of "input" variables: isl_dim_param + isl_dim_in
  * n_out: number of "output" variables: isl_dim_out + isl_dim_div
  * val: the coefficients of the output variables
  */
 struct isl_constraint_equal_info {
-	isl_basic_map *bmap;
 	unsigned n_in;
 	unsigned n_out;
 	isl_int *val;
@@ -4203,15 +4478,17 @@ static int constraint_equal(const void *entry, const void *val)
  * Note that the coefficients of the existentially quantified
  * variables need to be zero since the existentially quantified
  * of the result are usually not the same as those of the input.
- * the isl_dim_out and isl_dim_div dimensions.
- * If so, return 1 and return the row indices of the two constraints
+ * Furthermore, check that each of the input variables that occur
+ * in those constraints does not occur in any other constraint.
+ * If so, return true and return the row indices of the two constraints
  * in *first and *second.
  */
-static int parallel_constraints(__isl_keep isl_basic_map *bmap,
+static isl_bool parallel_constraints(__isl_keep isl_basic_map *bmap,
 	int *first, int *second)
 {
 	int i;
 	isl_ctx *ctx;
+	int *occurrences = NULL;
 	struct isl_hash_table *table = NULL;
 	struct isl_hash_table_entry *entry;
 	struct isl_constraint_equal_info info;
@@ -4225,7 +4502,9 @@ static int parallel_constraints(__isl_keep isl_basic_map *bmap,
 
 	info.n_in = isl_basic_map_dim(bmap, isl_dim_param) +
 		    isl_basic_map_dim(bmap, isl_dim_in);
-	info.bmap = bmap;
+	occurrences = count_occurrences(bmap, info.n_in);
+	if (info.n_in && !occurrences)
+		goto error;
 	n_out = isl_basic_map_dim(bmap, isl_dim_out);
 	n_div = isl_basic_map_dim(bmap, isl_dim_div);
 	info.n_out = n_out + n_div;
@@ -4237,6 +4516,9 @@ static int parallel_constraints(__isl_keep isl_basic_map *bmap,
 			continue;
 		if (isl_seq_first_non_zero(info.val + n_out, n_div) >= 0)
 			continue;
+		if (!single_occurrence(info.n_in, bmap->ineq[i] + 1,
+					occurrences))
+			continue;
 		hash = isl_seq_get_hash(info.val, info.n_out);
 		entry = isl_hash_table_find(ctx, table, hash,
 					    constraint_equal, &info, 1);
@@ -4253,11 +4535,13 @@ static int parallel_constraints(__isl_keep isl_basic_map *bmap,
 	}
 
 	isl_hash_table_free(ctx, table);
+	free(occurrences);
 
 	return i < bmap->n_ineq;
 error:
 	isl_hash_table_free(ctx, table);
-	return -1;
+	free(occurrences);
+	return isl_bool_error;
 }
 
 /* Given a set of upper bounds in "var", add constraints to "bset"
@@ -4355,7 +4639,7 @@ error:
  * an upper bound that is different from the upper bounds on which it
  * is defined.
  */
-static int need_split_basic_map(__isl_keep isl_basic_map *bmap,
+static isl_bool need_split_basic_map(__isl_keep isl_basic_map *bmap,
 	__isl_keep isl_mat *cst)
 {
 	int i, j;
@@ -4367,29 +4651,29 @@ static int need_split_basic_map(__isl_keep isl_basic_map *bmap,
 
 	for (i = 0; i < bmap->n_div; ++i)
 		if (!isl_int_is_zero(bmap->div[i][2 + pos]))
-			return 1;
+			return isl_bool_true;
 
 	for (i = 0; i < bmap->n_eq; ++i)
 		if (!isl_int_is_zero(bmap->eq[i][1 + pos]))
-			return 1;
+			return isl_bool_true;
 
 	for (i = 0; i < bmap->n_ineq; ++i) {
 		if (isl_int_is_nonneg(bmap->ineq[i][1 + pos]))
 			continue;
 		if (!isl_int_is_negone(bmap->ineq[i][1 + pos]))
-			return 1;
+			return isl_bool_true;
 		if (isl_seq_first_non_zero(bmap->ineq[i] + 1 + pos + 1,
 					   total - pos - 1) >= 0)
-			return 1;
+			return isl_bool_true;
 
 		for (j = 0; j < cst->n_row; ++j)
 			if (isl_seq_eq(bmap->ineq[i], cst->row[j], cst->n_col))
 				break;
 		if (j >= cst->n_row)
-			return 1;
+			return isl_bool_true;
 	}
 
-	return 0;
+	return isl_bool_false;
 }
 
 /* Given that the last set variable of "bset" represents the minimum
@@ -4400,25 +4684,29 @@ static int need_split_basic_map(__isl_keep isl_basic_map *bmap,
  * the position of the minimum is computed from "cst" and not
  * from "bmap".
  */
-static int need_split_basic_set(__isl_keep isl_basic_set *bset,
+static isl_bool need_split_basic_set(__isl_keep isl_basic_set *bset,
 	__isl_keep isl_mat *cst)
 {
-	return need_split_basic_map((isl_basic_map *)bset, cst);
+	return need_split_basic_map(bset_to_bmap(bset), cst);
 }
 
 /* Given that the last set variable of "set" represents the minimum
  * of the bounds in "cst", check whether we need to split the domain
  * based on which bound attains the minimum.
  */
-static int need_split_set(__isl_keep isl_set *set, __isl_keep isl_mat *cst)
+static isl_bool need_split_set(__isl_keep isl_set *set, __isl_keep isl_mat *cst)
 {
 	int i;
 
-	for (i = 0; i < set->n; ++i)
-		if (need_split_basic_set(set->p[i], cst))
-			return 1;
+	for (i = 0; i < set->n; ++i) {
+		isl_bool split;
 
-	return 0;
+		split = need_split_basic_set(set->p[i], cst);
+		if (split < 0 || split)
+			return split;
+	}
+
+	return isl_bool_false;
 }
 
 /* Given a set of which the last set variable is the minimum
@@ -4451,10 +4739,14 @@ static __isl_give isl_set *split(__isl_take isl_set *empty,
 	res = isl_set_empty(dim);
 
 	for (i = 0; i < empty->n; ++i) {
+		isl_bool split;
 		isl_set *set;
 
 		set = isl_set_from_basic_set(isl_basic_set_copy(empty->p[i]));
-		if (need_split_basic_set(empty->p[i], cst))
+		split = need_split_basic_set(empty->p[i], cst);
+		if (split < 0)
+			set = isl_set_free(set);
+		else if (split)
 			set = isl_set_intersect(set, isl_set_copy(min_expr));
 		set = isl_set_remove_dims(set, isl_dim_set, n_in - 1, 1);
 
@@ -4498,9 +4790,13 @@ static __isl_give isl_map *split_domain(__isl_take isl_map *opt,
 
 	for (i = 0; i < opt->n; ++i) {
 		isl_map *map;
+		isl_bool split;
 
 		map = isl_map_from_basic_map(isl_basic_map_copy(opt->p[i]));
-		if (need_split_basic_map(opt->p[i], cst))
+		split = need_split_basic_map(opt->p[i], cst);
+		if (split < 0)
+			map = isl_map_free(map);
+		else if (split)
 			map = isl_map_intersect_domain(map,
 						       isl_set_copy(min_expr));
 		map = isl_map_remove_dims(map, isl_dim_in, n_in - 1, 1);
@@ -4523,12 +4819,6 @@ static __isl_give isl_map *basic_map_partial_lexopt(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
 	__isl_give isl_set **empty, int max);
 
-union isl_lex_res {
-	void *p;
-	isl_map *map;
-	isl_pw_multi_aff *pma;
-};
-
 /* This function is called from basic_map_partial_lexopt_symm.
  * The last variable of "bmap" and "dom" corresponds to the minimum
  * of the bounds in "cst".  "map_space" is the space of the original
@@ -4538,14 +4828,13 @@ union isl_lex_res {
  * We recursively call basic_map_partial_lexopt and then plug in
  * the definition of the minimum in the result.
  */
-static __isl_give union isl_lex_res basic_map_partial_lexopt_symm_map_core(
+static __isl_give isl_map *basic_map_partial_lexopt_symm_core(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
 	__isl_give isl_set **empty, int max, __isl_take isl_mat *cst,
 	__isl_take isl_space *map_space, __isl_take isl_space *set_space)
 {
 	isl_map *opt;
 	isl_set *min_expr;
-	union isl_lex_res res;
 
 	min_expr = set_minimum(isl_basic_set_get_space(dom), isl_mat_copy(cst));
 
@@ -4560,238 +4849,69 @@ static __isl_give union isl_lex_res basic_map_partial_lexopt_symm_map_core(
 	opt = split_domain(opt, min_expr, cst);
 	opt = isl_map_reset_space(opt, map_space);
 
-	res.map = opt;
-	return res;
+	return opt;
 }
 
-/* Given a basic map with at least two parallel constraints (as found
- * by the function parallel_constraints), first look for more constraints
- * parallel to the two constraint and replace the found list of parallel
- * constraints by a single constraint with as "input" part the minimum
- * of the input parts of the list of constraints.  Then, recursively call
- * basic_map_partial_lexopt (possibly finding more parallel constraints)
- * and plug in the definition of the minimum in the result.
- *
- * More specifically, given a set of constraints
- *
- *	a x + b_i(p) >= 0
- *
- * Replace this set by a single constraint
- *
- *	a x + u >= 0
- *
- * with u a new parameter with constraints
- *
- *	u <= b_i(p)
- *
- * Any solution to the new system is also a solution for the original system
- * since
- *
- *	a x >= -u >= -b_i(p)
+/* Extract a domain from "bmap" for the purpose of computing
+ * a lexicographic optimum.
  *
- * Moreover, m = min_i(b_i(p)) satisfies the constraints on u and can
- * therefore be plugged into the solution.
- */
-static union isl_lex_res basic_map_partial_lexopt_symm(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty, int max, int first, int second,
-	__isl_give union isl_lex_res (*core)(__isl_take isl_basic_map *bmap,
-					    __isl_take isl_basic_set *dom,
-					    __isl_give isl_set **empty,
-					    int max, __isl_take isl_mat *cst,
-					    __isl_take isl_space *map_space,
-					    __isl_take isl_space *set_space))
-{
-	int i, n, k;
-	int *list = NULL;
-	unsigned n_in, n_out, n_div;
-	isl_ctx *ctx;
-	isl_vec *var = NULL;
-	isl_mat *cst = NULL;
-	isl_space *map_space, *set_space;
-	union isl_lex_res res;
-
-	map_space = isl_basic_map_get_space(bmap);
-	set_space = empty ? isl_basic_set_get_space(dom) : NULL;
-
-	n_in = isl_basic_map_dim(bmap, isl_dim_param) +
-	       isl_basic_map_dim(bmap, isl_dim_in);
-	n_out = isl_basic_map_dim(bmap, isl_dim_all) - n_in;
-
-	ctx = isl_basic_map_get_ctx(bmap);
-	list = isl_alloc_array(ctx, int, bmap->n_ineq);
-	var = isl_vec_alloc(ctx, n_out);
-	if ((bmap->n_ineq && !list) || (n_out && !var))
-		goto error;
-
-	list[0] = first;
-	list[1] = second;
-	isl_seq_cpy(var->el, bmap->ineq[first] + 1 + n_in, n_out);
-	for (i = second + 1, n = 2; i < bmap->n_ineq; ++i) {
-		if (isl_seq_eq(var->el, bmap->ineq[i] + 1 + n_in, n_out))
-			list[n++] = i;
-	}
-
-	cst = isl_mat_alloc(ctx, n, 1 + n_in);
-	if (!cst)
-		goto error;
-
-	for (i = 0; i < n; ++i)
-		isl_seq_cpy(cst->row[i], bmap->ineq[list[i]], 1 + n_in);
-
-	bmap = isl_basic_map_cow(bmap);
-	if (!bmap)
-		goto error;
-	for (i = n - 1; i >= 0; --i)
-		if (isl_basic_map_drop_inequality(bmap, list[i]) < 0)
-			goto error;
-
-	bmap = isl_basic_map_add_dims(bmap, isl_dim_in, 1);
-	bmap = isl_basic_map_extend_constraints(bmap, 0, 1);
-	k = isl_basic_map_alloc_inequality(bmap);
-	if (k < 0)
-		goto error;
-	isl_seq_clr(bmap->ineq[k], 1 + n_in);
-	isl_int_set_si(bmap->ineq[k][1 + n_in], 1);
-	isl_seq_cpy(bmap->ineq[k] + 1 + n_in + 1, var->el, n_out);
-	bmap = isl_basic_map_finalize(bmap);
-
-	n_div = isl_basic_set_dim(dom, isl_dim_div);
-	dom = isl_basic_set_add_dims(dom, isl_dim_set, 1);
-	dom = isl_basic_set_extend_constraints(dom, 0, n);
-	for (i = 0; i < n; ++i) {
-		k = isl_basic_set_alloc_inequality(dom);
-		if (k < 0)
-			goto error;
-		isl_seq_cpy(dom->ineq[k], cst->row[i], 1 + n_in);
-		isl_int_set_si(dom->ineq[k][1 + n_in], -1);
-		isl_seq_clr(dom->ineq[k] + 1 + n_in + 1, n_div);
-	}
-
-	isl_vec_free(var);
-	free(list);
-
-	return core(bmap, dom, empty, max, cst, map_space, set_space);
-error:
-	isl_space_free(map_space);
-	isl_space_free(set_space);
-	isl_mat_free(cst);
-	isl_vec_free(var);
-	free(list);
-	isl_basic_set_free(dom);
-	isl_basic_map_free(bmap);
-	res.p = NULL;
-	return res;
-}
-
-static __isl_give isl_map *basic_map_partial_lexopt_symm_map(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty, int max, int first, int second)
-{
-	return basic_map_partial_lexopt_symm(bmap, dom, empty, max,
-		    first, second, &basic_map_partial_lexopt_symm_map_core).map;
-}
-
-/* Recursive part of isl_tab_basic_map_partial_lexopt, after detecting
- * equalities and removing redundant constraints.
+ * This function is only called when the caller wants to compute a full
+ * lexicographic optimum, i.e., without specifying a domain.  In this case,
+ * the caller is not interested in the part of the domain space where
+ * there is no solution and the domain can be initialized to those constraints
+ * of "bmap" that only involve the parameters and the input dimensions.
+ * This relieves the parametric programming engine from detecting those
+ * inequalities and transferring them to the context.  More importantly,
+ * it ensures that those inequalities are transferred first and not
+ * intermixed with inequalities that actually split the domain.
  *
- * We first check if there are any parallel constraints (left).
- * If not, we are in the base case.
- * If there are parallel constraints, we replace them by a single
- * constraint in basic_map_partial_lexopt_symm and then call
- * this function recursively to look for more parallel constraints.
+ * If the caller does not require the absence of existentially quantified
+ * variables in the result (i.e., if ISL_OPT_QE is not set in "flags"),
+ * then the actual domain of "bmap" can be used.  This ensures that
+ * the domain does not need to be split at all just to separate out
+ * pieces of the domain that do not have a solution from piece that do.
+ * This domain cannot be used in general because it may involve
+ * (unknown) existentially quantified variables which will then also
+ * appear in the solution.
  */
-static __isl_give isl_map *basic_map_partial_lexopt(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty, int max)
+static __isl_give isl_basic_set *extract_domain(__isl_keep isl_basic_map *bmap,
+	unsigned flags)
 {
-	int par = 0;
-	int first, second;
-
-	if (!bmap)
-		goto error;
+	int n_div;
+	int n_out;
 
-	if (bmap->ctx->opt->pip_symmetry)
-		par = parallel_constraints(bmap, &first, &second);
-	if (par < 0)
-		goto error;
-	if (!par)
-		return basic_map_partial_lexopt_base_map(bmap, dom, empty, max);
-	
-	return basic_map_partial_lexopt_symm_map(bmap, dom, empty, max,
-						 first, second);
-error:
-	isl_basic_set_free(dom);
-	isl_basic_map_free(bmap);
-	return NULL;
+	n_div = isl_basic_map_dim(bmap, isl_dim_div);
+	n_out = isl_basic_map_dim(bmap, isl_dim_out);
+	bmap = isl_basic_map_copy(bmap);
+	if (ISL_FL_ISSET(flags, ISL_OPT_QE)) {
+		bmap = isl_basic_map_drop_constraints_involving_dims(bmap,
+							isl_dim_div, 0, n_div);
+		bmap = isl_basic_map_drop_constraints_involving_dims(bmap,
+							isl_dim_out, 0, n_out);
+	}
+	return isl_basic_map_domain(bmap);
 }
 
-/* Compute the lexicographic minimum (or maximum if "max" is set)
- * of "bmap" over the domain "dom" and return the result as a map.
- * If "empty" is not NULL, then *empty is assigned a set that
- * contains those parts of the domain where there is no solution.
- * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
- * then we compute the rational optimum.  Otherwise, we compute
- * the integral optimum.
- *
- * We perform some preprocessing.  As the PILP solver does not
- * handle implicit equalities very well, we first make sure all
- * the equalities are explicitly available.
- *
- * We also add context constraints to the basic map and remove
- * redundant constraints.  This is only needed because of the
- * way we handle simple symmetries.  In particular, we currently look
- * for symmetries on the constraints, before we set up the main tableau.
- * It is then no good to look for symmetries on possibly redundant constraints.
- */
-struct isl_map *isl_tab_basic_map_partial_lexopt(
-		struct isl_basic_map *bmap, struct isl_basic_set *dom,
-		struct isl_set **empty, int max)
-{
-	if (empty)
-		*empty = NULL;
-	if (!bmap || !dom)
-		goto error;
-
-	isl_assert(bmap->ctx,
-	    isl_basic_map_compatible_domain(bmap, dom), goto error);
-
-	if (isl_basic_set_dim(dom, isl_dim_all) == 0)
-		return basic_map_partial_lexopt(bmap, dom, empty, max);
-
-	bmap = isl_basic_map_intersect_domain(bmap, isl_basic_set_copy(dom));
-	bmap = isl_basic_map_detect_equalities(bmap);
-	bmap = isl_basic_map_remove_redundancies(bmap);
-
-	return basic_map_partial_lexopt(bmap, dom, empty, max);
-error:
-	isl_basic_set_free(dom);
-	isl_basic_map_free(bmap);
-	return NULL;
-}
+#undef TYPE
+#define TYPE	isl_map
+#undef SUFFIX
+#define SUFFIX
+#include "isl_tab_lexopt_templ.c"
 
 struct isl_sol_for {
 	struct isl_sol	sol;
-	int		(*fn)(__isl_take isl_basic_set *dom,
+	isl_stat	(*fn)(__isl_take isl_basic_set *dom,
 				__isl_take isl_aff_list *list, void *user);
 	void		*user;
 };
 
-static void sol_for_free(struct isl_sol_for *sol_for)
+static void sol_for_free(struct isl_sol *sol)
 {
-	if (!sol_for)
-		return;
-	if (sol_for->sol.context)
-		sol_for->sol.context->op->free(sol_for->sol.context);
-	free(sol_for);
-}
-
-static void sol_for_free_wrap(struct isl_sol *sol)
-{
-	sol_for_free((struct isl_sol_for *)sol);
 }
 
 /* Add the solution identified by the tableau and the context tableau.
+ * In particular, "dom" represents the context and "ma" expresses
+ * the solution on that context.
  *
  * See documentation of sol_add for more details.
  *
@@ -4803,30 +4923,23 @@ static void sol_for_free_wrap(struct isl_sol *sol)
  * affine expressions in the list is equal to the number of output variables.
  */
 static void sol_for_add(struct isl_sol_for *sol,
-	struct isl_basic_set *dom, struct isl_mat *M)
+	__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)
 {
-	int i;
+	int i, n;
 	isl_ctx *ctx;
-	isl_local_space *ls;
 	isl_aff *aff;
 	isl_aff_list *list;
 
-	if (sol->sol.error || !dom || !M)
+	if (sol->sol.error || !dom || !ma)
 		goto error;
 
 	ctx = isl_basic_set_get_ctx(dom);
-	ls = isl_basic_set_get_local_space(dom);
-	list = isl_aff_list_alloc(ctx, M->n_row - 1);
-	for (i = 1; i < M->n_row; ++i) {
-		aff = isl_aff_alloc(isl_local_space_copy(ls));
-		if (aff) {
-			isl_int_set(aff->v->el[0], M->row[0][0]);
-			isl_seq_cpy(aff->v->el + 1, M->row[i], M->n_col);
-		}
-		aff = isl_aff_normalize(aff);
+	n = isl_multi_aff_dim(ma, isl_dim_out);
+	list = isl_aff_list_alloc(ctx, n);
+	for (i = 0; i < n; ++i) {
+		aff = isl_multi_aff_get_aff(ma, i);
 		list = isl_aff_list_add(list, aff);
 	}
-	isl_local_space_free(ls);
 
 	dom = isl_basic_set_finalize(dom);
 
@@ -4834,23 +4947,23 @@ static void sol_for_add(struct isl_sol_for *sol,
 		goto error;
 
 	isl_basic_set_free(dom);
-	isl_mat_free(M);
+	isl_multi_aff_free(ma);
 	return;
 error:
 	isl_basic_set_free(dom);
-	isl_mat_free(M);
+	isl_multi_aff_free(ma);
 	sol->sol.error = 1;
 }
 
 static void sol_for_add_wrap(struct isl_sol *sol,
-	struct isl_basic_set *dom, struct isl_mat *M)
+	__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)
 {
-	sol_for_add((struct isl_sol_for *)sol, dom, M);
+	sol_for_add((struct isl_sol_for *)sol, dom, ma);
 }
 
-static struct isl_sol_for *sol_for_init(struct isl_basic_map *bmap, int max,
-	int (*fn)(__isl_take isl_basic_set *dom, __isl_take isl_aff_list *list,
-		  void *user),
+static struct isl_sol_for *sol_for_init(__isl_keep isl_basic_map *bmap, int max,
+	isl_stat (*fn)(__isl_take isl_basic_set *dom,
+		__isl_take isl_aff_list *list, void *user),
 	void *user)
 {
 	struct isl_sol_for *sol_for = NULL;
@@ -4864,26 +4977,19 @@ static struct isl_sol_for *sol_for_init(struct isl_basic_map *bmap, int max,
 	dom_dim = isl_space_domain(isl_space_copy(bmap->dim));
 	dom = isl_basic_set_universe(dom_dim);
 
-	sol_for->sol.rational = ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);
-	sol_for->sol.dec_level.callback.run = &sol_dec_level_wrap;
-	sol_for->sol.dec_level.sol = &sol_for->sol;
+	sol_for->sol.free = &sol_for_free;
+	if (sol_init(&sol_for->sol, bmap, dom, max) < 0)
+		goto error;
 	sol_for->fn = fn;
 	sol_for->user = user;
-	sol_for->sol.max = max;
-	sol_for->sol.n_out = isl_basic_map_dim(bmap, isl_dim_out);
 	sol_for->sol.add = &sol_for_add_wrap;
 	sol_for->sol.add_empty = NULL;
-	sol_for->sol.free = &sol_for_free_wrap;
-
-	sol_for->sol.context = isl_context_alloc(dom);
-	if (!sol_for->sol.context)
-		goto error;
 
 	isl_basic_set_free(dom);
 	return sol_for;
 error:
 	isl_basic_set_free(dom);
-	sol_for_free(sol_for);
+	sol_free(&sol_for->sol);
 	return NULL;
 }
 
@@ -4893,9 +4999,9 @@ static void sol_for_find_solutions(struct isl_sol_for *sol_for,
 	find_solutions_main(&sol_for->sol, tab);
 }
 
-int isl_basic_map_foreach_lexopt(__isl_keep isl_basic_map *bmap, int max,
-	int (*fn)(__isl_take isl_basic_set *dom, __isl_take isl_aff_list *list,
-		  void *user),
+isl_stat isl_basic_map_foreach_lexopt(__isl_keep isl_basic_map *bmap, int max,
+	isl_stat (*fn)(__isl_take isl_basic_set *dom,
+		__isl_take isl_aff_list *list, void *user),
 	void *user)
 {
 	struct isl_sol_for *sol_for = NULL;
@@ -4903,7 +5009,7 @@ int isl_basic_map_foreach_lexopt(__isl_keep isl_basic_map *bmap, int max,
 	bmap = isl_basic_map_copy(bmap);
 	bmap = isl_basic_map_detect_equalities(bmap);
 	if (!bmap)
-		return -1;
+		return isl_stat_error;
 
 	sol_for = sol_for_init(bmap, max, fn, user);
 	if (!sol_for)
@@ -4924,75 +5030,88 @@ int isl_basic_map_foreach_lexopt(__isl_keep isl_basic_map *bmap, int max,
 
 	sol_free(&sol_for->sol);
 	isl_basic_map_free(bmap);
-	return 0;
+	return isl_stat_ok;
 error:
 	sol_free(&sol_for->sol);
 	isl_basic_map_free(bmap);
-	return -1;
+	return isl_stat_error;
 }
 
-int isl_basic_set_foreach_lexopt(__isl_keep isl_basic_set *bset, int max,
-	int (*fn)(__isl_take isl_basic_set *dom, __isl_take isl_aff_list *list,
-		  void *user),
-	void *user)
-{
-	return isl_basic_map_foreach_lexopt(bset, max, fn, user);
-}
-
-/* Check if the given sequence of len variables starting at pos
- * represents a trivial (i.e., zero) solution.
- * The variables are assumed to be non-negative and to come in pairs,
- * with each pair representing a variable of unrestricted sign.
- * The solution is trivial if each such pair in the sequence consists
- * of two identical values, meaning that the variable being represented
- * has value zero.
+/* Extract the subsequence of the sample value of "tab"
+ * starting at "pos" and of length "len".
  */
-static int region_is_trivial(struct isl_tab *tab, int pos, int len)
+static __isl_give isl_vec *extract_sample_sequence(struct isl_tab *tab,
+	int pos, int len)
 {
 	int i;
+	isl_ctx *ctx;
+	isl_vec *v;
 
-	if (len == 0)
-		return 0;
+	ctx = isl_tab_get_ctx(tab);
+	v = isl_vec_alloc(ctx, len);
+	if (!v)
+		return NULL;
+	for (i = 0; i < len; ++i) {
+		if (!tab->var[pos + i].is_row) {
+			isl_int_set_si(v->el[i], 0);
+		} else {
+			int row;
 
-	for (i = 0; i < len; i +=  2) {
-		int neg_row;
-		int pos_row;
+			row = tab->var[pos + i].index;
+			isl_int_set(v->el[i], tab->mat->row[row][1]);
+		}
+	}
 
-		neg_row = tab->var[pos + i].is_row ?
-				tab->var[pos + i].index : -1;
-		pos_row = tab->var[pos + i + 1].is_row ?
-				tab->var[pos + i + 1].index : -1;
+	return v;
+}
 
-		if ((neg_row < 0 ||
-		     isl_int_is_zero(tab->mat->row[neg_row][1])) &&
-		    (pos_row < 0 ||
-		     isl_int_is_zero(tab->mat->row[pos_row][1])))
-			continue;
+/* Check if the sequence of variables starting at "pos"
+ * represents a trivial solution according to "trivial".
+ * That is, is the result of applying "trivial" to this sequence
+ * equal to the zero vector?
+ */
+static isl_bool region_is_trivial(struct isl_tab *tab, int pos,
+	__isl_keep isl_mat *trivial)
+{
+	int n, len;
+	isl_vec *v;
+	isl_bool is_trivial;
 
-		if (neg_row < 0 || pos_row < 0)
-			return 0;
-		if (isl_int_ne(tab->mat->row[neg_row][1],
-			       tab->mat->row[pos_row][1]))
-			return 0;
-	}
+	if (!trivial)
+		return isl_bool_error;
 
-	return 1;
+	n = isl_mat_rows(trivial);
+	if (n == 0)
+		return isl_bool_false;
+
+	len = isl_mat_cols(trivial);
+	v = extract_sample_sequence(tab, pos, len);
+	v = isl_mat_vec_product(isl_mat_copy(trivial), v);
+	is_trivial = isl_vec_is_zero(v);
+	isl_vec_free(v);
+
+	return is_trivial;
 }
 
-/* Return the index of the first trivial region or -1 if all regions
- * are non-trivial.
+/* Return the index of the first trivial region, "n_region" if all regions
+ * are non-trivial or -1 in case of error.
  */
 static int first_trivial_region(struct isl_tab *tab,
-	int n_region, struct isl_region *region)
+	int n_region, struct isl_trivial_region *region)
 {
 	int i;
 
 	for (i = 0; i < n_region; ++i) {
-		if (region_is_trivial(tab, region[i].pos, region[i].len))
+		isl_bool trivial;
+		trivial = region_is_trivial(tab, region[i].pos,
+					region[i].trivial);
+		if (trivial < 0)
+			return -1;
+		if (trivial)
 			return i;
 	}
 
-	return -1;
+	return n_region;
 }
 
 /* Check if the solution is optimal, i.e., whether the first
@@ -5014,28 +5133,32 @@ static int is_optimal(__isl_keep isl_vec *sol, int n_op)
  * with all previous coefficients) to be zero.
  * If the solution is already optimal (all relevant coefficients are zero),
  * then just mark the table as empty.
+ * "n_zero" is the number of coefficients that have been forced zero
+ * by previous calls to this function at the same level.
+ * Return the updated number of forced zero coefficients or -1 on error.
  *
- * This function assumes that at least 2 * n_op more rows and at least
- * 2 * n_op more elements in the constraint array are available in the tableau.
+ * This function assumes that at least 2 * (n_op - n_zero) more rows and
+ * at least 2 * (n_op - n_zero) more elements in the constraint array
+ * are available in the tableau.
  */
 static int force_better_solution(struct isl_tab *tab,
-	__isl_keep isl_vec *sol, int n_op)
+	__isl_keep isl_vec *sol, int n_op, int n_zero)
 {
-	int i;
+	int i, n;
 	isl_ctx *ctx;
 	isl_vec *v = NULL;
 
 	if (!sol)
 		return -1;
 
-	for (i = 0; i < n_op; ++i)
+	for (i = n_zero; i < n_op; ++i)
 		if (!isl_int_is_zero(sol->el[1 + i]))
 			break;
 
 	if (i == n_op) {
 		if (isl_tab_mark_empty(tab) < 0)
 			return -1;
-		return 0;
+		return n_op;
 	}
 
 	ctx = isl_vec_get_ctx(sol);
@@ -5043,7 +5166,8 @@ static int force_better_solution(struct isl_tab *tab,
 	if (!v)
 		return -1;
 
-	for (; i >= 0; --i) {
+	n = i + 1;
+	for (; i >= n_zero; --i) {
 		v = isl_vec_clr(v);
 		isl_int_set_si(v->el[1 + i], -1);
 		if (add_lexmin_eq(tab, v->el) < 0)
@@ -5051,16 +5175,92 @@ static int force_better_solution(struct isl_tab *tab,
 	}
 
 	isl_vec_free(v);
-	return 0;
+	return n;
 error:
 	isl_vec_free(v);
 	return -1;
 }
 
+/* Global internal data for isl_tab_basic_set_non_trivial_lexmin.
+ *
+ * "v" is a pre-allocated vector that can be used for adding
+ * constraints to the tableau.
+ */
+struct isl_trivial_global {
+	isl_vec *v;
+};
+
+/* Fix triviality direction "dir" of the given region to zero.
+ *
+ * This function assumes that at least two more rows and at least
+ * two more elements in the constraint array are available in the tableau.
+ */
+static isl_stat fix_zero(struct isl_tab *tab, struct isl_trivial_region *region,
+	int dir, struct isl_trivial_global *data)
+{
+	int len;
+
+	data->v = isl_vec_clr(data->v);
+	if (!data->v)
+		return isl_stat_error;
+	len = isl_mat_cols(region->trivial);
+	isl_seq_cpy(data->v->el + 1 + region->pos, region->trivial->row[dir],
+		    len);
+	if (add_lexmin_eq(tab, data->v->el) < 0)
+		return isl_stat_error;
+
+	return isl_stat_ok;
+}
+
+/* This function selects case "side" for non-triviality region "region",
+ * assuming all the equality constraints have been imposed already.
+ * In particular, the triviality direction side/2 is made positive
+ * if side is even and made negative if side is odd.
+ *
+ * This function assumes that at least one more row and at least
+ * one more element in the constraint array are available in the tableau.
+ */
+static struct isl_tab *pos_neg(struct isl_tab *tab,
+	struct isl_trivial_region *region,
+	int side, struct isl_trivial_global *data)
+{
+	int len;
+
+	data->v = isl_vec_clr(data->v);
+	if (!data->v)
+		goto error;
+	isl_int_set_si(data->v->el[0], -1);
+	len = isl_mat_cols(region->trivial);
+	if (side % 2 == 0)
+		isl_seq_cpy(data->v->el + 1 + region->pos,
+			    region->trivial->row[side / 2], len);
+	else
+		isl_seq_neg(data->v->el + 1 + region->pos,
+			    region->trivial->row[side / 2], len);
+	return add_lexmin_ineq(tab, data->v->el);
+error:
+	isl_tab_free(tab);
+	return NULL;
+}
+
+/* Local data at each level of the backtracking procedure of
+ * isl_tab_basic_set_non_trivial_lexmin.
+ *
+ * "update" is set if a solution has been found in the current case
+ * of this level, such that a better solution needs to be enforced
+ * in the next case.
+ * "n_zero" is the number of initial coordinates that have already
+ * been forced to be zero at this level.
+ * "region" is the non-triviality region considered at this level.
+ * "side" is the index of the current case at this level.
+ * "n" is the number of triviality directions.
+ */
 struct isl_trivial {
 	int update;
+	int n_zero;
 	int region;
 	int side;
+	int n;
 	struct isl_tab_undo *snap;
 };
 
@@ -5071,46 +5271,44 @@ struct isl_trivial {
  *
  * n_op is the number of initial coordinates to optimize.
  * That is, once a solution has been found, we will only continue looking
- * for solution that result in significantly better values for those
+ * for solutions that result in significantly better values for those
  * initial coordinates.  That is, we only continue looking for solutions
  * that increase the number of initial zeros in this sequence.
  *
  * A solution is non-trivial, if it is non-trivial on each of the
- * specified regions.  Each region represents a sequence of pairs
- * of variables.  A solution is non-trivial on such a region if
- * at least one of these pairs consists of different values, i.e.,
- * such that the non-negative variable represented by the pair is non-zero.
+ * specified regions.  Each region represents a sequence of
+ * triviality directions on a sequence of variables that starts
+ * at a given position.  A solution is non-trivial on such a region if
+ * at least one of the triviality directions is non-zero
+ * on that sequence of variables.
  *
  * Whenever a conflict is encountered, all constraints involved are
  * reported to the caller through a call to "conflict".
  *
  * We perform a simple branch-and-bound backtracking search.
- * Each level in the search represents initially trivial region that is forced
- * to be non-trivial.
- * At each level we consider n cases, where n is the length of the region.
- * In terms of the n/2 variables of unrestricted signs being encoded by
- * the region, we consider the cases
- *	x_0 >= 1
- *	x_0 <= -1
- *	x_0 = 0 and x_1 >= 1
- *	x_0 = 0 and x_1 <= -1
- *	x_0 = 0 and x_1 = 0 and x_2 >= 1
- *	x_0 = 0 and x_1 = 0 and x_2 <= -1
+ * Each level in the search represents an initially trivial region
+ * that is forced to be non-trivial.
+ * At each level we consider 2 * n cases, where n
+ * is the number of triviality directions.
+ * In terms of those n directions v_i, we consider the cases
+ *	v_0 >= 1
+ *	v_0 <= -1
+ *	v_0 = 0 and v_1 >= 1
+ *	v_0 = 0 and v_1 <= -1
+ *	v_0 = 0 and v_1 = 0 and v_2 >= 1
+ *	v_0 = 0 and v_1 = 0 and v_2 <= -1
  *	...
- * The cases are considered in this order, assuming that each pair
- * x_i_a x_i_b represents the value x_i_b - x_i_a.
- * That is, x_0 >= 1 is enforced by adding the constraint
- *	x_0_b - x_0_a >= 1
+ * in this order.
  */
 __isl_give isl_vec *isl_tab_basic_set_non_trivial_lexmin(
 	__isl_take isl_basic_set *bset, int n_op, int n_region,
-	struct isl_region *region,
+	struct isl_trivial_region *region,
 	int (*conflict)(int con, void *user), void *user)
 {
-	int i, j;
+	struct isl_trivial_global data = { 0 };
+	int i;
 	int r;
 	isl_ctx *ctx;
-	isl_vec *v = NULL;
 	isl_vec *sol = NULL;
 	struct isl_tab *tab;
 	struct isl_trivial *triv = NULL;
@@ -5128,9 +5326,9 @@ __isl_give isl_vec *isl_tab_basic_set_non_trivial_lexmin(
 	tab->conflict = conflict;
 	tab->conflict_user = user;
 
-	v = isl_vec_alloc(ctx, 1 + tab->n_var);
+	data.v = isl_vec_alloc(ctx, 1 + tab->n_var);
 	triv = isl_calloc_array(ctx, struct isl_trivial, n_region);
-	if (!v || (n_region && !triv))
+	if (!data.v || (n_region && !triv))
 		goto error;
 
 	level = 0;
@@ -5146,7 +5344,9 @@ __isl_give isl_vec *isl_tab_basic_set_non_trivial_lexmin(
 			if (tab->empty)
 				goto backtrack;
 			r = first_trivial_region(tab, n_region, region);
-			if (r < 0) {
+			if (r < 0)
+				goto error;
+			if (r == n_region) {
 				for (i = 0; i < level; ++i)
 					triv[i].update = 1;
 				isl_vec_free(sol);
@@ -5160,18 +5360,21 @@ __isl_give isl_vec *isl_tab_basic_set_non_trivial_lexmin(
 			if (level >= n_region)
 				isl_die(ctx, isl_error_internal,
 					"nesting level too deep", goto error);
+			triv[level].n = isl_mat_rows(region[r].trivial);
 			if (isl_tab_extend_cons(tab,
-					    2 * region[r].len + 2 * n_op) < 0)
+					    2 * triv[level].n + 2 * n_op) < 0)
 				goto error;
 			triv[level].region = r;
 			triv[level].side = 0;
+			triv[level].update = 0;
+			triv[level].n_zero = 0;
 		}
 
 		r = triv[level].region;
 		side = triv[level].side;
 		base = 2 * (side/2);
 
-		if (side >= region[r].len) {
+		if (side >= 2 * triv[level].n) {
 backtrack:
 			level--;
 			init = 0;
@@ -5182,29 +5385,24 @@ backtrack:
 		}
 
 		if (triv[level].update) {
-			if (force_better_solution(tab, sol, n_op) < 0)
+			triv[level].n_zero = force_better_solution(tab, sol,
+						    n_op, triv[level].n_zero);
+			if (triv[level].n_zero < 0)
 				goto error;
 			triv[level].update = 0;
 		}
 
-		if (side == base && base >= 2) {
-			for (j = base - 2; j < base; ++j) {
-				v = isl_vec_clr(v);
-				isl_int_set_si(v->el[1 + region[r].pos + j], 1);
-				if (add_lexmin_eq(tab, v->el) < 0)
-					goto error;
-			}
-		}
+		if (side == base && base >= 2 &&
+		    fix_zero(tab, &region[r], base / 2 - 1, &data) < 0)
+			goto error;
 
 		triv[level].snap = isl_tab_snap(tab);
 		if (isl_tab_push_basis(tab) < 0)
 			goto error;
 
-		v = isl_vec_clr(v);
-		isl_int_set_si(v->el[0], -1);
-		isl_int_set_si(v->el[1 + region[r].pos + side], -1);
-		isl_int_set_si(v->el[1 + region[r].pos + (side ^ 1)], 1);
-		tab = add_lexmin_ineq(tab, v->el);
+		tab = pos_neg(tab, &region[r], side, &data);
+		if (!tab)
+			goto error;
 
 		triv[level].side++;
 		level++;
@@ -5212,14 +5410,14 @@ backtrack:
 	}
 
 	free(triv);
-	isl_vec_free(v);
+	isl_vec_free(data.v);
 	isl_tab_free(tab);
 	isl_basic_set_free(bset);
 
 	return sol;
 error:
 	free(triv);
-	isl_vec_free(v);
+	isl_vec_free(data.v);
 	isl_tab_free(tab);
 	isl_basic_set_free(bset);
 	isl_vec_free(sol);
@@ -5312,6 +5510,20 @@ __isl_give isl_tab_lexmin *isl_tab_lexmin_add_eq(__isl_take isl_tab_lexmin *tl,
 	return tl;
 }
 
+/* Add cuts to "tl" until the sample value reaches an integer value or
+ * until the result becomes empty.
+ */
+__isl_give isl_tab_lexmin *isl_tab_lexmin_cut_to_integer(
+	__isl_take isl_tab_lexmin *tl)
+{
+	if (!tl)
+		return NULL;
+	tl->tab = cut_to_integer_lexmin(tl->tab, CUT_ONE);
+	if (!tl->tab)
+		return isl_tab_lexmin_free(tl);
+	return tl;
+}
+
 /* Return the lexicographically smallest rational point in the basic set
  * from which "tl" was constructed.
  * If the original input was empty, then return a zero-length vector.
@@ -5326,37 +5538,17 @@ __isl_give isl_vec *isl_tab_lexmin_get_solution(__isl_keep isl_tab_lexmin *tl)
 		return isl_tab_get_sample_value(tl->tab);
 }
 
-/* Return the lexicographically smallest rational point in "bset",
- * assuming that all variables are non-negative.
- * If "bset" is empty, then return a zero-length vector.
- */
-__isl_give isl_vec *isl_tab_basic_set_non_neg_lexmin(
-	__isl_take isl_basic_set *bset)
-{
-	isl_tab_lexmin *tl;
-	isl_vec *sol;
-
-	tl = isl_tab_lexmin_from_basic_set(bset);
-	sol = isl_tab_lexmin_get_solution(tl);
-	isl_tab_lexmin_free(tl);
-	return sol;
-}
-
 struct isl_sol_pma {
 	struct isl_sol	sol;
 	isl_pw_multi_aff *pma;
 	isl_set *empty;
 };
 
-static void sol_pma_free(struct isl_sol_pma *sol_pma)
+static void sol_pma_free(struct isl_sol *sol)
 {
-	if (!sol_pma)
-		return;
-	if (sol_pma->sol.context)
-		sol_pma->sol.context->op->free(sol_pma->sol.context);
+	struct isl_sol_pma *sol_pma = (struct isl_sol_pma *) sol;
 	isl_pw_multi_aff_free(sol_pma->pma);
 	isl_set_free(sol_pma->empty);
-	free(sol_pma);
 }
 
 /* This function is called for parts of the context where there is
@@ -5381,33 +5573,16 @@ error:
 	sol->sol.error = 1;
 }
 
-/* Given a basic map "dom" that represents the context and an affine
- * matrix "M" that maps the dimensions of the context to the
- * output variables, construct an isl_pw_multi_aff with a single
- * cell corresponding to "dom" and affine expressions copied from "M".
+/* Given a basic set "dom" that represents the context and a tuple of
+ * affine expressions "maff" defined over this domain, construct
+ * an isl_pw_multi_aff with a single cell corresponding to "dom" and
+ * the affine expressions in "maff".
  */
 static void sol_pma_add(struct isl_sol_pma *sol,
-	__isl_take isl_basic_set *dom, __isl_take isl_mat *M)
+	__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *maff)
 {
-	int i;
-	isl_local_space *ls;
-	isl_aff *aff;
-	isl_multi_aff *maff;
 	isl_pw_multi_aff *pma;
 
-	maff = isl_multi_aff_alloc(isl_pw_multi_aff_get_space(sol->pma));
-	ls = isl_basic_set_get_local_space(dom);
-	for (i = 1; i < M->n_row; ++i) {
-		aff = isl_aff_alloc(isl_local_space_copy(ls));
-		if (aff) {
-			isl_int_set(aff->v->el[0], M->row[0][0]);
-			isl_seq_cpy(aff->v->el + 1, M->row[i], M->n_col);
-		}
-		aff = isl_aff_normalize(aff);
-		maff = isl_multi_aff_set_aff(maff, i - 1, aff);
-	}
-	isl_local_space_free(ls);
-	isl_mat_free(M);
 	dom = isl_basic_set_simplify(dom);
 	dom = isl_basic_set_finalize(dom);
 	pma = isl_pw_multi_aff_alloc(isl_set_from_basic_set(dom), maff);
@@ -5416,11 +5591,6 @@ static void sol_pma_add(struct isl_sol_pma *sol,
 		sol->sol.error = 1;
 }
 
-static void sol_pma_free_wrap(struct isl_sol *sol)
-{
-	sol_pma_free((struct isl_sol_pma *)sol);
-}
-
 static void sol_pma_add_empty_wrap(struct isl_sol *sol,
 	__isl_take isl_basic_set *bset)
 {
@@ -5428,9 +5598,9 @@ static void sol_pma_add_empty_wrap(struct isl_sol *sol,
 }
 
 static void sol_pma_add_wrap(struct isl_sol *sol,
-	__isl_take isl_basic_set *dom, __isl_take isl_mat *M)
+	__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)
 {
-	sol_pma_add((struct isl_sol_pma *)sol, dom, M);
+	sol_pma_add((struct isl_sol_pma *)sol, dom, ma);
 }
 
 /* Construct an isl_sol_pma structure for accumulating the solution.
@@ -5444,6 +5614,7 @@ static struct isl_sol *sol_pma_init(__isl_keep isl_basic_map *bmap,
 	__isl_take isl_basic_set *dom, int track_empty, int max)
 {
 	struct isl_sol_pma *sol_pma = NULL;
+	isl_space *space;
 
 	if (!bmap)
 		goto error;
@@ -5452,22 +5623,16 @@ static struct isl_sol *sol_pma_init(__isl_keep isl_basic_map *bmap,
 	if (!sol_pma)
 		goto error;
 
-	sol_pma->sol.rational = ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);
-	sol_pma->sol.dec_level.callback.run = &sol_dec_level_wrap;
-	sol_pma->sol.dec_level.sol = &sol_pma->sol;
-	sol_pma->sol.max = max;
-	sol_pma->sol.n_out = isl_basic_map_dim(bmap, isl_dim_out);
+	sol_pma->sol.free = &sol_pma_free;
+	if (sol_init(&sol_pma->sol, bmap, dom, max) < 0)
+		goto error;
 	sol_pma->sol.add = &sol_pma_add_wrap;
 	sol_pma->sol.add_empty = track_empty ? &sol_pma_add_empty_wrap : NULL;
-	sol_pma->sol.free = &sol_pma_free_wrap;
-	sol_pma->pma = isl_pw_multi_aff_empty(isl_basic_map_get_space(bmap));
+	space = isl_space_copy(sol_pma->sol.space);
+	sol_pma->pma = isl_pw_multi_aff_empty(space);
 	if (!sol_pma->pma)
 		goto error;
 
-	sol_pma->sol.context = isl_context_alloc(dom);
-	if (!sol_pma->sol.context)
-		goto error;
-
 	if (track_empty) {
 		sol_pma->empty = isl_set_alloc_space(isl_basic_set_get_space(dom),
 							1, ISL_SET_DISJOINT);
@@ -5479,16 +5644,16 @@ static struct isl_sol *sol_pma_init(__isl_keep isl_basic_map *bmap,
 	return &sol_pma->sol;
 error:
 	isl_basic_set_free(dom);
-	sol_pma_free(sol_pma);
+	sol_free(&sol_pma->sol);
 	return NULL;
 }
 
 /* Base case of isl_tab_basic_map_partial_lexopt, after removing
  * some obvious symmetries.
  *
- * We call basic_map_partial_lexopt_base and extract the results.
+ * We call basic_map_partial_lexopt_base_sol and extract the results.
  */
-static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_base_pma(
+static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_base_pw_multi_aff(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
 	__isl_give isl_set **empty, int max)
 {
@@ -5496,8 +5661,8 @@ static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_base_pma(
 	struct isl_sol *sol;
 	struct isl_sol_pma *sol_pma;
 
-	sol = basic_map_partial_lexopt_base(bmap, dom, empty, max,
-					    &sol_pma_init);
+	sol = basic_map_partial_lexopt_base_sol(bmap, dom, empty, max,
+						&sol_pma_init);
 	if (!sol)
 		return NULL;
 	sol_pma = (struct isl_sol_pma *) sol;
@@ -5633,9 +5798,15 @@ static __isl_give isl_pw_multi_aff *split_domain_pma(
 		if (need_substitution(opt->p[i].maff))
 			pma = isl_pw_multi_aff_substitute(pma,
 					isl_dim_in, n_in - 1, min_expr_pa);
-		else if (need_split_set(opt->p[i].set, cst))
-			pma = isl_pw_multi_aff_intersect_domain(pma,
+		else {
+			isl_bool split;
+			split = need_split_set(opt->p[i].set, cst);
+			if (split < 0)
+				pma = isl_pw_multi_aff_free(pma);
+			else if (split)
+				pma = isl_pw_multi_aff_intersect_domain(pma,
 						       isl_set_copy(min_expr));
+		}
 		pma = isl_pw_multi_aff_project_out(pma,
 						    isl_dim_in, n_in - 1, 1);
 
@@ -5655,7 +5826,7 @@ error:
 	return NULL;
 }
 
-static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_pma(
+static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_pw_multi_aff(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
 	__isl_give isl_set **empty, int max);
 
@@ -5668,7 +5839,8 @@ static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_pma(
  * We recursively call basic_map_partial_lexopt and then plug in
  * the definition of the minimum in the result.
  */
-static __isl_give union isl_lex_res basic_map_partial_lexopt_symm_pma_core(
+static __isl_give isl_pw_multi_aff *
+basic_map_partial_lexopt_symm_core_pw_multi_aff(
 	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
 	__isl_give isl_set **empty, int max, __isl_take isl_mat *cst,
 	__isl_take isl_space *map_space, __isl_take isl_space *set_space)
@@ -5676,13 +5848,12 @@ static __isl_give union isl_lex_res basic_map_partial_lexopt_symm_pma_core(
 	isl_pw_multi_aff *opt;
 	isl_pw_aff *min_expr_pa;
 	isl_set *min_expr;
-	union isl_lex_res res;
 
 	min_expr = set_minimum(isl_basic_set_get_space(dom), isl_mat_copy(cst));
 	min_expr_pa = set_minimum_pa(isl_basic_set_get_space(dom),
 					isl_mat_copy(cst));
 
-	opt = basic_map_partial_lexopt_pma(bmap, dom, empty, max);
+	opt = basic_map_partial_lexopt_pw_multi_aff(bmap, dom, empty, max);
 
 	if (empty) {
 		*empty = split(*empty,
@@ -5693,93 +5864,11 @@ static __isl_give union isl_lex_res basic_map_partial_lexopt_symm_pma_core(
 	opt = split_domain_pma(opt, min_expr_pa, min_expr, cst);
 	opt = isl_pw_multi_aff_reset_space(opt, map_space);
 
-	res.pma = opt;
-	return res;
-}
-
-static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_symm_pma(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty, int max, int first, int second)
-{
-	return basic_map_partial_lexopt_symm(bmap, dom, empty, max,
-		    first, second, &basic_map_partial_lexopt_symm_pma_core).pma;
+	return opt;
 }
 
-/* Recursive part of isl_basic_map_partial_lexopt_pw_multi_aff, after detecting
- * equalities and removing redundant constraints.
- *
- * We first check if there are any parallel constraints (left).
- * If not, we are in the base case.
- * If there are parallel constraints, we replace them by a single
- * constraint in basic_map_partial_lexopt_symm_pma and then call
- * this function recursively to look for more parallel constraints.
- */
-static __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_pma(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty, int max)
-{
-	int par = 0;
-	int first, second;
-
-	if (!bmap)
-		goto error;
-
-	if (bmap->ctx->opt->pip_symmetry)
-		par = parallel_constraints(bmap, &first, &second);
-	if (par < 0)
-		goto error;
-	if (!par)
-		return basic_map_partial_lexopt_base_pma(bmap, dom, empty, max);
-	
-	return basic_map_partial_lexopt_symm_pma(bmap, dom, empty, max,
-						 first, second);
-error:
-	isl_basic_set_free(dom);
-	isl_basic_map_free(bmap);
-	return NULL;
-}
-
-/* Compute the lexicographic minimum (or maximum if "max" is set)
- * of "bmap" over the domain "dom" and return the result as a piecewise
- * multi-affine expression.
- * If "empty" is not NULL, then *empty is assigned a set that
- * contains those parts of the domain where there is no solution.
- * If "bmap" is marked as rational (ISL_BASIC_MAP_RATIONAL),
- * then we compute the rational optimum.  Otherwise, we compute
- * the integral optimum.
- *
- * We perform some preprocessing.  As the PILP solver does not
- * handle implicit equalities very well, we first make sure all
- * the equalities are explicitly available.
- *
- * We also add context constraints to the basic map and remove
- * redundant constraints.  This is only needed because of the
- * way we handle simple symmetries.  In particular, we currently look
- * for symmetries on the constraints, before we set up the main tableau.
- * It is then no good to look for symmetries on possibly redundant constraints.
- */
-__isl_give isl_pw_multi_aff *isl_basic_map_partial_lexopt_pw_multi_aff(
-	__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,
-	__isl_give isl_set **empty, int max)
-{
-	if (empty)
-		*empty = NULL;
-	if (!bmap || !dom)
-		goto error;
-
-	isl_assert(bmap->ctx,
-	    isl_basic_map_compatible_domain(bmap, dom), goto error);
-
-	if (isl_basic_set_dim(dom, isl_dim_all) == 0)
-		return basic_map_partial_lexopt_pma(bmap, dom, empty, max);
-
-	bmap = isl_basic_map_intersect_domain(bmap, isl_basic_set_copy(dom));
-	bmap = isl_basic_map_detect_equalities(bmap);
-	bmap = isl_basic_map_remove_redundancies(bmap);
-
-	return basic_map_partial_lexopt_pma(bmap, dom, empty, max);
-error:
-	isl_basic_set_free(dom);
-	isl_basic_map_free(bmap);
-	return NULL;
-}
+#undef TYPE
+#define TYPE	isl_pw_multi_aff
+#undef SUFFIX
+#define SUFFIX	_pw_multi_aff
+#include "isl_tab_lexopt_templ.c"
diff --git a/lib/Analysis/isl/isl_test.c b/lib/Analysis/isl/isl_test.c
index 3f2b93f..2773be5 100644
--- a/lib/Analysis/isl/isl_test.c
+++ b/lib/Analysis/isl/isl_test.c
@@ -32,16 +32,16 @@
 #include <isl/schedule.h>
 #include <isl/schedule_node.h>
 #include <isl_options_private.h>
-#include <isl/vertices.h>
+#include <isl_vertices_private.h>
 #include <isl/ast_build.h>
 #include <isl/val.h>
 #include <isl/ilp.h>
 #include <isl_ast_build_expr.h>
 #include <isl/options.h>
 
-#define ARRAY_SIZE(array) (sizeof(array)/sizeof(*array))
+#include "isl_srcdir.c"
 
-static char *srcdir;
+#define ARRAY_SIZE(array) (sizeof(array)/sizeof(*array))
 
 static char *get_filename(isl_ctx *ctx, const char *name, const char *suffix) {
 	char *filename;
@@ -190,6 +190,8 @@ struct {
 	{ "{ [x] -> [] : exists (a, b: 0 <= a <= 1 and 0 <= b <= 3 and "
 			    "2b <= x - 8a and 2b >= -1 + x - 8a) }",
 	  "{ [x] -> [] : 0 <= x <= 15 }" },
+	{ "{ [x] -> [x] : }",
+	  "{ [x] -> [x] }" },
 };
 
 int test_parse(struct isl_ctx *ctx)
@@ -249,6 +251,7 @@ int test_parse(struct isl_ctx *ctx)
 	test_parse_map(ctx, "{ S1[i] -> [([i/10]),i%10] : 0 <= i <= 45 }");
 	test_parse_pwaff(ctx, "{ [i] -> [i + 1] : i > 0; [a] -> [a] : a < 0 }");
 	test_parse_pwqp(ctx, "{ [x] -> ([(x)/2] * [(x)/3]) }");
+	test_parse_pwaff(ctx, "{ [] -> [(100)] }");
 
 	return 0;
 }
@@ -289,7 +292,7 @@ static int test_read(isl_ctx *ctx)
 static int test_bounded(isl_ctx *ctx)
 {
 	isl_set *set;
-	int bounded;
+	isl_bool bounded;
 
 	set = isl_set_read_from_str(ctx, "[n] -> {[i] : 0 <= i <= n }");
 	bounded = isl_set_is_bounded(set);
@@ -326,7 +329,7 @@ static int test_bounded(isl_ctx *ctx)
 }
 
 /* Construct the basic set { [i] : 5 <= i <= N } */
-static int test_construction(isl_ctx *ctx)
+static int test_construction_1(isl_ctx *ctx)
 {
 	isl_int v;
 	isl_space *dim;
@@ -342,16 +345,16 @@ static int test_construction(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_inequality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_param, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_param, 0, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_inequality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, -5);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	isl_local_space_free(ls);
@@ -362,6 +365,49 @@ static int test_construction(isl_ctx *ctx)
 	return 0;
 }
 
+/* Construct the basic set { [x] : -100 <= x <= 100 }
+ * using isl_basic_set_{lower,upper}_bound_val and
+ * check that it is equal the same basic set parsed from a string.
+ */
+static int test_construction_2(isl_ctx *ctx)
+{
+	isl_bool equal;
+	isl_val *v;
+	isl_space *space;
+	isl_basic_set *bset1, *bset2;
+
+	v = isl_val_int_from_si(ctx, 100);
+	space = isl_space_set_alloc(ctx, 0, 1);
+	bset1 = isl_basic_set_universe(space);
+	bset1 = isl_basic_set_upper_bound_val(bset1, isl_dim_set, 0,
+						isl_val_copy(v));
+	bset1 = isl_basic_set_lower_bound_val(bset1, isl_dim_set, 0,
+						isl_val_neg(v));
+	bset2 = isl_basic_set_read_from_str(ctx, "{ [x] : -100 <= x <= 100 }");
+	equal = isl_basic_set_is_equal(bset1, bset2);
+	isl_basic_set_free(bset1);
+	isl_basic_set_free(bset2);
+
+	if (equal < 0)
+		return -1;
+	if (!equal)
+		isl_die(ctx, isl_error_unknown,
+			"failed construction", return -1);
+
+	return 0;
+}
+
+/* Basic tests for constructing basic sets.
+ */
+static int test_construction(isl_ctx *ctx)
+{
+	if (test_construction_1(ctx) < 0)
+		return -1;
+	if (test_construction_2(ctx) < 0)
+		return -1;
+	return 0;
+}
+
 static int test_dim(isl_ctx *ctx)
 {
 	const char *str;
@@ -684,20 +730,20 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);
@@ -713,20 +759,20 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);
@@ -742,20 +788,20 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -3);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 4);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);
@@ -771,20 +817,20 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 2);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 6);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 1, 2);
@@ -800,16 +846,16 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, -3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 2, 1);
@@ -825,16 +871,16 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 6);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, -3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 2, 1);
@@ -859,13 +905,13 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, -3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	isl_int_set_si(v, -3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	isl_int_set_si(v, 6);
-	isl_constraint_set_coefficient(c, isl_dim_set, 3, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 3, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 3, 1);
@@ -884,22 +930,22 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, -3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	isl_int_set_si(v, -3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 3, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 3, v);
 	isl_int_set_si(v, 6);
-	isl_constraint_set_coefficient(c, isl_dim_set, 4, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 4, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	isl_int_set_si(v, 1);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 4, 1);
@@ -918,20 +964,20 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 1, v);
 	isl_int_set_si(v, -2);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, -1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, 3);
-	isl_constraint_set_coefficient(c, isl_dim_set, 3, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 3, v);
 	isl_int_set_si(v, 2);
-	isl_constraint_set_constant(c, v);
+	c = isl_constraint_set_constant(c, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 2, 2);
@@ -950,9 +996,9 @@ static int test_div(isl_ctx *ctx)
 
 	c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
 	isl_int_set_si(v, 1);
-	isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 0, v);
 	isl_int_set_si(v, -2);
-	isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
+	c = isl_constraint_set_coefficient(c, isl_dim_set, 2, v);
 	bset = isl_basic_set_add_constraint(bset, c);
 
 	bset = isl_basic_set_project_out(bset, isl_dim_set, 2, 1);
@@ -1262,6 +1308,9 @@ struct {
 	    "i2 <= 5 + i0 and i2 >= i0 }" },
 	{ "{ [x, y] : 3y <= 2x and y >= -2 + 2x and 2y >= 2 - x }",
 	    "{ [x, y] : 1 = 0 }" },
+	{ "{ [x, y, z] : 0 <= x, y, z <= 10; [x, y, 0] : x >= 0 and y > 0; "
+	    "[x, y, 0] : x >= 0 and y < 0 }",
+	    "{ [x, y, z] : x >= 0 and 0 <= z <= 10 }" },
 };
 
 static int test_convex_hull_algo(isl_ctx *ctx, int convex)
@@ -1846,6 +1895,10 @@ struct {
 				"9*floor((-4a + 2c)/9) <= -3 - 4a + 2c) or "
 			"(exists (e0 = floor((-16 + 2c)/9): a = 4 and "
 				"b = 3 and 9e0 <= -19 + 2c)) }" },
+	{ 1, "{ [a, b, c] : (b = -1 + a and 0 < a <= 3 and "
+				"9*floor((-4a + 2c)/9) <= -3 - 4a + 2c) or "
+			"(a = 4 and b = 3 and "
+				"9*floor((-16 + 2c)/9) <= -19 + 2c) }" },
 	{ 0, "{ [a, b, c] : (b <= 2 and b <= -2 + a) or "
 			"(b = -1 + a and 0 < a <= 3 and "
 				"9*floor((-4a + 2c)/9) <= -3 - 4a + 2c) or "
@@ -1864,6 +1917,37 @@ struct {
 	{ 1, "{ [x, 0] : 0 <= x <= 10 and x mod 2 = 0; "
 	       "[x, 0] : 0 <= x <= 10 and x mod 2 = 1; "
 	       "[x, y] : 0 <= x <= 10 and 1 <= y <= 10 }" },
+	{ 1, "{ [a] : a <= 8 and "
+			"(a mod 10 = 7 or a mod 10 = 8 or a mod 10 = 9) }" },
+	{ 1, "{ [x, y] : 2y = -x and x <= 0 or "
+			"x <= -1 and 2y <= -x - 1 and 2y >= x - 1 }" },
+	{ 0, "{ [x, y] : 2y = -x and x <= 0 or "
+			"x <= -2 and 2y <= -x - 1 and 2y >= x - 1 }" },
+	{ 1, "{ [a] : (a <= 0 and 3*floor((a)/3) = a) or "
+			"(a < 0 and 3*floor((a)/3) < a) }" },
+	{ 1, "{ [a] : (a <= 0 and 3*floor((a)/3) = a) or "
+			"(a < -1 and 3*floor((a)/3) < a) }" },
+	{ 1, "{ [a, b] : a <= 1024 and b >= 0 and "
+		"((-31 - a + b <= 32*floor((-1 - a)/32) <= -33 + b and "
+		  "32*floor((-1 - a)/32) <= -16 + b + 16*floor((-1 - a)/16))"
+		"or (2 <= a <= 15 and b < a)) }" },
+	{ 1, "{ [a] : a > 0 and ((16*floor((a)/16) < a and "
+			"32*floor((a)/32) < a) or a <= 15) }" },
+	{ 1, "{ [a, b, c, d] : (-a + d) mod 64 = 0 and a <= 8 and b <= 1 and "
+			"10 - a <= c <= 3 and d >= 5 and 9 - 64b <= d <= 70;"
+	    "[a, b = 1, c, d] : (-a + d) mod 64 = 0 and a <= 8 and c >= 4 and "
+			"10 - a <= c <= 5 and 5 <= d <= 73 - c }" },
+	{ 1, "[n, m] -> { S_0[i] : (-n + i) mod 3 = 0 and m >= 3 + n and "
+			    "i >= n and 3*floor((2 + n + 2m)/3) <= n + 3m - i; "
+			 "S_0[n] : n <= m <= 2 + n }" },
+	{ 1, "{ [a, b] : exists (e0: 0 <= a <= 1 and b >= 0 and "
+			"2e0 >= -5 + a + 2b and 2e0 >= -1 + a + b and "
+			"2e0 <= a + b); "
+		"[a, b] : exists (e0: 0 <= a <= 1 and 2e0 >= -5 + a + 2b and "
+			"2e0 >= -1 - a + b and 2e0 <= -a + b and "
+			"2e0 < -a + 2b) }" },
+	{ 1, "{ [i, j, i - 8j] : 8 <= i <= 63 and -7 + i <= 8j <= i; "
+		"[i, 0, i] : 0 <= i <= 7 }" },
 };
 
 /* A specialized coalescing test case that would result
@@ -1887,7 +1971,7 @@ static int test_coalesce_special(struct isl_ctx *ctx)
 	    "(exists (e0 = [(-2 + y)/3]: 3e0 = -2 + y and y <= 200 and "
 		"y >= 5 and o1 <= 241 and o1 >= 212)) }";
 	map1 = isl_map_read_from_str(ctx, str);
-	map1 = isl_map_align_divs(map1);
+	map1 = isl_map_align_divs_internal(map1);
 	map1 = isl_map_coalesce(map1);
 	str = "[y] -> { [S_L220_OUT[] -> T7[]] -> "
 	    "[[S_L309_IN[] -> T11[]] -> ce_imag2[o0, o1]] : "
@@ -1896,7 +1980,7 @@ static int test_coalesce_special(struct isl_ctx *ctx)
 		"o0 >= 3 - y and o0 <= -2 + y and o0 >= 0) }";
 	map2 = isl_map_read_from_str(ctx, str);
 	map2 = isl_map_union(map2, map1);
-	map2 = isl_map_align_divs(map2);
+	map2 = isl_map_align_divs_internal(map2);
 	map2 = isl_map_coalesce(map2);
 	isl_map_free(map2);
 	if (!map2)
@@ -1905,6 +1989,70 @@ static int test_coalesce_special(struct isl_ctx *ctx)
 	return 0;
 }
 
+/* A specialized coalescing test case that would result in an assertion
+ * in an earlier version of isl.
+ * The explicit call to isl_basic_set_union prevents the implicit
+ * equality constraints in the first basic map from being detected prior
+ * to the call to isl_set_coalesce, at least at the point
+ * where this test case was introduced.
+ */
+static int test_coalesce_special2(struct isl_ctx *ctx)
+{
+	const char *str;
+	isl_basic_set *bset1, *bset2;
+	isl_set *set;
+
+	str = "{ [x, y] : x, y >= 0 and x + 2y <= 1 and 2x + y <= 1 }";
+	bset1 = isl_basic_set_read_from_str(ctx, str);
+	str = "{ [x,0] : -1 <= x <= 1 and x mod 2 = 1 }" ;
+	bset2 = isl_basic_set_read_from_str(ctx, str);
+	set = isl_basic_set_union(bset1, bset2);
+	set = isl_set_coalesce(set);
+	isl_set_free(set);
+
+	if (!set)
+		return -1;
+	return 0;
+}
+
+/* Check that calling isl_set_coalesce does not leave other sets
+ * that may share some information with the input to isl_set_coalesce
+ * in an inconsistent state.
+ * In particular, older versions of isl would modify all copies
+ * of the basic sets in the isl_set_coalesce input in a way
+ * that could leave them in an inconsistent state.
+ * The result of printing any other set containing one of these
+ * basic sets would then result in an invalid set description.
+ */
+static int test_coalesce_special3(isl_ctx *ctx)
+{
+	const char *str;
+	char *s;
+	isl_set *set1, *set2;
+	isl_printer *p;
+
+	set1 = isl_set_read_from_str(ctx, "{ [0, 0, 0] }");
+	str = "{ [a, b, a + b] : a >= 0 and b >= 0 and 0 < a + b }";
+	set2 = isl_set_read_from_str(ctx, str);
+	set1 = isl_set_union(set1, isl_set_copy(set2));
+	set1 = isl_set_coalesce(set1);
+	isl_set_free(set1);
+
+	p = isl_printer_to_str(ctx);
+	p = isl_printer_print_set(p, set2);
+	isl_set_free(set2);
+	s = isl_printer_get_str(p);
+	isl_printer_free(p);
+	set1 = isl_set_read_from_str(ctx, s);
+	free(s);
+	isl_set_free(set1);
+
+	if (!set1)
+		return -1;
+
+	return 0;
+}
+
 /* Test the functionality of isl_set_coalesce.
  * That is, check that the output is always equal to the input
  * and in some cases that the result consists of a single disjunct.
@@ -1924,6 +2072,10 @@ static int test_coalesce(struct isl_ctx *ctx)
 		return -1;
 	if (test_coalesce_special(ctx) < 0)
 		return -1;
+	if (test_coalesce_special2(ctx) < 0)
+		return -1;
+	if (test_coalesce_special3(ctx) < 0)
+		return -1;
 
 	return 0;
 }
@@ -2230,8 +2382,57 @@ static int test_lex(struct isl_ctx *ctx)
 	return 0;
 }
 
+/* Inputs for isl_map_lexmin tests.
+ * "map" is the input and "lexmin" is the expected result.
+ */
+struct {
+	const char *map;
+	const char *lexmin;
+} lexmin_tests [] = {
+	{ "{ [x] -> [y] : x <= y <= 10; [x] -> [5] : -8 <= x <= 8 }",
+	  "{ [x] -> [5] : 6 <= x <= 8; "
+	    "[x] -> [x] : x <= 5 or (9 <= x <= 10) }" },
+	{ "{ [x] -> [y] : 4y = x or 4y = -1 + x or 4y = -2 + x }",
+	  "{ [x] -> [y] : 4y = x or 4y = -1 + x or 4y = -2 + x }" },
+	{ "{ [x] -> [y] : x = 4y; [x] -> [y] : x = 2y }",
+	  "{ [x] -> [y] : (4y = x and x >= 0) or "
+		"(exists (e0 = [(x)/4], e1 = [(-2 + x)/4]: 2y = x and "
+		"4e1 = -2 + x and 4e0 <= -1 + x and 4e0 >= -3 + x)) or "
+		"(exists (e0 = [(x)/4]: 2y = x and 4e0 = x and x <= -4)) }" },
+	{ "{ T[a] -> S[b, c] : a = 4b-2c and c >= b }",
+	  "{ T[a] -> S[b, c] : 2b = a and 2c = a }" },
+	/* Check that empty pieces are properly combined. */
+	{ "[K, N] -> { [x, y] -> [a, b] : K+2<=N<=K+4 and x>=4 and "
+		"2N-6<=x<K+N and N-1<=a<=K+N-1 and N+b-6<=a<=2N-4 and "
+		"b<=2N-3K+a and 3b<=4N-K+1 and b>=N and a>=x+1 }",
+	  "[K, N] -> { [x, y] -> [1 + x, N] : x >= -6 + 2N and "
+		"x <= -5 + 2N and x >= -1 + 3K - N and x <= -2 + K + N and "
+		"x >= 4 }" },
+	{ "{ [i, k, j] -> [a, b, c, d] : 8*floor((b)/8) = b and k <= 255 and "
+		"a <= 255 and c <= 255 and d <= 255 - j and "
+		"255 - j <= 7d <= 7 - i and 240d <= 239 + a and "
+		"247d <= 247 + k - j and 247d <= 247 + k - b and "
+		"247d <= 247 + i and 248 - b <= 248d <= c and "
+		"254d >= i - a + b and 254d >= -a + b and "
+		"255d >= -i + a - b and 1792d >= -63736 + 257b }",
+	  "{ [i, k, j] -> "
+	    "[-127762 + i + 502j, -62992 + 248j, 63240 - 248j, 255 - j] : "
+		"k <= 255 and 7j >= 1778 + i and 246j >= 62738 - k and "
+		"247j >= 62738 - i and 509j <= 129795 + i and "
+		"742j >= 188724 - i; "
+	    "[0, k, j] -> [1, 0, 248, 1] : k <= 255 and 248 <= j <= 254, k }" },
+	{ "{ [a] -> [b] : 0 <= b <= 255 and -509 + a <= 512b < a and "
+			"16*floor((8 + b)/16) <= 7 + b; "
+	    "[a] -> [1] }",
+	  "{ [a] -> [b = 1] : a >= 510 or a <= 0; "
+	    "[a] -> [b = 0] : 0 < a <= 509 }" },
+	{ "{ rat: [i] : 1 <= 2i <= 9 }", "{ rat: [i] : 2i = 1 }" },
+	{ "{ rat: [i] : 1 <= 2i <= 9 or i >= 10 }", "{ rat: [i] : 2i = 1 }" },
+};
+
 static int test_lexmin(struct isl_ctx *ctx)
 {
+	int i;
 	int equal;
 	const char *str;
 	isl_basic_map *bmap;
@@ -2266,35 +2467,20 @@ static int test_lexmin(struct isl_ctx *ctx)
 	assert(!isl_set_is_empty(set));
 	isl_set_free(set);
 
-	str = "{ [x] -> [y] : x <= y <= 10; [x] -> [5] : -8 <= x <= 8 }";
-	map = isl_map_read_from_str(ctx, str);
-	map = isl_map_lexmin(map);
-	str = "{ [x] -> [5] : 6 <= x <= 8; "
-		"[x] -> [x] : x <= 5 or (9 <= x <= 10) }";
-	map2 = isl_map_read_from_str(ctx, str);
-	assert(isl_map_is_equal(map, map2));
-	isl_map_free(map);
-	isl_map_free(map2);
-
-	str = "{ [x] -> [y] : 4y = x or 4y = -1 + x or 4y = -2 + x }";
-	map = isl_map_read_from_str(ctx, str);
-	map2 = isl_map_copy(map);
-	map = isl_map_lexmin(map);
-	assert(isl_map_is_equal(map, map2));
-	isl_map_free(map);
-	isl_map_free(map2);
+	for (i = 0; i < ARRAY_SIZE(lexmin_tests); ++i) {
+		map = isl_map_read_from_str(ctx, lexmin_tests[i].map);
+		map = isl_map_lexmin(map);
+		map2 = isl_map_read_from_str(ctx, lexmin_tests[i].lexmin);
+		equal = isl_map_is_equal(map, map2);
+		isl_map_free(map);
+		isl_map_free(map2);
 
-	str = "{ [x] -> [y] : x = 4y; [x] -> [y] : x = 2y }";
-	map = isl_map_read_from_str(ctx, str);
-	map = isl_map_lexmin(map);
-	str = "{ [x] -> [y] : (4y = x and x >= 0) or "
-		"(exists (e0 = [(x)/4], e1 = [(-2 + x)/4]: 2y = x and "
-		"4e1 = -2 + x and 4e0 <= -1 + x and 4e0 >= -3 + x)) or "
-		"(exists (e0 = [(x)/4]: 2y = x and 4e0 = x and x <= -4)) }";
-	map2 = isl_map_read_from_str(ctx, str);
-	assert(isl_map_is_equal(map, map2));
-	isl_map_free(map);
-	isl_map_free(map2);
+		if (equal < 0)
+			return -1;
+		if (!equal)
+			isl_die(ctx, isl_error_unknown,
+				"unexpected result", return -1);
+	}
 
 	str = "{ [i] -> [i', j] : j = i - 8i' and i' >= 0 and i' <= 7 and "
 				" 8i' <= i and 8i' >= -7 + i }";
@@ -2306,29 +2492,6 @@ static int test_lexmin(struct isl_ctx *ctx)
 	isl_map_free(map);
 	isl_map_free(map2);
 
-	str = "{ T[a] -> S[b, c] : a = 4b-2c and c >= b }";
-	map = isl_map_read_from_str(ctx, str);
-	map = isl_map_lexmin(map);
-	str = "{ T[a] -> S[b, c] : 2b = a and 2c = a }";
-	map2 = isl_map_read_from_str(ctx, str);
-	assert(isl_map_is_equal(map, map2));
-	isl_map_free(map);
-	isl_map_free(map2);
-
-	/* Check that empty pieces are properly combined. */
-	str = "[K, N] -> { [x, y] -> [a, b] : K+2<=N<=K+4 and x>=4 and "
-		"2N-6<=x<K+N and N-1<=a<=K+N-1 and N+b-6<=a<=2N-4 and "
-		"b<=2N-3K+a and 3b<=4N-K+1 and b>=N and a>=x+1 }";
-	map = isl_map_read_from_str(ctx, str);
-	map = isl_map_lexmin(map);
-	str = "[K, N] -> { [x, y] -> [1 + x, N] : x >= -6 + 2N and "
-		"x <= -5 + 2N and x >= -1 + 3K - N and x <= -2 + K + N and "
-		"x >= 4 }";
-	map2 = isl_map_read_from_str(ctx, str);
-	assert(isl_map_is_equal(map, map2));
-	isl_map_free(map);
-	isl_map_free(map2);
-
 	str = "[i] -> { [i', j] : j = i - 8i' and i' >= 0 and i' <= 7 and "
 				" 8i' <= i and 8i' >= -7 + i }";
 	set = isl_set_read_from_str(ctx, str);
@@ -2347,6 +2510,71 @@ static int test_lexmin(struct isl_ctx *ctx)
 	return 0;
 }
 
+/* A specialized isl_set_min_val test case that would return the wrong result
+ * in earlier versions of isl.
+ * The explicit call to isl_basic_set_union prevents the second basic set
+ * from being determined to be empty prior to the call to isl_set_min_val,
+ * at least at the point where this test case was introduced.
+ */
+static int test_min_special(isl_ctx *ctx)
+{
+	const char *str;
+	isl_basic_set *bset1, *bset2;
+	isl_set *set;
+	isl_aff *obj;
+	isl_val *res;
+	int ok;
+
+	str = "{ [a, b] : a >= 2 and b >= 0 and 14 - a <= b <= 9 }";
+	bset1 = isl_basic_set_read_from_str(ctx, str);
+	str = "{ [a, b] : 1 <= a, b and a + b <= 1 }";
+	bset2 = isl_basic_set_read_from_str(ctx, str);
+	set = isl_basic_set_union(bset1, bset2);
+	obj = isl_aff_read_from_str(ctx, "{ [a, b] -> [a] }");
+
+	res = isl_set_min_val(set, obj);
+	ok = isl_val_cmp_si(res, 5) == 0;
+
+	isl_aff_free(obj);
+	isl_set_free(set);
+	isl_val_free(res);
+
+	if (!res)
+		return -1;
+	if (!ok)
+		isl_die(ctx, isl_error_unknown, "unexpected minimum",
+			return -1);
+
+	return 0;
+}
+
+/* A specialized isl_set_min_val test case that would return an error
+ * in earlier versions of isl.
+ */
+static int test_min_special2(isl_ctx *ctx)
+{
+	const char *str;
+	isl_basic_set *bset;
+	isl_aff *obj;
+	isl_val *res;
+
+	str = "{ [i, j, k] : 2j = i and 2k = i + 1 and i >= 2 }";
+	bset = isl_basic_set_read_from_str(ctx, str);
+
+	obj = isl_aff_read_from_str(ctx, "{ [i, j, k] -> [i] }");
+
+	res = isl_basic_set_max_val(bset, obj);
+
+	isl_basic_set_free(bset);
+	isl_aff_free(obj);
+	isl_val_free(res);
+
+	if (!res)
+		return -1;
+
+	return 0;
+}
+
 struct {
 	const char *set;
 	const char *obj;
@@ -2391,6 +2619,11 @@ static int test_min(struct isl_ctx *ctx)
 				"unexpected optimum", return -1);
 	}
 
+	if (test_min_special(ctx) < 0)
+		return -1;
+	if (test_min_special2(ctx) < 0)
+		return -1;
+
 	return 0;
 }
 
@@ -3526,6 +3759,55 @@ static int test_special_conditional_schedule_constraints(isl_ctx *ctx)
 	return 0;
 }
 
+/* Check that the test for violated conditional validity constraints
+ * is not confused by domain compression.
+ * In particular, earlier versions of isl would apply
+ * a schedule on the compressed domains to the original domains,
+ * resulting in a failure to detect that the default schedule
+ * violates the conditional validity constraints.
+ */
+static int test_special_conditional_schedule_constraints_2(isl_ctx *ctx)
+{
+	const char *str;
+	isl_bool empty;
+	isl_union_set *domain;
+	isl_union_map *validity, *condition;
+	isl_schedule_constraints *sc;
+	isl_schedule *schedule;
+	isl_union_map *umap;
+	isl_map *map, *ge;
+
+	str = "{ A[0, i] : 0 <= i <= 10; B[1, i] : 0 <= i <= 10 }";
+	domain = isl_union_set_read_from_str(ctx, str);
+	sc = isl_schedule_constraints_on_domain(domain);
+	str = "{ B[1, i] -> A[0, i + 1] }";
+	condition = isl_union_map_read_from_str(ctx, str);
+	str = "{ A[0, i] -> B[1, i - 1] }";
+	validity = isl_union_map_read_from_str(ctx, str);
+	sc = isl_schedule_constraints_set_conditional_validity(sc, condition,
+						isl_union_map_copy(validity));
+	schedule = isl_schedule_constraints_compute_schedule(sc);
+	umap = isl_schedule_get_map(schedule);
+	isl_schedule_free(schedule);
+	validity = isl_union_map_apply_domain(validity,
+						isl_union_map_copy(umap));
+	validity = isl_union_map_apply_range(validity, umap);
+	map = isl_map_from_union_map(validity);
+	ge = isl_map_lex_ge(isl_space_domain(isl_map_get_space(map)));
+	map = isl_map_intersect(map, ge);
+	empty = isl_map_is_empty(map);
+	isl_map_free(map);
+
+	if (empty < 0)
+		return -1;
+	if (!empty)
+		isl_die(ctx, isl_error_unknown,
+			"conditional validity constraints not satisfied",
+			return -1);
+
+	return 0;
+}
+
 /* Input for testing of schedule construction based on
  * conditional constraints.
  *
@@ -3630,6 +3912,8 @@ static int test_conditional_schedule_constraints(isl_ctx *ctx)
 
 	if (test_special_conditional_schedule_constraints(ctx) < 0)
 		return -1;
+	if (test_special_conditional_schedule_constraints_2(ctx) < 0)
+		return -1;
 
 	for (i = 0; i < ARRAY_SIZE(live_range_tests); ++i) {
 		domain = isl_union_set_read_from_str(ctx,
@@ -3776,6 +4060,56 @@ static int test_bounded_coefficients_schedule(isl_ctx *ctx)
 	return 0;
 }
 
+/* Check that the bounds on the coefficients are respected.
+ * This function checks for a particular output schedule,
+ * but the exact output is not important, only that it does
+ * not contain any coefficients greater than 4.
+ * It is, however, easier to check for a particular output.
+ * This test is only run for the whole component scheduler
+ * because the incremental scheduler produces a slightly different schedule.
+ */
+static int test_bounded_coefficients_schedule_whole(isl_ctx *ctx)
+{
+	const char *domain, *dep, *str;
+	isl_union_set *I;
+	isl_union_map *D;
+	isl_schedule_constraints *sc;
+	isl_schedule *schedule;
+	isl_union_map *sched1, *sched2;
+	isl_bool equal;
+
+	domain = "{ S_4[i, j, k] : 0 <= i < j <= 10 and 0 <= k <= 100; "
+	    "S_2[i, j] : 0 <= i < j <= 10; S_6[i, j] : 0 <= i < j <= 10 }";
+	dep = "{ S_2[0, j] -> S_4[0, j, 0] : 0 < j <= 10; "
+	    "S_4[0, j, 100] -> S_6[0, j] : 0 < j <= 10 }";
+	I = isl_union_set_read_from_str(ctx, domain);
+	D = isl_union_map_read_from_str(ctx, dep);
+	sc = isl_schedule_constraints_on_domain(I);
+	sc = isl_schedule_constraints_set_validity(sc, D);
+	isl_options_set_schedule_max_constant_term(ctx, 10);
+	isl_options_set_schedule_max_coefficient(ctx, 4);
+	schedule = isl_schedule_constraints_compute_schedule(sc);
+	isl_options_set_schedule_max_coefficient(ctx, -1);
+	isl_options_set_schedule_max_constant_term(ctx, -1);
+	sched1 = isl_schedule_get_map(schedule);
+	isl_schedule_free(schedule);
+
+	str = "{ S_4[i, j, k] -> [i, j, 10 - k, 1]; "
+	    "S_2[i, j] -> [0, i, j, 0]; S_6[i, j] -> [0, 10 + i, j, 2] }";
+	sched2 = isl_union_map_read_from_str(ctx, str);
+	equal = isl_union_map_is_equal(sched1, sched2);
+	isl_union_map_free(sched1);
+	isl_union_map_free(sched2);
+
+	if (equal < 0)
+		return -1;
+	if (!equal)
+		isl_die(ctx, isl_error_unknown,
+			"unexpected schedule", return -1);
+
+	return 0;
+}
+
 /* Check that a set of schedule constraints that only allow for
  * a coalescing schedule still produces a schedule even if the user
  * request a non-coalescing schedule.  Earlier versions of isl
@@ -3806,6 +4140,28 @@ static int test_coalescing_schedule(isl_ctx *ctx)
 	return 0;
 }
 
+/* Check that the scheduler does not perform any needless
+ * compound skewing.  Earlier versions of isl would compute
+ * schedules in terms of transformed schedule coefficients and
+ * would not accurately keep track of the sum of the original
+ * schedule coefficients.  It could then produce the schedule
+ * S[t,i,j,k] -> [t, 2t + i, 2t + i + j, 2t + i + j + k]
+ * for the input below instead of the schedule below.
+ */
+static int test_skewing_schedule(isl_ctx *ctx)
+{
+	const char *D, *V, *P, *S;
+
+	D = "[n] -> { S[t,i,j,k] : 0 <= t,i,j,k < n }";
+	V = "[n] -> { S[t,i,j,k] -> S[t+1,a,b,c] : 0 <= t,i,j,k,a,b,c < n and "
+		"-2 <= a-i <= 2 and -1 <= a-i + b-j <= 1 and "
+		"-1 <= a-i + b-j + c-k <= 1 }";
+	P = "{ }";
+	S = "{ S[t,i,j,k] -> [t, 2t + i, t + i + j, 2t + k] }";
+
+	return test_special_schedule(ctx, D, V, P, S);
+}
+
 int test_schedule(isl_ctx *ctx)
 {
 	const char *D, *W, *R, *V, *P, *S;
@@ -4020,13 +4376,10 @@ int test_schedule(isl_ctx *ctx)
 		"i0 >= 0 and i0 <= 1 and i1 >= 0 and o2 >= -i1 + i2 and "
 		"o2 >= 1 and o2 <= 6 - i1 and i2 >= 1 + i1 }";
 	P = V;
-	S = "{ Stmt_for_body24[i0, i1, i2, i3] -> "
-		"[i0, 5i0 + i1, 6i0 + i1 + i2, 1 + 6i0 + i1 + i2 + i3, 1];"
-	    "Stmt_for_body7[i0, i1, i2] -> [0, 5i0, 6i0 + i1, 6i0 + i2, 0] }";
 
 	treat_coalescing = isl_options_get_schedule_treat_coalescing(ctx);
 	isl_options_set_schedule_treat_coalescing(ctx, 0);
-	if (test_special_schedule(ctx, D, V, P, S) < 0)
+	if (test_has_schedule(ctx, D, V, P) < 0)
 		return -1;
 	isl_options_set_schedule_treat_coalescing(ctx, treat_coalescing);
 
@@ -4036,7 +4389,7 @@ int test_schedule(isl_ctx *ctx)
 		"S_0[i, j] -> S_0[1 + i, j] : i >= 1 and i <= 9 and "
 					     "j >= 1 and j <= 8 }";
 	P = "{ }";
-	S = "{ S_0[i, j] -> [i + j, j] }";
+	S = "{ S_0[i, j] -> [i + j, i] }";
 	ctx->opt->schedule_algorithm = ISL_SCHEDULE_ALGORITHM_FEAUTRIER;
 	if (test_special_schedule(ctx, D, V, P, S) < 0)
 		return -1;
@@ -4116,6 +4469,8 @@ int test_schedule(isl_ctx *ctx)
 		return -1;
 	if (test_coalescing_schedule(ctx) < 0)
 		return -1;
+	if (test_skewing_schedule(ctx) < 0)
+		return -1;
 
 	return 0;
 }
@@ -4130,6 +4485,8 @@ static int test_schedule_whole(isl_ctx *ctx)
 	whole = isl_options_get_schedule_whole_component(ctx);
 	isl_options_set_schedule_whole_component(ctx, 1);
 	r = test_schedule(ctx);
+	if (r >= 0)
+		r = test_bounded_coefficients_schedule_whole(ctx);
 	isl_options_set_schedule_whole_component(ctx, whole);
 
 	return r;
@@ -4316,6 +4673,67 @@ static int test_bin_aff(isl_ctx *ctx)
 }
 
 struct {
+	__isl_give isl_pw_aff *(*fn)(__isl_take isl_pw_aff *pa1,
+				     __isl_take isl_pw_aff *pa2);
+} pw_aff_bin_op[] = {
+	['m'] = { &isl_pw_aff_min },
+	['M'] = { &isl_pw_aff_max },
+};
+
+/* Inputs for binary isl_pw_aff operation tests.
+ * "arg1" and "arg2" are the two arguments, "op" identifies the operation
+ * defined by pw_aff_bin_op, and "res" is the expected result.
+ */
+struct {
+	const char *arg1;
+	unsigned char op;
+	const char *arg2;
+	const char *res;
+} pw_aff_bin_tests[] = {
+	{ "{ [i] -> [i] }", 'm', "{ [i] -> [i] }",
+	  "{ [i] -> [i] }" },
+	{ "{ [i] -> [i] }", 'M', "{ [i] -> [i] }",
+	  "{ [i] -> [i] }" },
+	{ "{ [i] -> [i] }", 'm', "{ [i] -> [0] }",
+	  "{ [i] -> [i] : i <= 0; [i] -> [0] : i > 0 }" },
+	{ "{ [i] -> [i] }", 'M', "{ [i] -> [0] }",
+	  "{ [i] -> [i] : i >= 0; [i] -> [0] : i < 0 }" },
+	{ "{ [i] -> [i] }", 'm', "{ [i] -> [NaN] }",
+	  "{ [i] -> [NaN] }" },
+	{ "{ [i] -> [NaN] }", 'm', "{ [i] -> [i] }",
+	  "{ [i] -> [NaN] }" },
+};
+
+/* Perform some basic tests of binary operations on isl_pw_aff objects.
+ */
+static int test_bin_pw_aff(isl_ctx *ctx)
+{
+	int i;
+	isl_bool ok;
+	isl_pw_aff *pa1, *pa2, *res;
+
+	for (i = 0; i < ARRAY_SIZE(pw_aff_bin_tests); ++i) {
+		pa1 = isl_pw_aff_read_from_str(ctx, pw_aff_bin_tests[i].arg1);
+		pa2 = isl_pw_aff_read_from_str(ctx, pw_aff_bin_tests[i].arg2);
+		res = isl_pw_aff_read_from_str(ctx, pw_aff_bin_tests[i].res);
+		pa1 = pw_aff_bin_op[pw_aff_bin_tests[i].op].fn(pa1, pa2);
+		if (isl_pw_aff_involves_nan(res))
+			ok = isl_pw_aff_involves_nan(pa1);
+		else
+			ok = isl_pw_aff_plain_is_equal(pa1, res);
+		isl_pw_aff_free(pa1);
+		isl_pw_aff_free(res);
+		if (ok < 0)
+			return -1;
+		if (!ok)
+			isl_die(ctx, isl_error_unknown,
+				"unexpected result", return -1);
+	}
+
+	return 0;
+}
+
+struct {
 	__isl_give isl_union_pw_multi_aff *(*fn)(
 		__isl_take isl_union_pw_multi_aff *upma1,
 		__isl_take isl_union_pw_multi_aff *upma2);
@@ -4423,6 +4841,8 @@ int test_aff(isl_ctx *ctx)
 
 	if (test_bin_aff(ctx) < 0)
 		return -1;
+	if (test_bin_pw_aff(ctx) < 0)
+		return -1;
 	if (test_bin_upma(ctx) < 0)
 		return -1;
 	if (test_bin_upma_fail(ctx) < 0)
@@ -4464,6 +4884,35 @@ int test_aff(isl_ctx *ctx)
 	return 0;
 }
 
+/* Check that the computation below results in a single expression.
+ * One or two expressions may result depending on which constraint
+ * ends up being considered as redundant with respect to the other
+ * constraints after the projection that is performed internally
+ * by isl_set_dim_min.
+ */
+static int test_dim_max_1(isl_ctx *ctx)
+{
+	const char *str;
+	isl_set *set;
+	isl_pw_aff *pa;
+	int n;
+
+	str = "[n] -> { [a, b] : n >= 0 and 4a >= -4 + n and b >= 0 and "
+				"-4a <= b <= 3 and b < n - 4a }";
+	set = isl_set_read_from_str(ctx, str);
+	pa = isl_set_dim_min(set, 0);
+	n = isl_pw_aff_n_piece(pa);
+	isl_pw_aff_free(pa);
+
+	if (!pa)
+		return -1;
+	if (n != 1)
+		isl_die(ctx, isl_error_unknown, "expecting single expression",
+			return -1);
+
+	return 0;
+}
+
 int test_dim_max(isl_ctx *ctx)
 {
 	int equal;
@@ -4473,6 +4922,9 @@ int test_dim_max(isl_ctx *ctx)
 	isl_map *map;
 	isl_pw_aff *pwaff;
 
+	if (test_dim_max_1(ctx) < 0)
+		return -1;
+
 	str = "[N] -> { [i] : 0 <= i <= min(N,10) }";
 	set = isl_set_read_from_str(ctx, str);
 	pwaff = isl_set_dim_max(set, 0);
@@ -4703,8 +5155,27 @@ static int test_disjoint(isl_ctx *ctx)
 	return 0;
 }
 
+/* Inputs for isl_pw_multi_aff_is_equal tests.
+ * "f1" and "f2" are the two function that need to be compared.
+ * "equal" is the expected result.
+ */
+struct {
+	int equal;
+	const char *f1;
+	const char *f2;
+} pma_equal_tests[] = {
+	{ 1, "[N] -> { [floor(N/2)] : 0 <= N <= 1 }",
+	     "[N] -> { [0] : 0 <= N <= 1 }" },
+	{ 1, "[N] -> { [floor(N/2)] : 0 <= N <= 2 }",
+	     "[N] -> { [0] : 0 <= N <= 1; [1] : N = 2 }" },
+	{ 0, "[N] -> { [floor(N/2)] : 0 <= N <= 2 }",
+	     "[N] -> { [0] : 0 <= N <= 1 }" },
+	{ 0, "{ [NaN] }", "{ [NaN] }" },
+};
+
 int test_equal(isl_ctx *ctx)
 {
+	int i;
 	const char *str;
 	isl_set *set, *set2;
 	int equal;
@@ -4721,13 +5192,29 @@ int test_equal(isl_ctx *ctx)
 	if (equal)
 		isl_die(ctx, isl_error_unknown, "unexpected result", return -1);
 
+	for (i = 0; i < ARRAY_SIZE(pma_equal_tests); ++i) {
+		int expected = pma_equal_tests[i].equal;
+		isl_pw_multi_aff *f1, *f2;
+
+		f1 = isl_pw_multi_aff_read_from_str(ctx, pma_equal_tests[i].f1);
+		f2 = isl_pw_multi_aff_read_from_str(ctx, pma_equal_tests[i].f2);
+		equal = isl_pw_multi_aff_is_equal(f1, f2);
+		isl_pw_multi_aff_free(f1);
+		isl_pw_multi_aff_free(f2);
+		if (equal < 0)
+			return -1;
+		if (equal != expected)
+			isl_die(ctx, isl_error_unknown,
+				"unexpected equality result", return -1);
+	}
+
 	return 0;
 }
 
 static int test_plain_fixed(isl_ctx *ctx, __isl_take isl_map *map,
 	enum isl_dim_type type, unsigned pos, int fixed)
 {
-	int test;
+	isl_bool test;
 
 	test = isl_map_plain_is_fixed(map, type, pos, NULL);
 	isl_map_free(map);
@@ -4771,12 +5258,22 @@ int test_fixed(isl_ctx *ctx)
 struct isl_vertices_test_data {
 	const char *set;
 	int n;
-	const char *vertex[2];
+	const char *vertex[6];
 } vertices_tests[] = {
 	{ "{ A[t, i] : t = 12 and i >= 4 and i <= 12 }",
 	  2, { "{ A[12, 4] }", "{ A[12, 12] }" } },
 	{ "{ A[t, i] : t = 14 and i = 1 }",
 	  1, { "{ A[14, 1] }" } },
+	{ "[n, m] -> { [a, b, c] : b <= a and a <= n and b > 0 and c >= b and "
+				"c <= m and m <= n and m > 0 }",
+	  6, {
+		"[n, m] -> { [n, m, m] : 0 < m <= n }",
+		"[n, m] -> { [n, 1, m] : 0 < m <= n }",
+		"[n, m] -> { [n, 1, 1] : 0 < m <= n }",
+		"[n, m] -> { [m, m, m] : 0 < m <= n }",
+		"[n, m] -> { [1, 1, m] : 0 < m <= n }",
+		"[n, m] -> { [1, 1, 1] : 0 < m <= n }"
+	    } },
 };
 
 /* Check that "vertex" corresponds to one of the vertices in data->vertex.
@@ -4874,7 +5371,7 @@ int test_union_pw(isl_ctx *ctx)
 /* Test that isl_union_pw_qpolynomial_eval picks up the function
  * defined over the correct domain space.
  */
-static int test_eval(isl_ctx *ctx)
+static int test_eval_1(isl_ctx *ctx)
 {
 	const char *str;
 	isl_point *pnt;
@@ -4900,6 +5397,45 @@ static int test_eval(isl_ctx *ctx)
 	return 0;
 }
 
+/* Check that isl_qpolynomial_eval handles getting called on a void point.
+ */
+static int test_eval_2(isl_ctx *ctx)
+{
+	const char *str;
+	isl_point *pnt;
+	isl_set *set;
+	isl_qpolynomial *qp;
+	isl_val *v;
+	isl_bool ok;
+
+	str = "{ A[x] -> [x] }";
+	qp = isl_qpolynomial_from_aff(isl_aff_read_from_str(ctx, str));
+	str = "{ A[x] : false }";
+	set = isl_set_read_from_str(ctx, str);
+	pnt = isl_set_sample_point(set);
+	v = isl_qpolynomial_eval(qp, pnt);
+	ok = isl_val_is_nan(v);
+	isl_val_free(v);
+
+	if (ok < 0)
+		return -1;
+	if (!ok)
+		isl_die(ctx, isl_error_unknown, "expecting NaN", return -1);
+
+	return 0;
+}
+
+/* Perform basic polynomial evaluation tests.
+ */
+static int test_eval(isl_ctx *ctx)
+{
+	if (test_eval_1(ctx) < 0)
+		return -1;
+	if (test_eval_2(ctx) < 0)
+		return -1;
+	return 0;
+}
+
 /* Descriptions of sets that are tested for reparsing after printing.
  */
 const char *output_tests[] = {
@@ -5119,7 +5655,7 @@ static int test_residue_class(isl_ctx *ctx)
 	const char *str;
 	isl_set *set;
 	isl_int m, r;
-	int res;
+	isl_stat res;
 
 	str = "{ [i,j] : j = 4 i + 1 and 0 <= i <= 100; "
 		"[i,j] : j = 4 i + 3 and 500 <= i <= 600 }";
@@ -5130,7 +5666,7 @@ static int test_residue_class(isl_ctx *ctx)
 	if (res >= 0 &&
 	    (isl_int_cmp_si(m, 2) != 0 || isl_int_cmp_si(r, 1) != 0))
 		isl_die(ctx, isl_error_unknown, "incorrect residue class",
-			res = -1);
+			res = isl_stat_error);
 	isl_int_clear(r);
 	isl_int_clear(m);
 	isl_set_free(set);
@@ -5181,8 +5717,8 @@ static int test_list(isl_ctx *ctx)
 	d = isl_id_alloc(ctx, "d", NULL);
 
 	list = isl_id_list_alloc(ctx, 4);
-	list = isl_id_list_add(list, a);
 	list = isl_id_list_add(list, b);
+	list = isl_id_list_insert(list, 0, a);
 	list = isl_id_list_add(list, c);
 	list = isl_id_list_add(list, d);
 	list = isl_id_list_drop(list, 1, 1);
@@ -5519,7 +6055,7 @@ static int test_ast(isl_ctx *ctx)
 	expr = isl_ast_expr_neg(expr);
 	expr2 = isl_ast_expr_neg(expr2);
 	equal = isl_ast_expr_is_equal(expr, expr2);
-	str = isl_ast_expr_to_str(expr);
+	str = isl_ast_expr_to_C_str(expr);
 	ok = str ? !strcmp(str, "-(A + B)") : -1;
 	free(str);
 	isl_ast_expr_free(expr);
@@ -5539,7 +6075,7 @@ static int test_ast(isl_ctx *ctx)
 	expr = isl_ast_expr_add(expr1, expr2);
 	expr3 = isl_ast_expr_from_id(isl_id_alloc(ctx, "C", NULL));
 	expr = isl_ast_expr_sub(expr3, expr);
-	str = isl_ast_expr_to_str(expr);
+	str = isl_ast_expr_to_C_str(expr);
 	ok = str ? !strcmp(str, "C - (A + B)") : -1;
 	free(str);
 	isl_ast_expr_free(expr);
@@ -5938,6 +6474,49 @@ static int test_ast_gen5(isl_ctx *ctx)
 	return 0;
 }
 
+/* Check that the expression
+ *
+ *	[n] -> { [n/2] : n <= 0 and n % 2 = 0; [0] : n > 0 }
+ *
+ * is not combined into
+ *
+ *	min(n/2, 0)
+ *
+ * as this would result in n/2 being evaluated in parts of
+ * the definition domain where n is not a multiple of 2.
+ */
+static int test_ast_expr(isl_ctx *ctx)
+{
+	const char *str;
+	isl_pw_aff *pa;
+	isl_ast_build *build;
+	isl_ast_expr *expr;
+	int min_max;
+	int is_min;
+
+	min_max = isl_options_get_ast_build_detect_min_max(ctx);
+	isl_options_set_ast_build_detect_min_max(ctx, 1);
+
+	str = "[n] -> { [n/2] : n <= 0 and n % 2 = 0; [0] : n > 0 }";
+	pa = isl_pw_aff_read_from_str(ctx, str);
+	build = isl_ast_build_alloc(ctx);
+	expr = isl_ast_build_expr_from_pw_aff(build, pa);
+	is_min = isl_ast_expr_get_type(expr) == isl_ast_expr_op &&
+		 isl_ast_expr_get_op_type(expr) == isl_ast_op_min;
+	isl_ast_build_free(build);
+	isl_ast_expr_free(expr);
+
+	isl_options_set_ast_build_detect_min_max(ctx, min_max);
+
+	if (!expr)
+		return -1;
+	if (is_min)
+		isl_die(ctx, isl_error_unknown,
+			"expressions should not be combined", return -1);
+
+	return 0;
+}
+
 static int test_ast_gen(isl_ctx *ctx)
 {
 	if (test_ast_gen1(ctx) < 0)
@@ -5950,6 +6529,8 @@ static int test_ast_gen(isl_ctx *ctx)
 		return -1;
 	if (test_ast_gen5(ctx) < 0)
 		return -1;
+	if (test_ast_expr(ctx) < 0)
+		return -1;
 	return 0;
 }
 
@@ -6534,6 +7115,94 @@ static int test_universe(isl_ctx *ctx)
 	return 0;
 }
 
+/* Sets for which chambers are computed and checked.
+ */
+const char *chambers_tests[] = {
+	"[A, B, C] -> { [x, y, z] : x >= 0 and y >= 0 and y <= A - x and "
+				"z >= 0 and z <= C - y and z <= B - x - y }",
+};
+
+/* Add the domain of "cell" to "cells".
+ */
+static isl_stat add_cell(__isl_take isl_cell *cell, void *user)
+{
+	isl_basic_set_list **cells = user;
+	isl_basic_set *dom;
+
+	dom = isl_cell_get_domain(cell);
+	isl_cell_free(cell);
+	*cells = isl_basic_set_list_add(*cells, dom);
+
+	return *cells ? isl_stat_ok : isl_stat_error;
+}
+
+/* Check that the elements of "list" are pairwise disjoint.
+ */
+static isl_stat check_pairwise_disjoint(__isl_keep isl_basic_set_list *list)
+{
+	int i, j, n;
+
+	if (!list)
+		return isl_stat_error;
+
+	n = isl_basic_set_list_n_basic_set(list);
+	for (i = 0; i < n; ++i) {
+		isl_basic_set *bset_i;
+
+		bset_i = isl_basic_set_list_get_basic_set(list, i);
+		for (j = i + 1; j < n; ++j) {
+			isl_basic_set *bset_j;
+			isl_bool disjoint;
+
+			bset_j = isl_basic_set_list_get_basic_set(list, j);
+			disjoint = isl_basic_set_is_disjoint(bset_i, bset_j);
+			isl_basic_set_free(bset_j);
+			if (!disjoint)
+				isl_die(isl_basic_set_list_get_ctx(list),
+					isl_error_unknown, "not disjoint",
+					break);
+			if (disjoint < 0 || !disjoint)
+				break;
+		}
+		isl_basic_set_free(bset_i);
+		if (j < n)
+			return isl_stat_error;
+	}
+
+	return isl_stat_ok;
+}
+
+/* Check that the chambers computed by isl_vertices_foreach_disjoint_cell
+ * are pairwise disjoint.
+ */
+static int test_chambers(isl_ctx *ctx)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(chambers_tests); ++i) {
+		isl_basic_set *bset;
+		isl_vertices *vertices;
+		isl_basic_set_list *cells;
+		isl_stat ok;
+
+		bset = isl_basic_set_read_from_str(ctx, chambers_tests[i]);
+		vertices = isl_basic_set_compute_vertices(bset);
+		cells = isl_basic_set_list_alloc(ctx, 0);
+		if (isl_vertices_foreach_disjoint_cell(vertices, &add_cell,
+							&cells) < 0)
+			cells = isl_basic_set_list_free(cells);
+		ok = check_pairwise_disjoint(cells);
+		isl_basic_set_list_free(cells);
+		isl_vertices_free(vertices);
+		isl_basic_set_free(bset);
+
+		if (ok < 0)
+			return -1;
+	}
+
+	return 0;
+}
+
 struct {
 	const char *name;
 	int (*fn)(isl_ctx *ctx);
@@ -6565,6 +7234,7 @@ struct {
 	{ "sample", &test_sample },
 	{ "output", &test_output },
 	{ "vertices", &test_vertices },
+	{ "chambers", &test_chambers },
 	{ "fixed", &test_fixed },
 	{ "equal", &test_equal },
 	{ "disjoint", &test_disjoint },
@@ -6613,9 +7283,6 @@ int main(int argc, char **argv)
 	struct isl_ctx *ctx;
 	struct isl_options *options;
 
-	srcdir = getenv("srcdir");
-	assert(srcdir);
-
 	options = isl_options_new_with_defaults();
 	assert(options);
 	argc = isl_options_parse(options, argc, argv, ISL_ARG_ALL);
diff --git a/lib/Analysis/isl/isl_test_int.c b/lib/Analysis/isl/isl_test_int.c
index 9ae30ad..a996411 100644
--- a/lib/Analysis/isl/isl_test_int.c
+++ b/lib/Analysis/isl/isl_test_int.c
@@ -261,6 +261,9 @@ static void int_test_divexact(isl_int expected, isl_int lhs, isl_int rhs)
 
 		isl_int_fdiv_q_ui(result, lhs, rhsulong);
 		assert(isl_int_eq(expected, result));
+
+		isl_int_cdiv_q_ui(result, lhs, rhsulong);
+		assert(isl_int_eq(expected, result));
 	}
 
 	isl_int_clear(result);
@@ -358,12 +361,20 @@ static void int_test_fdiv(isl_int expected, isl_int lhs, isl_int rhs)
 
 static void int_test_cdiv(isl_int expected, isl_int lhs, isl_int rhs)
 {
+	unsigned long rhsulong;
 	isl_int result;
 	isl_int_init(result);
 
 	isl_int_cdiv_q(result, lhs, rhs);
 	assert(isl_int_eq(expected, result));
 
+	if (isl_int_fits_ulong(rhs)) {
+		rhsulong = isl_int_get_ui(rhs);
+
+		isl_int_cdiv_q_ui(result, lhs, rhsulong);
+		assert(isl_int_eq(expected, result));
+	}
+
 	isl_int_clear(result);
 }
 
@@ -466,6 +477,17 @@ static void int_test_abs_cmp(isl_int expected, isl_int lhs, isl_int rhs)
 	assert(-exp == sgn(isl_int_abs_cmp(rhs, lhs)));
 }
 
+/* If "expected" is equal to 1, then check that "rhs" divides "lhs".
+ * If "expected" is equal to 0, then check that "rhs" does not divide "lhs".
+ */
+static void int_test_divisible(isl_int expected, isl_int lhs, isl_int rhs)
+{
+	int exp;
+
+	exp = isl_int_get_si(expected);
+	assert(isl_int_is_divisible_by(lhs, rhs) == exp);
+}
+
 struct {
 	void (*fn)(isl_int, isl_int, isl_int);
 	char *expected, *lhs, *rhs;
@@ -550,6 +572,11 @@ struct {
 	{ &int_test_cdiv, "0", "1", "-2" },
 	{ &int_test_cdiv, "1", "-1", "-2" },
 
+	{ &int_test_cdiv, "1073741824", "2147483647", "2" },
+	{ &int_test_cdiv, "1073741824", "2147483648", "2" },
+	{ &int_test_cdiv, "-1073741824", "-2147483648", "2" },
+	{ &int_test_cdiv, "-1073741823", "-2147483647", "2" },
+
 	{ &int_test_tdiv, "0", "1", "2" },
 	{ &int_test_tdiv, "0", "-1", "2" },
 	{ &int_test_tdiv, "0", "1", "-2" },
@@ -596,6 +623,22 @@ struct {
 	{ &int_test_abs_cmp, "-1", "5", "9223372036854775807" },
 	{ &int_test_cmps, "1", "5", "-9223372036854775809" },
 	{ &int_test_abs_cmp, "-1", "5", "-9223372036854775809" },
+
+	{ &int_test_divisible, "1", "0", "0" },
+	{ &int_test_divisible, "0", "1", "0" },
+	{ &int_test_divisible, "0", "2", "0" },
+	{ &int_test_divisible, "0", "2147483647", "0" },
+	{ &int_test_divisible, "0", "9223372036854775807", "0" },
+	{ &int_test_divisible, "1", "0", "1" },
+	{ &int_test_divisible, "1", "1", "1" },
+	{ &int_test_divisible, "1", "2", "1" },
+	{ &int_test_divisible, "1", "2147483647", "1" },
+	{ &int_test_divisible, "1", "9223372036854775807", "1" },
+	{ &int_test_divisible, "1", "0", "2" },
+	{ &int_test_divisible, "0", "1", "2" },
+	{ &int_test_divisible, "1", "2", "2" },
+	{ &int_test_divisible, "0", "2147483647", "2" },
+	{ &int_test_divisible, "0", "9223372036854775807", "2" },
 };
 
 /* Tests the isl_int_* function to give the expected results. Tests are
diff --git a/lib/Analysis/isl/isl_transitive_closure.c b/lib/Analysis/isl/isl_transitive_closure.c
index a03df7c..6e1b4bb 100644
--- a/lib/Analysis/isl/isl_transitive_closure.c
+++ b/lib/Analysis/isl/isl_transitive_closure.c
@@ -284,15 +284,15 @@ error:
 /* Check whether the parametric constant term of constraint c is never
  * positive in "bset".
  */
-static int parametric_constant_never_positive(__isl_keep isl_basic_set *bset,
-	isl_int *c, int *div_purity)
+static isl_bool parametric_constant_never_positive(
+	__isl_keep isl_basic_set *bset, isl_int *c, int *div_purity)
 {
 	unsigned d;
 	unsigned n_div;
 	unsigned nparam;
 	int i;
 	int k;
-	int empty;
+	isl_bool empty;
 
 	n_div = isl_basic_set_dim(bset, isl_dim_div);
 	d = isl_basic_set_dim(bset, isl_dim_set);
@@ -319,7 +319,7 @@ static int parametric_constant_never_positive(__isl_keep isl_basic_set *bset,
 	return empty;
 error:
 	isl_basic_set_free(bset);
-	return -1;
+	return isl_bool_error;
 }
 
 /* Return PURE_PARAM if only the coefficients of the parameters are non-zero.
@@ -335,7 +335,7 @@ static int purity(__isl_keep isl_basic_set *bset, isl_int *c, int *div_purity,
 	unsigned d;
 	unsigned n_div;
 	unsigned nparam;
-	int empty;
+	isl_bool empty;
 	int i;
 	int p = 0, v = 0;
 
@@ -777,7 +777,7 @@ static __isl_give isl_map *construct_extended_path(__isl_take isl_space *dim,
 		delta = isl_basic_map_deltas(isl_basic_map_copy(map->p[i]));
 
 		for (j = 0; j < d; ++j) {
-			int fixed;
+			isl_bool fixed;
 
 			fixed = isl_basic_set_plain_dim_is_fixed(delta, j,
 							    &steps->row[n][j]);
@@ -822,23 +822,24 @@ error:
 	return NULL;
 }
 
-static int isl_set_overlaps(__isl_keep isl_set *set1, __isl_keep isl_set *set2)
+static isl_bool isl_set_overlaps(__isl_keep isl_set *set1,
+	__isl_keep isl_set *set2)
 {
 	isl_set *i;
-	int no_overlap;
+	isl_bool no_overlap;
 
 	if (!set1 || !set2)
-		return -1;
+		return isl_bool_error;
 
 	if (!isl_space_tuple_is_equal(set1->dim, isl_dim_set,
 					set2->dim, isl_dim_set))
-		return 0;
+		return isl_bool_false;
 
 	i = isl_set_intersect(isl_set_copy(set1), isl_set_copy(set2));
 	no_overlap = isl_set_is_empty(i);
 	isl_set_free(i);
 
-	return no_overlap < 0 ? -1 : !no_overlap;
+	return isl_bool_not(no_overlap);
 }
 
 /* Given a union of basic maps R = \cup_i R_i \subseteq D \times D
@@ -867,7 +868,7 @@ static __isl_give isl_map *construct_component(__isl_take isl_space *dim,
 	struct isl_set *range = NULL;
 	struct isl_map *app = NULL;
 	struct isl_map *path = NULL;
-	int overlaps;
+	isl_bool overlaps;
 
 	domain = isl_map_domain(isl_map_copy(map));
 	domain = isl_set_coalesce(domain);
@@ -1040,7 +1041,7 @@ static int composability(__isl_keep isl_set *C, int i,
 
 	ok = LEFT | RIGHT;
 	for (j = 0; j < map->n && ok; ++j) {
-		int overlaps, subset;
+		isl_bool overlaps, subset;
 		if (j == i)
 			continue;
 
@@ -1440,7 +1441,7 @@ static int merge(isl_set **set, int *group, __isl_take isl_set *dom, int pos)
 	set[pos] = isl_set_copy(dom);
 
 	for (i = pos - 1; i >= 0; --i) {
-		int o;
+		isl_bool o;
 
 		if (group[i] != i)
 			continue;
@@ -2115,53 +2116,6 @@ __isl_give isl_map *isl_map_reaching_path_lengths(__isl_take isl_map *map,
 	return map;
 }
 
-/* Check whether equality i of bset is a pure stride constraint
- * on a single dimensions, i.e., of the form
- *
- *	v = k e
- *
- * with k a constant and e an existentially quantified variable.
- */
-static int is_eq_stride(__isl_keep isl_basic_set *bset, int i)
-{
-	unsigned nparam;
-	unsigned d;
-	unsigned n_div;
-	int pos1;
-	int pos2;
-
-	if (!bset)
-		return -1;
-
-	if (!isl_int_is_zero(bset->eq[i][0]))
-		return 0;
-
-	nparam = isl_basic_set_dim(bset, isl_dim_param);
-	d = isl_basic_set_dim(bset, isl_dim_set);
-	n_div = isl_basic_set_dim(bset, isl_dim_div);
-
-	if (isl_seq_first_non_zero(bset->eq[i] + 1, nparam) != -1)
-		return 0;
-	pos1 = isl_seq_first_non_zero(bset->eq[i] + 1 + nparam, d);
-	if (pos1 == -1)
-		return 0;
-	if (isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + pos1 + 1, 
-					d - pos1 - 1) != -1)
-		return 0;
-
-	pos2 = isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + d, n_div);
-	if (pos2 == -1)
-		return 0;
-	if (isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + d  + pos2 + 1,
-				   n_div - pos2 - 1) != -1)
-		return 0;
-	if (!isl_int_is_one(bset->eq[i][1 + nparam + pos1]) &&
-	    !isl_int_is_negone(bset->eq[i][1 + nparam + pos1]))
-		return 0;
-
-	return 1;
-}
-
 /* Given a map, compute the smallest superset of this map that is of the form
  *
  *	{ i -> j : L <= j - i <= U and exists a_p: j_p - i_p = M_p a_p }
@@ -2227,7 +2181,7 @@ static __isl_give isl_map *box_closure_on_domain(__isl_take isl_map *map,
 		isl_int_set_si(bmap->div[k][0], 0);
 	}
 	for (i = 0; i < aff->n_eq; ++i) {
-		if (!is_eq_stride(aff, i))
+		if (!isl_basic_set_eq_is_stride(aff, i))
 			continue;
 		k = isl_basic_map_alloc_equality(bmap);
 		if (k < 0)
diff --git a/lib/Analysis/isl/isl_union_map.c b/lib/Analysis/isl/isl_union_map.c
index 367af02..a5ae135 100644
--- a/lib/Analysis/isl/isl_union_map.c
+++ b/lib/Analysis/isl/isl_union_map.c
@@ -2,7 +2,7 @@
  * Copyright 2010-2011 INRIA Saclay
  * Copyright 2013-2014 Ecole Normale Superieure
  * Copyright 2014      INRIA Rocquencourt
- * Copyright 2016      Sven Verdoolaege
+ * Copyright 2016-2017 Sven Verdoolaege
  *
  * Use of this software is governed by the MIT license
  *
@@ -23,8 +23,13 @@
 #include <isl/set.h>
 #include <isl_space_private.h>
 #include <isl/union_set.h>
+#include <isl_maybe_map.h>
 #include <isl/deprecated/union_map_int.h>
 
+#include <bset_from_bmap.c>
+#include <set_to_map.c>
+#include <set_from_map.c>
+
 /* Return the number of parameters of "umap", where "type"
  * is required to be set to isl_dim_param.
  */
@@ -126,11 +131,16 @@ isl_ctx *isl_union_set_get_ctx(__isl_keep isl_union_set *uset)
 	return uset ? uset->dim->ctx : NULL;
 }
 
+/* Return the space of "umap".
+ */
+__isl_keep isl_space *isl_union_map_peek_space(__isl_keep isl_union_map *umap)
+{
+	return umap ? umap->dim : NULL;
+}
+
 __isl_give isl_space *isl_union_map_get_space(__isl_keep isl_union_map *umap)
 {
-	if (!umap)
-		return NULL;
-	return isl_space_copy(umap->dim);
+	return isl_space_copy(isl_union_map_peek_space(umap));
 }
 
 /* Return the position of the parameter with the given name
@@ -222,11 +232,15 @@ __isl_give isl_union_map *isl_union_map_align_params(
 	__isl_take isl_union_map *umap, __isl_take isl_space *model)
 {
 	struct isl_union_align data = { NULL, NULL };
+	isl_bool equal_params;
 
 	if (!umap || !model)
 		goto error;
 
-	if (isl_space_match(umap->dim, isl_dim_param, model, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(umap->dim, model);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params) {
 		isl_space_free(model);
 		return umap;
 	}
@@ -324,12 +338,23 @@ __isl_null isl_union_set *isl_union_set_free(__isl_take isl_union_set *uset)
 	return isl_union_map_free(uset);
 }
 
-static int has_dim(const void *entry, const void *val)
+/* Do "umap" and "space" have the same parameters?
+ */
+isl_bool isl_union_map_space_has_equal_params(__isl_keep isl_union_map *umap,
+	__isl_keep isl_space *space)
+{
+	isl_space *umap_space;
+
+	umap_space = isl_union_map_peek_space(umap);
+	return isl_space_has_equal_params(umap_space, space);
+}
+
+static int has_space(const void *entry, const void *val)
 {
 	isl_map *map = (isl_map *)entry;
-	isl_space *dim = (isl_space *)val;
+	isl_space *space = (isl_space *) val;
 
-	return isl_space_is_equal(map->dim, dim);
+	return isl_space_is_equal(map->dim, space);
 }
 
 __isl_give isl_union_map *isl_union_map_add_map(__isl_take isl_union_map *umap,
@@ -337,6 +362,7 @@ __isl_give isl_union_map *isl_union_map_add_map(__isl_take isl_union_map *umap,
 {
 	uint32_t hash;
 	struct isl_hash_table_entry *entry;
+	isl_bool aligned;
 
 	if (!map || !umap)
 		goto error;
@@ -346,7 +372,10 @@ __isl_give isl_union_map *isl_union_map_add_map(__isl_take isl_union_map *umap,
 		return umap;
 	}
 
-	if (!isl_space_match(map->dim, isl_dim_param, umap->dim, isl_dim_param)) {
+	aligned = isl_map_space_has_equal_params(map, umap->dim);
+	if (aligned < 0)
+		goto error;
+	if (!aligned) {
 		umap = isl_union_map_align_params(umap, isl_map_get_space(map));
 		map = isl_map_align_params(map, isl_union_map_get_space(umap));
 	}
@@ -358,7 +387,7 @@ __isl_give isl_union_map *isl_union_map_add_map(__isl_take isl_union_map *umap,
 
 	hash = isl_space_get_hash(map->dim);
 	entry = isl_hash_table_find(umap->dim->ctx, &umap->table, hash,
-				    &has_dim, map->dim, 1);
+				    &has_space, map->dim, 1);
 	if (!entry)
 		goto error;
 
@@ -381,7 +410,7 @@ error:
 __isl_give isl_union_set *isl_union_set_add_set(__isl_take isl_union_set *uset,
 	__isl_take isl_set *set)
 {
-	return isl_union_map_add_map(uset, (isl_map *)set);
+	return isl_union_map_add_map(uset, set_to_map(set));
 }
 
 __isl_give isl_union_map *isl_union_map_from_map(__isl_take isl_map *map)
@@ -402,7 +431,7 @@ __isl_give isl_union_map *isl_union_map_from_map(__isl_take isl_map *map)
 
 __isl_give isl_union_set *isl_union_set_from_set(__isl_take isl_set *set)
 {
-	return isl_union_map_from_map((isl_map *)set);
+	return isl_union_map_from_map(set_to_map(set));
 }
 
 __isl_give isl_union_map *isl_union_map_from_basic_map(
@@ -509,7 +538,7 @@ __isl_give isl_map *isl_union_map_extract_map(__isl_keep isl_union_map *umap,
 
 	hash = isl_space_get_hash(space);
 	entry = isl_hash_table_find(umap->dim->ctx, &umap->table, hash,
-				    &has_dim, space, 0);
+				    &has_space, space, 0);
 	if (!entry)
 		return isl_map_empty(space);
 	isl_space_free(space);
@@ -522,30 +551,30 @@ error:
 __isl_give isl_set *isl_union_set_extract_set(__isl_keep isl_union_set *uset,
 	__isl_take isl_space *dim)
 {
-	return (isl_set *)isl_union_map_extract_map(uset, dim);
+	return set_from_map(isl_union_map_extract_map(uset, dim));
 }
 
 /* Check if umap contains a map in the given space.
  */
-__isl_give int isl_union_map_contains(__isl_keep isl_union_map *umap,
-	__isl_keep isl_space *dim)
+isl_bool isl_union_map_contains(__isl_keep isl_union_map *umap,
+	__isl_keep isl_space *space)
 {
 	uint32_t hash;
 	struct isl_hash_table_entry *entry;
 
-	if (!umap || !dim)
-		return -1;
+	if (!umap || !space)
+		return isl_bool_error;
 
-	hash = isl_space_get_hash(dim);
+	hash = isl_space_get_hash(space);
 	entry = isl_hash_table_find(umap->dim->ctx, &umap->table, hash,
-				    &has_dim, dim, 0);
+				    &has_space, space, 0);
 	return !!entry;
 }
 
-__isl_give int isl_union_set_contains(__isl_keep isl_union_set *uset,
-	__isl_keep isl_space *dim)
+isl_bool isl_union_set_contains(__isl_keep isl_union_set *uset,
+	__isl_keep isl_space *space)
 {
-	return isl_union_map_contains(uset, dim);
+	return isl_union_map_contains(uset, space);
 }
 
 isl_stat isl_union_set_foreach_set(__isl_keep isl_union_set *uset,
@@ -578,45 +607,159 @@ isl_stat isl_union_set_foreach_point(__isl_keep isl_union_set *uset,
 	return isl_union_set_foreach_set(uset, &foreach_point, &data);
 }
 
+/* Data structure that specifies how gen_bin_op should
+ * construct results from the inputs.
+ *
+ * If "subtract" is set, then a map in the first input is copied to the result
+ * if there is no corresponding map in the second input.
+ * Otherwise, a map in the first input with no corresponding map
+ * in the second input is ignored.
+ * If "filter" is not NULL, then it specifies which maps in the first
+ * input may have a matching map in the second input.
+ * In particular, it makes sure that "match_space" can be called
+ * on the space of the map.
+ * "match_space" specifies how to transform the space of a map
+ * in the first input to the space of the corresponding map
+ * in the second input.
+ * "fn_map" specifies how the matching maps, one from each input,
+ * should be combined to form a map in the result.
+ */
+struct isl_bin_op_control {
+	int subtract;
+	isl_bool (*filter)(__isl_keep isl_map *map);
+	__isl_give isl_space *(*match_space)(__isl_take isl_space *space);
+	__isl_give isl_map *(*fn_map)(__isl_take isl_map *map1,
+		__isl_take isl_map *map2);
+};
+
+/* Internal data structure for gen_bin_op.
+ * "control" specifies how the maps in the result should be constructed.
+ * "umap2" is a pointer to the second argument.
+ * "res" collects the results.
+ */
 struct isl_union_map_gen_bin_data {
+	struct isl_bin_op_control *control;
 	isl_union_map *umap2;
 	isl_union_map *res;
 };
 
-static isl_stat subtract_entry(void **entry, void *user)
+/* Add a copy of "map" to "res" and return the result.
+ */
+static __isl_give isl_union_map *bin_add_map(__isl_take isl_union_map *res,
+	__isl_keep isl_map *map)
+{
+	return isl_union_map_add_map(res, isl_map_copy(map));
+}
+
+/* Combine "map1" and "map2", add the result to "res" and return the result.
+ * Check whether the result is empty before adding it to "res".
+ */
+static __isl_give isl_union_map *bin_add_pair(__isl_take isl_union_map *res,
+	__isl_keep isl_map *map1, __isl_keep isl_map *map2,
+	struct isl_union_map_gen_bin_data *data)
+{
+	isl_bool empty;
+	isl_map *map;
+
+	map = data->control->fn_map(isl_map_copy(map1), isl_map_copy(map2));
+	empty = isl_map_is_empty(map);
+	if (empty < 0 || empty) {
+		isl_map_free(map);
+		if (empty < 0)
+			return isl_union_map_free(res);
+		return res;
+	}
+	return isl_union_map_add_map(res, map);
+}
+
+/* Dummy match_space function that simply returns the input space.
+ */
+static __isl_give isl_space *identity(__isl_take isl_space *space)
+{
+	return space;
+}
+
+/* Look for the map in data->umap2 that corresponds to "map", if any.
+ * Return (isl_bool_true, matching map) if there is one,
+ * (isl_bool_false, NULL) if there is no matching map and
+ * (isl_bool_error, NULL) on error.
+ *
+ * If not NULL, then data->control->filter specifies whether "map"
+ * can have any matching map.  If so,
+ * data->control->match_space specifies which map in data->umap2
+ * corresponds to "map".
+ */
+static __isl_keep isl_maybe_isl_map bin_try_get_match(
+	struct isl_union_map_gen_bin_data *data, __isl_keep isl_map *map)
 {
-	struct isl_union_map_gen_bin_data *data = user;
 	uint32_t hash;
 	struct isl_hash_table_entry *entry2;
+	isl_space *space;
+	isl_maybe_isl_map res = { isl_bool_error, NULL };
+
+	if (data->control->filter) {
+		res.valid = data->control->filter(map);
+		if (res.valid < 0 || !res.valid)
+			return res;
+		res.valid = isl_bool_error;
+	}
+
+	space = isl_map_get_space(map);
+	if (data->control->match_space != &identity)
+		space = data->control->match_space(space);
+	if (!space)
+		return res;
+	hash = isl_space_get_hash(space);
+	entry2 = isl_hash_table_find(isl_union_map_get_ctx(data->umap2),
+				     &data->umap2->table, hash,
+				     &has_space, space, 0);
+	isl_space_free(space);
+	res.valid = entry2 != NULL;
+	if (entry2)
+		res.value = entry2->data;
+
+	return res;
+}
+
+/* isl_hash_table_foreach callback for gen_bin_op.
+ * Look for the map in data->umap2 that corresponds
+ * to the map that "entry" points to, apply the binary operation and
+ * add the result to data->res.
+ *
+ * If no corresponding map can be found, then the effect depends
+ * on data->control->subtract.  If it is set, then the current map
+ * is added directly to the result.  Otherwise, it is ignored.
+ */
+static isl_stat gen_bin_entry(void **entry, void *user)
+{
+	struct isl_union_map_gen_bin_data *data = user;
 	isl_map *map = *entry;
+	isl_maybe_isl_map m;
 
-	hash = isl_space_get_hash(map->dim);
-	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, map->dim, 0);
-	map = isl_map_copy(map);
-	if (entry2) {
-		int empty;
-		map = isl_map_subtract(map, isl_map_copy(entry2->data));
+	m = bin_try_get_match(data, map);
+	if (m.valid < 0)
+		return isl_stat_error;
+	if (!m.valid && !data->control->subtract)
+		return isl_stat_ok;
 
-		empty = isl_map_is_empty(map);
-		if (empty < 0) {
-			isl_map_free(map);
-			return isl_stat_error;
-		}
-		if (empty) {
-			isl_map_free(map);
-			return isl_stat_ok;
-		}
-	}
-	data->res = isl_union_map_add_map(data->res, map);
+	if (!m.valid)
+		data->res = bin_add_map(data->res, map);
+	else
+		data->res = bin_add_pair(data->res, map, m.value, data);
+	if (!data->res)
+		return isl_stat_error;
 
 	return isl_stat_ok;
 }
 
+/* Apply a binary operation to "umap1" and "umap2" based on "control".
+ * Run over all maps in "umap1" and look for the corresponding map in "umap2"
+ * in gen_bin_entry.
+ */
 static __isl_give isl_union_map *gen_bin_op(__isl_take isl_union_map *umap1,
-	__isl_take isl_union_map *umap2, isl_stat (*fn)(void **, void *))
+	__isl_take isl_union_map *umap2, struct isl_bin_op_control *control)
 {
-	struct isl_union_map_gen_bin_data data = { NULL, NULL };
+	struct isl_union_map_gen_bin_data data = { control, NULL, NULL };
 
 	umap1 = isl_union_map_align_params(umap1, isl_union_map_get_space(umap2));
 	umap2 = isl_union_map_align_params(umap2, isl_union_map_get_space(umap1));
@@ -628,7 +771,7 @@ static __isl_give isl_union_map *gen_bin_op(__isl_take isl_union_map *umap1,
 	data.res = isl_union_map_alloc(isl_space_copy(umap1->dim),
 				       umap1->table.n);
 	if (isl_hash_table_foreach(umap1->dim->ctx, &umap1->table,
-				   fn, &data) < 0)
+				   &gen_bin_entry, &data) < 0)
 		goto error;
 
 	isl_union_map_free(umap1);
@@ -644,7 +787,13 @@ error:
 __isl_give isl_union_map *isl_union_map_subtract(
 	__isl_take isl_union_map *umap1, __isl_take isl_union_map *umap2)
 {
-	return gen_bin_op(umap1, umap2, &subtract_entry);
+	struct isl_bin_op_control control = {
+		.subtract = 1,
+		.match_space = &identity,
+		.fn_map = &isl_map_subtract,
+	};
+
+	return gen_bin_op(umap1, umap2, &control);
 }
 
 __isl_give isl_union_set *isl_union_set_subtract(
@@ -765,7 +914,7 @@ static isl_stat match_bin_entry(void **entry, void *user)
 
 	hash = isl_space_get_hash(map->dim);
 	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, map->dim, 0);
+				     hash, &has_space, map->dim, 0);
 	if (!entry2)
 		return isl_stat_ok;
 
@@ -893,16 +1042,38 @@ __isl_give isl_union_set *isl_union_set_gist(__isl_take isl_union_set *uset,
 	return isl_union_map_gist(uset, context);
 }
 
+/* For each map in "umap", remove the constraints in the corresponding map
+ * of "context".
+ * Each map in "context" is assumed to consist of a single disjunct and
+ * to have explicit representations for all local variables.
+ */
+__isl_give isl_union_map *isl_union_map_plain_gist(
+	__isl_take isl_union_map *umap, __isl_take isl_union_map *context)
+{
+	return match_bin_op(umap, context, &isl_map_plain_gist);
+}
+
+/* For each set in "uset", remove the constraints in the corresponding set
+ * of "context".
+ * Each set in "context" is assumed to consist of a single disjunct and
+ * to have explicit representations for all local variables.
+ */
+__isl_give isl_union_set *isl_union_set_plain_gist(
+	__isl_take isl_union_set *uset, __isl_take isl_union_set *context)
+{
+	return isl_union_map_plain_gist(uset, context);
+}
+
 static __isl_give isl_map *lex_le_set(__isl_take isl_map *set1,
 	__isl_take isl_map *set2)
 {
-	return isl_set_lex_le_set((isl_set *)set1, (isl_set *)set2);
+	return isl_set_lex_le_set(set_from_map(set1), set_from_map(set2));
 }
 
 static __isl_give isl_map *lex_lt_set(__isl_take isl_map *set1,
 	__isl_take isl_map *set2)
 {
-	return isl_set_lex_lt_set((isl_set *)set1, (isl_set *)set2);
+	return isl_set_lex_lt_set(set_from_map(set1), set_from_map(set2));
 }
 
 __isl_give isl_union_map *isl_union_set_lex_lt_union_set(
@@ -941,40 +1112,17 @@ __isl_give isl_union_map *isl_union_map_lex_ge_union_map(
 	return isl_union_map_reverse(isl_union_map_lex_le_union_map(umap2, umap1));
 }
 
-static isl_stat intersect_domain_entry(void **entry, void *user)
+/* Intersect the domain of "umap" with "uset".
+ */
+static __isl_give isl_union_map *union_map_intersect_domain(
+	__isl_take isl_union_map *umap, __isl_take isl_union_set *uset)
 {
-	struct isl_union_map_gen_bin_data *data = user;
-	uint32_t hash;
-	struct isl_hash_table_entry *entry2;
-	isl_space *dim;
-	isl_map *map = *entry;
-	isl_bool empty;
-
-	dim = isl_map_get_space(map);
-	dim = isl_space_domain(dim);
-	hash = isl_space_get_hash(dim);
-	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, dim, 0);
-	isl_space_free(dim);
-	if (!entry2)
-		return isl_stat_ok;
-
-	map = isl_map_copy(map);
-	map = isl_map_intersect_domain(map, isl_set_copy(entry2->data));
-
-	empty = isl_map_is_empty(map);
-	if (empty < 0) {
-		isl_map_free(map);
-		return isl_stat_error;
-	}
-	if (empty) {
-		isl_map_free(map);
-		return isl_stat_ok;
-	}
+	struct isl_bin_op_control control = {
+		.match_space = &isl_space_domain,
+		.fn_map = &isl_map_intersect_domain,
+	};
 
-	data->res = isl_union_map_add_map(data->res, map);
-
-	return isl_stat_ok;
+	return gen_bin_op(umap, uset, &control);
 }
 
 /* Intersect the domain of "umap" with "uset".
@@ -986,50 +1134,8 @@ __isl_give isl_union_map *isl_union_map_intersect_domain(
 {
 	if (isl_union_set_is_params(uset))
 		return union_map_intersect_params(umap, uset);
-	return gen_bin_op(umap, uset, &intersect_domain_entry);
-}
-
-/* Remove the elements of data->umap2 from the domain of *entry
- * and add the result to data->res.
- */
-static isl_stat subtract_domain_entry(void **entry, void *user)
-{
-	struct isl_union_map_gen_bin_data *data = user;
-	uint32_t hash;
-	struct isl_hash_table_entry *entry2;
-	isl_space *dim;
-	isl_map *map = *entry;
-	isl_bool empty;
-
-	dim = isl_map_get_space(map);
-	dim = isl_space_domain(dim);
-	hash = isl_space_get_hash(dim);
-	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, dim, 0);
-	isl_space_free(dim);
-
-	map = isl_map_copy(map);
-
-	if (!entry2) {
-		data->res = isl_union_map_add_map(data->res, map);
-		return isl_stat_ok;
-	}
-
-	map = isl_map_subtract_domain(map, isl_set_copy(entry2->data));
-
-	empty = isl_map_is_empty(map);
-	if (empty < 0) {
-		isl_map_free(map);
-		return isl_stat_error;
-	}
-	if (empty) {
-		isl_map_free(map);
-		return isl_stat_ok;
-	}
-
-	data->res = isl_union_map_add_map(data->res, map);
-
-	return isl_stat_ok;
+	else
+		return union_map_intersect_domain(umap, uset);
 }
 
 /* Remove the elements of "uset" from the domain of "umap".
@@ -1037,50 +1143,13 @@ static isl_stat subtract_domain_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_subtract_domain(
 	__isl_take isl_union_map *umap, __isl_take isl_union_set *dom)
 {
-	return gen_bin_op(umap, dom, &subtract_domain_entry);
-}
-
-/* Remove the elements of data->umap2 from the range of *entry
- * and add the result to data->res.
- */
-static isl_stat subtract_range_entry(void **entry, void *user)
-{
-	struct isl_union_map_gen_bin_data *data = user;
-	uint32_t hash;
-	struct isl_hash_table_entry *entry2;
-	isl_space *space;
-	isl_map *map = *entry;
-	isl_bool empty;
-
-	space = isl_map_get_space(map);
-	space = isl_space_range(space);
-	hash = isl_space_get_hash(space);
-	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, space, 0);
-	isl_space_free(space);
+	struct isl_bin_op_control control = {
+		.subtract = 1,
+		.match_space = &isl_space_domain,
+		.fn_map = &isl_map_subtract_domain,
+	};
 
-	map = isl_map_copy(map);
-
-	if (!entry2) {
-		data->res = isl_union_map_add_map(data->res, map);
-		return isl_stat_ok;
-	}
-
-	map = isl_map_subtract_range(map, isl_set_copy(entry2->data));
-
-	empty = isl_map_is_empty(map);
-	if (empty < 0) {
-		isl_map_free(map);
-		return isl_stat_error;
-	}
-	if (empty) {
-		isl_map_free(map);
-		return isl_stat_ok;
-	}
-
-	data->res = isl_union_map_add_map(data->res, map);
-
-	return isl_stat_ok;
+	return gen_bin_op(umap, dom, &control);
 }
 
 /* Remove the elements of "uset" from the range of "umap".
@@ -1088,39 +1157,26 @@ static isl_stat subtract_range_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_subtract_range(
 	__isl_take isl_union_map *umap, __isl_take isl_union_set *dom)
 {
-	return gen_bin_op(umap, dom, &subtract_range_entry);
+	struct isl_bin_op_control control = {
+		.subtract = 1,
+		.match_space = &isl_space_range,
+		.fn_map = &isl_map_subtract_range,
+	};
+
+	return gen_bin_op(umap, dom, &control);
 }
 
-static isl_stat gist_domain_entry(void **entry, void *user)
+/* Compute the gist of "umap" with respect to the domain "uset".
+ */
+static __isl_give isl_union_map *union_map_gist_domain(
+	__isl_take isl_union_map *umap, __isl_take isl_union_set *uset)
 {
-	struct isl_union_map_gen_bin_data *data = user;
-	uint32_t hash;
-	struct isl_hash_table_entry *entry2;
-	isl_space *dim;
-	isl_map *map = *entry;
-	isl_bool empty;
+	struct isl_bin_op_control control = {
+		.match_space = &isl_space_domain,
+		.fn_map = &isl_map_gist_domain,
+	};
 
-	dim = isl_map_get_space(map);
-	dim = isl_space_domain(dim);
-	hash = isl_space_get_hash(dim);
-	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, dim, 0);
-	isl_space_free(dim);
-	if (!entry2)
-		return isl_stat_ok;
-
-	map = isl_map_copy(map);
-	map = isl_map_gist_domain(map, isl_set_copy(entry2->data));
-
-	empty = isl_map_is_empty(map);
-	if (empty < 0) {
-		isl_map_free(map);
-		return isl_stat_error;
-	}
-
-	data->res = isl_union_map_add_map(data->res, map);
-
-	return isl_stat_ok;
+	return gen_bin_op(umap, uset, &control);
 }
 
 /* Compute the gist of "umap" with respect to the domain "uset".
@@ -1132,39 +1188,8 @@ __isl_give isl_union_map *isl_union_map_gist_domain(
 {
 	if (isl_union_set_is_params(uset))
 		return union_map_gist_params(umap, uset);
-	return gen_bin_op(umap, uset, &gist_domain_entry);
-}
-
-static isl_stat gist_range_entry(void **entry, void *user)
-{
-	struct isl_union_map_gen_bin_data *data = user;
-	uint32_t hash;
-	struct isl_hash_table_entry *entry2;
-	isl_space *space;
-	isl_map *map = *entry;
-	isl_bool empty;
-
-	space = isl_map_get_space(map);
-	space = isl_space_range(space);
-	hash = isl_space_get_hash(space);
-	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, space, 0);
-	isl_space_free(space);
-	if (!entry2)
-		return isl_stat_ok;
-
-	map = isl_map_copy(map);
-	map = isl_map_gist_range(map, isl_set_copy(entry2->data));
-
-	empty = isl_map_is_empty(map);
-	if (empty < 0) {
-		isl_map_free(map);
-		return isl_stat_error;
-	}
-
-	data->res = isl_union_map_add_map(data->res, map);
-
-	return isl_stat_ok;
+	else
+		return union_map_gist_domain(umap, uset);
 }
 
 /* Compute the gist of "umap" with respect to the range "uset".
@@ -1172,49 +1197,39 @@ static isl_stat gist_range_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_gist_range(
 	__isl_take isl_union_map *umap, __isl_take isl_union_set *uset)
 {
-	return gen_bin_op(umap, uset, &gist_range_entry);
+	struct isl_bin_op_control control = {
+		.match_space = &isl_space_range,
+		.fn_map = &isl_map_gist_range,
+	};
+
+	return gen_bin_op(umap, uset, &control);
 }
 
-static isl_stat intersect_range_entry(void **entry, void *user)
+__isl_give isl_union_map *isl_union_map_intersect_range(
+	__isl_take isl_union_map *umap, __isl_take isl_union_set *uset)
 {
-	struct isl_union_map_gen_bin_data *data = user;
-	uint32_t hash;
-	struct isl_hash_table_entry *entry2;
-	isl_space *dim;
-	isl_map *map = *entry;
-	isl_bool empty;
-
-	dim = isl_map_get_space(map);
-	dim = isl_space_range(dim);
-	hash = isl_space_get_hash(dim);
-	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, dim, 0);
-	isl_space_free(dim);
-	if (!entry2)
-		return isl_stat_ok;
-
-	map = isl_map_copy(map);
-	map = isl_map_intersect_range(map, isl_set_copy(entry2->data));
-
-	empty = isl_map_is_empty(map);
-	if (empty < 0) {
-		isl_map_free(map);
-		return isl_stat_error;
-	}
-	if (empty) {
-		isl_map_free(map);
-		return isl_stat_ok;
-	}
+	struct isl_bin_op_control control = {
+		.match_space = &isl_space_range,
+		.fn_map = &isl_map_intersect_range,
+	};
 
-	data->res = isl_union_map_add_map(data->res, map);
-
-	return isl_stat_ok;
+	return gen_bin_op(umap, uset, &control);
 }
 
-__isl_give isl_union_map *isl_union_map_intersect_range(
-	__isl_take isl_union_map *umap, __isl_take isl_union_set *uset)
+/* Intersect each map in "umap" in a space A -> [B -> C]
+ * with the corresponding map in "factor" in the space A -> C and
+ * collect the results.
+ */
+__isl_give isl_union_map *isl_union_map_intersect_range_factor_range(
+	__isl_take isl_union_map *umap, __isl_take isl_union_map *factor)
 {
-	return gen_bin_op(umap, uset, &intersect_range_entry);
+	struct isl_bin_op_control control = {
+		.filter = &isl_map_range_is_wrapping,
+		.match_space = &isl_space_range_factor_range,
+		.fn_map = &isl_map_intersect_range_factor_range,
+	};
+
+	return gen_bin_op(umap, factor, &control);
 }
 
 struct isl_union_map_bin_data {
@@ -1492,41 +1507,122 @@ __isl_give isl_union_map *isl_union_map_flat_range_product(
 	return bin_op(umap1, umap2, &flat_range_product_entry);
 }
 
-static __isl_give isl_union_set *cond_un_op(__isl_take isl_union_map *umap,
-	isl_stat (*fn)(void **, void *))
+/* Data structure that specifies how un_op should modify
+ * the maps in the union map.
+ *
+ * If "inplace" is set, then the maps in the input union map
+ * are modified in place.  This means that "fn_map" should not
+ * change the meaning of the map or that the union map only
+ * has a single reference.
+ * If "total" is set, then all maps need to be modified and
+ * the results need to live in the same space.
+ * Otherwise, a new union map is constructed to store the results.
+ * If "filter" is not NULL, then only the input maps that satisfy "filter"
+ * are taken into account.  No filter can be set if "inplace" or
+ * "total" is set.
+ * "fn_map" specifies how the maps (selected by "filter")
+ * should be transformed.
+ */
+struct isl_un_op_control {
+	int inplace;
+	int total;
+	isl_bool (*filter)(__isl_keep isl_map *map);
+	__isl_give isl_map *(*fn_map)(__isl_take isl_map *map);
+};
+
+/* Internal data structure for "un_op".
+ * "control" specifies how the maps in the union map should be modified.
+ * "res" collects the results.
+ */
+struct isl_union_map_un_data {
+	struct isl_un_op_control *control;
+	isl_union_map *res;
+};
+
+/* isl_hash_table_foreach callback for un_op.
+ * Handle the map that "entry" points to.
+ *
+ * If control->filter is set, then check if this map satisfies the filter.
+ * If so (or if control->filter is not set), modify the map
+ * by calling control->fn_map and either add the result to data->res or
+ * replace the original entry by the result (if control->inplace is set).
+ */
+static isl_stat un_entry(void **entry, void *user)
 {
-	isl_union_set *res;
+	struct isl_union_map_un_data *data = user;
+	isl_map *map = *entry;
 
-	if (!umap)
-		return NULL;
+	if (data->control->filter) {
+		isl_bool ok;
 
-	res = isl_union_map_alloc(isl_space_copy(umap->dim), umap->table.n);
-	if (isl_hash_table_foreach(umap->dim->ctx, &umap->table, fn, &res) < 0)
-		goto error;
+		ok = data->control->filter(map);
+		if (ok < 0)
+			return isl_stat_error;
+		if (!ok)
+			return isl_stat_ok;
+	}
 
-	isl_union_map_free(umap);
-	return res;
-error:
-	isl_union_map_free(umap);
-	isl_union_set_free(res);
-	return NULL;
+	map = data->control->fn_map(isl_map_copy(map));
+	if (!map)
+		return isl_stat_error;
+	if (data->control->inplace) {
+		isl_map_free(*entry);
+		*entry = map;
+	} else {
+		data->res = isl_union_map_add_map(data->res, map);
+		if (!data->res)
+			return isl_stat_error;
+	}
+
+	return isl_stat_ok;
 }
 
-static isl_stat from_range_entry(void **entry, void *user)
+/* Modify the maps in "umap" based on "control".
+ * If control->inplace is set, then modify the maps in "umap" in-place.
+ * Otherwise, create a new union map to hold the results.
+ * If control->total is set, then perform an inplace computation
+ * if "umap" is only referenced once.  Otherwise, create a new union map
+ * to store the results.
+ */
+static __isl_give isl_union_map *un_op(__isl_take isl_union_map *umap,
+	struct isl_un_op_control *control)
 {
-	isl_map *set = *entry;
-	isl_union_set **res = user;
+	struct isl_union_map_un_data data = { control };
+
+	if (!umap)
+		return NULL;
+	if ((control->inplace || control->total) && control->filter)
+		isl_die(isl_union_map_get_ctx(umap), isl_error_invalid,
+			"inplace/total modification cannot be filtered",
+			return isl_union_map_free(umap));
 
-	*res = isl_union_map_add_map(*res,
-					isl_map_from_range(isl_set_copy(set)));
+	if (control->total && umap->ref == 1)
+		control->inplace = 1;
+	if (control->inplace) {
+		data.res = umap;
+	} else {
+		isl_space *space;
 
-	return isl_stat_ok;
+		space = isl_union_map_get_space(umap);
+		data.res = isl_union_map_alloc(space, umap->table.n);
+	}
+	if (isl_hash_table_foreach(isl_union_map_get_ctx(umap),
+				    &umap->table, &un_entry, &data) < 0)
+		data.res = isl_union_map_free(data.res);
+
+	if (control->inplace)
+		return data.res;
+	isl_union_map_free(umap);
+	return data.res;
 }
 
 __isl_give isl_union_map *isl_union_map_from_range(
 	__isl_take isl_union_set *uset)
 {
-	return cond_un_op(uset, &from_range_entry);
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_from_range,
+	};
+	return un_op(uset, &control);
 }
 
 __isl_give isl_union_map *isl_union_map_from_domain(
@@ -1542,35 +1638,31 @@ __isl_give isl_union_map *isl_union_map_from_domain_and_range(
 				         isl_union_map_from_range(range));
 }
 
-static __isl_give isl_union_map *un_op(__isl_take isl_union_map *umap,
-	isl_stat (*fn)(void **, void *))
+/* Modify the maps in "umap" by applying "fn" on them.
+ * "fn" should apply to all maps in "umap" and should not modify the space.
+ */
+static __isl_give isl_union_map *total(__isl_take isl_union_map *umap,
+	__isl_give isl_map *(*fn)(__isl_take isl_map *))
 {
-	umap = isl_union_map_cow(umap);
-	if (!umap)
-		return NULL;
+	struct isl_un_op_control control = {
+		.total = 1,
+		.fn_map = fn,
+	};
 
-	if (isl_hash_table_foreach(umap->dim->ctx, &umap->table, fn, NULL) < 0)
-		goto error;
-
-	return umap;
-error:
-	isl_union_map_free(umap);
-	return NULL;
+	return un_op(umap, &control);
 }
 
-static isl_stat affine_entry(void **entry, void *user)
+/* Compute the affine hull of "map" and return the result as an isl_map.
+ */
+static __isl_give isl_map *isl_map_affine_hull_map(__isl_take isl_map *map)
 {
-	isl_map **map = (isl_map **)entry;
-
-	*map = isl_map_from_basic_map(isl_map_affine_hull(*map));
-
-	return *map ? isl_stat_ok : isl_stat_error;
+	return isl_map_from_basic_map(isl_map_affine_hull(map));
 }
 
 __isl_give isl_union_map *isl_union_map_affine_hull(
 	__isl_take isl_union_map *umap)
 {
-	return un_op(umap, &affine_entry);
+	return total(umap, &isl_map_affine_hull_map);
 }
 
 __isl_give isl_union_set *isl_union_set_affine_hull(
@@ -1579,19 +1671,39 @@ __isl_give isl_union_set *isl_union_set_affine_hull(
 	return isl_union_map_affine_hull(uset);
 }
 
-static isl_stat polyhedral_entry(void **entry, void *user)
+/* Wrapper around isl_set_combined_lineality_space
+ * that returns the combined lineality space in the form of an isl_set
+ * instead of an isl_basic_set.
+ */
+static __isl_give isl_set *combined_lineality_space(__isl_take isl_set *set)
 {
-	isl_map **map = (isl_map **)entry;
+	return isl_set_from_basic_set(isl_set_combined_lineality_space(set));
+}
 
-	*map = isl_map_from_basic_map(isl_map_polyhedral_hull(*map));
+/* For each set in "uset", compute the (linear) hull
+ * of the lineality spaces of its basic sets and
+ * collect and return the results.
+ */
+__isl_give isl_union_set *isl_union_set_combined_lineality_space(
+	__isl_take isl_union_set *uset)
+{
+	struct isl_un_op_control control = {
+		.fn_map = &combined_lineality_space,
+	};
+	return un_op(uset, &control);
+}
 
-	return *map ? isl_stat_ok : isl_stat_error;
+/* Compute the polyhedral hull of "map" and return the result as an isl_map.
+ */
+static __isl_give isl_map *isl_map_polyhedral_hull_map(__isl_take isl_map *map)
+{
+	return isl_map_from_basic_map(isl_map_polyhedral_hull(map));
 }
 
 __isl_give isl_union_map *isl_union_map_polyhedral_hull(
 	__isl_take isl_union_map *umap)
 {
-	return un_op(umap, &polyhedral_entry);
+	return total(umap, &isl_map_polyhedral_hull_map);
 }
 
 __isl_give isl_union_set *isl_union_set_polyhedral_hull(
@@ -1600,19 +1712,19 @@ __isl_give isl_union_set *isl_union_set_polyhedral_hull(
 	return isl_union_map_polyhedral_hull(uset);
 }
 
-static isl_stat simple_entry(void **entry, void *user)
+/* Compute a superset of the convex hull of "map" that is described
+ * by only translates of the constraints in the constituents of "map" and
+ * return the result as an isl_map.
+ */
+static __isl_give isl_map *isl_map_simple_hull_map(__isl_take isl_map *map)
 {
-	isl_map **map = (isl_map **)entry;
-
-	*map = isl_map_from_basic_map(isl_map_simple_hull(*map));
-
-	return *map ? isl_stat_ok : isl_stat_error;
+	return isl_map_from_basic_map(isl_map_simple_hull(map));
 }
 
 __isl_give isl_union_map *isl_union_map_simple_hull(
 	__isl_take isl_union_map *umap)
 {
-	return un_op(umap, &simple_entry);
+	return total(umap, &isl_map_simple_hull_map);
 }
 
 __isl_give isl_union_set *isl_union_set_simple_hull(
@@ -1621,37 +1733,15 @@ __isl_give isl_union_set *isl_union_set_simple_hull(
 	return isl_union_map_simple_hull(uset);
 }
 
-static isl_stat inplace_entry(void **entry, void *user)
-{
-	__isl_give isl_map *(*fn)(__isl_take isl_map *);
-	isl_map **map = (isl_map **)entry;
-	isl_map *copy;
-
-	fn = *(__isl_give isl_map *(**)(__isl_take isl_map *)) user;
-	copy = fn(isl_map_copy(*map));
-	if (!copy)
-		return isl_stat_error;
-
-	isl_map_free(*map);
-	*map = copy;
-
-	return isl_stat_ok;
-}
-
 static __isl_give isl_union_map *inplace(__isl_take isl_union_map *umap,
 	__isl_give isl_map *(*fn)(__isl_take isl_map *))
 {
-	if (!umap)
-		return NULL;
-
-	if (isl_hash_table_foreach(umap->dim->ctx, &umap->table,
-				    &inplace_entry, &fn) < 0)
-		goto error;
+	struct isl_un_op_control control = {
+		.inplace = 1,
+		.fn_map = fn,
+	};
 
-	return umap;
-error:
-	isl_union_map_free(umap);
-	return NULL;
+	return un_op(umap, &control);
 }
 
 /* Remove redundant constraints in each of the basic maps of "umap".
@@ -1708,19 +1798,10 @@ __isl_give isl_union_set *isl_union_set_compute_divs(
 	return isl_union_map_compute_divs(uset);
 }
 
-static isl_stat lexmin_entry(void **entry, void *user)
-{
-	isl_map **map = (isl_map **)entry;
-
-	*map = isl_map_lexmin(*map);
-
-	return *map ? isl_stat_ok : isl_stat_error;
-}
-
 __isl_give isl_union_map *isl_union_map_lexmin(
 	__isl_take isl_union_map *umap)
 {
-	return un_op(umap, &lexmin_entry);
+	return total(umap, &isl_map_lexmin);
 }
 
 __isl_give isl_union_set *isl_union_set_lexmin(
@@ -1729,19 +1810,10 @@ __isl_give isl_union_set *isl_union_set_lexmin(
 	return isl_union_map_lexmin(uset);
 }
 
-static isl_stat lexmax_entry(void **entry, void *user)
-{
-	isl_map **map = (isl_map **)entry;
-
-	*map = isl_map_lexmax(*map);
-
-	return *map ? isl_stat_ok : isl_stat_error;
-}
-
 __isl_give isl_union_map *isl_union_map_lexmax(
 	__isl_take isl_union_map *umap)
 {
-	return un_op(umap, &lexmax_entry);
+	return total(umap, &isl_map_lexmax);
 }
 
 __isl_give isl_union_set *isl_union_set_lexmax(
@@ -1750,56 +1822,45 @@ __isl_give isl_union_set *isl_union_set_lexmax(
 	return isl_union_map_lexmax(uset);
 }
 
-static isl_stat universe_entry(void **entry, void *user)
+/* Return the universe in the space of "map".
+ */
+static __isl_give isl_map *universe(__isl_take isl_map *map)
 {
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	map = isl_map_universe(isl_map_get_space(map));
-	*res = isl_union_map_add_map(*res, map);
+	isl_space *space;
 
-	return isl_stat_ok;
+	space = isl_map_get_space(map);
+	isl_map_free(map);
+	return isl_map_universe(space);
 }
 
 __isl_give isl_union_map *isl_union_map_universe(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &universe_entry);
+	struct isl_un_op_control control = {
+		.fn_map = &universe,
+	};
+	return un_op(umap, &control);
 }
 
 __isl_give isl_union_set *isl_union_set_universe(__isl_take isl_union_set *uset)
 {
 	return isl_union_map_universe(uset);
-}
-
-static isl_stat reverse_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	*res = isl_union_map_add_map(*res, isl_map_reverse(isl_map_copy(map)));
-
-	return isl_stat_ok;
-}
-
-__isl_give isl_union_map *isl_union_map_reverse(__isl_take isl_union_map *umap)
-{
-	return cond_un_op(umap, &reverse_entry);
-}
-
-static isl_stat params_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_set **res = user;
-
-	*res = isl_union_set_add_set(*res, isl_map_params(isl_map_copy(map)));
+}
 
-	return isl_stat_ok;
+__isl_give isl_union_map *isl_union_map_reverse(__isl_take isl_union_map *umap)
+{
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_reverse,
+	};
+	return un_op(umap, &control);
 }
 
 /* Compute the parameter domain of the given union map.
  */
 __isl_give isl_set *isl_union_map_params(__isl_take isl_union_map *umap)
 {
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_params,
+	};
 	int empty;
 
 	empty = isl_union_map_is_empty(umap);
@@ -1811,7 +1872,7 @@ __isl_give isl_set *isl_union_map_params(__isl_take isl_union_map *umap)
 		isl_union_map_free(umap);
 		return isl_set_empty(space);
 	}
-	return isl_set_from_union_set(cond_un_op(umap, &params_entry));
+	return isl_set_from_union_set(un_op(umap, &control));
 error:
 	isl_union_map_free(umap);
 	return NULL;
@@ -1824,51 +1885,29 @@ __isl_give isl_set *isl_union_set_params(__isl_take isl_union_set *uset)
 	return isl_union_map_params(uset);
 }
 
-static isl_stat domain_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_set **res = user;
-
-	*res = isl_union_set_add_set(*res, isl_map_domain(isl_map_copy(map)));
-
-	return isl_stat_ok;
-}
-
 __isl_give isl_union_set *isl_union_map_domain(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &domain_entry);
-}
-
-static isl_stat range_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_set **res = user;
-
-	*res = isl_union_set_add_set(*res, isl_map_range(isl_map_copy(map)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_domain,
+	};
+	return un_op(umap, &control);
 }
 
 __isl_give isl_union_set *isl_union_map_range(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &range_entry);
-}
-
-static isl_stat domain_map_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_set **res = user;
-
-	*res = isl_union_map_add_map(*res,
-					isl_map_domain_map(isl_map_copy(map)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_range,
+	};
+	return un_op(umap, &control);
 }
 
 __isl_give isl_union_map *isl_union_map_domain_map(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &domain_map_entry);
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_domain_map,
+	};
+	return un_op(umap, &control);
 }
 
 /* Construct an isl_pw_multi_aff that maps "map" to its domain and
@@ -1904,42 +1943,13 @@ __isl_give isl_union_pw_multi_aff *isl_union_map_domain_map_union_pw_multi_aff(
 	return res;
 }
 
-static isl_stat range_map_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_set **res = user;
-
-	*res = isl_union_map_add_map(*res,
-					isl_map_range_map(isl_map_copy(map)));
-
-	return isl_stat_ok;
-}
-
 __isl_give isl_union_map *isl_union_map_range_map(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &range_map_entry);
-}
-
-/* Check if "set" is of the form A[B -> C].
- * If so, add A[B -> C] -> B to "res".
- */
-static isl_stat wrapped_domain_map_entry(void **entry, void *user)
-{
-	isl_set *set = *entry;
-	isl_union_set **res = user;
-	int wrapping;
-
-	wrapping = isl_set_is_wrapping(set);
-	if (wrapping < 0)
-		return isl_stat_error;
-	if (!wrapping)
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-				isl_set_wrapped_domain_map(isl_set_copy(set)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_range_map,
+	};
+	return un_op(umap, &control);
 }
 
 /* Given a collection of wrapped maps of the form A[B -> C],
@@ -1948,62 +1958,46 @@ static isl_stat wrapped_domain_map_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_set_wrapped_domain_map(
 	__isl_take isl_union_set *uset)
 {
-	return cond_un_op(uset, &wrapped_domain_map_entry);
+	struct isl_un_op_control control = {
+		.filter = &isl_set_is_wrapping,
+		.fn_map = &isl_set_wrapped_domain_map,
+	};
+	return un_op(uset, &control);
 }
 
-static isl_stat deltas_entry(void **entry, void *user)
+/* Does "map" relate elements from the same space?
+ */
+static isl_bool equal_tuples(__isl_keep isl_map *map)
 {
-	isl_map *map = *entry;
-	isl_union_set **res = user;
-
-	if (!isl_space_tuple_is_equal(map->dim, isl_dim_in,
-					map->dim, isl_dim_out))
-		return isl_stat_ok;
-
-	*res = isl_union_set_add_set(*res, isl_map_deltas(isl_map_copy(map)));
-
-	return isl_stat_ok;
+	return isl_space_tuple_is_equal(map->dim, isl_dim_in,
+					map->dim, isl_dim_out);
 }
 
 __isl_give isl_union_set *isl_union_map_deltas(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &deltas_entry);
-}
-
-static isl_stat deltas_map_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_space_tuple_is_equal(map->dim, isl_dim_in,
-					map->dim, isl_dim_out))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-				     isl_map_deltas_map(isl_map_copy(map)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &equal_tuples,
+		.fn_map = &isl_map_deltas,
+	};
+	return un_op(umap, &control);
 }
 
 __isl_give isl_union_map *isl_union_map_deltas_map(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &deltas_map_entry);
-}
-
-static isl_stat identity_entry(void **entry, void *user)
-{
-	isl_set *set = *entry;
-	isl_union_map **res = user;
-
-	*res = isl_union_map_add_map(*res, isl_set_identity(isl_set_copy(set)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &equal_tuples,
+		.fn_map = &isl_map_deltas_map,
+	};
+	return un_op(umap, &control);
 }
 
 __isl_give isl_union_map *isl_union_set_identity(__isl_take isl_union_set *uset)
 {
-	return cond_un_op(uset, &identity_entry);
+	struct isl_un_op_control control = {
+		.fn_map = &isl_set_identity,
+	};
+	return un_op(uset, &control);
 }
 
 /* Construct an identity isl_pw_multi_aff on "set" and add it to *res.
@@ -2038,45 +2032,17 @@ __isl_give isl_union_pw_multi_aff *isl_union_set_identity_union_pw_multi_aff(
 	return res;
 }
 
-/* If "map" is of the form [A -> B] -> C, then add A -> C to "res".
- */
-static isl_stat domain_factor_domain_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_domain_is_wrapping(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-			    isl_map_domain_factor_domain(isl_map_copy(map)));
-
-	return *res ? isl_stat_ok : isl_stat_error;
-}
-
 /* For each map in "umap" of the form [A -> B] -> C,
  * construct the map A -> C and collect the results.
  */
 __isl_give isl_union_map *isl_union_map_domain_factor_domain(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &domain_factor_domain_entry);
-}
-
-/* If "map" is of the form [A -> B] -> C, then add B -> C to "res".
- */
-static isl_stat domain_factor_range_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_domain_is_wrapping(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-				isl_map_domain_factor_range(isl_map_copy(map)));
-
-	return *res ? isl_stat_ok : isl_stat_error;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_domain_is_wrapping,
+		.fn_map = &isl_map_domain_factor_domain,
+	};
+	return un_op(umap, &control);
 }
 
 /* For each map in "umap" of the form [A -> B] -> C,
@@ -2085,23 +2051,11 @@ static isl_stat domain_factor_range_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_domain_factor_range(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &domain_factor_range_entry);
-}
-
-/* If "map" is of the form A -> [B -> C], then add A -> B to "res".
- */
-static isl_stat range_factor_domain_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_range_is_wrapping(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-				isl_map_range_factor_domain(isl_map_copy(map)));
-
-	return *res ? isl_stat_ok : isl_stat_error;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_domain_is_wrapping,
+		.fn_map = &isl_map_domain_factor_range,
+	};
+	return un_op(umap, &control);
 }
 
 /* For each map in "umap" of the form A -> [B -> C],
@@ -2110,23 +2064,11 @@ static isl_stat range_factor_domain_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_range_factor_domain(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &range_factor_domain_entry);
-}
-
-/* If "map" is of the form A -> [B -> C], then add A -> C to "res".
- */
-static isl_stat range_factor_range_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_range_is_wrapping(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-				isl_map_range_factor_range(isl_map_copy(map)));
-
-	return *res ? isl_stat_ok : isl_stat_error;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_range_is_wrapping,
+		.fn_map = &isl_map_range_factor_domain,
+	};
+	return un_op(umap, &control);
 }
 
 /* For each map in "umap" of the form A -> [B -> C],
@@ -2135,23 +2077,11 @@ static isl_stat range_factor_range_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_range_factor_range(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &range_factor_range_entry);
-}
-
-/* If "map" is of the form [A -> B] -> [C -> D], then add A -> C to "res".
- */
-static isl_stat factor_domain_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_domain_is_wrapping(map) || !isl_map_range_is_wrapping(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-				isl_map_factor_domain(isl_map_copy(map)));
-
-	return *res ? isl_stat_ok : isl_stat_error;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_range_is_wrapping,
+		.fn_map = &isl_map_range_factor_range,
+	};
+	return un_op(umap, &control);
 }
 
 /* For each map in "umap" of the form [A -> B] -> [C -> D],
@@ -2160,23 +2090,11 @@ static isl_stat factor_domain_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_factor_domain(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &factor_domain_entry);
-}
-
-/* If "map" is of the form [A -> B] -> [C -> D], then add B -> D to "res".
- */
-static isl_stat factor_range_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_domain_is_wrapping(map) || !isl_map_range_is_wrapping(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res,
-				isl_map_factor_range(isl_map_copy(map)));
-
-	return *res ? isl_stat_ok : isl_stat_error;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_is_product,
+		.fn_map = &isl_map_factor_domain,
+	};
+	return un_op(umap, &control);
 }
 
 /* For each map in "umap" of the form [A -> B] -> [C -> D],
@@ -2185,40 +2103,28 @@ static isl_stat factor_range_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_factor_range(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &factor_range_entry);
-}
-
-static isl_stat unwrap_entry(void **entry, void *user)
-{
-	isl_set *set = *entry;
-	isl_union_set **res = user;
-
-	if (!isl_set_is_wrapping(set))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res, isl_set_unwrap(isl_set_copy(set)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_is_product,
+		.fn_map = &isl_map_factor_range,
+	};
+	return un_op(umap, &control);
 }
 
 __isl_give isl_union_map *isl_union_set_unwrap(__isl_take isl_union_set *uset)
 {
-	return cond_un_op(uset, &unwrap_entry);
-}
-
-static isl_stat wrap_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_set **res = user;
-
-	*res = isl_union_set_add_set(*res, isl_map_wrap(isl_map_copy(map)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &isl_set_is_wrapping,
+		.fn_map = &isl_set_unwrap,
+	};
+	return un_op(uset, &control);
 }
 
 __isl_give isl_union_set *isl_union_map_wrap(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &wrap_entry);
+	struct isl_un_op_control control = {
+		.fn_map = &isl_map_wrap,
+	};
+	return un_op(umap, &control);
 }
 
 struct isl_union_map_is_subset_data {
@@ -2235,7 +2141,7 @@ static isl_stat is_subset_entry(void **entry, void *user)
 
 	hash = isl_space_get_hash(map->dim);
 	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, map->dim, 0);
+				     hash, &has_space, map->dim, 0);
 	if (!entry2) {
 		int empty = isl_map_is_empty(map);
 		if (empty < 0)
@@ -2352,7 +2258,7 @@ static isl_stat is_disjoint_entry(void **entry, void *user)
 
 	hash = isl_space_get_hash(map->dim);
 	entry2 = isl_hash_table_find(data->umap2->dim->ctx, &data->umap2->table,
-				     hash, &has_dim, map->dim, 0);
+				     hash, &has_space, map->dim, 0);
 	if (!entry2)
 		return isl_stat_ok;
 
@@ -2442,7 +2348,7 @@ error:
 
 __isl_give isl_basic_set *isl_union_set_sample(__isl_take isl_union_set *uset)
 {
-	return (isl_basic_set *)isl_union_map_sample(uset);
+	return bset_from_bmap(isl_union_map_sample(uset));
 }
 
 /* Return an element in "uset" in the form of an isl_point.
@@ -2999,35 +2905,13 @@ isl_bool isl_union_map_is_bijective(__isl_keep isl_union_map *umap)
 	return isl_union_map_is_injective(umap);
 }
 
-static isl_stat zip_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_can_zip(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res, isl_map_zip(isl_map_copy(map)));
-
-	return isl_stat_ok;
-}
-
 __isl_give isl_union_map *isl_union_map_zip(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &zip_entry);
-}
-
-static isl_stat uncurry_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_can_uncurry(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res, isl_map_uncurry(isl_map_copy(map)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_can_zip,
+		.fn_map = &isl_map_zip,
+	};
+	return un_op(umap, &control);
 }
 
 /* Given a union map, take the maps of the form A -> (B -> C) and
@@ -3035,20 +2919,11 @@ static isl_stat uncurry_entry(void **entry, void *user)
  */
 __isl_give isl_union_map *isl_union_map_uncurry(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &uncurry_entry);
-}
-
-static isl_stat curry_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_can_curry(map))
-		return isl_stat_ok;
-
-	*res = isl_union_map_add_map(*res, isl_map_curry(isl_map_copy(map)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_can_uncurry,
+		.fn_map = &isl_map_uncurry,
+	};
+	return un_op(umap, &control);
 }
 
 /* Given a union map, take the maps of the form (A -> B) -> C and
@@ -3056,24 +2931,11 @@ static isl_stat curry_entry(void **entry, void *user)
  */
 __isl_give isl_union_map *isl_union_map_curry(__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &curry_entry);
-}
-
-/* If *entry is of the form A -> ((B -> C) -> D), then apply
- * isl_map_range_curry to it and add the result to *res.
- */
-static isl_stat range_curry_entry(void **entry, void *user)
-{
-	isl_map *map = *entry;
-	isl_union_map **res = user;
-
-	if (!isl_map_can_range_curry(map))
-		return isl_stat_ok;
-
-	map = isl_map_range_curry(isl_map_copy(map));
-	*res = isl_union_map_add_map(*res, map);
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_can_curry,
+		.fn_map = &isl_map_curry,
+	};
+	return un_op(umap, &control);
 }
 
 /* Given a union map, take the maps of the form A -> ((B -> C) -> D) and
@@ -3082,22 +2944,19 @@ static isl_stat range_curry_entry(void **entry, void *user)
 __isl_give isl_union_map *isl_union_map_range_curry(
 	__isl_take isl_union_map *umap)
 {
-	return cond_un_op(umap, &range_curry_entry);
-}
-
-static isl_stat lift_entry(void **entry, void *user)
-{
-	isl_set *set = *entry;
-	isl_union_set **res = user;
-
-	*res = isl_union_set_add_set(*res, isl_set_lift(isl_set_copy(set)));
-
-	return isl_stat_ok;
+	struct isl_un_op_control control = {
+		.filter = &isl_map_can_range_curry,
+		.fn_map = &isl_map_range_curry,
+	};
+	return un_op(umap, &control);
 }
 
 __isl_give isl_union_set *isl_union_set_lift(__isl_take isl_union_set *uset)
 {
-	return cond_un_op(uset, &lift_entry);
+	struct isl_un_op_control control = {
+		.fn_map = &isl_set_lift,
+	};
+	return un_op(uset, &control);
 }
 
 static isl_stat coefficients_entry(void **entry, void *user)
@@ -3590,18 +3449,6 @@ __isl_give isl_union_set *isl_union_set_preimage_union_pw_multi_aff(
 }
 
 /* Reset the user pointer on all identifiers of parameters and tuples
- * of the space of *entry.
- */
-static isl_stat reset_user(void **entry, void *user)
-{
-	isl_map **map = (isl_map **)entry;
-
-	*map = isl_map_reset_user(*map);
-
-	return *map ? isl_stat_ok : isl_stat_error;
-}
-
-/* Reset the user pointer on all identifiers of parameters and tuples
  * of the spaces of "umap".
  */
 __isl_give isl_union_map *isl_union_map_reset_user(
@@ -3613,9 +3460,7 @@ __isl_give isl_union_map *isl_union_map_reset_user(
 	umap->dim = isl_space_reset_user(umap->dim);
 	if (!umap->dim)
 		return isl_union_map_free(umap);
-	umap = un_op(umap, &reset_user);
-
-	return umap;
+	return total(umap, &isl_map_reset_user);
 }
 
 /* Reset the user pointer on all identifiers of parameters and tuples
@@ -3627,6 +3472,24 @@ __isl_give isl_union_set *isl_union_set_reset_user(
 	return isl_union_map_reset_user(uset);
 }
 
+/* Remove all existentially quantified variables and integer divisions
+ * from "umap" using Fourier-Motzkin elimination.
+ */
+__isl_give isl_union_map *isl_union_map_remove_divs(
+	__isl_take isl_union_map *umap)
+{
+	return total(umap, &isl_map_remove_divs);
+}
+
+/* Remove all existentially quantified variables and integer divisions
+ * from "uset" using Fourier-Motzkin elimination.
+ */
+__isl_give isl_union_set *isl_union_set_remove_divs(
+	__isl_take isl_union_set *uset)
+{
+	return isl_union_map_remove_divs(uset);
+}
+
 /* Internal data structure for isl_union_map_project_out.
  * "type", "first" and "n" are the arguments for the isl_map_project_out
  * call.
@@ -3953,3 +3816,68 @@ uint32_t isl_union_set_get_hash(__isl_keep isl_union_set *uset)
 {
 	return isl_union_map_get_hash(uset);
 }
+
+/* Add the number of basic sets in "set" to "n".
+ */
+static isl_stat add_n(__isl_take isl_set *set, void *user)
+{
+	int *n = user;
+
+	*n += isl_set_n_basic_set(set);
+	isl_set_free(set);
+
+	return isl_stat_ok;
+}
+
+/* Return the total number of basic sets in "uset".
+ */
+int isl_union_set_n_basic_set(__isl_keep isl_union_set *uset)
+{
+	int n = 0;
+
+	if (isl_union_set_foreach_set(uset, &add_n, &n) < 0)
+		return -1;
+
+	return n;
+}
+
+/* Add the basic sets in "set" to "list".
+ */
+static isl_stat add_list(__isl_take isl_set *set, void *user)
+{
+	isl_basic_set_list **list = user;
+	isl_basic_set_list *list_i;
+
+	list_i = isl_set_get_basic_set_list(set);
+	*list = isl_basic_set_list_concat(*list, list_i);
+	isl_set_free(set);
+
+	if (!*list)
+		return isl_stat_error;
+	return isl_stat_ok;
+}
+
+/* Return a list containing all the basic sets in "uset".
+ *
+ * First construct a list of the appropriate size and
+ * then add all the elements.
+ */
+__isl_give isl_basic_set_list *isl_union_set_get_basic_set_list(
+	__isl_keep isl_union_set *uset)
+{
+	int n;
+	isl_ctx *ctx;
+	isl_basic_set_list *list;
+
+	if (!uset)
+		return NULL;
+	ctx = isl_union_set_get_ctx(uset);
+	n = isl_union_set_n_basic_set(uset);
+	if (n < 0)
+		return NULL;
+	list = isl_basic_set_list_alloc(ctx, n);
+	if (isl_union_set_foreach_set(uset, &add_list, &list) < 0)
+		list = isl_basic_set_list_free(list);
+
+	return list;
+}
diff --git a/lib/Analysis/isl/isl_union_map_private.h b/lib/Analysis/isl/isl_union_map_private.h
index 5cd2783..1edd760 100644
--- a/lib/Analysis/isl/isl_union_map_private.h
+++ b/lib/Analysis/isl/isl_union_map_private.h
@@ -10,5 +10,7 @@ struct isl_union_map {
 	struct isl_hash_table	table;
 };
 
+isl_bool isl_union_map_space_has_equal_params(__isl_keep isl_union_map *umap,
+	__isl_keep isl_space *space);
 __isl_give isl_union_map *isl_union_map_reset_range_space(
 	__isl_take isl_union_map *umap, __isl_take isl_space *space);
diff --git a/lib/Analysis/isl/isl_union_set_private.h b/lib/Analysis/isl/isl_union_set_private.h
new file mode 100644
index 0000000..32a7073
--- /dev/null
+++ b/lib/Analysis/isl/isl_union_set_private.h
@@ -0,0 +1,11 @@
+#ifndef ISL_UNION_SET_PRIVATE_H
+#define ISL_UNION_SET_PRIVATE_H
+
+#include <isl/union_set.h>
+
+__isl_give isl_union_set *isl_union_set_combined_lineality_space(
+	__isl_take isl_union_set *uset);
+__isl_give isl_union_set *isl_union_set_plain_gist(
+	__isl_take isl_union_set *uset, __isl_take isl_union_set *context);
+
+#endif
diff --git a/lib/Analysis/isl/isl_union_templ.c b/lib/Analysis/isl/isl_union_templ.c
index 66bbd2b..85f0570 100644
--- a/lib/Analysis/isl/isl_union_templ.c
+++ b/lib/Analysis/isl/isl_union_templ.c
@@ -112,10 +112,14 @@ __isl_give PART *FN(FN(UNION,extract),PARTS)(__isl_keep UNION *u,
 	__isl_take isl_space *space)
 {
 	struct isl_hash_table_entry *entry;
+	isl_bool equal_params;
 
 	if (!u || !space)
 		goto error;
-	if (!isl_space_match(u->space, isl_dim_param, space, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(u->space, space);
+	if (equal_params < 0)
+		goto error;
+	if (!equal_params) {
 		space = isl_space_drop_dims(space, isl_dim_param,
 					0, isl_space_dim(space, isl_dim_param));
 		space = isl_space_align_params(space,
@@ -413,12 +417,16 @@ error:
 __isl_give UNION *FN(UNION,align_params)(__isl_take UNION *u,
 	__isl_take isl_space *model)
 {
+	isl_bool equal_params;
 	isl_reordering *r;
 
 	if (!u || !model)
 		goto error;
 
-	if (isl_space_match(u->space, isl_dim_param, model, isl_dim_param)) {
+	equal_params = isl_space_has_equal_params(u->space, model);
+	if (equal_params < 0)
+		goto error;
+	if (equal_params) {
 		isl_space_free(model);
 		return u;
 	}
@@ -1055,6 +1063,39 @@ error:
 	return isl_bool_error;
 }
 
+/* Check whether the element that "entry" points to involves any NaNs and
+ * store the result in *nan.
+ * Abort as soon as one such element has been found.
+ */
+static isl_stat FN(UNION,involves_nan_entry)(void **entry, void *user)
+{
+	isl_bool *nan = user;
+	PW *pw = *entry;
+
+	*nan = FN(PW,involves_nan)(pw);
+	if (*nan < 0 || !nan)
+		return isl_stat_error;
+
+	return isl_stat_ok;
+}
+
+/* Does "u" involve any NaNs?
+ */
+isl_bool FN(UNION,involves_nan)(__isl_keep UNION *u)
+{
+	isl_bool nan = isl_bool_false;
+
+	if (!u)
+		return isl_bool_error;
+
+	if (FN(UNION,foreach_inplace)(u,
+				    &FN(UNION,involves_nan_entry), &nan) < 0 &&
+	    !nan)
+		return isl_bool_error;
+
+	return nan;
+}
+
 /* Internal data structure for isl_union_*_drop_dims.
  * type, first and n are passed to isl_*_drop_dims.
  */
diff --git a/lib/Analysis/isl/isl_val.c b/lib/Analysis/isl/isl_val.c
index 6a62a33..b2a98fa 100644
--- a/lib/Analysis/isl/isl_val.c
+++ b/lib/Analysis/isl/isl_val.c
@@ -916,6 +916,31 @@ error:
 }
 
 /* Divide "v1" by "v2".
+ */
+__isl_give isl_val *isl_val_div_ui(__isl_take isl_val *v1, unsigned long v2)
+{
+	if (!v1)
+		return NULL;
+	if (isl_val_is_nan(v1))
+		return v1;
+	if (v2 == 0)
+		return isl_val_set_nan(v1);
+	if (v2 == 1)
+		return v1;
+	if (isl_val_is_zero(v1))
+		return v1;
+	if (isl_val_is_infty(v1) || isl_val_is_neginfty(v1))
+		return v1;
+	v1 = isl_val_cow(v1);
+	if (!v1)
+		return NULL;
+
+	isl_int_mul_ui(v1->d, v1->d, v2);
+
+	return isl_val_normalize(v1);
+}
+
+/* Divide "v1" by "v2".
  *
  * This is a private copy of isl_val_div for use in the generic
  * isl_multi_*_scale_down_val instantiated for isl_val.
@@ -1170,6 +1195,9 @@ isl_bool isl_val_is_one(__isl_keep isl_val *v)
 	if (!v)
 		return isl_bool_error;
 
+	if (isl_val_is_nan(v))
+		return isl_bool_false;
+
 	return isl_int_eq(v->n, v->d);
 }
 
@@ -1578,32 +1606,33 @@ __isl_give isl_val *isl_val_zero_on_domain(__isl_take isl_local_space *ls)
  * This function is only meant to be used in the generic isl_multi_*
  * functions which have to deal with base objects that have an associated
  * space.  Since an isl_val does not have an associated space, this function
- * simply returns 1, except if "v" or "space" are NULL.
+ * simply returns true, except if "v" or "space" are NULL.
  */
-int isl_val_matching_params(__isl_keep isl_val *v, __isl_keep isl_space *space)
+isl_bool isl_val_matching_params(__isl_keep isl_val *v,
+	__isl_keep isl_space *space)
 {
 	if (!v || !space)
-		return -1;
-	return 1;
+		return isl_bool_error;
+	return isl_bool_true;
 }
 
 /* Check that the domain space of "v" matches "space".
  *
- * Return 0 on success and -1 on error.
- *
  * This function is only meant to be used in the generic isl_multi_*
  * functions which have to deal with base objects that have an associated
  * space.  Since an isl_val does not have an associated space, this function
  * simply returns 0, except if "v" or "space" are NULL.
  */
-int isl_val_check_match_domain_space(__isl_keep isl_val *v,
+isl_stat isl_val_check_match_domain_space(__isl_keep isl_val *v,
 	__isl_keep isl_space *space)
 {
 	if (!v || !space)
-		return -1;
-	return 0;
+		return isl_stat_error;
+	return isl_stat_ok;
 }
 
+#define isl_val_involves_nan isl_val_is_nan
+
 #undef BASE
 #define BASE val
 
diff --git a/lib/Analysis/isl/isl_val_private.h b/lib/Analysis/isl/isl_val_private.h
index ec1076d..4276ddb 100644
--- a/lib/Analysis/isl/isl_val_private.h
+++ b/lib/Analysis/isl/isl_val_private.h
@@ -34,6 +34,8 @@ __isl_give isl_val *isl_val_rat_from_isl_int(isl_ctx *ctx,
 	isl_int n, isl_int d);
 __isl_give isl_val *isl_val_cow(__isl_take isl_val *val);
 
+int isl_val_get_num_isl_int(__isl_keep isl_val *v, isl_int *n);
+
 int isl_val_involves_dims(__isl_keep isl_val *v, enum isl_dim_type type,
 	unsigned first, unsigned n);
 __isl_give isl_val *isl_val_insert_dims(__isl_take isl_val *v,
@@ -60,8 +62,9 @@ __isl_give isl_val *isl_val_mod_val(__isl_take isl_val *v1,
 
 int isl_val_plain_is_equal(__isl_keep isl_val *val1, __isl_keep isl_val *val2);
 
-int isl_val_matching_params(__isl_keep isl_val *v, __isl_keep isl_space *space);
-int isl_val_check_match_domain_space(__isl_keep isl_val *v,
+isl_bool isl_val_matching_params(__isl_keep isl_val *v,
+	__isl_keep isl_space *space);
+isl_stat isl_val_check_match_domain_space(__isl_keep isl_val *v,
 	__isl_keep isl_space *space);
 
 #undef BASE
diff --git a/lib/Analysis/isl/isl_vec.c b/lib/Analysis/isl/isl_vec.c
index 2b49a81..a48abf9 100644
--- a/lib/Analysis/isl/isl_vec.c
+++ b/lib/Analysis/isl/isl_vec.c
@@ -30,7 +30,7 @@ uint32_t isl_vec_get_hash(__isl_keep isl_vec *vec)
 	return isl_seq_get_hash(vec->el, vec->size);
 }
 
-struct isl_vec *isl_vec_alloc(struct isl_ctx *ctx, unsigned size)
+__isl_give isl_vec *isl_vec_alloc(struct isl_ctx *ctx, unsigned size)
 {
 	struct isl_vec *vec;
 
@@ -94,7 +94,7 @@ __isl_give isl_vec *isl_vec_expand(__isl_take isl_vec *vec, int pos, int n,
 		return NULL;
 	if (expanded < n)
 		isl_die(isl_vec_get_ctx(vec), isl_error_invalid,
-			"not an expansion", isl_vec_free(vec));
+			"not an expansion", return isl_vec_free(vec));
 	if (expanded == n)
 		return vec;
 	if (pos < 0 || n < 0 || pos + n > vec->size)
@@ -328,6 +328,15 @@ int isl_vec_cmp_element(__isl_keep isl_vec *vec1, __isl_keep isl_vec *vec2,
 	return isl_int_cmp(vec1->el[pos], vec2->el[pos]);
 }
 
+/* Does "vec" contain only zero elements?
+ */
+isl_bool isl_vec_is_zero(__isl_keep isl_vec *vec)
+{
+	if (!vec)
+		return isl_bool_error;
+	return isl_seq_first_non_zero(vec->el, vec->size) < 0;
+}
+
 isl_bool isl_vec_is_equal(__isl_keep isl_vec *vec1, __isl_keep isl_vec *vec2)
 {
 	if (!vec1 || !vec2)
@@ -430,7 +439,7 @@ void isl_vec_lcm(struct isl_vec *vec, isl_int *lcm)
 /* Given a rational vector, with the denominator in the first element
  * of the vector, round up all coordinates.
  */
-struct isl_vec *isl_vec_ceil(struct isl_vec *vec)
+__isl_give isl_vec *isl_vec_ceil(__isl_take isl_vec *vec)
 {
 	vec = isl_vec_cow(vec);
 	if (!vec)
diff --git a/lib/Analysis/isl/isl_vec_private.h b/lib/Analysis/isl/isl_vec_private.h
index c02267c..8f6de86 100644
--- a/lib/Analysis/isl/isl_vec_private.h
+++ b/lib/Analysis/isl/isl_vec_private.h
@@ -23,6 +23,8 @@ void isl_vec_lcm(struct isl_vec *vec, isl_int *lcm);
 int isl_vec_get_element(__isl_keep isl_vec *vec, int pos, isl_int *v);
 __isl_give isl_vec *isl_vec_set(__isl_take isl_vec *vec, isl_int v);
 
+isl_bool isl_vec_is_zero(__isl_keep isl_vec *vec);
+
 __isl_give isl_vec *isl_vec_expand(__isl_take isl_vec *vec, int pos, int n,
 	int *exp, int expanded);
 
diff --git a/lib/Analysis/isl/isl_vertices.c b/lib/Analysis/isl/isl_vertices.c
index 6e74a4f..f70e410 100644
--- a/lib/Analysis/isl/isl_vertices.c
+++ b/lib/Analysis/isl/isl_vertices.c
@@ -35,15 +35,15 @@ __isl_give isl_vertices *isl_vertices_copy(__isl_keep isl_vertices *vertices)
 	return vertices;
 }
 
-void isl_vertices_free(__isl_take isl_vertices *vertices)
+__isl_null isl_vertices *isl_vertices_free(__isl_take isl_vertices *vertices)
 {
 	int i;
 
 	if (!vertices)
-		return;
+		return NULL;
 
 	if (--vertices->ref > 0)
-		return;
+		return NULL;
 
 	for (i = 0; i < vertices->n_vertices; ++i) {
 		isl_basic_set_free(vertices->v[i].vertex);
@@ -59,6 +59,8 @@ void isl_vertices_free(__isl_take isl_vertices *vertices)
 
 	isl_basic_set_free(vertices->bset);
 	free(vertices);
+
+	return NULL;
 }
 
 struct isl_vertex_list {
@@ -66,7 +68,7 @@ struct isl_vertex_list {
 	struct isl_vertex_list *next;
 };
 
-static void free_vertex_list(struct isl_vertex_list *list)
+static struct isl_vertex_list *free_vertex_list(struct isl_vertex_list *list)
 {
 	struct isl_vertex_list *next;
 
@@ -76,6 +78,8 @@ static void free_vertex_list(struct isl_vertex_list *list)
 		isl_basic_set_free(list->v.dom);
 		free(list);
 	}
+
+	return NULL;
 }
 
 static __isl_give isl_vertices *vertices_from_list(__isl_keep isl_basic_set *bset,
@@ -109,15 +113,20 @@ error:
 }
 
 /* Prepend a vertex to the linked list "list" based on the equalities in "tab".
+ * Return isl_bool_true if the vertex was actually added and
+ * isl_bool_false otherwise.
+ * In particular, vertices with a lower-dimensional activity domain are
+ * not added to the list because they would not be included in any chamber.
+ * Return isl_bool_error on error.
  */
-static int add_vertex(struct isl_vertex_list **list,
+static isl_bool add_vertex(struct isl_vertex_list **list,
 	__isl_keep isl_basic_set *bset, struct isl_tab *tab)
 {
 	unsigned nvar;
 	struct isl_vertex_list *v = NULL;
 
 	if (isl_tab_detect_implicit_equalities(tab) < 0)
-		return -1;
+		return isl_bool_error;
 
 	nvar = isl_basic_set_dim(bset, isl_dim_set);
 
@@ -138,13 +147,18 @@ static int add_vertex(struct isl_vertex_list **list,
 	if (!v->v.dom)
 		goto error;
 
+	if (v->v.dom->n_eq > 0) {
+		free_vertex_list(v);
+		return isl_bool_false;
+	}
+
 	v->next = *list;
 	*list = v;
 
-	return 0;
+	return isl_bool_true;
 error:
 	free_vertex_list(v);
-	return -1;
+	return isl_bool_error;
 }
 
 /* Compute the parametric vertices and the chamber decomposition
@@ -262,7 +276,7 @@ static int is_independent(__isl_keep isl_mat *facets, int n, isl_int *f)
  *
  * If the constraint is (strictly) redundant in the tableau, selecting it would
  * result in an empty tableau, so it can't be selected.
- * If the set variable part of the constraint is not linearly indepedent
+ * If the set variable part of the constraint is not linearly independent
  * of the set variable parts of the already selected constraints,
  * the constraint cannot be selected.
  * If selecting the constraint results in an empty tableau, the constraint
@@ -466,9 +480,11 @@ __isl_give isl_vertices *isl_basic_set_compute_vertices(
 		}
 		if (selected == nvar) {
 			if (tab->n_dead == nvar) {
-				if (add_vertex(&list, bset, tab) < 0)
+				isl_bool added = add_vertex(&list, bset, tab);
+				if (added < 0)
 					goto error;
-				n_vertices++;
+				if (added)
+					n_vertices++;
 			}
 			init = 0;
 			continue;
@@ -518,23 +534,24 @@ static void free_chamber_list(struct isl_chamber_list *list)
 /* Check whether the basic set "bset" is a superset of the basic set described
  * by "tab", i.e., check whether all constraints of "bset" are redundant.
  */
-static int bset_covers_tab(__isl_keep isl_basic_set *bset, struct isl_tab *tab)
+static isl_bool bset_covers_tab(__isl_keep isl_basic_set *bset,
+	struct isl_tab *tab)
 {
 	int i;
 
 	if (!bset || !tab)
-		return -1;
+		return isl_bool_error;
 
 	for (i = 0; i < bset->n_ineq; ++i) {
 		enum isl_ineq_type type = isl_tab_ineq_type(tab, bset->ineq[i]);
 		switch (type) {
-		case isl_ineq_error:		return -1;
+		case isl_ineq_error:		return isl_bool_error;
 		case isl_ineq_redundant:	continue;
-		default:			return 0;
+		default:			return isl_bool_false;
 		}
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
 static __isl_give isl_vertices *vertices_add_chambers(
@@ -566,14 +583,21 @@ error:
 
 /* Can "tab" be intersected with "bset" without resulting in
  * a lower-dimensional set.
+ * "bset" itself is assumed to be full-dimensional.
  */
-static int can_intersect(struct isl_tab *tab, __isl_keep isl_basic_set *bset)
+static isl_bool can_intersect(struct isl_tab *tab,
+	__isl_keep isl_basic_set *bset)
 {
 	int i;
 	struct isl_tab_undo *snap;
 
+	if (bset->n_eq > 0)
+		isl_die(isl_basic_set_get_ctx(bset), isl_error_internal,
+			"expecting full-dimensional input",
+			return isl_bool_error);
+
 	if (isl_tab_extend_cons(tab, bset->n_ineq) < 0)
-		return -1;
+		return isl_bool_error;
 
 	snap = isl_tab_snap(tab);
 
@@ -581,18 +605,18 @@ static int can_intersect(struct isl_tab *tab, __isl_keep isl_basic_set *bset)
 		if (isl_tab_ineq_type(tab, bset->ineq[i]) == isl_ineq_redundant)
 			continue;
 		if (isl_tab_add_ineq(tab, bset->ineq[i]) < 0)
-			return -1;
+			return isl_bool_error;
 	}
 
 	if (isl_tab_detect_implicit_equalities(tab) < 0)
-		return -1;
+		return isl_bool_error;
 	if (tab->n_dead) {
 		if (isl_tab_rollback(tab, snap) < 0)
-			return -1;
-		return 0;
+			return isl_bool_error;
+		return isl_bool_false;
 	}
 
-	return 1;
+	return isl_bool_true;
 }
 
 static int add_chamber(struct isl_chamber_list **list,
@@ -840,7 +864,7 @@ static int update_todo(struct isl_facet_todo *first, struct isl_tab *tab)
  * set.  As a minor optimization, we only consider those activity domains
  * that contain some arbitrary point.
  *
- * For each of interior facets of the chamber, we construct a todo item,
+ * For each of the interior facets of the chamber, we construct a todo item,
  * containing the facet and a constraint containing the other side of the facet,
  * for constructing the chamber on the other side.
  * While their are any todo items left, we pick a todo item and
@@ -979,23 +1003,6 @@ int isl_vertex_get_id(__isl_keep isl_vertex *vertex)
 	return vertex ? vertex->id : -1;
 }
 
-__isl_give isl_basic_set *isl_basic_set_set_integral(__isl_take isl_basic_set *bset)
-{
-	if (!bset)
-		return NULL;
-
-	if (!ISL_F_ISSET(bset, ISL_BASIC_MAP_RATIONAL))
-		return bset;
-
-	bset = isl_basic_set_cow(bset);
-	if (!bset)
-		return NULL;
-
-	ISL_F_CLR(bset, ISL_BASIC_MAP_RATIONAL);
-
-	return isl_basic_set_finalize(bset);
-}
-
 /* Return the activity domain of the vertex "vertex".
  */
 __isl_give isl_basic_set *isl_vertex_get_domain(__isl_keep isl_vertex *vertex)
@@ -1126,7 +1133,7 @@ static struct isl_tab *tab_for_shifted_cone(__isl_keep isl_basic_set *bset)
 
 	if (!bset)
 		return NULL;
-	tab = isl_tab_alloc(bset->ctx, bset->n_ineq + 1,
+	tab = isl_tab_alloc(bset->ctx, bset->n_eq + bset->n_ineq + 1,
 			    1 + isl_basic_set_total_dim(bset), 0);
 	if (!tab)
 		return NULL;
@@ -1198,49 +1205,41 @@ static __isl_give isl_vec *isl_basic_set_interior_point(
  *
  * We pick an interior point from one of the chambers and then make
  * all constraints that do not satisfy this point strict.
+ * For constraints that saturate the interior point, the sign
+ * of the first non-zero coefficient is used to determine which
+ * of the two (internal) constraints should be tightened.
  */
-int isl_vertices_foreach_disjoint_cell(__isl_keep isl_vertices *vertices,
-	int (*fn)(__isl_take isl_cell *cell, void *user), void *user)
+isl_stat isl_vertices_foreach_disjoint_cell(__isl_keep isl_vertices *vertices,
+	isl_stat (*fn)(__isl_take isl_cell *cell, void *user), void *user)
 {
-	int i, j;
+	int i;
 	isl_vec *vec;
-	isl_int v;
 	isl_cell *cell;
 
 	if (!vertices)
-		return -1;
+		return isl_stat_error;
 
 	if (vertices->n_chambers == 0)
-		return 0;
+		return isl_stat_ok;
 
 	if (vertices->n_chambers == 1) {
 		isl_basic_set *dom = isl_basic_set_copy(vertices->c[0].dom);
 		dom = isl_basic_set_set_integral(dom);
 		cell = isl_cell_alloc(isl_vertices_copy(vertices), dom, 0);
 		if (!cell)
-			return -1;
+			return isl_stat_error;
 		return fn(cell, user);
 	}
 
 	vec = isl_basic_set_interior_point(vertices->c[0].dom);
 	if (!vec)
-		return -1;
-
-	isl_int_init(v);
+		return isl_stat_error;
 
 	for (i = 0; i < vertices->n_chambers; ++i) {
 		int r;
 		isl_basic_set *dom = isl_basic_set_copy(vertices->c[i].dom);
-		dom = isl_basic_set_cow(dom);
-		if (!dom)
-			goto error;
-		for (j = 0; i && j < dom->n_ineq; ++j) {
-			isl_seq_inner_product(vec->el, dom->ineq[j], vec->size,
-						&v);
-			if (!isl_int_is_neg(v))
-				continue;
-			isl_int_sub_ui(dom->ineq[j][0], dom->ineq[j][0], 1);
-		}
+		if (i)
+			dom = isl_basic_set_tighten_outward(dom, vec);
 		dom = isl_basic_set_set_integral(dom);
 		cell = isl_cell_alloc(isl_vertices_copy(vertices), dom, i);
 		if (!cell)
@@ -1250,14 +1249,12 @@ int isl_vertices_foreach_disjoint_cell(__isl_keep isl_vertices *vertices,
 			goto error;
 	}
 
-	isl_int_clear(v);
 	isl_vec_free(vec);
 
-	return 0;
+	return isl_stat_ok;
 error:
-	isl_int_clear(v);
 	isl_vec_free(vec);
-	return -1;
+	return isl_stat_error;
 }
 
 isl_stat isl_vertices_foreach_cell(__isl_keep isl_vertices *vertices,
@@ -1397,9 +1394,9 @@ error:
 /* Construct a simplex isl_cell spanned by the vertices with indices in
  * "simplex_ids" and "other_ids" and call "fn" on this isl_cell.
  */
-static int call_on_simplex(__isl_keep isl_cell *cell,
+static isl_stat call_on_simplex(__isl_keep isl_cell *cell,
 	int *simplex_ids, int n_simplex, int *other_ids, int n_other,
-	int (*fn)(__isl_take isl_cell *simplex, void *user), void *user)
+	isl_stat (*fn)(__isl_take isl_cell *simplex, void *user), void *user)
 {
 	int i;
 	isl_ctx *ctx;
@@ -1409,7 +1406,7 @@ static int call_on_simplex(__isl_keep isl_cell *cell,
 
 	simplex = isl_calloc_type(ctx, struct isl_cell);
 	if (!simplex)
-		return -1;
+		return isl_stat_error;
 	simplex->vertices = isl_vertices_copy(cell->vertices);
 	if (!simplex->vertices)
 		goto error;
@@ -1429,7 +1426,7 @@ static int call_on_simplex(__isl_keep isl_cell *cell,
 	return fn(simplex, user);
 error:
 	isl_cell_free(simplex);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Check whether the parametric vertex described by "vertex"
@@ -1472,9 +1469,9 @@ static int vertex_on_facet(__isl_keep isl_basic_set *vertex,
  * and call ourselves recursively on the polytope spanned by the new
  * "simplex_ids" and those points in "other_ids" that lie on the facet.
  */
-static int triangulate(__isl_keep isl_cell *cell, __isl_keep isl_vec *v,
+static isl_stat triangulate(__isl_keep isl_cell *cell, __isl_keep isl_vec *v,
 	int *simplex_ids, int n_simplex, int *other_ids, int n_other,
-	int (*fn)(__isl_take isl_cell *simplex, void *user), void *user)
+	isl_stat (*fn)(__isl_take isl_cell *simplex, void *user), void *user)
 {
 	int i, j, k;
 	int d, nparam;
@@ -1496,6 +1493,8 @@ static int triangulate(__isl_keep isl_cell *cell, __isl_keep isl_vec *v,
 	bset = cell->vertices->bset;
 
 	ids = isl_alloc_array(ctx, int, n_other - 1);
+	if (!ids)
+		goto error;
 	for (i = 0; i < bset->n_ineq; ++i) {
 		if (isl_seq_first_non_zero(bset->ineq[i] + 1 + nparam, d) == -1)
 			continue;
@@ -1517,17 +1516,17 @@ static int triangulate(__isl_keep isl_cell *cell, __isl_keep isl_vec *v,
 	}
 	free(ids);
 
-	return 0;
+	return isl_stat_ok;
 error:
 	free(ids);
-	return -1;
+	return isl_stat_error;
 }
 
 /* Triangulate the given cell and call "fn" on each of the resulting
  * simplices.
  */
-int isl_cell_foreach_simplex(__isl_take isl_cell *cell,
-	int (*fn)(__isl_take isl_cell *simplex, void *user), void *user)
+isl_stat isl_cell_foreach_simplex(__isl_take isl_cell *cell,
+	isl_stat (*fn)(__isl_take isl_cell *simplex, void *user), void *user)
 {
 	int d, total;
 	int r;
@@ -1536,7 +1535,7 @@ int isl_cell_foreach_simplex(__isl_take isl_cell *cell,
 	int *simplex_ids = NULL;
 
 	if (!cell)
-		return -1;
+		return isl_stat_error;
 
 	d = isl_basic_set_dim(cell->vertices->bset, isl_dim_set);
 	total = isl_basic_set_total_dim(cell->vertices->bset);
@@ -1566,5 +1565,5 @@ error:
 	free(simplex_ids);
 	isl_vec_free(v);
 	isl_cell_free(cell);
-	return -1;
+	return isl_stat_error;
 }
diff --git a/lib/Analysis/isl/isl_vertices_private.h b/lib/Analysis/isl/isl_vertices_private.h
index 7c707fd..37e6407 100644
--- a/lib/Analysis/isl/isl_vertices_private.h
+++ b/lib/Analysis/isl/isl_vertices_private.h
@@ -1,3 +1,6 @@
+#ifndef ISL_VERTICES_PRIVATE_H
+#define ISL_VERTICES_PRIVATE_H
+
 #include <isl/set.h>
 #include <isl/vertices.h>
 
@@ -11,6 +14,8 @@ struct isl_morph;
  * of the vertex as a singleton parametric set.  "dom" is the projection
  * of "vertex" onto the parameter space, i.e., the activity domain
  * of the vertex.
+ * During the construction of vertices and chambers, the activity domain
+ * of every parametric vertex is full-dimensional.
  */
 struct isl_vertex {
 	isl_basic_set *dom;
@@ -51,10 +56,10 @@ struct isl_external_vertex {
 	int id;
 };
 
-int isl_vertices_foreach_disjoint_cell(__isl_keep isl_vertices *vertices,
-	int (*fn)(__isl_take isl_cell *cell, void *user), void *user);
-int isl_cell_foreach_simplex(__isl_take isl_cell *cell,
-	int (*fn)(__isl_take isl_cell *simplex, void *user), void *user);
+isl_stat isl_vertices_foreach_disjoint_cell(__isl_keep isl_vertices *vertices,
+	isl_stat (*fn)(__isl_take isl_cell *cell, void *user), void *user);
+isl_stat isl_cell_foreach_simplex(__isl_take isl_cell *cell,
+	isl_stat (*fn)(__isl_take isl_cell *simplex, void *user), void *user);
 
 __isl_give isl_vertices *isl_morph_vertices(__isl_take struct isl_morph *morph,
 	__isl_take isl_vertices *vertices);
@@ -62,3 +67,5 @@ __isl_give isl_vertices *isl_morph_vertices(__isl_take struct isl_morph *morph,
 #if defined(__cplusplus)
 }
 #endif
+
+#endif
diff --git a/lib/Analysis/isl/ltmain.sh b/lib/Analysis/isl/ltmain.sh
index bffda54..2ad8be8 100644
--- a/lib/Analysis/isl/ltmain.sh
+++ b/lib/Analysis/isl/ltmain.sh
@@ -1,9 +1,12 @@
+#! /bin/sh
+## DO NOT EDIT - This file generated from ./build-aux/ltmain.in
+##               by inline-source v2014-01-03.01
 
-# libtool (GNU libtool) 2.4.2
+# libtool (GNU libtool) 2.4.6
+# Provide generalized library-building support services.
 # Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,
-# 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+# Copyright (C) 1996-2015 Free Software Foundation, Inc.
 # This is free software; see the source for copying conditions.  There is NO
 # warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
@@ -23,881 +26,2112 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with GNU Libtool; see the file COPYING.  If not, a copy
-# can be downloaded from http://www.gnu.org/licenses/gpl.html,
-# or obtained by writing to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-# Usage: $progname [OPTION]... [MODE-ARG]...
-#
-# Provide generalized library-building support services.
-#
-#       --config             show all configuration variables
-#       --debug              enable verbose shell tracing
-#   -n, --dry-run            display commands without modifying any files
-#       --features           display basic configuration information and exit
-#       --mode=MODE          use operation mode MODE
-#       --preserve-dup-deps  don't remove duplicate dependency libraries
-#       --quiet, --silent    don't print informational messages
-#       --no-quiet, --no-silent
-#                            print informational messages (default)
-#       --no-warn            don't display warning messages
-#       --tag=TAG            use configuration variables from tag TAG
-#   -v, --verbose            print more informational messages than default
-#       --no-verbose         don't print the extra informational messages
-#       --version            print version information
-#   -h, --help, --help-all   print short, long, or detailed help message
-#
-# MODE must be one of the following:
-#
-#         clean              remove files from the build directory
-#         compile            compile a source file into a libtool object
-#         execute            automatically set library path, then run a program
-#         finish             complete the installation of libtool libraries
-#         install            install libraries or executables
-#         link               create a library or an executable
-#         uninstall          remove libraries from an installed directory
-#
-# MODE-ARGS vary depending on the MODE.  When passed as first option,
-# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.
-# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
-#
-# When reporting a bug, please describe a test case to reproduce it and
-# include the following information:
-#
-#         host-triplet:	$host
-#         shell:		$SHELL
-#         compiler:		$LTCC
-#         compiler flags:		$LTCFLAGS
-#         linker:		$LD (gnu? $with_gnu_ld)
-#         $progname:	(GNU libtool) 2.4.2 Debian-2.4.2-1.11
-#         automake:	$automake_version
-#         autoconf:	$autoconf_version
-#
-# Report bugs to <bug-libtool@gnu.org>.
-# GNU libtool home page: <http://www.gnu.org/software/libtool/>.
-# General help using GNU software: <http://www.gnu.org/gethelp/>.
 
 PROGRAM=libtool
 PACKAGE=libtool
-VERSION="2.4.2 Debian-2.4.2-1.11"
-TIMESTAMP=""
-package_revision=1.3337
+VERSION="2.4.6 Debian-2.4.6-1"
+package_revision=2.4.6
 
-# Be Bourne compatible
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+
+## ------ ##
+## Usage. ##
+## ------ ##
+
+# Run './libtool --help' for help with using this script from the
+# command line.
+
+
+## ------------------------------- ##
+## User overridable command paths. ##
+## ------------------------------- ##
+
+# After configure completes, it has a better idea of some of the
+# shell tools we need than the defaults used by the functions shared
+# with bootstrap, so set those here where they can still be over-
+# ridden by the user, but otherwise take precedence.
+
+: ${AUTOCONF="autoconf"}
+: ${AUTOMAKE="automake"}
+
+
+## -------------------------- ##
+## Source external libraries. ##
+## -------------------------- ##
+
+# Much of our low-level functionality needs to be sourced from external
+# libraries, which are installed to $pkgauxdir.
+
+# Set a version string for this script.
+scriptversion=2015-01-20.17; # UTC
+
+# General shell script boiler plate, and helper functions.
+# Written by Gary V. Vaughan, 2004
+
+# Copyright (C) 2004-2015 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+
+# As a special exception to the GNU General Public License, if you distribute
+# this file as part of a program or library that is built using GNU Libtool,
+# you may include this file under the same distribution terms that you use
+# for the rest of that program.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNES FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+# Please report bugs or propose patches to gary@gnu.org.
+
+
+## ------ ##
+## Usage. ##
+## ------ ##
+
+# Evaluate this file near the top of your script to gain access to
+# the functions and variables defined here:
+#
+#   . `echo "$0" | ${SED-sed} 's|[^/]*$||'`/build-aux/funclib.sh
+#
+# If you need to override any of the default environment variable
+# settings, do that before evaluating this file.
+
+
+## -------------------- ##
+## Shell normalisation. ##
+## -------------------- ##
+
+# Some shells need a little help to be as Bourne compatible as possible.
+# Before doing anything else, make sure all that help has been provided!
+
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
   NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
 else
-  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix ;; esac
 fi
-BIN_SH=xpg4; export BIN_SH # for Tru64
-DUALCASE=1; export DUALCASE # for MKS sh
-
-# A function that is used when there is no print builtin or printf.
-func_fallback_echo ()
-{
-  eval 'cat <<_LTECHO_EOF
-$1
-_LTECHO_EOF'
-}
 
-# NLS nuisances: We save the old values to restore during execute mode.
-lt_user_locale=
-lt_safe_locale=
-for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+# NLS nuisances: We save the old values in case they are required later.
+_G_user_locale=
+_G_safe_locale=
+for _G_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
 do
-  eval "if test \"\${$lt_var+set}\" = set; then
-          save_$lt_var=\$$lt_var
-          $lt_var=C
-	  export $lt_var
-	  lt_user_locale=\"$lt_var=\\\$save_\$lt_var; \$lt_user_locale\"
-	  lt_safe_locale=\"$lt_var=C; \$lt_safe_locale\"
+  eval "if test set = \"\${$_G_var+set}\"; then
+          save_$_G_var=\$$_G_var
+          $_G_var=C
+	  export $_G_var
+	  _G_user_locale=\"$_G_var=\\\$save_\$_G_var; \$_G_user_locale\"
+	  _G_safe_locale=\"$_G_var=C; \$_G_safe_locale\"
 	fi"
 done
-LC_ALL=C
-LANGUAGE=C
-export LANGUAGE LC_ALL
 
-$lt_unset CDPATH
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# Make sure IFS has a sensible default
+sp=' '
+nl='
+'
+IFS="$sp	$nl"
+
+# There are apparently some retarded systems that use ';' as a PATH separator!
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
 
-# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
-# is ksh but when the shell is invoked as "sh" and the current value of
-# the _XPG environment variable is not equal to 1 (one), the special
-# positional parameter $0, within a function call, is the name of the
-# function.
-progpath="$0"
 
 
+## ------------------------- ##
+## Locate command utilities. ##
+## ------------------------- ##
+
+
+# func_executable_p FILE
+# ----------------------
+# Check that FILE is an executable regular file.
+func_executable_p ()
+{
+    test -f "$1" && test -x "$1"
+}
+
+
+# func_path_progs PROGS_LIST CHECK_FUNC [PATH]
+# --------------------------------------------
+# Search for either a program that responds to --version with output
+# containing "GNU", or else returned by CHECK_FUNC otherwise, by
+# trying all the directories in PATH with each of the elements of
+# PROGS_LIST.
+#
+# CHECK_FUNC should accept the path to a candidate program, and
+# set $func_check_prog_result if it truncates its output less than
+# $_G_path_prog_max characters.
+func_path_progs ()
+{
+    _G_progs_list=$1
+    _G_check_func=$2
+    _G_PATH=${3-"$PATH"}
+
+    _G_path_prog_max=0
+    _G_path_prog_found=false
+    _G_save_IFS=$IFS; IFS=${PATH_SEPARATOR-:}
+    for _G_dir in $_G_PATH; do
+      IFS=$_G_save_IFS
+      test -z "$_G_dir" && _G_dir=.
+      for _G_prog_name in $_G_progs_list; do
+        for _exeext in '' .EXE; do
+          _G_path_prog=$_G_dir/$_G_prog_name$_exeext
+          func_executable_p "$_G_path_prog" || continue
+          case `"$_G_path_prog" --version 2>&1` in
+            *GNU*) func_path_progs_result=$_G_path_prog _G_path_prog_found=: ;;
+            *)     $_G_check_func $_G_path_prog
+		   func_path_progs_result=$func_check_prog_result
+		   ;;
+          esac
+          $_G_path_prog_found && break 3
+        done
+      done
+    done
+    IFS=$_G_save_IFS
+    test -z "$func_path_progs_result" && {
+      echo "no acceptable sed could be found in \$PATH" >&2
+      exit 1
+    }
+}
+
+
+# We want to be able to use the functions in this file before configure
+# has figured out where the best binaries are kept, which means we have
+# to search for them ourselves - except when the results are already set
+# where we skip the searches.
+
+# Unless the user overrides by setting SED, search the path for either GNU
+# sed, or the sed that truncates its output the least.
+test -z "$SED" && {
+  _G_sed_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+  for _G_i in 1 2 3 4 5 6 7; do
+    _G_sed_script=$_G_sed_script$nl$_G_sed_script
+  done
+  echo "$_G_sed_script" 2>/dev/null | sed 99q >conftest.sed
+  _G_sed_script=
+
+  func_check_prog_sed ()
+  {
+    _G_path_prog=$1
+
+    _G_count=0
+    printf 0123456789 >conftest.in
+    while :
+    do
+      cat conftest.in conftest.in >conftest.tmp
+      mv conftest.tmp conftest.in
+      cp conftest.in conftest.nl
+      echo '' >> conftest.nl
+      "$_G_path_prog" -f conftest.sed <conftest.nl >conftest.out 2>/dev/null || break
+      diff conftest.out conftest.nl >/dev/null 2>&1 || break
+      _G_count=`expr $_G_count + 1`
+      if test "$_G_count" -gt "$_G_path_prog_max"; then
+        # Best one so far, save it but keep looking for a better one
+        func_check_prog_result=$_G_path_prog
+        _G_path_prog_max=$_G_count
+      fi
+      # 10*(2^10) chars as input seems more than enough
+      test 10 -lt "$_G_count" && break
+    done
+    rm -f conftest.in conftest.tmp conftest.nl conftest.out
+  }
+
+  func_path_progs "sed gsed" func_check_prog_sed $PATH:/usr/xpg4/bin
+  rm -f conftest.sed
+  SED=$func_path_progs_result
+}
+
+
+# Unless the user overrides by setting GREP, search the path for either GNU
+# grep, or the grep that truncates its output the least.
+test -z "$GREP" && {
+  func_check_prog_grep ()
+  {
+    _G_path_prog=$1
+
+    _G_count=0
+    _G_path_prog_max=0
+    printf 0123456789 >conftest.in
+    while :
+    do
+      cat conftest.in conftest.in >conftest.tmp
+      mv conftest.tmp conftest.in
+      cp conftest.in conftest.nl
+      echo 'GREP' >> conftest.nl
+      "$_G_path_prog" -e 'GREP$' -e '-(cannot match)-' <conftest.nl >conftest.out 2>/dev/null || break
+      diff conftest.out conftest.nl >/dev/null 2>&1 || break
+      _G_count=`expr $_G_count + 1`
+      if test "$_G_count" -gt "$_G_path_prog_max"; then
+        # Best one so far, save it but keep looking for a better one
+        func_check_prog_result=$_G_path_prog
+        _G_path_prog_max=$_G_count
+      fi
+      # 10*(2^10) chars as input seems more than enough
+      test 10 -lt "$_G_count" && break
+    done
+    rm -f conftest.in conftest.tmp conftest.nl conftest.out
+  }
+
+  func_path_progs "grep ggrep" func_check_prog_grep $PATH:/usr/xpg4/bin
+  GREP=$func_path_progs_result
+}
+
+
+## ------------------------------- ##
+## User overridable command paths. ##
+## ------------------------------- ##
+
+# All uppercase variable names are used for environment variables.  These
+# variables can be overridden by the user before calling a script that
+# uses them if a suitable command of that name is not already available
+# in the command search PATH.
 
 : ${CP="cp -f"}
-test "${ECHO+set}" = set || ECHO=${as_echo-'printf %s\n'}
+: ${ECHO="printf %s\n"}
+: ${EGREP="$GREP -E"}
+: ${FGREP="$GREP -F"}
+: ${LN_S="ln -s"}
 : ${MAKE="make"}
 : ${MKDIR="mkdir"}
 : ${MV="mv -f"}
 : ${RM="rm -f"}
 : ${SHELL="${CONFIG_SHELL-/bin/sh}"}
-: ${Xsed="$SED -e 1s/^X//"}
-
-# Global variables:
-EXIT_SUCCESS=0
-EXIT_FAILURE=1
-EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
-EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
-
-exit_status=$EXIT_SUCCESS
-
-# Make sure IFS has a sensible default
-lt_nl='
-'
-IFS=" 	$lt_nl"
 
-dirname="s,/[^/]*$,,"
-basename="s,^.*/,,"
 
-# func_dirname file append nondir_replacement
-# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
-# otherwise set result to NONDIR_REPLACEMENT.
-func_dirname ()
-{
-    func_dirname_result=`$ECHO "${1}" | $SED "$dirname"`
-    if test "X$func_dirname_result" = "X${1}"; then
-      func_dirname_result="${3}"
-    else
-      func_dirname_result="$func_dirname_result${2}"
-    fi
-} # func_dirname may be replaced by extended shell implementation
+## -------------------- ##
+## Useful sed snippets. ##
+## -------------------- ##
 
+sed_dirname='s|/[^/]*$||'
+sed_basename='s|^.*/||'
 
-# func_basename file
-func_basename ()
-{
-    func_basename_result=`$ECHO "${1}" | $SED "$basename"`
-} # func_basename may be replaced by extended shell implementation
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+sed_quote_subst='s|\([`"$\\]\)|\\\1|g'
 
+# Same as above, but do not quote variable references.
+sed_double_quote_subst='s/\(["`\\]\)/\\\1/g'
 
-# func_dirname_and_basename file append nondir_replacement
-# perform func_basename and func_dirname in a single function
-# call:
-#   dirname:  Compute the dirname of FILE.  If nonempty,
-#             add APPEND to the result, otherwise set result
-#             to NONDIR_REPLACEMENT.
-#             value returned in "$func_dirname_result"
-#   basename: Compute filename of FILE.
-#             value retuned in "$func_basename_result"
-# Implementation must be kept synchronized with func_dirname
-# and func_basename. For efficiency, we do not delegate to
-# those functions but instead duplicate the functionality here.
-func_dirname_and_basename ()
-{
-    # Extract subdirectory from the argument.
-    func_dirname_result=`$ECHO "${1}" | $SED -e "$dirname"`
-    if test "X$func_dirname_result" = "X${1}"; then
-      func_dirname_result="${3}"
-    else
-      func_dirname_result="$func_dirname_result${2}"
-    fi
-    func_basename_result=`$ECHO "${1}" | $SED -e "$basename"`
-} # func_dirname_and_basename may be replaced by extended shell implementation
+# Sed substitution that turns a string into a regex matching for the
+# string literally.
+sed_make_literal_regex='s|[].[^$\\*\/]|\\&|g'
 
+# Sed substitution that converts a w32 file name or path
+# that contains forward slashes, into one that contains
+# (escaped) backslashes.  A very naive implementation.
+sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+
+# Re-'\' parameter expansions in output of sed_double_quote_subst that
+# were '\'-ed in input to the same.  If an odd number of '\' preceded a
+# '$' in input to sed_double_quote_subst, that '$' was protected from
+# expansion.  Since each input '\' is now two '\'s, look for any number
+# of runs of four '\'s followed by two '\'s and then a '$'.  '\' that '$'.
+_G_bs='\\'
+_G_bs2='\\\\'
+_G_bs4='\\\\\\\\'
+_G_dollar='\$'
+sed_double_backslash="\
+  s/$_G_bs4/&\\
+/g
+  s/^$_G_bs2$_G_dollar/$_G_bs&/
+  s/\\([^$_G_bs]\\)$_G_bs2$_G_dollar/\\1$_G_bs2$_G_bs$_G_dollar/g
+  s/\n//g"
 
-# func_stripname prefix suffix name
-# strip PREFIX and SUFFIX off of NAME.
-# PREFIX and SUFFIX must not contain globbing or regex special
-# characters, hashes, percent signs, but SUFFIX may contain a leading
-# dot (in which case that matches only a dot).
-# func_strip_suffix prefix name
-func_stripname ()
-{
-    case ${2} in
-      .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
-      *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
-    esac
-} # func_stripname may be replaced by extended shell implementation
 
+## ----------------- ##
+## Global variables. ##
+## ----------------- ##
 
-# These SED scripts presuppose an absolute path with a trailing slash.
-pathcar='s,^/\([^/]*\).*$,\1,'
-pathcdr='s,^/[^/]*,,'
-removedotparts=':dotsl
-		s@/\./@/@g
-		t dotsl
-		s,/\.$,/,'
-collapseslashes='s@/\{1,\}@/@g'
-finalslash='s,/*$,/,'
+# Except for the global variables explicitly listed below, the following
+# functions in the '^func_' namespace, and the '^require_' namespace
+# variables initialised in the 'Resource management' section, sourcing
+# this file will not pollute your global namespace with anything
+# else. There's no portable way to scope variables in Bourne shell
+# though, so actually running these functions will sometimes place
+# results into a variable named after the function, and often use
+# temporary variables in the '^_G_' namespace. If you are careful to
+# avoid using those namespaces casually in your sourcing script, things
+# should continue to work as you expect. And, of course, you can freely
+# overwrite any of the functions or variables defined here before
+# calling anything to customize them.
 
-# func_normal_abspath PATH
-# Remove doubled-up and trailing slashes, "." path components,
-# and cancel out any ".." path components in PATH after making
-# it an absolute path.
-#             value returned in "$func_normal_abspath_result"
-func_normal_abspath ()
-{
-  # Start from root dir and reassemble the path.
-  func_normal_abspath_result=
-  func_normal_abspath_tpath=$1
-  func_normal_abspath_altnamespace=
-  case $func_normal_abspath_tpath in
-    "")
-      # Empty path, that just means $cwd.
-      func_stripname '' '/' "`pwd`"
-      func_normal_abspath_result=$func_stripname_result
-      return
-    ;;
-    # The next three entries are used to spot a run of precisely
-    # two leading slashes without using negated character classes;
-    # we take advantage of case's first-match behaviour.
-    ///*)
-      # Unusual form of absolute path, do nothing.
-    ;;
-    //*)
-      # Not necessarily an ordinary path; POSIX reserves leading '//'
-      # and for example Cygwin uses it to access remote file shares
-      # over CIFS/SMB, so we conserve a leading double slash if found.
-      func_normal_abspath_altnamespace=/
-    ;;
-    /*)
-      # Absolute path, do nothing.
-    ;;
-    *)
-      # Relative path, prepend $cwd.
-      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath
-    ;;
-  esac
-  # Cancel out all the simple stuff to save iterations.  We also want
-  # the path to end with a slash for ease of parsing, so make sure
-  # there is one (and only one) here.
-  func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
-        -e "$removedotparts" -e "$collapseslashes" -e "$finalslash"`
-  while :; do
-    # Processed it all yet?
-    if test "$func_normal_abspath_tpath" = / ; then
-      # If we ascended to the root using ".." the result may be empty now.
-      if test -z "$func_normal_abspath_result" ; then
-        func_normal_abspath_result=/
-      fi
-      break
-    fi
-    func_normal_abspath_tcomponent=`$ECHO "$func_normal_abspath_tpath" | $SED \
-        -e "$pathcar"`
-    func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
-        -e "$pathcdr"`
-    # Figure out what to do with it
-    case $func_normal_abspath_tcomponent in
-      "")
-        # Trailing empty path component, ignore it.
-      ;;
-      ..)
-        # Parent dir; strip last assembled component from result.
-        func_dirname "$func_normal_abspath_result"
-        func_normal_abspath_result=$func_dirname_result
-      ;;
-      *)
-        # Actual path component, append it.
-        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent
-      ;;
-    esac
-  done
-  # Restore leading double-slash if one was found on entry.
-  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result
-}
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
 
-# func_relative_path SRCDIR DSTDIR
-# generates a relative path from SRCDIR to DSTDIR, with a trailing
-# slash if non-empty, suitable for immediately appending a filename
-# without needing to append a separator.
-#             value returned in "$func_relative_path_result"
-func_relative_path ()
-{
-  func_relative_path_result=
-  func_normal_abspath "$1"
-  func_relative_path_tlibdir=$func_normal_abspath_result
-  func_normal_abspath "$2"
-  func_relative_path_tbindir=$func_normal_abspath_result
-
-  # Ascend the tree starting from libdir
-  while :; do
-    # check if we have found a prefix of bindir
-    case $func_relative_path_tbindir in
-      $func_relative_path_tlibdir)
-        # found an exact match
-        func_relative_path_tcancelled=
-        break
-        ;;
-      $func_relative_path_tlibdir*)
-        # found a matching prefix
-        func_stripname "$func_relative_path_tlibdir" '' "$func_relative_path_tbindir"
-        func_relative_path_tcancelled=$func_stripname_result
-        if test -z "$func_relative_path_result"; then
-          func_relative_path_result=.
-        fi
-        break
-        ;;
-      *)
-        func_dirname $func_relative_path_tlibdir
-        func_relative_path_tlibdir=${func_dirname_result}
-        if test "x$func_relative_path_tlibdir" = x ; then
-          # Have to descend all the way to the root!
-          func_relative_path_result=../$func_relative_path_result
-          func_relative_path_tcancelled=$func_relative_path_tbindir
-          break
-        fi
-        func_relative_path_result=../$func_relative_path_result
-        ;;
-    esac
-  done
+# Allow overriding, eg assuming that you follow the convention of
+# putting '$debug_cmd' at the start of all your functions, you can get
+# bash to show function call trace with:
+#
+#    debug_cmd='eval echo "${FUNCNAME[0]} $*" >&2' bash your-script-name
+debug_cmd=${debug_cmd-":"}
+exit_cmd=:
 
-  # Now calculate path; take care to avoid doubling-up slashes.
-  func_stripname '' '/' "$func_relative_path_result"
-  func_relative_path_result=$func_stripname_result
-  func_stripname '/' '/' "$func_relative_path_tcancelled"
-  if test "x$func_stripname_result" != x ; then
-    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}
-  fi
+# By convention, finish your script with:
+#
+#    exit $exit_status
+#
+# so that you can set exit_status to non-zero if you want to indicate
+# something went wrong during execution without actually bailing out at
+# the point of failure.
+exit_status=$EXIT_SUCCESS
 
-  # Normalisation. If bindir is libdir, return empty string,
-  # else relative path ending with a slash; either way, target
-  # file name can be directly appended.
-  if test ! -z "$func_relative_path_result"; then
-    func_stripname './' '' "$func_relative_path_result/"
-    func_relative_path_result=$func_stripname_result
-  fi
-}
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath=$0
 
-# The name of this program:
-func_dirname_and_basename "$progpath"
-progname=$func_basename_result
+# The name of this program.
+progname=`$ECHO "$progpath" |$SED "$sed_basename"`
 
-# Make sure we have an absolute path for reexecution:
+# Make sure we have an absolute progpath for reexecution:
 case $progpath in
   [\\/]*|[A-Za-z]:\\*) ;;
   *[\\/]*)
-     progdir=$func_dirname_result
+     progdir=`$ECHO "$progpath" |$SED "$sed_dirname"`
      progdir=`cd "$progdir" && pwd`
-     progpath="$progdir/$progname"
+     progpath=$progdir/$progname
      ;;
   *)
-     save_IFS="$IFS"
+     _G_IFS=$IFS
      IFS=${PATH_SEPARATOR-:}
      for progdir in $PATH; do
-       IFS="$save_IFS"
+       IFS=$_G_IFS
        test -x "$progdir/$progname" && break
      done
-     IFS="$save_IFS"
+     IFS=$_G_IFS
      test -n "$progdir" || progdir=`pwd`
-     progpath="$progdir/$progname"
+     progpath=$progdir/$progname
      ;;
 esac
 
-# Sed substitution that helps us do robust quoting.  It backslashifies
-# metacharacters that are still active within double-quoted strings.
-Xsed="${SED}"' -e 1s/^X//'
-sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
-
-# Same as above, but do not quote variable references.
-double_quote_subst='s/\(["`\\]\)/\\\1/g'
 
-# Sed substitution that turns a string into a regex matching for the
-# string literally.
-sed_make_literal_regex='s,[].[^$\\*\/],\\&,g'
+## ----------------- ##
+## Standard options. ##
+## ----------------- ##
 
-# Sed substitution that converts a w32 file name or path
-# which contains forward slashes, into one that contains
-# (escaped) backslashes.  A very naive implementation.
-lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
-
-# Re-`\' parameter expansions in output of double_quote_subst that were
-# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
-# in input to double_quote_subst, that '$' was protected from expansion.
-# Since each input `\' is now two `\'s, look for any number of runs of
-# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
-bs='\\'
-bs2='\\\\'
-bs4='\\\\\\\\'
-dollar='\$'
-sed_double_backslash="\
-  s/$bs4/&\\
-/g
-  s/^$bs2$dollar/$bs&/
-  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
-  s/\n//g"
+# The following options affect the operation of the functions defined
+# below, and should be set appropriately depending on run-time para-
+# meters passed on the command line.
 
-# Standard options:
 opt_dry_run=false
-opt_help=false
 opt_quiet=false
 opt_verbose=false
-opt_warning=:
 
-# func_echo arg...
-# Echo program name prefixed message, along with the current mode
-# name if it has been set yet.
-func_echo ()
-{
-    $ECHO "$progname: ${opt_mode+$opt_mode: }$*"
-}
+# Categories 'all' and 'none' are always available.  Append any others
+# you will pass as the first argument to func_warning from your own
+# code.
+warning_categories=
 
-# func_verbose arg...
-# Echo program name prefixed message in verbose mode only.
-func_verbose ()
-{
-    $opt_verbose && func_echo ${1+"$@"}
+# By default, display warnings according to 'opt_warning_types'.  Set
+# 'warning_func'  to ':' to elide all warnings, or func_fatal_error to
+# treat the next displayed warning as a fatal error.
+warning_func=func_warn_and_continue
 
-    # A bug in bash halts the script if the last line of a function
-    # fails when set -e is in force, so we need another command to
-    # work around that:
-    :
-}
+# Set to 'all' to display all warnings, 'none' to suppress all
+# warnings, or a space delimited list of some subset of
+# 'warning_categories' to display only the listed warnings.
+opt_warning_types=all
 
-# func_echo_all arg...
-# Invoke $ECHO with all args, space-separated.
-func_echo_all ()
-{
-    $ECHO "$*"
-}
 
-# func_error arg...
-# Echo program name prefixed message to standard error.
-func_error ()
-{
-    $ECHO "$progname: ${opt_mode+$opt_mode: }"${1+"$@"} 1>&2
-}
+## -------------------- ##
+## Resource management. ##
+## -------------------- ##
 
-# func_warning arg...
-# Echo program name prefixed warning message to standard error.
-func_warning ()
-{
-    $opt_warning && $ECHO "$progname: ${opt_mode+$opt_mode: }warning: "${1+"$@"} 1>&2
+# This section contains definitions for functions that each ensure a
+# particular resource (a file, or a non-empty configuration variable for
+# example) is available, and if appropriate to extract default values
+# from pertinent package files. Call them using their associated
+# 'require_*' variable to ensure that they are executed, at most, once.
+#
+# It's entirely deliberate that calling these functions can set
+# variables that don't obey the namespace limitations obeyed by the rest
+# of this file, in order that that they be as useful as possible to
+# callers.
 
-    # bash bug again:
-    :
-}
 
-# func_fatal_error arg...
-# Echo program name prefixed message to standard error, and exit.
-func_fatal_error ()
+# require_term_colors
+# -------------------
+# Allow display of bold text on terminals that support it.
+require_term_colors=func_require_term_colors
+func_require_term_colors ()
 {
-    func_error ${1+"$@"}
-    exit $EXIT_FAILURE
-}
+    $debug_cmd
+
+    test -t 1 && {
+      # COLORTERM and USE_ANSI_COLORS environment variables take
+      # precedence, because most terminfo databases neglect to describe
+      # whether color sequences are supported.
+      test -n "${COLORTERM+set}" && : ${USE_ANSI_COLORS="1"}
+
+      if test 1 = "$USE_ANSI_COLORS"; then
+        # Standard ANSI escape sequences
+        tc_reset='[0m'
+        tc_bold='[1m';   tc_standout='[7m'
+        tc_red='[31m';   tc_green='[32m'
+        tc_blue='[34m';  tc_cyan='[36m'
+      else
+        # Otherwise trust the terminfo database after all.
+        test -n "`tput sgr0 2>/dev/null`" && {
+          tc_reset=`tput sgr0`
+          test -n "`tput bold 2>/dev/null`" && tc_bold=`tput bold`
+          tc_standout=$tc_bold
+          test -n "`tput smso 2>/dev/null`" && tc_standout=`tput smso`
+          test -n "`tput setaf 1 2>/dev/null`" && tc_red=`tput setaf 1`
+          test -n "`tput setaf 2 2>/dev/null`" && tc_green=`tput setaf 2`
+          test -n "`tput setaf 4 2>/dev/null`" && tc_blue=`tput setaf 4`
+          test -n "`tput setaf 5 2>/dev/null`" && tc_cyan=`tput setaf 5`
+        }
+      fi
+    }
 
-# func_fatal_help arg...
-# Echo program name prefixed message to standard error, followed by
-# a help hint, and exit.
-func_fatal_help ()
-{
-    func_error ${1+"$@"}
-    func_fatal_error "$help"
+    require_term_colors=:
 }
-help="Try \`$progname --help' for more information."  ## default
 
 
-# func_grep expression filename
+## ----------------- ##
+## Function library. ##
+## ----------------- ##
+
+# This section contains a variety of useful functions to call in your
+# scripts. Take note of the portable wrappers for features provided by
+# some modern shells, which will fall back to slower equivalents on
+# less featureful shells.
+
+
+# func_append VAR VALUE
+# ---------------------
+# Append VALUE onto the existing contents of VAR.
+
+  # We should try to minimise forks, especially on Windows where they are
+  # unreasonably slow, so skip the feature probes when bash or zsh are
+  # being used:
+  if test set = "${BASH_VERSION+set}${ZSH_VERSION+set}"; then
+    : ${_G_HAVE_ARITH_OP="yes"}
+    : ${_G_HAVE_XSI_OPS="yes"}
+    # The += operator was introduced in bash 3.1
+    case $BASH_VERSION in
+      [12].* | 3.0 | 3.0*) ;;
+      *)
+        : ${_G_HAVE_PLUSEQ_OP="yes"}
+        ;;
+    esac
+  fi
+
+  # _G_HAVE_PLUSEQ_OP
+  # Can be empty, in which case the shell is probed, "yes" if += is
+  # useable or anything else if it does not work.
+  test -z "$_G_HAVE_PLUSEQ_OP" \
+    && (eval 'x=a; x+=" b"; test "a b" = "$x"') 2>/dev/null \
+    && _G_HAVE_PLUSEQ_OP=yes
+
+if test yes = "$_G_HAVE_PLUSEQ_OP"
+then
+  # This is an XSI compatible shell, allowing a faster implementation...
+  eval 'func_append ()
+  {
+    $debug_cmd
+
+    eval "$1+=\$2"
+  }'
+else
+  # ...otherwise fall back to using expr, which is often a shell builtin.
+  func_append ()
+  {
+    $debug_cmd
+
+    eval "$1=\$$1\$2"
+  }
+fi
+
+
+# func_append_quoted VAR VALUE
+# ----------------------------
+# Quote VALUE and append to the end of shell variable VAR, separated
+# by a space.
+if test yes = "$_G_HAVE_PLUSEQ_OP"; then
+  eval 'func_append_quoted ()
+  {
+    $debug_cmd
+
+    func_quote_for_eval "$2"
+    eval "$1+=\\ \$func_quote_for_eval_result"
+  }'
+else
+  func_append_quoted ()
+  {
+    $debug_cmd
+
+    func_quote_for_eval "$2"
+    eval "$1=\$$1\\ \$func_quote_for_eval_result"
+  }
+fi
+
+
+# func_append_uniq VAR VALUE
+# --------------------------
+# Append unique VALUE onto the existing contents of VAR, assuming
+# entries are delimited by the first character of VALUE.  For example:
+#
+#   func_append_uniq options " --another-option option-argument"
+#
+# will only append to $options if " --another-option option-argument "
+# is not already present somewhere in $options already (note spaces at
+# each end implied by leading space in second argument).
+func_append_uniq ()
+{
+    $debug_cmd
+
+    eval _G_current_value='`$ECHO $'$1'`'
+    _G_delim=`expr "$2" : '\(.\)'`
+
+    case $_G_delim$_G_current_value$_G_delim in
+      *"$2$_G_delim"*) ;;
+      *) func_append "$@" ;;
+    esac
+}
+
+
+# func_arith TERM...
+# ------------------
+# Set func_arith_result to the result of evaluating TERMs.
+  test -z "$_G_HAVE_ARITH_OP" \
+    && (eval 'test 2 = $(( 1 + 1 ))') 2>/dev/null \
+    && _G_HAVE_ARITH_OP=yes
+
+if test yes = "$_G_HAVE_ARITH_OP"; then
+  eval 'func_arith ()
+  {
+    $debug_cmd
+
+    func_arith_result=$(( $* ))
+  }'
+else
+  func_arith ()
+  {
+    $debug_cmd
+
+    func_arith_result=`expr "$@"`
+  }
+fi
+
+
+# func_basename FILE
+# ------------------
+# Set func_basename_result to FILE with everything up to and including
+# the last / stripped.
+if test yes = "$_G_HAVE_XSI_OPS"; then
+  # If this shell supports suffix pattern removal, then use it to avoid
+  # forking. Hide the definitions single quotes in case the shell chokes
+  # on unsupported syntax...
+  _b='func_basename_result=${1##*/}'
+  _d='case $1 in
+        */*) func_dirname_result=${1%/*}$2 ;;
+        *  ) func_dirname_result=$3        ;;
+      esac'
+
+else
+  # ...otherwise fall back to using sed.
+  _b='func_basename_result=`$ECHO "$1" |$SED "$sed_basename"`'
+  _d='func_dirname_result=`$ECHO "$1"  |$SED "$sed_dirname"`
+      if test "X$func_dirname_result" = "X$1"; then
+        func_dirname_result=$3
+      else
+        func_append func_dirname_result "$2"
+      fi'
+fi
+
+eval 'func_basename ()
+{
+    $debug_cmd
+
+    '"$_b"'
+}'
+
+
+# func_dirname FILE APPEND NONDIR_REPLACEMENT
+# -------------------------------------------
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+eval 'func_dirname ()
+{
+    $debug_cmd
+
+    '"$_d"'
+}'
+
+
+# func_dirname_and_basename FILE APPEND NONDIR_REPLACEMENT
+# --------------------------------------------------------
+# Perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# For efficiency, we do not delegate to the functions above but instead
+# duplicate the functionality here.
+eval 'func_dirname_and_basename ()
+{
+    $debug_cmd
+
+    '"$_b"'
+    '"$_d"'
+}'
+
+
+# func_echo ARG...
+# ----------------
+# Echo program name prefixed message.
+func_echo ()
+{
+    $debug_cmd
+
+    _G_message=$*
+
+    func_echo_IFS=$IFS
+    IFS=$nl
+    for _G_line in $_G_message; do
+      IFS=$func_echo_IFS
+      $ECHO "$progname: $_G_line"
+    done
+    IFS=$func_echo_IFS
+}
+
+
+# func_echo_all ARG...
+# --------------------
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO "$*"
+}
+
+
+# func_echo_infix_1 INFIX ARG...
+# ------------------------------
+# Echo program name, followed by INFIX on the first line, with any
+# additional lines not showing INFIX.
+func_echo_infix_1 ()
+{
+    $debug_cmd
+
+    $require_term_colors
+
+    _G_infix=$1; shift
+    _G_indent=$_G_infix
+    _G_prefix="$progname: $_G_infix: "
+    _G_message=$*
+
+    # Strip color escape sequences before counting printable length
+    for _G_tc in "$tc_reset" "$tc_bold" "$tc_standout" "$tc_red" "$tc_green" "$tc_blue" "$tc_cyan"
+    do
+      test -n "$_G_tc" && {
+        _G_esc_tc=`$ECHO "$_G_tc" | $SED "$sed_make_literal_regex"`
+        _G_indent=`$ECHO "$_G_indent" | $SED "s|$_G_esc_tc||g"`
+      }
+    done
+    _G_indent="$progname: "`echo "$_G_indent" | $SED 's|.| |g'`"  " ## exclude from sc_prohibit_nested_quotes
+
+    func_echo_infix_1_IFS=$IFS
+    IFS=$nl
+    for _G_line in $_G_message; do
+      IFS=$func_echo_infix_1_IFS
+      $ECHO "$_G_prefix$tc_bold$_G_line$tc_reset" >&2
+      _G_prefix=$_G_indent
+    done
+    IFS=$func_echo_infix_1_IFS
+}
+
+
+# func_error ARG...
+# -----------------
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $debug_cmd
+
+    $require_term_colors
+
+    func_echo_infix_1 "  $tc_standout${tc_red}error$tc_reset" "$*" >&2
+}
+
+
+# func_fatal_error ARG...
+# -----------------------
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    $debug_cmd
+
+    func_error "$*"
+    exit $EXIT_FAILURE
+}
+
+
+# func_grep EXPRESSION FILENAME
+# -----------------------------
 # Check whether EXPRESSION matches any line of FILENAME, without output.
 func_grep ()
 {
+    $debug_cmd
+
     $GREP "$1" "$2" >/dev/null 2>&1
 }
 
 
-# func_mkdir_p directory-path
+# func_len STRING
+# ---------------
+# Set func_len_result to the length of STRING. STRING may not
+# start with a hyphen.
+  test -z "$_G_HAVE_XSI_OPS" \
+    && (eval 'x=a/b/c;
+      test 5aa/bb/cc = "${#x}${x%%/*}${x%/*}${x#*/}${x##*/}"') 2>/dev/null \
+    && _G_HAVE_XSI_OPS=yes
+
+if test yes = "$_G_HAVE_XSI_OPS"; then
+  eval 'func_len ()
+  {
+    $debug_cmd
+
+    func_len_result=${#1}
+  }'
+else
+  func_len ()
+  {
+    $debug_cmd
+
+    func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
+  }
+fi
+
+
+# func_mkdir_p DIRECTORY-PATH
+# ---------------------------
 # Make sure the entire path to DIRECTORY-PATH is available.
 func_mkdir_p ()
 {
-    my_directory_path="$1"
-    my_dir_list=
+    $debug_cmd
 
-    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+    _G_directory_path=$1
+    _G_dir_list=
 
-      # Protect directory names starting with `-'
-      case $my_directory_path in
-        -*) my_directory_path="./$my_directory_path" ;;
+    if test -n "$_G_directory_path" && test : != "$opt_dry_run"; then
+
+      # Protect directory names starting with '-'
+      case $_G_directory_path in
+        -*) _G_directory_path=./$_G_directory_path ;;
       esac
 
       # While some portion of DIR does not yet exist...
-      while test ! -d "$my_directory_path"; do
+      while test ! -d "$_G_directory_path"; do
         # ...make a list in topmost first order.  Use a colon delimited
 	# list incase some portion of path contains whitespace.
-        my_dir_list="$my_directory_path:$my_dir_list"
+        _G_dir_list=$_G_directory_path:$_G_dir_list
 
         # If the last portion added has no slash in it, the list is done
-        case $my_directory_path in */*) ;; *) break ;; esac
+        case $_G_directory_path in */*) ;; *) break ;; esac
 
         # ...otherwise throw away the child directory and loop
-        my_directory_path=`$ECHO "$my_directory_path" | $SED -e "$dirname"`
+        _G_directory_path=`$ECHO "$_G_directory_path" | $SED -e "$sed_dirname"`
       done
-      my_dir_list=`$ECHO "$my_dir_list" | $SED 's,:*$,,'`
+      _G_dir_list=`$ECHO "$_G_dir_list" | $SED 's|:*$||'`
 
-      save_mkdir_p_IFS="$IFS"; IFS=':'
-      for my_dir in $my_dir_list; do
-	IFS="$save_mkdir_p_IFS"
-        # mkdir can fail with a `File exist' error if two processes
+      func_mkdir_p_IFS=$IFS; IFS=:
+      for _G_dir in $_G_dir_list; do
+	IFS=$func_mkdir_p_IFS
+        # mkdir can fail with a 'File exist' error if two processes
         # try to create one of the directories concurrently.  Don't
         # stop in that case!
-        $MKDIR "$my_dir" 2>/dev/null || :
+        $MKDIR "$_G_dir" 2>/dev/null || :
       done
-      IFS="$save_mkdir_p_IFS"
+      IFS=$func_mkdir_p_IFS
 
       # Bail out if we (or some other process) failed to create a directory.
-      test -d "$my_directory_path" || \
-        func_fatal_error "Failed to create \`$1'"
+      test -d "$_G_directory_path" || \
+        func_fatal_error "Failed to create '$1'"
     fi
 }
 
 
-# func_mktempdir [string]
+# func_mktempdir [BASENAME]
+# -------------------------
 # Make a temporary directory that won't clash with other running
 # libtool processes, and avoids race conditions if possible.  If
-# given, STRING is the basename for that directory.
+# given, BASENAME is the basename for that directory.
 func_mktempdir ()
 {
-    my_template="${TMPDIR-/tmp}/${1-$progname}"
+    $debug_cmd
+
+    _G_template=${TMPDIR-/tmp}/${1-$progname}
 
-    if test "$opt_dry_run" = ":"; then
+    if test : = "$opt_dry_run"; then
       # Return a directory name, but don't create it in dry-run mode
-      my_tmpdir="${my_template}-$$"
+      _G_tmpdir=$_G_template-$$
     else
 
       # If mktemp works, use that first and foremost
-      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+      _G_tmpdir=`mktemp -d "$_G_template-XXXXXXXX" 2>/dev/null`
 
-      if test ! -d "$my_tmpdir"; then
+      if test ! -d "$_G_tmpdir"; then
         # Failing that, at least try and use $RANDOM to avoid a race
-        my_tmpdir="${my_template}-${RANDOM-0}$$"
+        _G_tmpdir=$_G_template-${RANDOM-0}$$
 
-        save_mktempdir_umask=`umask`
+        func_mktempdir_umask=`umask`
         umask 0077
-        $MKDIR "$my_tmpdir"
-        umask $save_mktempdir_umask
+        $MKDIR "$_G_tmpdir"
+        umask $func_mktempdir_umask
       fi
 
       # If we're not in dry-run mode, bomb out on failure
-      test -d "$my_tmpdir" || \
-        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+      test -d "$_G_tmpdir" || \
+        func_fatal_error "cannot create temporary directory '$_G_tmpdir'"
+    fi
+
+    $ECHO "$_G_tmpdir"
+}
+
+
+# func_normal_abspath PATH
+# ------------------------
+# Remove doubled-up and trailing slashes, "." path components,
+# and cancel out any ".." path components in PATH after making
+# it an absolute path.
+func_normal_abspath ()
+{
+    $debug_cmd
+
+    # These SED scripts presuppose an absolute path with a trailing slash.
+    _G_pathcar='s|^/\([^/]*\).*$|\1|'
+    _G_pathcdr='s|^/[^/]*||'
+    _G_removedotparts=':dotsl
+		s|/\./|/|g
+		t dotsl
+		s|/\.$|/|'
+    _G_collapseslashes='s|/\{1,\}|/|g'
+    _G_finalslash='s|/*$|/|'
+
+    # Start from root dir and reassemble the path.
+    func_normal_abspath_result=
+    func_normal_abspath_tpath=$1
+    func_normal_abspath_altnamespace=
+    case $func_normal_abspath_tpath in
+      "")
+        # Empty path, that just means $cwd.
+        func_stripname '' '/' "`pwd`"
+        func_normal_abspath_result=$func_stripname_result
+        return
+        ;;
+      # The next three entries are used to spot a run of precisely
+      # two leading slashes without using negated character classes;
+      # we take advantage of case's first-match behaviour.
+      ///*)
+        # Unusual form of absolute path, do nothing.
+        ;;
+      //*)
+        # Not necessarily an ordinary path; POSIX reserves leading '//'
+        # and for example Cygwin uses it to access remote file shares
+        # over CIFS/SMB, so we conserve a leading double slash if found.
+        func_normal_abspath_altnamespace=/
+        ;;
+      /*)
+        # Absolute path, do nothing.
+        ;;
+      *)
+        # Relative path, prepend $cwd.
+        func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath
+        ;;
+    esac
+
+    # Cancel out all the simple stuff to save iterations.  We also want
+    # the path to end with a slash for ease of parsing, so make sure
+    # there is one (and only one) here.
+    func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
+          -e "$_G_removedotparts" -e "$_G_collapseslashes" -e "$_G_finalslash"`
+    while :; do
+      # Processed it all yet?
+      if test / = "$func_normal_abspath_tpath"; then
+        # If we ascended to the root using ".." the result may be empty now.
+        if test -z "$func_normal_abspath_result"; then
+          func_normal_abspath_result=/
+        fi
+        break
+      fi
+      func_normal_abspath_tcomponent=`$ECHO "$func_normal_abspath_tpath" | $SED \
+          -e "$_G_pathcar"`
+      func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
+          -e "$_G_pathcdr"`
+      # Figure out what to do with it
+      case $func_normal_abspath_tcomponent in
+        "")
+          # Trailing empty path component, ignore it.
+          ;;
+        ..)
+          # Parent dir; strip last assembled component from result.
+          func_dirname "$func_normal_abspath_result"
+          func_normal_abspath_result=$func_dirname_result
+          ;;
+        *)
+          # Actual path component, append it.
+          func_append func_normal_abspath_result "/$func_normal_abspath_tcomponent"
+          ;;
+      esac
+    done
+    # Restore leading double-slash if one was found on entry.
+    func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result
+}
+
+
+# func_notquiet ARG...
+# --------------------
+# Echo program name prefixed message only when not in quiet mode.
+func_notquiet ()
+{
+    $debug_cmd
+
+    $opt_quiet || func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+
+# func_relative_path SRCDIR DSTDIR
+# --------------------------------
+# Set func_relative_path_result to the relative path from SRCDIR to DSTDIR.
+func_relative_path ()
+{
+    $debug_cmd
+
+    func_relative_path_result=
+    func_normal_abspath "$1"
+    func_relative_path_tlibdir=$func_normal_abspath_result
+    func_normal_abspath "$2"
+    func_relative_path_tbindir=$func_normal_abspath_result
+
+    # Ascend the tree starting from libdir
+    while :; do
+      # check if we have found a prefix of bindir
+      case $func_relative_path_tbindir in
+        $func_relative_path_tlibdir)
+          # found an exact match
+          func_relative_path_tcancelled=
+          break
+          ;;
+        $func_relative_path_tlibdir*)
+          # found a matching prefix
+          func_stripname "$func_relative_path_tlibdir" '' "$func_relative_path_tbindir"
+          func_relative_path_tcancelled=$func_stripname_result
+          if test -z "$func_relative_path_result"; then
+            func_relative_path_result=.
+          fi
+          break
+          ;;
+        *)
+          func_dirname $func_relative_path_tlibdir
+          func_relative_path_tlibdir=$func_dirname_result
+          if test -z "$func_relative_path_tlibdir"; then
+            # Have to descend all the way to the root!
+            func_relative_path_result=../$func_relative_path_result
+            func_relative_path_tcancelled=$func_relative_path_tbindir
+            break
+          fi
+          func_relative_path_result=../$func_relative_path_result
+          ;;
+      esac
+    done
+
+    # Now calculate path; take care to avoid doubling-up slashes.
+    func_stripname '' '/' "$func_relative_path_result"
+    func_relative_path_result=$func_stripname_result
+    func_stripname '/' '/' "$func_relative_path_tcancelled"
+    if test -n "$func_stripname_result"; then
+      func_append func_relative_path_result "/$func_stripname_result"
+    fi
+
+    # Normalisation. If bindir is libdir, return '.' else relative path.
+    if test -n "$func_relative_path_result"; then
+      func_stripname './' '' "$func_relative_path_result"
+      func_relative_path_result=$func_stripname_result
     fi
 
-    $ECHO "$my_tmpdir"
+    test -n "$func_relative_path_result" || func_relative_path_result=.
+
+    :
+}
+
+
+# func_quote_for_eval ARG...
+# --------------------------
+# Aesthetically quote ARGs to be evaled later.
+# This function returns two values:
+#   i) func_quote_for_eval_result
+#      double-quoted, suitable for a subsequent eval
+#  ii) func_quote_for_eval_unquoted_result
+#      has all characters that are still active within double
+#      quotes backslashified.
+func_quote_for_eval ()
+{
+    $debug_cmd
+
+    func_quote_for_eval_unquoted_result=
+    func_quote_for_eval_result=
+    while test 0 -lt $#; do
+      case $1 in
+        *[\\\`\"\$]*)
+	  _G_unquoted_arg=`printf '%s\n' "$1" |$SED "$sed_quote_subst"` ;;
+        *)
+          _G_unquoted_arg=$1 ;;
+      esac
+      if test -n "$func_quote_for_eval_unquoted_result"; then
+	func_append func_quote_for_eval_unquoted_result " $_G_unquoted_arg"
+      else
+        func_append func_quote_for_eval_unquoted_result "$_G_unquoted_arg"
+      fi
+
+      case $_G_unquoted_arg in
+        # Double-quote args containing shell metacharacters to delay
+        # word splitting, command substitution and variable expansion
+        # for a subsequent eval.
+        # Many Bourne shells cannot handle close brackets correctly
+        # in scan sets, so we specify it separately.
+        *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+          _G_quoted_arg=\"$_G_unquoted_arg\"
+          ;;
+        *)
+          _G_quoted_arg=$_G_unquoted_arg
+	  ;;
+      esac
+
+      if test -n "$func_quote_for_eval_result"; then
+	func_append func_quote_for_eval_result " $_G_quoted_arg"
+      else
+        func_append func_quote_for_eval_result "$_G_quoted_arg"
+      fi
+      shift
+    done
+}
+
+
+# func_quote_for_expand ARG
+# -------------------------
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    $debug_cmd
+
+    case $1 in
+      *[\\\`\"]*)
+	_G_arg=`$ECHO "$1" | $SED \
+	    -e "$sed_double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        _G_arg=$1 ;;
+    esac
+
+    case $_G_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        _G_arg=\"$_G_arg\"
+        ;;
+    esac
+
+    func_quote_for_expand_result=$_G_arg
+}
+
+
+# func_stripname PREFIX SUFFIX NAME
+# ---------------------------------
+# strip PREFIX and SUFFIX from NAME, and store in func_stripname_result.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+if test yes = "$_G_HAVE_XSI_OPS"; then
+  eval 'func_stripname ()
+  {
+    $debug_cmd
+
+    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+    # positional parameters, so assign one to ordinary variable first.
+    func_stripname_result=$3
+    func_stripname_result=${func_stripname_result#"$1"}
+    func_stripname_result=${func_stripname_result%"$2"}
+  }'
+else
+  func_stripname ()
+  {
+    $debug_cmd
+
+    case $2 in
+      .*) func_stripname_result=`$ECHO "$3" | $SED -e "s%^$1%%" -e "s%\\\\$2\$%%"`;;
+      *)  func_stripname_result=`$ECHO "$3" | $SED -e "s%^$1%%" -e "s%$2\$%%"`;;
+    esac
+  }
+fi
+
+
+# func_show_eval CMD [FAIL_EXP]
+# -----------------------------
+# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    $debug_cmd
+
+    _G_cmd=$1
+    _G_fail_exp=${2-':'}
+
+    func_quote_for_expand "$_G_cmd"
+    eval "func_notquiet $func_quote_for_expand_result"
+
+    $opt_dry_run || {
+      eval "$_G_cmd"
+      _G_status=$?
+      if test 0 -ne "$_G_status"; then
+	eval "(exit $_G_status); $_G_fail_exp"
+      fi
+    }
+}
+
+
+# func_show_eval_locale CMD [FAIL_EXP]
+# ------------------------------------
+# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.  Use the saved locale for evaluation.
+func_show_eval_locale ()
+{
+    $debug_cmd
+
+    _G_cmd=$1
+    _G_fail_exp=${2-':'}
+
+    $opt_quiet || {
+      func_quote_for_expand "$_G_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    $opt_dry_run || {
+      eval "$_G_user_locale
+	    $_G_cmd"
+      _G_status=$?
+      eval "$_G_safe_locale"
+      if test 0 -ne "$_G_status"; then
+	eval "(exit $_G_status); $_G_fail_exp"
+      fi
+    }
+}
+
+
+# func_tr_sh
+# ----------
+# Turn $1 into a string suitable for a shell variable name.
+# Result is stored in $func_tr_sh_result.  All characters
+# not in the set a-zA-Z0-9_ are replaced with '_'. Further,
+# if $1 begins with a digit, a '_' is prepended as well.
+func_tr_sh ()
+{
+    $debug_cmd
+
+    case $1 in
+    [0-9]* | *[!a-zA-Z0-9_]*)
+      func_tr_sh_result=`$ECHO "$1" | $SED -e 's/^\([0-9]\)/_\1/' -e 's/[^a-zA-Z0-9_]/_/g'`
+      ;;
+    * )
+      func_tr_sh_result=$1
+      ;;
+    esac
+}
+
+
+# func_verbose ARG...
+# -------------------
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $debug_cmd
+
+    $opt_verbose && func_echo "$*"
+
+    :
+}
+
+
+# func_warn_and_continue ARG...
+# -----------------------------
+# Echo program name prefixed warning message to standard error.
+func_warn_and_continue ()
+{
+    $debug_cmd
+
+    $require_term_colors
+
+    func_echo_infix_1 "${tc_red}warning$tc_reset" "$*" >&2
+}
+
+
+# func_warning CATEGORY ARG...
+# ----------------------------
+# Echo program name prefixed warning message to standard error. Warning
+# messages can be filtered according to CATEGORY, where this function
+# elides messages where CATEGORY is not listed in the global variable
+# 'opt_warning_types'.
+func_warning ()
+{
+    $debug_cmd
+
+    # CATEGORY must be in the warning_categories list!
+    case " $warning_categories " in
+      *" $1 "*) ;;
+      *) func_internal_error "invalid warning category '$1'" ;;
+    esac
+
+    _G_category=$1
+    shift
+
+    case " $opt_warning_types " in
+      *" $_G_category "*) $warning_func ${1+"$@"} ;;
+    esac
+}
+
+
+# func_sort_ver VER1 VER2
+# -----------------------
+# 'sort -V' is not generally available.
+# Note this deviates from the version comparison in automake
+# in that it treats 1.5 < 1.5.0, and treats 1.4.4a < 1.4-p3a
+# but this should suffice as we won't be specifying old
+# version formats or redundant trailing .0 in bootstrap.conf.
+# If we did want full compatibility then we should probably
+# use m4_version_compare from autoconf.
+func_sort_ver ()
+{
+    $debug_cmd
+
+    printf '%s\n%s\n' "$1" "$2" \
+      | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n
+}
+
+# func_lt_ver PREV CURR
+# ---------------------
+# Return true if PREV and CURR are in the correct order according to
+# func_sort_ver, otherwise false.  Use it like this:
+#
+#  func_lt_ver "$prev_ver" "$proposed_ver" || func_fatal_error "..."
+func_lt_ver ()
+{
+    $debug_cmd
+
+    test "x$1" = x`func_sort_ver "$1" "$2" | $SED 1q`
+}
+
+
+# Local variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-pattern: "10/scriptversion=%:y-%02m-%02d.%02H; # UTC"
+# time-stamp-time-zone: "UTC"
+# End:
+#! /bin/sh
+
+# Set a version string for this script.
+scriptversion=2014-01-07.03; # UTC
+
+# A portable, pluggable option parser for Bourne shell.
+# Written by Gary V. Vaughan, 2010
+
+# Copyright (C) 2010-2015 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Please report bugs or propose patches to gary@gnu.org.
+
+
+## ------ ##
+## Usage. ##
+## ------ ##
+
+# This file is a library for parsing options in your shell scripts along
+# with assorted other useful supporting features that you can make use
+# of too.
+#
+# For the simplest scripts you might need only:
+#
+#   #!/bin/sh
+#   . relative/path/to/funclib.sh
+#   . relative/path/to/options-parser
+#   scriptversion=1.0
+#   func_options ${1+"$@"}
+#   eval set dummy "$func_options_result"; shift
+#   ...rest of your script...
+#
+# In order for the '--version' option to work, you will need to have a
+# suitably formatted comment like the one at the top of this file
+# starting with '# Written by ' and ending with '# warranty; '.
+#
+# For '-h' and '--help' to work, you will also need a one line
+# description of your script's purpose in a comment directly above the
+# '# Written by ' line, like the one at the top of this file.
+#
+# The default options also support '--debug', which will turn on shell
+# execution tracing (see the comment above debug_cmd below for another
+# use), and '--verbose' and the func_verbose function to allow your script
+# to display verbose messages only when your user has specified
+# '--verbose'.
+#
+# After sourcing this file, you can plug processing for additional
+# options by amending the variables from the 'Configuration' section
+# below, and following the instructions in the 'Option parsing'
+# section further down.
+
+## -------------- ##
+## Configuration. ##
+## -------------- ##
+
+# You should override these variables in your script after sourcing this
+# file so that they reflect the customisations you have added to the
+# option parser.
+
+# The usage line for option parsing errors and the start of '-h' and
+# '--help' output messages. You can embed shell variables for delayed
+# expansion at the time the message is displayed, but you will need to
+# quote other shell meta-characters carefully to prevent them being
+# expanded when the contents are evaled.
+usage='$progpath [OPTION]...'
+
+# Short help message in response to '-h' and '--help'.  Add to this or
+# override it after sourcing this library to reflect the full set of
+# options your script accepts.
+usage_message="\
+       --debug        enable verbose shell tracing
+   -W, --warnings=CATEGORY
+                      report the warnings falling in CATEGORY [all]
+   -v, --verbose      verbosely report processing
+       --version      print version information and exit
+   -h, --help         print short or long help message and exit
+"
+
+# Additional text appended to 'usage_message' in response to '--help'.
+long_help_message="
+Warning categories include:
+       'all'          show all warnings
+       'none'         turn off all the warnings
+       'error'        warnings are treated as fatal errors"
+
+# Help message printed before fatal option parsing errors.
+fatal_help="Try '\$progname --help' for more information."
+
+
+
+## ------------------------- ##
+## Hook function management. ##
+## ------------------------- ##
+
+# This section contains functions for adding, removing, and running hooks
+# to the main code.  A hook is just a named list of of function, that can
+# be run in order later on.
+
+# func_hookable FUNC_NAME
+# -----------------------
+# Declare that FUNC_NAME will run hooks added with
+# 'func_add_hook FUNC_NAME ...'.
+func_hookable ()
+{
+    $debug_cmd
+
+    func_append hookable_fns " $1"
+}
+
+
+# func_add_hook FUNC_NAME HOOK_FUNC
+# ---------------------------------
+# Request that FUNC_NAME call HOOK_FUNC before it returns.  FUNC_NAME must
+# first have been declared "hookable" by a call to 'func_hookable'.
+func_add_hook ()
+{
+    $debug_cmd
+
+    case " $hookable_fns " in
+      *" $1 "*) ;;
+      *) func_fatal_error "'$1' does not accept hook functions." ;;
+    esac
+
+    eval func_append ${1}_hooks '" $2"'
+}
+
+
+# func_remove_hook FUNC_NAME HOOK_FUNC
+# ------------------------------------
+# Remove HOOK_FUNC from the list of functions called by FUNC_NAME.
+func_remove_hook ()
+{
+    $debug_cmd
+
+    eval ${1}_hooks='`$ECHO "\$'$1'_hooks" |$SED "s| '$2'||"`'
+}
+
+
+# func_run_hooks FUNC_NAME [ARG]...
+# ---------------------------------
+# Run all hook functions registered to FUNC_NAME.
+# It is assumed that the list of hook functions contains nothing more
+# than a whitespace-delimited list of legal shell function names, and
+# no effort is wasted trying to catch shell meta-characters or preserve
+# whitespace.
+func_run_hooks ()
+{
+    $debug_cmd
+
+    case " $hookable_fns " in
+      *" $1 "*) ;;
+      *) func_fatal_error "'$1' does not support hook funcions.n" ;;
+    esac
+
+    eval _G_hook_fns=\$$1_hooks; shift
+
+    for _G_hook in $_G_hook_fns; do
+      eval $_G_hook '"$@"'
+
+      # store returned options list back into positional
+      # parameters for next 'cmd' execution.
+      eval _G_hook_result=\$${_G_hook}_result
+      eval set dummy "$_G_hook_result"; shift
+    done
+
+    func_quote_for_eval ${1+"$@"}
+    func_run_hooks_result=$func_quote_for_eval_result
+}
+
+
+
+## --------------- ##
+## Option parsing. ##
+## --------------- ##
+
+# In order to add your own option parsing hooks, you must accept the
+# full positional parameter list in your hook function, remove any
+# options that you action, and then pass back the remaining unprocessed
+# options in '<hooked_function_name>_result', escaped suitably for
+# 'eval'.  Like this:
+#
+#    my_options_prep ()
+#    {
+#        $debug_cmd
+#
+#        # Extend the existing usage message.
+#        usage_message=$usage_message'
+#      -s, --silent       don'\''t print informational messages
+#    '
+#
+#        func_quote_for_eval ${1+"$@"}
+#        my_options_prep_result=$func_quote_for_eval_result
+#    }
+#    func_add_hook func_options_prep my_options_prep
+#
+#
+#    my_silent_option ()
+#    {
+#        $debug_cmd
+#
+#        # Note that for efficiency, we parse as many options as we can
+#        # recognise in a loop before passing the remainder back to the
+#        # caller on the first unrecognised argument we encounter.
+#        while test $# -gt 0; do
+#          opt=$1; shift
+#          case $opt in
+#            --silent|-s) opt_silent=: ;;
+#            # Separate non-argument short options:
+#            -s*)         func_split_short_opt "$_G_opt"
+#                         set dummy "$func_split_short_opt_name" \
+#                             "-$func_split_short_opt_arg" ${1+"$@"}
+#                         shift
+#                         ;;
+#            *)            set dummy "$_G_opt" "$*"; shift; break ;;
+#          esac
+#        done
+#
+#        func_quote_for_eval ${1+"$@"}
+#        my_silent_option_result=$func_quote_for_eval_result
+#    }
+#    func_add_hook func_parse_options my_silent_option
+#
+#
+#    my_option_validation ()
+#    {
+#        $debug_cmd
+#
+#        $opt_silent && $opt_verbose && func_fatal_help "\
+#    '--silent' and '--verbose' options are mutually exclusive."
+#
+#        func_quote_for_eval ${1+"$@"}
+#        my_option_validation_result=$func_quote_for_eval_result
+#    }
+#    func_add_hook func_validate_options my_option_validation
+#
+# You'll alse need to manually amend $usage_message to reflect the extra
+# options you parse.  It's preferable to append if you can, so that
+# multiple option parsing hooks can be added safely.
+
+
+# func_options [ARG]...
+# ---------------------
+# All the functions called inside func_options are hookable. See the
+# individual implementations for details.
+func_hookable func_options
+func_options ()
+{
+    $debug_cmd
+
+    func_options_prep ${1+"$@"}
+    eval func_parse_options \
+        ${func_options_prep_result+"$func_options_prep_result"}
+    eval func_validate_options \
+        ${func_parse_options_result+"$func_parse_options_result"}
+
+    eval func_run_hooks func_options \
+        ${func_validate_options_result+"$func_validate_options_result"}
+
+    # save modified positional parameters for caller
+    func_options_result=$func_run_hooks_result
 }
 
 
-# func_quote_for_eval arg
-# Aesthetically quote ARG to be evaled later.
-# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
-# is double-quoted, suitable for a subsequent eval, whereas
-# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
-# which are still active within double quotes backslashified.
-func_quote_for_eval ()
+# func_options_prep [ARG]...
+# --------------------------
+# All initialisations required before starting the option parse loop.
+# Note that when calling hook functions, we pass through the list of
+# positional parameters.  If a hook function modifies that list, and
+# needs to propogate that back to rest of this script, then the complete
+# modified list must be put in 'func_run_hooks_result' before
+# returning.
+func_hookable func_options_prep
+func_options_prep ()
 {
-    case $1 in
-      *[\\\`\"\$]*)
-	func_quote_for_eval_unquoted_result=`$ECHO "$1" | $SED "$sed_quote_subst"` ;;
-      *)
-        func_quote_for_eval_unquoted_result="$1" ;;
-    esac
+    $debug_cmd
 
-    case $func_quote_for_eval_unquoted_result in
-      # Double-quote args containing shell metacharacters to delay
-      # word splitting, command substitution and and variable
-      # expansion for a subsequent eval.
-      # Many Bourne shells cannot handle close brackets correctly
-      # in scan sets, so we specify it separately.
-      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
-        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
-        ;;
-      *)
-        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
-    esac
+    # Option defaults:
+    opt_verbose=false
+    opt_warning_types=
+
+    func_run_hooks func_options_prep ${1+"$@"}
+
+    # save modified positional parameters for caller
+    func_options_prep_result=$func_run_hooks_result
 }
 
 
-# func_quote_for_expand arg
-# Aesthetically quote ARG to be evaled later; same as above,
-# but do not quote variable references.
-func_quote_for_expand ()
+# func_parse_options [ARG]...
+# ---------------------------
+# The main option parsing loop.
+func_hookable func_parse_options
+func_parse_options ()
 {
-    case $1 in
-      *[\\\`\"]*)
-	my_arg=`$ECHO "$1" | $SED \
-	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
-      *)
-        my_arg="$1" ;;
-    esac
+    $debug_cmd
 
-    case $my_arg in
-      # Double-quote args containing shell metacharacters to delay
-      # word splitting and command substitution for a subsequent eval.
-      # Many Bourne shells cannot handle close brackets correctly
-      # in scan sets, so we specify it separately.
-      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
-        my_arg="\"$my_arg\""
-        ;;
-    esac
+    func_parse_options_result=
 
-    func_quote_for_expand_result="$my_arg"
-}
+    # this just eases exit handling
+    while test $# -gt 0; do
+      # Defer to hook functions for initial option parsing, so they
+      # get priority in the event of reusing an option name.
+      func_run_hooks func_parse_options ${1+"$@"}
 
+      # Adjust func_parse_options positional parameters to match
+      eval set dummy "$func_run_hooks_result"; shift
 
-# func_show_eval cmd [fail_exp]
-# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
-# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
-# is given, then evaluate it.
-func_show_eval ()
-{
-    my_cmd="$1"
-    my_fail_exp="${2-:}"
+      # Break out of the loop if we already parsed every option.
+      test $# -gt 0 || break
 
-    ${opt_silent-false} || {
-      func_quote_for_expand "$my_cmd"
-      eval "func_echo $func_quote_for_expand_result"
-    }
+      _G_opt=$1
+      shift
+      case $_G_opt in
+        --debug|-x)   debug_cmd='set -x'
+                      func_echo "enabling shell trace mode"
+                      $debug_cmd
+                      ;;
+
+        --no-warnings|--no-warning|--no-warn)
+                      set dummy --warnings none ${1+"$@"}
+                      shift
+		      ;;
 
-    if ${opt_dry_run-false}; then :; else
-      eval "$my_cmd"
-      my_status=$?
-      if test "$my_status" -eq 0; then :; else
-	eval "(exit $my_status); $my_fail_exp"
-      fi
-    fi
+        --warnings|--warning|-W)
+                      test $# = 0 && func_missing_arg $_G_opt && break
+                      case " $warning_categories $1" in
+                        *" $1 "*)
+                          # trailing space prevents matching last $1 above
+                          func_append_uniq opt_warning_types " $1"
+                          ;;
+                        *all)
+                          opt_warning_types=$warning_categories
+                          ;;
+                        *none)
+                          opt_warning_types=none
+                          warning_func=:
+                          ;;
+                        *error)
+                          opt_warning_types=$warning_categories
+                          warning_func=func_fatal_error
+                          ;;
+                        *)
+                          func_fatal_error \
+                             "unsupported warning category: '$1'"
+                          ;;
+                      esac
+                      shift
+                      ;;
+
+        --verbose|-v) opt_verbose=: ;;
+        --version)    func_version ;;
+        -\?|-h)       func_usage ;;
+        --help)       func_help ;;
+
+	# Separate optargs to long options (plugins may need this):
+	--*=*)        func_split_equals "$_G_opt"
+	              set dummy "$func_split_equals_lhs" \
+                          "$func_split_equals_rhs" ${1+"$@"}
+                      shift
+                      ;;
+
+       # Separate optargs to short options:
+        -W*)
+                      func_split_short_opt "$_G_opt"
+                      set dummy "$func_split_short_opt_name" \
+                          "$func_split_short_opt_arg" ${1+"$@"}
+                      shift
+                      ;;
+
+        # Separate non-argument short options:
+        -\?*|-h*|-v*|-x*)
+                      func_split_short_opt "$_G_opt"
+                      set dummy "$func_split_short_opt_name" \
+                          "-$func_split_short_opt_arg" ${1+"$@"}
+                      shift
+                      ;;
+
+        --)           break ;;
+        -*)           func_fatal_help "unrecognised option: '$_G_opt'" ;;
+        *)            set dummy "$_G_opt" ${1+"$@"}; shift; break ;;
+      esac
+    done
+
+    # save modified positional parameters for caller
+    func_quote_for_eval ${1+"$@"}
+    func_parse_options_result=$func_quote_for_eval_result
 }
 
 
-# func_show_eval_locale cmd [fail_exp]
-# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
-# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
-# is given, then evaluate it.  Use the saved locale for evaluation.
-func_show_eval_locale ()
+# func_validate_options [ARG]...
+# ------------------------------
+# Perform any sanity checks on option settings and/or unconsumed
+# arguments.
+func_hookable func_validate_options
+func_validate_options ()
 {
-    my_cmd="$1"
-    my_fail_exp="${2-:}"
+    $debug_cmd
 
-    ${opt_silent-false} || {
-      func_quote_for_expand "$my_cmd"
-      eval "func_echo $func_quote_for_expand_result"
-    }
+    # Display all warnings if -W was not given.
+    test -n "$opt_warning_types" || opt_warning_types=" $warning_categories"
 
-    if ${opt_dry_run-false}; then :; else
-      eval "$lt_user_locale
-	    $my_cmd"
-      my_status=$?
-      eval "$lt_safe_locale"
-      if test "$my_status" -eq 0; then :; else
-	eval "(exit $my_status); $my_fail_exp"
-      fi
-    fi
-}
+    func_run_hooks func_validate_options ${1+"$@"}
 
-# func_tr_sh
-# Turn $1 into a string suitable for a shell variable name.
-# Result is stored in $func_tr_sh_result.  All characters
-# not in the set a-zA-Z0-9_ are replaced with '_'. Further,
-# if $1 begins with a digit, a '_' is prepended as well.
-func_tr_sh ()
-{
-  case $1 in
-  [0-9]* | *[!a-zA-Z0-9_]*)
-    func_tr_sh_result=`$ECHO "$1" | $SED 's/^\([0-9]\)/_\1/; s/[^a-zA-Z0-9_]/_/g'`
-    ;;
-  * )
-    func_tr_sh_result=$1
-    ;;
-  esac
+    # Bail if the options were screwed!
+    $exit_cmd $EXIT_FAILURE
+
+    # save modified positional parameters for caller
+    func_validate_options_result=$func_run_hooks_result
 }
 
 
-# func_version
-# Echo version message to standard output and exit.
-func_version ()
-{
-    $opt_debug
 
-    $SED -n '/(C)/!b go
-	:more
-	/\./!{
-	  N
-	  s/\n# / /
-	  b more
-	}
-	:go
-	/^# '$PROGRAM' (GNU /,/# warranty; / {
-        s/^# //
-	s/^# *$//
-        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
-        p
-     }' < "$progpath"
-     exit $?
-}
+## ----------------- ##
+## Helper functions. ##
+## ----------------- ##
 
-# func_usage
-# Echo short help message to standard output and exit.
-func_usage ()
+# This section contains the helper functions used by the rest of the
+# hookable option parser framework in ascii-betical order.
+
+
+# func_fatal_help ARG...
+# ----------------------
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
 {
-    $opt_debug
+    $debug_cmd
 
-    $SED -n '/^# Usage:/,/^#  *.*--help/ {
-        s/^# //
-	s/^# *$//
-	s/\$progname/'$progname'/
-	p
-    }' < "$progpath"
-    echo
-    $ECHO "run \`$progname --help | more' for full usage"
-    exit $?
+    eval \$ECHO \""Usage: $usage"\"
+    eval \$ECHO \""$fatal_help"\"
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
 }
 
-# func_help [NOEXIT]
-# Echo long help message to standard output and exit,
-# unless 'noexit' is passed as argument.
+
+# func_help
+# ---------
+# Echo long help message to standard output and exit.
 func_help ()
 {
-    $opt_debug
-
-    $SED -n '/^# Usage:/,/# Report bugs to/ {
-	:print
-        s/^# //
-	s/^# *$//
-	s*\$progname*'$progname'*
-	s*\$host*'"$host"'*
-	s*\$SHELL*'"$SHELL"'*
-	s*\$LTCC*'"$LTCC"'*
-	s*\$LTCFLAGS*'"$LTCFLAGS"'*
-	s*\$LD*'"$LD"'*
-	s/\$with_gnu_ld/'"$with_gnu_ld"'/
-	s/\$automake_version/'"`(${AUTOMAKE-automake} --version) 2>/dev/null |$SED 1q`"'/
-	s/\$autoconf_version/'"`(${AUTOCONF-autoconf} --version) 2>/dev/null |$SED 1q`"'/
-	p
-	d
-     }
-     /^# .* home page:/b print
-     /^# General help using/b print
-     ' < "$progpath"
-    ret=$?
-    if test -z "$1"; then
-      exit $ret
-    fi
+    $debug_cmd
+
+    func_usage_message
+    $ECHO "$long_help_message"
+    exit 0
 }
 
-# func_missing_arg argname
+
+# func_missing_arg ARGNAME
+# ------------------------
 # Echo program name prefixed message to standard error and set global
 # exit_cmd.
 func_missing_arg ()
 {
-    $opt_debug
+    $debug_cmd
 
-    func_error "missing argument for $1."
+    func_error "Missing argument for '$1'."
     exit_cmd=exit
 }
 
 
-# func_split_short_opt shortopt
+# func_split_equals STRING
+# ------------------------
+# Set func_split_equals_lhs and func_split_equals_rhs shell variables after
+# splitting STRING at the '=' sign.
+test -z "$_G_HAVE_XSI_OPS" \
+    && (eval 'x=a/b/c;
+      test 5aa/bb/cc = "${#x}${x%%/*}${x%/*}${x#*/}${x##*/}"') 2>/dev/null \
+    && _G_HAVE_XSI_OPS=yes
+
+if test yes = "$_G_HAVE_XSI_OPS"
+then
+  # This is an XSI compatible shell, allowing a faster implementation...
+  eval 'func_split_equals ()
+  {
+      $debug_cmd
+
+      func_split_equals_lhs=${1%%=*}
+      func_split_equals_rhs=${1#*=}
+      test "x$func_split_equals_lhs" = "x$1" \
+        && func_split_equals_rhs=
+  }'
+else
+  # ...otherwise fall back to using expr, which is often a shell builtin.
+  func_split_equals ()
+  {
+      $debug_cmd
+
+      func_split_equals_lhs=`expr "x$1" : 'x\([^=]*\)'`
+      func_split_equals_rhs=
+      test "x$func_split_equals_lhs" = "x$1" \
+        || func_split_equals_rhs=`expr "x$1" : 'x[^=]*=\(.*\)$'`
+  }
+fi #func_split_equals
+
+
+# func_split_short_opt SHORTOPT
+# -----------------------------
 # Set func_split_short_opt_name and func_split_short_opt_arg shell
 # variables after splitting SHORTOPT after the 2nd character.
-func_split_short_opt ()
+if test yes = "$_G_HAVE_XSI_OPS"
+then
+  # This is an XSI compatible shell, allowing a faster implementation...
+  eval 'func_split_short_opt ()
+  {
+      $debug_cmd
+
+      func_split_short_opt_arg=${1#??}
+      func_split_short_opt_name=${1%"$func_split_short_opt_arg"}
+  }'
+else
+  # ...otherwise fall back to using expr, which is often a shell builtin.
+  func_split_short_opt ()
+  {
+      $debug_cmd
+
+      func_split_short_opt_name=`expr "x$1" : 'x-\(.\)'`
+      func_split_short_opt_arg=`expr "x$1" : 'x-.\(.*\)$'`
+  }
+fi #func_split_short_opt
+
+
+# func_usage
+# ----------
+# Echo short help message to standard output and exit.
+func_usage ()
 {
-    my_sed_short_opt='1s/^\(..\).*$/\1/;q'
-    my_sed_short_rest='1s/^..\(.*\)$/\1/;q'
+    $debug_cmd
 
-    func_split_short_opt_name=`$ECHO "$1" | $SED "$my_sed_short_opt"`
-    func_split_short_opt_arg=`$ECHO "$1" | $SED "$my_sed_short_rest"`
-} # func_split_short_opt may be replaced by extended shell implementation
+    func_usage_message
+    $ECHO "Run '$progname --help |${PAGER-more}' for full usage"
+    exit 0
+}
 
 
-# func_split_long_opt longopt
-# Set func_split_long_opt_name and func_split_long_opt_arg shell
-# variables after splitting LONGOPT at the `=' sign.
-func_split_long_opt ()
+# func_usage_message
+# ------------------
+# Echo short help message to standard output.
+func_usage_message ()
 {
-    my_sed_long_opt='1s/^\(--[^=]*\)=.*/\1/;q'
-    my_sed_long_arg='1s/^--[^=]*=//'
+    $debug_cmd
 
-    func_split_long_opt_name=`$ECHO "$1" | $SED "$my_sed_long_opt"`
-    func_split_long_opt_arg=`$ECHO "$1" | $SED "$my_sed_long_arg"`
-} # func_split_long_opt may be replaced by extended shell implementation
+    eval \$ECHO \""Usage: $usage"\"
+    echo
+    $SED -n 's|^# ||
+        /^Written by/{
+          x;p;x
+        }
+	h
+	/^Written by/q' < "$progpath"
+    echo
+    eval \$ECHO \""$usage_message"\"
+}
 
-exit_cmd=:
 
+# func_version
+# ------------
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $debug_cmd
 
+    printf '%s\n' "$progname $scriptversion"
+    $SED -n '
+        /(C)/!b go
+        :more
+        /\./!{
+          N
+          s|\n# | |
+          b more
+        }
+        :go
+        /^# Written by /,/# warranty; / {
+          s|^# ||
+          s|^# *$||
+          s|\((C)\)[ 0-9,-]*[ ,-]\([1-9][0-9]* \)|\1 \2|
+          p
+        }
+        /^# Written by / {
+          s|^# ||
+          p
+        }
+        /^warranty; /q' < "$progpath"
 
+    exit $?
+}
 
 
-magic="%%%MAGIC variable%%%"
-magic_exe="%%%MAGIC EXE variable%%%"
+# Local variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-pattern: "10/scriptversion=%:y-%02m-%02d.%02H; # UTC"
+# time-stamp-time-zone: "UTC"
+# End:
 
-# Global variables.
-nonopt=
-preserve_args=
-lo2o="s/\\.lo\$/.${objext}/"
-o2lo="s/\\.${objext}\$/.lo/"
-extracted_archives=
-extracted_serial=0
+# Set a version string.
+scriptversion='(GNU libtool) 2.4.6 Debian-2.4.6-1'
 
-# If this variable is set in any of the actions, the command in it
-# will be execed at the end.  This prevents here-documents from being
-# left over by shells.
-exec_cmd=
 
-# func_append var value
-# Append VALUE to the end of shell variable VAR.
-func_append ()
+# func_echo ARG...
+# ----------------
+# Libtool also displays the current mode in messages, so override
+# funclib.sh func_echo with this custom definition.
+func_echo ()
 {
-    eval "${1}=\$${1}\${2}"
-} # func_append may be replaced by extended shell implementation
+    $debug_cmd
 
-# func_append_quoted var value
-# Quote VALUE and append to the end of shell variable VAR, separated
-# by a space.
-func_append_quoted ()
-{
-    func_quote_for_eval "${2}"
-    eval "${1}=\$${1}\\ \$func_quote_for_eval_result"
-} # func_append_quoted may be replaced by extended shell implementation
+    _G_message=$*
 
+    func_echo_IFS=$IFS
+    IFS=$nl
+    for _G_line in $_G_message; do
+      IFS=$func_echo_IFS
+      $ECHO "$progname${opt_mode+: $opt_mode}: $_G_line"
+    done
+    IFS=$func_echo_IFS
+}
 
-# func_arith arithmetic-term...
-func_arith ()
+
+# func_warning ARG...
+# -------------------
+# Libtool warnings are not categorized, so override funclib.sh
+# func_warning with this simpler definition.
+func_warning ()
 {
-    func_arith_result=`expr "${@}"`
-} # func_arith may be replaced by extended shell implementation
+    $debug_cmd
 
+    $warning_func ${1+"$@"}
+}
 
-# func_len string
-# STRING may not start with a hyphen.
-func_len ()
-{
-    func_len_result=`expr "${1}" : ".*" 2>/dev/null || echo $max_cmd_len`
-} # func_len may be replaced by extended shell implementation
 
+## ---------------- ##
+## Options parsing. ##
+## ---------------- ##
+
+# Hook in the functions to make sure our own options are parsed during
+# the option parsing loop.
+
+usage='$progpath [OPTION]... [MODE-ARG]...'
+
+# Short help message in response to '-h'.
+usage_message="Options:
+       --config             show all configuration variables
+       --debug              enable verbose shell tracing
+   -n, --dry-run            display commands without modifying any files
+       --features           display basic configuration information and exit
+       --mode=MODE          use operation mode MODE
+       --no-warnings        equivalent to '-Wnone'
+       --preserve-dup-deps  don't remove duplicate dependency libraries
+       --quiet, --silent    don't print informational messages
+       --tag=TAG            use configuration variables from tag TAG
+   -v, --verbose            print more informational messages than default
+       --version            print version information
+   -W, --warnings=CATEGORY  report the warnings falling in CATEGORY [all]
+   -h, --help, --help-all   print short, long, or detailed help message
+"
 
-# func_lo2o object
-func_lo2o ()
+# Additional text appended to 'usage_message' in response to '--help'.
+func_help ()
 {
-    func_lo2o_result=`$ECHO "${1}" | $SED "$lo2o"`
-} # func_lo2o may be replaced by extended shell implementation
+    $debug_cmd
+
+    func_usage_message
+    $ECHO "$long_help_message
+
+MODE must be one of the following:
+
+       clean           remove files from the build directory
+       compile         compile a source file into a libtool object
+       execute         automatically set library path, then run a program
+       finish          complete the installation of libtool libraries
+       install         install libraries or executables
+       link            create a library or an executable
+       uninstall       remove libraries from an installed directory
+
+MODE-ARGS vary depending on the MODE.  When passed as first option,
+'--mode=MODE' may be abbreviated as 'MODE' or a unique abbreviation of that.
+Try '$progname --help --mode=MODE' for a more detailed description of MODE.
+
+When reporting a bug, please describe a test case to reproduce it and
+include the following information:
+
+       host-triplet:   $host
+       shell:          $SHELL
+       compiler:       $LTCC
+       compiler flags: $LTCFLAGS
+       linker:         $LD (gnu? $with_gnu_ld)
+       version:        $progname $scriptversion
+       automake:       `($AUTOMAKE --version) 2>/dev/null |$SED 1q`
+       autoconf:       `($AUTOCONF --version) 2>/dev/null |$SED 1q`
+
+Report bugs to <bug-libtool@gnu.org>.
+GNU libtool home page: <http://www.gnu.org/s/libtool/>.
+General help using GNU software: <http://www.gnu.org/gethelp/>."
+    exit 0
+}
 
 
-# func_xform libobj-or-source
-func_xform ()
-{
-    func_xform_result=`$ECHO "${1}" | $SED 's/\.[^.]*$/.lo/'`
-} # func_xform may be replaced by extended shell implementation
+# func_lo2o OBJECT-NAME
+# ---------------------
+# Transform OBJECT-NAME from a '.lo' suffix to the platform specific
+# object suffix.
+
+lo2o=s/\\.lo\$/.$objext/
+o2lo=s/\\.$objext\$/.lo/
+
+if test yes = "$_G_HAVE_XSI_OPS"; then
+  eval 'func_lo2o ()
+  {
+    case $1 in
+      *.lo) func_lo2o_result=${1%.lo}.$objext ;;
+      *   ) func_lo2o_result=$1               ;;
+    esac
+  }'
+
+  # func_xform LIBOBJ-OR-SOURCE
+  # ---------------------------
+  # Transform LIBOBJ-OR-SOURCE from a '.o' or '.c' (or otherwise)
+  # suffix to a '.lo' libtool-object suffix.
+  eval 'func_xform ()
+  {
+    func_xform_result=${1%.*}.lo
+  }'
+else
+  # ...otherwise fall back to using sed.
+  func_lo2o ()
+  {
+    func_lo2o_result=`$ECHO "$1" | $SED "$lo2o"`
+  }
+
+  func_xform ()
+  {
+    func_xform_result=`$ECHO "$1" | $SED 's|\.[^.]*$|.lo|'`
+  }
+fi
 
 
-# func_fatal_configuration arg...
+# func_fatal_configuration ARG...
+# -------------------------------
 # Echo program name prefixed message to standard error, followed by
 # a configuration failure hint, and exit.
 func_fatal_configuration ()
 {
-    func_error ${1+"$@"}
-    func_error "See the $PACKAGE documentation for more information."
-    func_fatal_error "Fatal configuration error."
+    func__fatal_error ${1+"$@"} \
+      "See the $PACKAGE documentation for more information." \
+      "Fatal configuration error."
 }
 
 
 # func_config
+# -----------
 # Display the configuration for all the tags in this script.
 func_config ()
 {
@@ -915,17 +2149,19 @@ func_config ()
     exit $?
 }
 
+
 # func_features
+# -------------
 # Display the features supported by this script.
 func_features ()
 {
     echo "host: $host"
-    if test "$build_libtool_libs" = yes; then
+    if test yes = "$build_libtool_libs"; then
       echo "enable shared libraries"
     else
       echo "disable shared libraries"
     fi
-    if test "$build_old_libs" = yes; then
+    if test yes = "$build_old_libs"; then
       echo "enable static libraries"
     else
       echo "disable static libraries"
@@ -934,314 +2170,350 @@ func_features ()
     exit $?
 }
 
-# func_enable_tag tagname
+
+# func_enable_tag TAGNAME
+# -----------------------
 # Verify that TAGNAME is valid, and either flag an error and exit, or
 # enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
 # variable here.
 func_enable_tag ()
 {
-  # Global variable:
-  tagname="$1"
+    # Global variable:
+    tagname=$1
 
-  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
-  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
-  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+    re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+    re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+    sed_extractcf=/$re_begincf/,/$re_endcf/p
 
-  # Validate tagname.
-  case $tagname in
-    *[!-_A-Za-z0-9,/]*)
-      func_fatal_error "invalid tag name: $tagname"
-      ;;
-  esac
+    # Validate tagname.
+    case $tagname in
+      *[!-_A-Za-z0-9,/]*)
+        func_fatal_error "invalid tag name: $tagname"
+        ;;
+    esac
 
-  # Don't test for the "default" C tag, as we know it's
-  # there but not specially marked.
-  case $tagname in
-    CC) ;;
+    # Don't test for the "default" C tag, as we know it's
+    # there but not specially marked.
+    case $tagname in
+        CC) ;;
     *)
-      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
-	taglist="$taglist $tagname"
-
-	# Evaluate the configuration.  Be careful to quote the path
-	# and the sed script, to avoid splitting on whitespace, but
-	# also don't use non-portable quotes within backquotes within
-	# quotes we have to do it in 2 steps:
-	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
-	eval "$extractedcf"
-      else
-	func_error "ignoring unknown tag $tagname"
-      fi
-      ;;
-  esac
+        if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	  taglist="$taglist $tagname"
+
+	  # Evaluate the configuration.  Be careful to quote the path
+	  # and the sed script, to avoid splitting on whitespace, but
+	  # also don't use non-portable quotes within backquotes within
+	  # quotes we have to do it in 2 steps:
+	  extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	  eval "$extractedcf"
+        else
+	  func_error "ignoring unknown tag $tagname"
+        fi
+        ;;
+    esac
 }
 
+
 # func_check_version_match
+# ------------------------
 # Ensure that we are using m4 macros, and libtool script from the same
 # release of libtool.
 func_check_version_match ()
 {
-  if test "$package_revision" != "$macro_revision"; then
-    if test "$VERSION" != "$macro_version"; then
-      if test -z "$macro_version"; then
-        cat >&2 <<_LT_EOF
+    if test "$package_revision" != "$macro_revision"; then
+      if test "$VERSION" != "$macro_version"; then
+        if test -z "$macro_version"; then
+          cat >&2 <<_LT_EOF
 $progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
 $progname: definition of this LT_INIT comes from an older release.
 $progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
 $progname: and run autoconf again.
 _LT_EOF
-      else
-        cat >&2 <<_LT_EOF
+        else
+          cat >&2 <<_LT_EOF
 $progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
 $progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
 $progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
 $progname: and run autoconf again.
 _LT_EOF
-      fi
-    else
-      cat >&2 <<_LT_EOF
+        fi
+      else
+        cat >&2 <<_LT_EOF
 $progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
 $progname: but the definition of this LT_INIT comes from revision $macro_revision.
 $progname: You should recreate aclocal.m4 with macros from revision $package_revision
 $progname: of $PACKAGE $VERSION and run autoconf again.
 _LT_EOF
-    fi
+      fi
 
-    exit $EXIT_MISMATCH
-  fi
+      exit $EXIT_MISMATCH
+    fi
 }
 
 
-# Shorthand for --mode=foo, only valid as the first argument
-case $1 in
-clean|clea|cle|cl)
-  shift; set dummy --mode clean ${1+"$@"}; shift
-  ;;
-compile|compil|compi|comp|com|co|c)
-  shift; set dummy --mode compile ${1+"$@"}; shift
-  ;;
-execute|execut|execu|exec|exe|ex|e)
-  shift; set dummy --mode execute ${1+"$@"}; shift
-  ;;
-finish|finis|fini|fin|fi|f)
-  shift; set dummy --mode finish ${1+"$@"}; shift
-  ;;
-install|instal|insta|inst|ins|in|i)
-  shift; set dummy --mode install ${1+"$@"}; shift
-  ;;
-link|lin|li|l)
-  shift; set dummy --mode link ${1+"$@"}; shift
-  ;;
-uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
-  shift; set dummy --mode uninstall ${1+"$@"}; shift
-  ;;
-esac
+# libtool_options_prep [ARG]...
+# -----------------------------
+# Preparation for options parsed by libtool.
+libtool_options_prep ()
+{
+    $debug_mode
 
+    # Option defaults:
+    opt_config=false
+    opt_dlopen=
+    opt_dry_run=false
+    opt_help=false
+    opt_mode=
+    opt_preserve_dup_deps=false
+    opt_quiet=false
 
+    nonopt=
+    preserve_args=
 
-# Option defaults:
-opt_debug=:
-opt_dry_run=false
-opt_config=false
-opt_preserve_dup_deps=false
-opt_features=false
-opt_finish=false
-opt_help=false
-opt_help_all=false
-opt_silent=:
-opt_warning=:
-opt_verbose=:
-opt_silent=false
-opt_verbose=false
+    # Shorthand for --mode=foo, only valid as the first argument
+    case $1 in
+    clean|clea|cle|cl)
+      shift; set dummy --mode clean ${1+"$@"}; shift
+      ;;
+    compile|compil|compi|comp|com|co|c)
+      shift; set dummy --mode compile ${1+"$@"}; shift
+      ;;
+    execute|execut|execu|exec|exe|ex|e)
+      shift; set dummy --mode execute ${1+"$@"}; shift
+      ;;
+    finish|finis|fini|fin|fi|f)
+      shift; set dummy --mode finish ${1+"$@"}; shift
+      ;;
+    install|instal|insta|inst|ins|in|i)
+      shift; set dummy --mode install ${1+"$@"}; shift
+      ;;
+    link|lin|li|l)
+      shift; set dummy --mode link ${1+"$@"}; shift
+      ;;
+    uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+      shift; set dummy --mode uninstall ${1+"$@"}; shift
+      ;;
+    esac
+
+    # Pass back the list of options.
+    func_quote_for_eval ${1+"$@"}
+    libtool_options_prep_result=$func_quote_for_eval_result
+}
+func_add_hook func_options_prep libtool_options_prep
 
 
-# Parse options once, thoroughly.  This comes as soon as possible in the
-# script to make things like `--version' happen as quickly as we can.
+# libtool_parse_options [ARG]...
+# ---------------------------------
+# Provide handling for libtool specific options.
+libtool_parse_options ()
 {
-  # this just eases exit handling
-  while test $# -gt 0; do
-    opt="$1"
-    shift
-    case $opt in
-      --debug|-x)	opt_debug='set -x'
-			func_echo "enabling shell trace mode"
-			$opt_debug
-			;;
-      --dry-run|--dryrun|-n)
-			opt_dry_run=:
-			;;
-      --config)
-			opt_config=:
-func_config
-			;;
-      --dlopen|-dlopen)
-			optarg="$1"
-			opt_dlopen="${opt_dlopen+$opt_dlopen
-}$optarg"
-			shift
-			;;
-      --preserve-dup-deps)
-			opt_preserve_dup_deps=:
-			;;
-      --features)
-			opt_features=:
-func_features
-			;;
-      --finish)
-			opt_finish=:
-set dummy --mode finish ${1+"$@"}; shift
-			;;
-      --help)
-			opt_help=:
-			;;
-      --help-all)
-			opt_help_all=:
-opt_help=': help-all'
-			;;
-      --mode)
-			test $# = 0 && func_missing_arg $opt && break
-			optarg="$1"
-			opt_mode="$optarg"
-case $optarg in
-  # Valid mode arguments:
-  clean|compile|execute|finish|install|link|relink|uninstall) ;;
-
-  # Catch anything else as an error
-  *) func_error "invalid argument for $opt"
-     exit_cmd=exit
-     break
-     ;;
-esac
-			shift
-			;;
-      --no-silent|--no-quiet)
-			opt_silent=false
-func_append preserve_args " $opt"
-			;;
-      --no-warning|--no-warn)
-			opt_warning=false
-func_append preserve_args " $opt"
-			;;
-      --no-verbose)
-			opt_verbose=false
-func_append preserve_args " $opt"
-			;;
-      --silent|--quiet)
-			opt_silent=:
-func_append preserve_args " $opt"
-        opt_verbose=false
-			;;
-      --verbose|-v)
-			opt_verbose=:
-func_append preserve_args " $opt"
-opt_silent=false
-			;;
-      --tag)
-			test $# = 0 && func_missing_arg $opt && break
-			optarg="$1"
-			opt_tag="$optarg"
-func_append preserve_args " $opt $optarg"
-func_enable_tag "$optarg"
-			shift
-			;;
-
-      -\?|-h)		func_usage				;;
-      --help)		func_help				;;
-      --version)	func_version				;;
-
-      # Separate optargs to long options:
-      --*=*)
-			func_split_long_opt "$opt"
-			set dummy "$func_split_long_opt_name" "$func_split_long_opt_arg" ${1+"$@"}
-			shift
-			;;
-
-      # Separate non-argument short options:
-      -\?*|-h*|-n*|-v*)
-			func_split_short_opt "$opt"
-			set dummy "$func_split_short_opt_name" "-$func_split_short_opt_arg" ${1+"$@"}
-			shift
-			;;
-
-      --)		break					;;
-      -*)		func_fatal_help "unrecognized option \`$opt'" ;;
-      *)		set dummy "$opt" ${1+"$@"};	shift; break  ;;
-    esac
-  done
+    $debug_cmd
 
-  # Validate options:
+    # Perform our own loop to consume as many options as possible in
+    # each iteration.
+    while test $# -gt 0; do
+      _G_opt=$1
+      shift
+      case $_G_opt in
+        --dry-run|--dryrun|-n)
+                        opt_dry_run=:
+                        ;;
+
+        --config)       func_config ;;
+
+        --dlopen|-dlopen)
+                        opt_dlopen="${opt_dlopen+$opt_dlopen
+}$1"
+                        shift
+                        ;;
+
+        --preserve-dup-deps)
+                        opt_preserve_dup_deps=: ;;
+
+        --features)     func_features ;;
+
+        --finish)       set dummy --mode finish ${1+"$@"}; shift ;;
+
+        --help)         opt_help=: ;;
+
+        --help-all)     opt_help=': help-all' ;;
+
+        --mode)         test $# = 0 && func_missing_arg $_G_opt && break
+                        opt_mode=$1
+                        case $1 in
+                          # Valid mode arguments:
+                          clean|compile|execute|finish|install|link|relink|uninstall) ;;
+
+                          # Catch anything else as an error
+                          *) func_error "invalid argument for $_G_opt"
+                             exit_cmd=exit
+                             break
+                             ;;
+                        esac
+                        shift
+                        ;;
+
+        --no-silent|--no-quiet)
+                        opt_quiet=false
+                        func_append preserve_args " $_G_opt"
+                        ;;
+
+        --no-warnings|--no-warning|--no-warn)
+                        opt_warning=false
+                        func_append preserve_args " $_G_opt"
+                        ;;
+
+        --no-verbose)
+                        opt_verbose=false
+                        func_append preserve_args " $_G_opt"
+                        ;;
+
+        --silent|--quiet)
+                        opt_quiet=:
+                        opt_verbose=false
+                        func_append preserve_args " $_G_opt"
+                        ;;
+
+        --tag)          test $# = 0 && func_missing_arg $_G_opt && break
+                        opt_tag=$1
+                        func_append preserve_args " $_G_opt $1"
+                        func_enable_tag "$1"
+                        shift
+                        ;;
+
+        --verbose|-v)   opt_quiet=false
+                        opt_verbose=:
+                        func_append preserve_args " $_G_opt"
+                        ;;
+
+	# An option not handled by this hook function:
+        *)		set dummy "$_G_opt" ${1+"$@"};	shift; break  ;;
+      esac
+    done
 
-  # save first non-option argument
-  if test "$#" -gt 0; then
-    nonopt="$opt"
-    shift
-  fi
 
-  # preserve --debug
-  test "$opt_debug" = : || func_append preserve_args " --debug"
+    # save modified positional parameters for caller
+    func_quote_for_eval ${1+"$@"}
+    libtool_parse_options_result=$func_quote_for_eval_result
+}
+func_add_hook func_parse_options libtool_parse_options
 
-  case $host in
-    *cygwin* | *mingw* | *pw32* | *cegcc*)
-      # don't eliminate duplications in $postdeps and $predeps
-      opt_duplicate_compiler_generated_deps=:
-      ;;
-    *)
-      opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps
-      ;;
-  esac
 
-  $opt_help || {
-    # Sanity checks first:
-    func_check_version_match
 
-    if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
-      func_fatal_configuration "not configured to build any kind of library"
+# libtool_validate_options [ARG]...
+# ---------------------------------
+# Perform any sanity checks on option settings and/or unconsumed
+# arguments.
+libtool_validate_options ()
+{
+    # save first non-option argument
+    if test 0 -lt $#; then
+      nonopt=$1
+      shift
     fi
 
-    # Darwin sucks
-    eval std_shrext=\"$shrext_cmds\"
+    # preserve --debug
+    test : = "$debug_cmd" || func_append preserve_args " --debug"
 
-    # Only execute mode is allowed to have -dlopen flags.
-    if test -n "$opt_dlopen" && test "$opt_mode" != execute; then
-      func_error "unrecognized option \`-dlopen'"
-      $ECHO "$help" 1>&2
-      exit $EXIT_FAILURE
-    fi
+    case $host in
+      # Solaris2 added to fix http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16452
+      # see also: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59788
+      *cygwin* | *mingw* | *pw32* | *cegcc* | *solaris2* | *os2*)
+        # don't eliminate duplications in $postdeps and $predeps
+        opt_duplicate_compiler_generated_deps=:
+        ;;
+      *)
+        opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps
+        ;;
+    esac
 
-    # Change the help message to a mode-specific one.
-    generic_help="$help"
-    help="Try \`$progname --help --mode=$opt_mode' for more information."
-  }
+    $opt_help || {
+      # Sanity checks first:
+      func_check_version_match
+
+      test yes != "$build_libtool_libs" \
+        && test yes != "$build_old_libs" \
+        && func_fatal_configuration "not configured to build any kind of library"
+
+      # Darwin sucks
+      eval std_shrext=\"$shrext_cmds\"
+
+      # Only execute mode is allowed to have -dlopen flags.
+      if test -n "$opt_dlopen" && test execute != "$opt_mode"; then
+        func_error "unrecognized option '-dlopen'"
+        $ECHO "$help" 1>&2
+        exit $EXIT_FAILURE
+      fi
 
+      # Change the help message to a mode-specific one.
+      generic_help=$help
+      help="Try '$progname --help --mode=$opt_mode' for more information."
+    }
 
-  # Bail if the options were screwed
-  $exit_cmd $EXIT_FAILURE
+    # Pass back the unparsed argument list
+    func_quote_for_eval ${1+"$@"}
+    libtool_validate_options_result=$func_quote_for_eval_result
 }
+func_add_hook func_validate_options libtool_validate_options
 
 
+# Process options as early as possible so that --help and --version
+# can return quickly.
+func_options ${1+"$@"}
+eval set dummy "$func_options_result"; shift
+
 
 
 ## ----------- ##
 ##    Main.    ##
 ## ----------- ##
 
+magic='%%%MAGIC variable%%%'
+magic_exe='%%%MAGIC EXE variable%%%'
+
+# Global variables.
+extracted_archives=
+extracted_serial=0
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+$1
+_LTECHO_EOF'
+}
+
+# func_generated_by_libtool
+# True iff stdin has been generated by Libtool. This function is only
+# a basic sanity check; it will hardly flush out determined imposters.
+func_generated_by_libtool_p ()
+{
+  $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
 # func_lalib_p file
-# True iff FILE is a libtool `.la' library or `.lo' object file.
+# True iff FILE is a libtool '.la' library or '.lo' object file.
 # This function is only a basic sanity check; it will hardly flush out
 # determined imposters.
 func_lalib_p ()
 {
     test -f "$1" &&
-      $SED -e 4q "$1" 2>/dev/null \
-        | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+      $SED -e 4q "$1" 2>/dev/null | func_generated_by_libtool_p
 }
 
 # func_lalib_unsafe_p file
-# True iff FILE is a libtool `.la' library or `.lo' object file.
+# True iff FILE is a libtool '.la' library or '.lo' object file.
 # This function implements the same check as func_lalib_p without
 # resorting to external programs.  To this end, it redirects stdin and
 # closes it afterwards, without saving the original file descriptor.
 # As a safety measure, use it only where a negative result would be
-# fatal anyway.  Works if `file' does not exist.
+# fatal anyway.  Works if 'file' does not exist.
 func_lalib_unsafe_p ()
 {
     lalib_p=no
@@ -1249,13 +2521,13 @@ func_lalib_unsafe_p ()
 	for lalib_p_l in 1 2 3 4
 	do
 	    read lalib_p_line
-	    case "$lalib_p_line" in
+	    case $lalib_p_line in
 		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
 	    esac
 	done
 	exec 0<&5 5<&-
     fi
-    test "$lalib_p" = yes
+    test yes = "$lalib_p"
 }
 
 # func_ltwrapper_script_p file
@@ -1264,7 +2536,8 @@ func_lalib_unsafe_p ()
 # determined imposters.
 func_ltwrapper_script_p ()
 {
-    func_lalib_p "$1"
+    test -f "$1" &&
+      $lt_truncate_bin < "$1" 2>/dev/null | func_generated_by_libtool_p
 }
 
 # func_ltwrapper_executable_p file
@@ -1289,7 +2562,7 @@ func_ltwrapper_scriptname ()
 {
     func_dirname_and_basename "$1" "" "."
     func_stripname '' '.exe' "$func_basename_result"
-    func_ltwrapper_scriptname_result="$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper"
+    func_ltwrapper_scriptname_result=$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper
 }
 
 # func_ltwrapper_p file
@@ -1308,11 +2581,13 @@ func_ltwrapper_p ()
 # FAIL_CMD may read-access the current command in variable CMD!
 func_execute_cmds ()
 {
-    $opt_debug
+    $debug_cmd
+
     save_ifs=$IFS; IFS='~'
     for cmd in $1; do
-      IFS=$save_ifs
+      IFS=$sp$nl
       eval cmd=\"$cmd\"
+      IFS=$save_ifs
       func_show_eval "$cmd" "${2-:}"
     done
     IFS=$save_ifs
@@ -1324,10 +2599,11 @@ func_execute_cmds ()
 # Note that it is not necessary on cygwin/mingw to append a dot to
 # FILE even if both FILE and FILE.exe exist: automatic-append-.exe
 # behavior happens only for exec(3), not for open(2)!  Also, sourcing
-# `FILE.' does not work on cygwin managed mounts.
+# 'FILE.' does not work on cygwin managed mounts.
 func_source ()
 {
-    $opt_debug
+    $debug_cmd
+
     case $1 in
     */* | *\\*)	. "$1" ;;
     *)		. "./$1" ;;
@@ -1354,10 +2630,10 @@ func_resolve_sysroot ()
 # store the result into func_replace_sysroot_result.
 func_replace_sysroot ()
 {
-  case "$lt_sysroot:$1" in
+  case $lt_sysroot:$1 in
   ?*:"$lt_sysroot"*)
     func_stripname "$lt_sysroot" '' "$1"
-    func_replace_sysroot_result="=$func_stripname_result"
+    func_replace_sysroot_result='='$func_stripname_result
     ;;
   *)
     # Including no sysroot.
@@ -1374,7 +2650,8 @@ func_replace_sysroot ()
 # arg is usually of the form 'gcc ...'
 func_infer_tag ()
 {
-    $opt_debug
+    $debug_cmd
+
     if test -n "$available_tags" && test -z "$tagname"; then
       CC_quoted=
       for arg in $CC; do
@@ -1393,7 +2670,7 @@ func_infer_tag ()
 	for z in $available_tags; do
 	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
 	    # Evaluate the configuration.
-	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    eval "`$SED -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
 	    CC_quoted=
 	    for arg in $CC; do
 	      # Double-quote args containing other shell metacharacters.
@@ -1418,7 +2695,7 @@ func_infer_tag ()
 	# line option must be used.
 	if test -z "$tagname"; then
 	  func_echo "unable to infer tagged configuration"
-	  func_fatal_error "specify a tag with \`--tag'"
+	  func_fatal_error "specify a tag with '--tag'"
 #	else
 #	  func_verbose "using $tagname tagged configuration"
 	fi
@@ -1434,15 +2711,15 @@ func_infer_tag ()
 # but don't create it if we're doing a dry run.
 func_write_libtool_object ()
 {
-    write_libobj=${1}
-    if test "$build_libtool_libs" = yes; then
-      write_lobj=\'${2}\'
+    write_libobj=$1
+    if test yes = "$build_libtool_libs"; then
+      write_lobj=\'$2\'
     else
       write_lobj=none
     fi
 
-    if test "$build_old_libs" = yes; then
-      write_oldobj=\'${3}\'
+    if test yes = "$build_old_libs"; then
+      write_oldobj=\'$3\'
     else
       write_oldobj=none
     fi
@@ -1450,7 +2727,7 @@ func_write_libtool_object ()
     $opt_dry_run || {
       cat >${write_libobj}T <<EOF
 # $write_libobj - a libtool object file
-# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+# Generated by $PROGRAM (GNU $PACKAGE) $VERSION
 #
 # Please DO NOT delete this file!
 # It is necessary for linking the library.
@@ -1462,7 +2739,7 @@ pic_object=$write_lobj
 non_pic_object=$write_oldobj
 
 EOF
-      $MV "${write_libobj}T" "${write_libobj}"
+      $MV "${write_libobj}T" "$write_libobj"
     }
 }
 
@@ -1482,8 +2759,9 @@ EOF
 # be empty on error (or when ARG is empty)
 func_convert_core_file_wine_to_w32 ()
 {
-  $opt_debug
-  func_convert_core_file_wine_to_w32_result="$1"
+  $debug_cmd
+
+  func_convert_core_file_wine_to_w32_result=$1
   if test -n "$1"; then
     # Unfortunately, winepath does not exit with a non-zero error code, so we
     # are forced to check the contents of stdout. On the other hand, if the
@@ -1491,9 +2769,9 @@ func_convert_core_file_wine_to_w32 ()
     # *an error message* to stdout. So we must check for both error code of
     # zero AND non-empty stdout, which explains the odd construction:
     func_convert_core_file_wine_to_w32_tmp=`winepath -w "$1" 2>/dev/null`
-    if test "$?" -eq 0 && test -n "${func_convert_core_file_wine_to_w32_tmp}"; then
+    if test "$?" -eq 0 && test -n "$func_convert_core_file_wine_to_w32_tmp"; then
       func_convert_core_file_wine_to_w32_result=`$ECHO "$func_convert_core_file_wine_to_w32_tmp" |
-        $SED -e "$lt_sed_naive_backslashify"`
+        $SED -e "$sed_naive_backslashify"`
     else
       func_convert_core_file_wine_to_w32_result=
     fi
@@ -1514,18 +2792,19 @@ func_convert_core_file_wine_to_w32 ()
 # are convertible, then the result may be empty.
 func_convert_core_path_wine_to_w32 ()
 {
-  $opt_debug
+  $debug_cmd
+
   # unfortunately, winepath doesn't convert paths, only file names
-  func_convert_core_path_wine_to_w32_result=""
+  func_convert_core_path_wine_to_w32_result=
   if test -n "$1"; then
     oldIFS=$IFS
     IFS=:
     for func_convert_core_path_wine_to_w32_f in $1; do
       IFS=$oldIFS
       func_convert_core_file_wine_to_w32 "$func_convert_core_path_wine_to_w32_f"
-      if test -n "$func_convert_core_file_wine_to_w32_result" ; then
+      if test -n "$func_convert_core_file_wine_to_w32_result"; then
         if test -z "$func_convert_core_path_wine_to_w32_result"; then
-          func_convert_core_path_wine_to_w32_result="$func_convert_core_file_wine_to_w32_result"
+          func_convert_core_path_wine_to_w32_result=$func_convert_core_file_wine_to_w32_result
         else
           func_append func_convert_core_path_wine_to_w32_result ";$func_convert_core_file_wine_to_w32_result"
         fi
@@ -1554,7 +2833,8 @@ func_convert_core_path_wine_to_w32 ()
 # environment variable; do not put it in $PATH.
 func_cygpath ()
 {
-  $opt_debug
+  $debug_cmd
+
   if test -n "$LT_CYGPATH" && test -f "$LT_CYGPATH"; then
     func_cygpath_result=`$LT_CYGPATH "$@" 2>/dev/null`
     if test "$?" -ne 0; then
@@ -1563,7 +2843,7 @@ func_cygpath ()
     fi
   else
     func_cygpath_result=
-    func_error "LT_CYGPATH is empty or specifies non-existent file: \`$LT_CYGPATH'"
+    func_error "LT_CYGPATH is empty or specifies non-existent file: '$LT_CYGPATH'"
   fi
 }
 #end: func_cygpath
@@ -1574,10 +2854,11 @@ func_cygpath ()
 # result in func_convert_core_msys_to_w32_result.
 func_convert_core_msys_to_w32 ()
 {
-  $opt_debug
+  $debug_cmd
+
   # awkward: cmd appends spaces to result
   func_convert_core_msys_to_w32_result=`( cmd //c echo "$1" ) 2>/dev/null |
-    $SED -e 's/[ ]*$//' -e "$lt_sed_naive_backslashify"`
+    $SED -e 's/[ ]*$//' -e "$sed_naive_backslashify"`
 }
 #end: func_convert_core_msys_to_w32
 
@@ -1588,13 +2869,14 @@ func_convert_core_msys_to_w32 ()
 # func_to_host_file_result to ARG1).
 func_convert_file_check ()
 {
-  $opt_debug
-  if test -z "$2" && test -n "$1" ; then
+  $debug_cmd
+
+  if test -z "$2" && test -n "$1"; then
     func_error "Could not determine host file name corresponding to"
-    func_error "  \`$1'"
+    func_error "  '$1'"
     func_error "Continuing, but uninstalled executables may not work."
     # Fallback:
-    func_to_host_file_result="$1"
+    func_to_host_file_result=$1
   fi
 }
 # end func_convert_file_check
@@ -1606,10 +2888,11 @@ func_convert_file_check ()
 # func_to_host_file_result to a simplistic fallback value (see below).
 func_convert_path_check ()
 {
-  $opt_debug
+  $debug_cmd
+
   if test -z "$4" && test -n "$3"; then
     func_error "Could not determine the host path corresponding to"
-    func_error "  \`$3'"
+    func_error "  '$3'"
     func_error "Continuing, but uninstalled executables may not work."
     # Fallback.  This is a deliberately simplistic "conversion" and
     # should not be "improved".  See libtool.info.
@@ -1618,7 +2901,7 @@ func_convert_path_check ()
       func_to_host_path_result=`echo "$3" |
         $SED -e "$lt_replace_pathsep_chars"`
     else
-      func_to_host_path_result="$3"
+      func_to_host_path_result=$3
     fi
   fi
 }
@@ -1630,9 +2913,10 @@ func_convert_path_check ()
 # and appending REPL if ORIG matches BACKPAT.
 func_convert_path_front_back_pathsep ()
 {
-  $opt_debug
+  $debug_cmd
+
   case $4 in
-  $1 ) func_to_host_path_result="$3$func_to_host_path_result"
+  $1 ) func_to_host_path_result=$3$func_to_host_path_result
     ;;
   esac
   case $4 in
@@ -1646,7 +2930,7 @@ func_convert_path_front_back_pathsep ()
 ##################################################
 # $build to $host FILE NAME CONVERSION FUNCTIONS #
 ##################################################
-# invoked via `$to_host_file_cmd ARG'
+# invoked via '$to_host_file_cmd ARG'
 #
 # In each case, ARG is the path to be converted from $build to $host format.
 # Result will be available in $func_to_host_file_result.
@@ -1657,7 +2941,8 @@ func_convert_path_front_back_pathsep ()
 # in func_to_host_file_result.
 func_to_host_file ()
 {
-  $opt_debug
+  $debug_cmd
+
   $to_host_file_cmd "$1"
 }
 # end func_to_host_file
@@ -1669,7 +2954,8 @@ func_to_host_file ()
 # in (the comma separated) LAZY, no conversion takes place.
 func_to_tool_file ()
 {
-  $opt_debug
+  $debug_cmd
+
   case ,$2, in
     *,"$to_tool_file_cmd",*)
       func_to_tool_file_result=$1
@@ -1687,7 +2973,7 @@ func_to_tool_file ()
 # Copy ARG to func_to_host_file_result.
 func_convert_file_noop ()
 {
-  func_to_host_file_result="$1"
+  func_to_host_file_result=$1
 }
 # end func_convert_file_noop
 
@@ -1698,11 +2984,12 @@ func_convert_file_noop ()
 # func_to_host_file_result.
 func_convert_file_msys_to_w32 ()
 {
-  $opt_debug
-  func_to_host_file_result="$1"
+  $debug_cmd
+
+  func_to_host_file_result=$1
   if test -n "$1"; then
     func_convert_core_msys_to_w32 "$1"
-    func_to_host_file_result="$func_convert_core_msys_to_w32_result"
+    func_to_host_file_result=$func_convert_core_msys_to_w32_result
   fi
   func_convert_file_check "$1" "$func_to_host_file_result"
 }
@@ -1714,8 +3001,9 @@ func_convert_file_msys_to_w32 ()
 # func_to_host_file_result.
 func_convert_file_cygwin_to_w32 ()
 {
-  $opt_debug
-  func_to_host_file_result="$1"
+  $debug_cmd
+
+  func_to_host_file_result=$1
   if test -n "$1"; then
     # because $build is cygwin, we call "the" cygpath in $PATH; no need to use
     # LT_CYGPATH in this case.
@@ -1731,11 +3019,12 @@ func_convert_file_cygwin_to_w32 ()
 # and a working winepath. Returns result in func_to_host_file_result.
 func_convert_file_nix_to_w32 ()
 {
-  $opt_debug
-  func_to_host_file_result="$1"
+  $debug_cmd
+
+  func_to_host_file_result=$1
   if test -n "$1"; then
     func_convert_core_file_wine_to_w32 "$1"
-    func_to_host_file_result="$func_convert_core_file_wine_to_w32_result"
+    func_to_host_file_result=$func_convert_core_file_wine_to_w32_result
   fi
   func_convert_file_check "$1" "$func_to_host_file_result"
 }
@@ -1747,12 +3036,13 @@ func_convert_file_nix_to_w32 ()
 # Returns result in func_to_host_file_result.
 func_convert_file_msys_to_cygwin ()
 {
-  $opt_debug
-  func_to_host_file_result="$1"
+  $debug_cmd
+
+  func_to_host_file_result=$1
   if test -n "$1"; then
     func_convert_core_msys_to_w32 "$1"
     func_cygpath -u "$func_convert_core_msys_to_w32_result"
-    func_to_host_file_result="$func_cygpath_result"
+    func_to_host_file_result=$func_cygpath_result
   fi
   func_convert_file_check "$1" "$func_to_host_file_result"
 }
@@ -1765,13 +3055,14 @@ func_convert_file_msys_to_cygwin ()
 # in func_to_host_file_result.
 func_convert_file_nix_to_cygwin ()
 {
-  $opt_debug
-  func_to_host_file_result="$1"
+  $debug_cmd
+
+  func_to_host_file_result=$1
   if test -n "$1"; then
     # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.
     func_convert_core_file_wine_to_w32 "$1"
     func_cygpath -u "$func_convert_core_file_wine_to_w32_result"
-    func_to_host_file_result="$func_cygpath_result"
+    func_to_host_file_result=$func_cygpath_result
   fi
   func_convert_file_check "$1" "$func_to_host_file_result"
 }
@@ -1781,7 +3072,7 @@ func_convert_file_nix_to_cygwin ()
 #############################################
 # $build to $host PATH CONVERSION FUNCTIONS #
 #############################################
-# invoked via `$to_host_path_cmd ARG'
+# invoked via '$to_host_path_cmd ARG'
 #
 # In each case, ARG is the path to be converted from $build to $host format.
 # The result will be available in $func_to_host_path_result.
@@ -1805,10 +3096,11 @@ func_convert_file_nix_to_cygwin ()
 to_host_path_cmd=
 func_init_to_host_path_cmd ()
 {
-  $opt_debug
+  $debug_cmd
+
   if test -z "$to_host_path_cmd"; then
     func_stripname 'func_convert_file_' '' "$to_host_file_cmd"
-    to_host_path_cmd="func_convert_path_${func_stripname_result}"
+    to_host_path_cmd=func_convert_path_$func_stripname_result
   fi
 }
 
@@ -1818,7 +3110,8 @@ func_init_to_host_path_cmd ()
 # in func_to_host_path_result.
 func_to_host_path ()
 {
-  $opt_debug
+  $debug_cmd
+
   func_init_to_host_path_cmd
   $to_host_path_cmd "$1"
 }
@@ -1829,7 +3122,7 @@ func_to_host_path ()
 # Copy ARG to func_to_host_path_result.
 func_convert_path_noop ()
 {
-  func_to_host_path_result="$1"
+  func_to_host_path_result=$1
 }
 # end func_convert_path_noop
 
@@ -1840,8 +3133,9 @@ func_convert_path_noop ()
 # func_to_host_path_result.
 func_convert_path_msys_to_w32 ()
 {
-  $opt_debug
-  func_to_host_path_result="$1"
+  $debug_cmd
+
+  func_to_host_path_result=$1
   if test -n "$1"; then
     # Remove leading and trailing path separator characters from ARG.  MSYS
     # behavior is inconsistent here; cygpath turns them into '.;' and ';.';
@@ -1849,7 +3143,7 @@ func_convert_path_msys_to_w32 ()
     func_stripname : : "$1"
     func_to_host_path_tmp1=$func_stripname_result
     func_convert_core_msys_to_w32 "$func_to_host_path_tmp1"
-    func_to_host_path_result="$func_convert_core_msys_to_w32_result"
+    func_to_host_path_result=$func_convert_core_msys_to_w32_result
     func_convert_path_check : ";" \
       "$func_to_host_path_tmp1" "$func_to_host_path_result"
     func_convert_path_front_back_pathsep ":*" "*:" ";" "$1"
@@ -1863,8 +3157,9 @@ func_convert_path_msys_to_w32 ()
 # func_to_host_file_result.
 func_convert_path_cygwin_to_w32 ()
 {
-  $opt_debug
-  func_to_host_path_result="$1"
+  $debug_cmd
+
+  func_to_host_path_result=$1
   if test -n "$1"; then
     # See func_convert_path_msys_to_w32:
     func_stripname : : "$1"
@@ -1883,14 +3178,15 @@ func_convert_path_cygwin_to_w32 ()
 # a working winepath.  Returns result in func_to_host_file_result.
 func_convert_path_nix_to_w32 ()
 {
-  $opt_debug
-  func_to_host_path_result="$1"
+  $debug_cmd
+
+  func_to_host_path_result=$1
   if test -n "$1"; then
     # See func_convert_path_msys_to_w32:
     func_stripname : : "$1"
     func_to_host_path_tmp1=$func_stripname_result
     func_convert_core_path_wine_to_w32 "$func_to_host_path_tmp1"
-    func_to_host_path_result="$func_convert_core_path_wine_to_w32_result"
+    func_to_host_path_result=$func_convert_core_path_wine_to_w32_result
     func_convert_path_check : ";" \
       "$func_to_host_path_tmp1" "$func_to_host_path_result"
     func_convert_path_front_back_pathsep ":*" "*:" ";" "$1"
@@ -1904,15 +3200,16 @@ func_convert_path_nix_to_w32 ()
 # Returns result in func_to_host_file_result.
 func_convert_path_msys_to_cygwin ()
 {
-  $opt_debug
-  func_to_host_path_result="$1"
+  $debug_cmd
+
+  func_to_host_path_result=$1
   if test -n "$1"; then
     # See func_convert_path_msys_to_w32:
     func_stripname : : "$1"
     func_to_host_path_tmp1=$func_stripname_result
     func_convert_core_msys_to_w32 "$func_to_host_path_tmp1"
     func_cygpath -u -p "$func_convert_core_msys_to_w32_result"
-    func_to_host_path_result="$func_cygpath_result"
+    func_to_host_path_result=$func_cygpath_result
     func_convert_path_check : : \
       "$func_to_host_path_tmp1" "$func_to_host_path_result"
     func_convert_path_front_back_pathsep ":*" "*:" : "$1"
@@ -1927,8 +3224,9 @@ func_convert_path_msys_to_cygwin ()
 # func_to_host_file_result.
 func_convert_path_nix_to_cygwin ()
 {
-  $opt_debug
-  func_to_host_path_result="$1"
+  $debug_cmd
+
+  func_to_host_path_result=$1
   if test -n "$1"; then
     # Remove leading and trailing path separator characters from
     # ARG. msys behavior is inconsistent here, cygpath turns them
@@ -1937,7 +3235,7 @@ func_convert_path_nix_to_cygwin ()
     func_to_host_path_tmp1=$func_stripname_result
     func_convert_core_path_wine_to_w32 "$func_to_host_path_tmp1"
     func_cygpath -u -p "$func_convert_core_path_wine_to_w32_result"
-    func_to_host_path_result="$func_cygpath_result"
+    func_to_host_path_result=$func_cygpath_result
     func_convert_path_check : : \
       "$func_to_host_path_tmp1" "$func_to_host_path_result"
     func_convert_path_front_back_pathsep ":*" "*:" : "$1"
@@ -1946,13 +3244,31 @@ func_convert_path_nix_to_cygwin ()
 # end func_convert_path_nix_to_cygwin
 
 
+# func_dll_def_p FILE
+# True iff FILE is a Windows DLL '.def' file.
+# Keep in sync with _LT_DLL_DEF_P in libtool.m4
+func_dll_def_p ()
+{
+  $debug_cmd
+
+  func_dll_def_p_tmp=`$SED -n \
+    -e 's/^[	 ]*//' \
+    -e '/^\(;.*\)*$/d' \
+    -e 's/^\(EXPORTS\|LIBRARY\)\([	 ].*\)*$/DEF/p' \
+    -e q \
+    "$1"`
+  test DEF = "$func_dll_def_p_tmp"
+}
+
+
 # func_mode_compile arg...
 func_mode_compile ()
 {
-    $opt_debug
+    $debug_cmd
+
     # Get the compilation command and the source file.
     base_compile=
-    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    srcfile=$nonopt  #  always keep a non-empty value in "srcfile"
     suppress_opt=yes
     suppress_output=
     arg_mode=normal
@@ -1965,12 +3281,12 @@ func_mode_compile ()
       case $arg_mode in
       arg  )
 	# do not "continue".  Instead, add this to base_compile
-	lastarg="$arg"
+	lastarg=$arg
 	arg_mode=normal
 	;;
 
       target )
-	libobj="$arg"
+	libobj=$arg
 	arg_mode=normal
 	continue
 	;;
@@ -1980,7 +3296,7 @@ func_mode_compile ()
 	case $arg in
 	-o)
 	  test -n "$libobj" && \
-	    func_fatal_error "you cannot specify \`-o' more than once"
+	    func_fatal_error "you cannot specify '-o' more than once"
 	  arg_mode=target
 	  continue
 	  ;;
@@ -2009,12 +3325,12 @@ func_mode_compile ()
 	  func_stripname '-Wc,' '' "$arg"
 	  args=$func_stripname_result
 	  lastarg=
-	  save_ifs="$IFS"; IFS=','
+	  save_ifs=$IFS; IFS=,
 	  for arg in $args; do
-	    IFS="$save_ifs"
+	    IFS=$save_ifs
 	    func_append_quoted lastarg "$arg"
 	  done
-	  IFS="$save_ifs"
+	  IFS=$save_ifs
 	  func_stripname ' ' '' "$lastarg"
 	  lastarg=$func_stripname_result
 
@@ -2027,8 +3343,8 @@ func_mode_compile ()
 	  # Accept the current argument as the source file.
 	  # The previous "srcfile" becomes the current argument.
 	  #
-	  lastarg="$srcfile"
-	  srcfile="$arg"
+	  lastarg=$srcfile
+	  srcfile=$arg
 	  ;;
 	esac  #  case $arg
 	;;
@@ -2043,13 +3359,13 @@ func_mode_compile ()
       func_fatal_error "you must specify an argument for -Xcompile"
       ;;
     target)
-      func_fatal_error "you must specify a target with \`-o'"
+      func_fatal_error "you must specify a target with '-o'"
       ;;
     *)
       # Get the name of the library object.
       test -z "$libobj" && {
 	func_basename "$srcfile"
-	libobj="$func_basename_result"
+	libobj=$func_basename_result
       }
       ;;
     esac
@@ -2069,7 +3385,7 @@ func_mode_compile ()
     case $libobj in
     *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
     *)
-      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      func_fatal_error "cannot determine name of library object from '$libobj'"
       ;;
     esac
 
@@ -2078,8 +3394,8 @@ func_mode_compile ()
     for arg in $later; do
       case $arg in
       -shared)
-	test "$build_libtool_libs" != yes && \
-	  func_fatal_configuration "can not build a shared library"
+	test yes = "$build_libtool_libs" \
+	  || func_fatal_configuration "cannot build a shared library"
 	build_old_libs=no
 	continue
 	;;
@@ -2105,17 +3421,17 @@ func_mode_compile ()
     func_quote_for_eval "$libobj"
     test "X$libobj" != "X$func_quote_for_eval_result" \
       && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"'	 &()|`$[]' \
-      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+      && func_warning "libobj name '$libobj' may not contain shell special characters."
     func_dirname_and_basename "$obj" "/" ""
-    objname="$func_basename_result"
-    xdir="$func_dirname_result"
-    lobj=${xdir}$objdir/$objname
+    objname=$func_basename_result
+    xdir=$func_dirname_result
+    lobj=$xdir$objdir/$objname
 
     test -z "$base_compile" && \
       func_fatal_help "you must specify a compilation command"
 
     # Delete any leftover library objects.
-    if test "$build_old_libs" = yes; then
+    if test yes = "$build_old_libs"; then
       removelist="$obj $lobj $libobj ${libobj}T"
     else
       removelist="$lobj $libobj ${libobj}T"
@@ -2127,16 +3443,16 @@ func_mode_compile ()
       pic_mode=default
       ;;
     esac
-    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+    if test no = "$pic_mode" && test pass_all != "$deplibs_check_method"; then
       # non-PIC code in shared libraries is not supported
       pic_mode=default
     fi
 
     # Calculate the filename of the output object if compiler does
     # not support -o with -c
-    if test "$compiler_c_o" = no; then
-      output_obj=`$ECHO "$srcfile" | $SED 's%^.*/%%; s%\.[^.]*$%%'`.${objext}
-      lockfile="$output_obj.lock"
+    if test no = "$compiler_c_o"; then
+      output_obj=`$ECHO "$srcfile" | $SED 's%^.*/%%; s%\.[^.]*$%%'`.$objext
+      lockfile=$output_obj.lock
     else
       output_obj=
       need_locks=no
@@ -2145,12 +3461,12 @@ func_mode_compile ()
 
     # Lock this critical section if it is needed
     # We use this script file to make the link, it avoids creating a new file
-    if test "$need_locks" = yes; then
+    if test yes = "$need_locks"; then
       until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
 	func_echo "Waiting for $lockfile to be removed"
 	sleep 2
       done
-    elif test "$need_locks" = warn; then
+    elif test warn = "$need_locks"; then
       if test -f "$lockfile"; then
 	$ECHO "\
 *** ERROR, $lockfile exists and contains:
@@ -2158,7 +3474,7 @@ func_mode_compile ()
 
 This indicates that another process is trying to use the same
 temporary object file, and libtool could not work around it because
-your compiler does not support \`-c' and \`-o' together.  If you
+your compiler does not support '-c' and '-o' together.  If you
 repeat this compilation, it may succeed, by chance, but you had better
 avoid parallel builds (make -j) in this platform, or get a better
 compiler."
@@ -2180,11 +3496,11 @@ compiler."
     qsrcfile=$func_quote_for_eval_result
 
     # Only build a PIC object if we are building libtool libraries.
-    if test "$build_libtool_libs" = yes; then
+    if test yes = "$build_libtool_libs"; then
       # Without this assignment, base_compile gets emptied.
       fbsd_hideous_sh_bug=$base_compile
 
-      if test "$pic_mode" != no; then
+      if test no != "$pic_mode"; then
 	command="$base_compile $qsrcfile $pic_flag"
       else
 	# Don't build PIC code
@@ -2201,7 +3517,7 @@ compiler."
       func_show_eval_locale "$command"	\
           'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
 
-      if test "$need_locks" = warn &&
+      if test warn = "$need_locks" &&
 	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
 	$ECHO "\
 *** ERROR, $lockfile contains:
@@ -2212,7 +3528,7 @@ $srcfile
 
 This indicates that another process is trying to use the same
 temporary object file, and libtool could not work around it because
-your compiler does not support \`-c' and \`-o' together.  If you
+your compiler does not support '-c' and '-o' together.  If you
 repeat this compilation, it may succeed, by chance, but you had better
 avoid parallel builds (make -j) in this platform, or get a better
 compiler."
@@ -2228,20 +3544,20 @@ compiler."
       fi
 
       # Allow error messages only from the first compilation.
-      if test "$suppress_opt" = yes; then
+      if test yes = "$suppress_opt"; then
 	suppress_output=' >/dev/null 2>&1'
       fi
     fi
 
     # Only build a position-dependent object if we build old libraries.
-    if test "$build_old_libs" = yes; then
-      if test "$pic_mode" != yes; then
+    if test yes = "$build_old_libs"; then
+      if test yes != "$pic_mode"; then
 	# Don't build PIC code
 	command="$base_compile $qsrcfile$pie_flag"
       else
 	command="$base_compile $qsrcfile $pic_flag"
       fi
-      if test "$compiler_c_o" = yes; then
+      if test yes = "$compiler_c_o"; then
 	func_append command " -o $obj"
       fi
 
@@ -2250,7 +3566,7 @@ compiler."
       func_show_eval_locale "$command" \
         '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
 
-      if test "$need_locks" = warn &&
+      if test warn = "$need_locks" &&
 	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
 	$ECHO "\
 *** ERROR, $lockfile contains:
@@ -2261,7 +3577,7 @@ $srcfile
 
 This indicates that another process is trying to use the same
 temporary object file, and libtool could not work around it because
-your compiler does not support \`-c' and \`-o' together.  If you
+your compiler does not support '-c' and '-o' together.  If you
 repeat this compilation, it may succeed, by chance, but you had better
 avoid parallel builds (make -j) in this platform, or get a better
 compiler."
@@ -2281,7 +3597,7 @@ compiler."
       func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
 
       # Unlock the critical section if it was locked
-      if test "$need_locks" != no; then
+      if test no != "$need_locks"; then
 	removelist=$lockfile
         $RM "$lockfile"
       fi
@@ -2291,7 +3607,7 @@ compiler."
 }
 
 $opt_help || {
-  test "$opt_mode" = compile && func_mode_compile ${1+"$@"}
+  test compile = "$opt_mode" && func_mode_compile ${1+"$@"}
 }
 
 func_mode_help ()
@@ -2311,7 +3627,7 @@ func_mode_help ()
 Remove files from the build directory.
 
 RM is the name of the program to use to delete files associated with each FILE
-(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed
 to RM.
 
 If FILE is a libtool library, object or program, all the files associated
@@ -2330,16 +3646,16 @@ This mode accepts the following additional options:
   -no-suppress      do not suppress compiler output for multiple passes
   -prefer-pic       try to build PIC objects only
   -prefer-non-pic   try to build non-PIC objects only
-  -shared           do not build a \`.o' file suitable for static linking
-  -static           only build a \`.o' file suitable for static linking
+  -shared           do not build a '.o' file suitable for static linking
+  -static           only build a '.o' file suitable for static linking
   -Wc,FLAG          pass FLAG directly to the compiler
 
-COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+COMPILE-COMMAND is a command to be used in creating a 'standard' object file
 from the given SOURCEFILE.
 
 The output file name is determined by removing the directory component from
-SOURCEFILE, then substituting the C source code suffix \`.c' with the
-library object suffix, \`.lo'."
+SOURCEFILE, then substituting the C source code suffix '.c' with the
+library object suffix, '.lo'."
         ;;
 
       execute)
@@ -2352,7 +3668,7 @@ This mode accepts the following additional options:
 
   -dlopen FILE      add the directory containing FILE to the library path
 
-This mode sets the library path environment variable according to \`-dlopen'
+This mode sets the library path environment variable according to '-dlopen'
 flags.
 
 If any of the ARGS are libtool executable wrappers, then they are translated
@@ -2371,7 +3687,7 @@ Complete the installation of libtool libraries.
 Each LIBDIR is a directory that contains libtool libraries.
 
 The commands that this mode executes may require superuser privileges.  Use
-the \`--dry-run' option if you just want to see what would be executed."
+the '--dry-run' option if you just want to see what would be executed."
         ;;
 
       install)
@@ -2381,7 +3697,7 @@ the \`--dry-run' option if you just want to see what would be executed."
 Install executables or libraries.
 
 INSTALL-COMMAND is the installation command.  The first component should be
-either the \`install' or \`cp' program.
+either the 'install' or 'cp' program.
 
 The following components of INSTALL-COMMAND are treated specially:
 
@@ -2407,7 +3723,7 @@ The following components of LINK-COMMAND are treated specially:
   -avoid-version    do not add a version suffix if possible
   -bindir BINDIR    specify path to binaries directory (for systems where
                     libraries must be found in the PATH setting at runtime)
-  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlopen FILE      '-dlpreopen' FILE if it cannot be dlopened at runtime
   -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
   -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
   -export-symbols SYMFILE
@@ -2421,7 +3737,8 @@ The following components of LINK-COMMAND are treated specially:
   -no-install       link a not-installable executable
   -no-undefined     declare that a library does not refer to external symbols
   -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
-  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -objectlist FILE  use a list of object files found in FILE to specify objects
+  -os2dllname NAME  force a short DLL name on OS/2 (no effect on other OSes)
   -precious-files-regex REGEX
                     don't remove output files matching REGEX
   -release RELEASE  specify package release information
@@ -2441,20 +3758,20 @@ The following components of LINK-COMMAND are treated specially:
   -Xlinker FLAG     pass linker-specific FLAG directly to the linker
   -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)
 
-All other options (arguments beginning with \`-') are ignored.
+All other options (arguments beginning with '-') are ignored.
 
-Every other argument is treated as a filename.  Files ending in \`.la' are
+Every other argument is treated as a filename.  Files ending in '.la' are
 treated as uninstalled libtool libraries, other files are standard or library
 object files.
 
-If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
-only library objects (\`.lo' files) may be specified, and \`-rpath' is
+If the OUTPUT-FILE ends in '.la', then a libtool library is created,
+only library objects ('.lo' files) may be specified, and '-rpath' is
 required, except when creating a convenience library.
 
-If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
-using \`ar' and \`ranlib', or on Windows using \`lib'.
+If OUTPUT-FILE ends in '.a' or '.lib', then a standard library is created
+using 'ar' and 'ranlib', or on Windows using 'lib'.
 
-If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+If OUTPUT-FILE ends in '.lo' or '.$objext', then a reloadable object file
 is created, otherwise an executable program is created."
         ;;
 
@@ -2465,7 +3782,7 @@ is created, otherwise an executable program is created."
 Remove libraries from an installation directory.
 
 RM is the name of the program to use to delete files associated with each FILE
-(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed
 to RM.
 
 If FILE is a libtool library, all the files associated with it are deleted.
@@ -2473,17 +3790,17 @@ Otherwise, only FILE itself is deleted using RM."
         ;;
 
       *)
-        func_fatal_help "invalid operation mode \`$opt_mode'"
+        func_fatal_help "invalid operation mode '$opt_mode'"
         ;;
     esac
 
     echo
-    $ECHO "Try \`$progname --help' for more information about other modes."
+    $ECHO "Try '$progname --help' for more information about other modes."
 }
 
 # Now that we've collected a possible --mode arg, show help if necessary
 if $opt_help; then
-  if test "$opt_help" = :; then
+  if test : = "$opt_help"; then
     func_mode_help
   else
     {
@@ -2491,7 +3808,7 @@ if $opt_help; then
       for opt_mode in compile link execute install finish uninstall clean; do
 	func_mode_help
       done
-    } | sed -n '1p; 2,$s/^Usage:/  or: /p'
+    } | $SED -n '1p; 2,$s/^Usage:/  or: /p'
     {
       func_help noexit
       for opt_mode in compile link execute install finish uninstall clean; do
@@ -2499,7 +3816,7 @@ if $opt_help; then
 	func_mode_help
       done
     } |
-    sed '1d
+    $SED '1d
       /^When reporting/,/^Report/{
 	H
 	d
@@ -2516,16 +3833,17 @@ fi
 # func_mode_execute arg...
 func_mode_execute ()
 {
-    $opt_debug
+    $debug_cmd
+
     # The first argument is the command name.
-    cmd="$nonopt"
+    cmd=$nonopt
     test -z "$cmd" && \
       func_fatal_help "you must specify a COMMAND"
 
     # Handle -dlopen flags immediately.
     for file in $opt_dlopen; do
       test -f "$file" \
-	|| func_fatal_help "\`$file' is not a file"
+	|| func_fatal_help "'$file' is not a file"
 
       dir=
       case $file in
@@ -2535,7 +3853,7 @@ func_mode_execute ()
 
 	# Check to see that this really is a libtool archive.
 	func_lalib_unsafe_p "$file" \
-	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+	  || func_fatal_help "'$lib' is not a valid libtool archive"
 
 	# Read the libtool library.
 	dlname=
@@ -2546,18 +3864,18 @@ func_mode_execute ()
 	if test -z "$dlname"; then
 	  # Warn if it was a shared library.
 	  test -n "$library_names" && \
-	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	    func_warning "'$file' was not linked with '-export-dynamic'"
 	  continue
 	fi
 
 	func_dirname "$file" "" "."
-	dir="$func_dirname_result"
+	dir=$func_dirname_result
 
 	if test -f "$dir/$objdir/$dlname"; then
 	  func_append dir "/$objdir"
 	else
 	  if test ! -f "$dir/$dlname"; then
-	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	    func_fatal_error "cannot find '$dlname' in '$dir' or '$dir/$objdir'"
 	  fi
 	fi
 	;;
@@ -2565,18 +3883,18 @@ func_mode_execute ()
       *.lo)
 	# Just add the directory containing the .lo file.
 	func_dirname "$file" "" "."
-	dir="$func_dirname_result"
+	dir=$func_dirname_result
 	;;
 
       *)
-	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	func_warning "'-dlopen' is ignored for non-libtool libraries and objects"
 	continue
 	;;
       esac
 
       # Get the absolute pathname.
       absdir=`cd "$dir" && pwd`
-      test -n "$absdir" && dir="$absdir"
+      test -n "$absdir" && dir=$absdir
 
       # Now add the directory to shlibpath_var.
       if eval "test -z \"\$$shlibpath_var\""; then
@@ -2588,7 +3906,7 @@ func_mode_execute ()
 
     # This variable tells wrapper scripts just to set shlibpath_var
     # rather than running their programs.
-    libtool_execute_magic="$magic"
+    libtool_execute_magic=$magic
 
     # Check if any of the arguments is a wrapper script.
     args=
@@ -2601,12 +3919,12 @@ func_mode_execute ()
 	if func_ltwrapper_script_p "$file"; then
 	  func_source "$file"
 	  # Transform arg to wrapped name.
-	  file="$progdir/$program"
+	  file=$progdir/$program
 	elif func_ltwrapper_executable_p "$file"; then
 	  func_ltwrapper_scriptname "$file"
 	  func_source "$func_ltwrapper_scriptname_result"
 	  # Transform arg to wrapped name.
-	  file="$progdir/$program"
+	  file=$progdir/$program
 	fi
 	;;
       esac
@@ -2614,7 +3932,15 @@ func_mode_execute ()
       func_append_quoted args "$file"
     done
 
-    if test "X$opt_dry_run" = Xfalse; then
+    if $opt_dry_run; then
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	echo "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    else
       if test -n "$shlibpath_var"; then
 	# Export the shlibpath_var.
 	eval "export $shlibpath_var"
@@ -2631,25 +3957,18 @@ func_mode_execute ()
       done
 
       # Now prepare to actually exec the command.
-      exec_cmd="\$cmd$args"
-    else
-      # Display what would be done.
-      if test -n "$shlibpath_var"; then
-	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
-	echo "export $shlibpath_var"
-      fi
-      $ECHO "$cmd$args"
-      exit $EXIT_SUCCESS
+      exec_cmd=\$cmd$args
     fi
 }
 
-test "$opt_mode" = execute && func_mode_execute ${1+"$@"}
+test execute = "$opt_mode" && func_mode_execute ${1+"$@"}
 
 
 # func_mode_finish arg...
 func_mode_finish ()
 {
-    $opt_debug
+    $debug_cmd
+
     libs=
     libdirs=
     admincmds=
@@ -2663,11 +3982,11 @@ func_mode_finish ()
 	if func_lalib_unsafe_p "$opt"; then
 	  func_append libs " $opt"
 	else
-	  func_warning "\`$opt' is not a valid libtool archive"
+	  func_warning "'$opt' is not a valid libtool archive"
 	fi
 
       else
-	func_fatal_error "invalid argument \`$opt'"
+	func_fatal_error "invalid argument '$opt'"
       fi
     done
 
@@ -2682,12 +4001,12 @@ func_mode_finish ()
       # Remove sysroot references
       if $opt_dry_run; then
         for lib in $libs; do
-          echo "removing references to $lt_sysroot and \`=' prefixes from $lib"
+          echo "removing references to $lt_sysroot and '=' prefixes from $lib"
         done
       else
         tmpdir=`func_mktempdir`
         for lib in $libs; do
-	  sed -e "${sysroot_cmd} s/\([ ']-[LR]\)=/\1/g; s/\([ ']\)=/\1/g" $lib \
+	  $SED -e "$sysroot_cmd s/\([ ']-[LR]\)=/\1/g; s/\([ ']\)=/\1/g" $lib \
 	    > $tmpdir/tmp-la
 	  mv -f $tmpdir/tmp-la $lib
 	done
@@ -2712,7 +4031,7 @@ func_mode_finish ()
     fi
 
     # Exit here if they wanted silent mode.
-    $opt_silent && exit $EXIT_SUCCESS
+    $opt_quiet && exit $EXIT_SUCCESS
 
     if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
       echo "----------------------------------------------------------------------"
@@ -2723,27 +4042,27 @@ func_mode_finish ()
       echo
       echo "If you ever happen to want to link against installed libraries"
       echo "in a given directory, LIBDIR, you must either use libtool, and"
-      echo "specify the full pathname of the library, or use the \`-LLIBDIR'"
+      echo "specify the full pathname of the library, or use the '-LLIBDIR'"
       echo "flag during linking and do at least one of the following:"
       if test -n "$shlibpath_var"; then
-	echo "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+	echo "   - add LIBDIR to the '$shlibpath_var' environment variable"
 	echo "     during execution"
       fi
       if test -n "$runpath_var"; then
-	echo "   - add LIBDIR to the \`$runpath_var' environment variable"
+	echo "   - add LIBDIR to the '$runpath_var' environment variable"
 	echo "     during linking"
       fi
       if test -n "$hardcode_libdir_flag_spec"; then
 	libdir=LIBDIR
 	eval flag=\"$hardcode_libdir_flag_spec\"
 
-	$ECHO "   - use the \`$flag' linker flag"
+	$ECHO "   - use the '$flag' linker flag"
       fi
       if test -n "$admincmds"; then
 	$ECHO "   - have your system administrator run these commands:$admincmds"
       fi
       if test -f /etc/ld.so.conf; then
-	echo "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+	echo "   - have your system administrator add LIBDIR to '/etc/ld.so.conf'"
       fi
       echo
 
@@ -2762,18 +4081,20 @@ func_mode_finish ()
     exit $EXIT_SUCCESS
 }
 
-test "$opt_mode" = finish && func_mode_finish ${1+"$@"}
+test finish = "$opt_mode" && func_mode_finish ${1+"$@"}
 
 
 # func_mode_install arg...
 func_mode_install ()
 {
-    $opt_debug
+    $debug_cmd
+
     # There may be an optional sh(1) argument at the beginning of
     # install_prog (especially on Windows NT).
-    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+    if test "$SHELL" = "$nonopt" || test /bin/sh = "$nonopt" ||
        # Allow the use of GNU shtool's install command.
-       case $nonopt in *shtool*) :;; *) false;; esac; then
+       case $nonopt in *shtool*) :;; *) false;; esac
+    then
       # Aesthetically quote it.
       func_quote_for_eval "$nonopt"
       install_prog="$func_quote_for_eval_result "
@@ -2800,7 +4121,7 @@ func_mode_install ()
     opts=
     prev=
     install_type=
-    isdir=no
+    isdir=false
     stripme=
     no_mode=:
     for arg
@@ -2813,7 +4134,7 @@ func_mode_install ()
       fi
 
       case $arg in
-      -d) isdir=yes ;;
+      -d) isdir=: ;;
       -f)
 	if $install_cp; then :; else
 	  prev=$arg
@@ -2831,7 +4152,7 @@ func_mode_install ()
       *)
 	# If the previous option needed an argument, then skip it.
 	if test -n "$prev"; then
-	  if test "x$prev" = x-m && test -n "$install_override_mode"; then
+	  if test X-m = "X$prev" && test -n "$install_override_mode"; then
 	    arg2=$install_override_mode
 	    no_mode=false
 	  fi
@@ -2856,7 +4177,7 @@ func_mode_install ()
       func_fatal_help "you must specify an install program"
 
     test -n "$prev" && \
-      func_fatal_help "the \`$prev' option requires an argument"
+      func_fatal_help "the '$prev' option requires an argument"
 
     if test -n "$install_override_mode" && $no_mode; then
       if $install_cp; then :; else
@@ -2878,19 +4199,19 @@ func_mode_install ()
     dest=$func_stripname_result
 
     # Check to see that the destination is a directory.
-    test -d "$dest" && isdir=yes
-    if test "$isdir" = yes; then
-      destdir="$dest"
+    test -d "$dest" && isdir=:
+    if $isdir; then
+      destdir=$dest
       destname=
     else
       func_dirname_and_basename "$dest" "" "."
-      destdir="$func_dirname_result"
-      destname="$func_basename_result"
+      destdir=$func_dirname_result
+      destname=$func_basename_result
 
       # Not a directory, so check to see that there is only one file specified.
       set dummy $files; shift
       test "$#" -gt 1 && \
-	func_fatal_help "\`$dest' is not a directory"
+	func_fatal_help "'$dest' is not a directory"
     fi
     case $destdir in
     [\\/]* | [A-Za-z]:[\\/]*) ;;
@@ -2899,7 +4220,7 @@ func_mode_install ()
 	case $file in
 	*.lo) ;;
 	*)
-	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  func_fatal_help "'$destdir' must be an absolute directory name"
 	  ;;
 	esac
       done
@@ -2908,7 +4229,7 @@ func_mode_install ()
 
     # This variable tells wrapper scripts just to set variables rather
     # than running their programs.
-    libtool_install_magic="$magic"
+    libtool_install_magic=$magic
 
     staticlibs=
     future_libdirs=
@@ -2928,7 +4249,7 @@ func_mode_install ()
 
 	# Check to see that this really is a libtool archive.
 	func_lalib_unsafe_p "$file" \
-	  || func_fatal_help "\`$file' is not a valid libtool archive"
+	  || func_fatal_help "'$file' is not a valid libtool archive"
 
 	library_names=
 	old_library=
@@ -2950,7 +4271,7 @@ func_mode_install ()
 	fi
 
 	func_dirname "$file" "/" ""
-	dir="$func_dirname_result"
+	dir=$func_dirname_result
 	func_append dir "$objdir"
 
 	if test -n "$relink_command"; then
@@ -2964,7 +4285,7 @@ func_mode_install ()
 	  # are installed into $libdir/../bin (currently, that works fine)
 	  # but it's something to keep an eye on.
 	  test "$inst_prefix_dir" = "$destdir" && \
-	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+	    func_fatal_error "error: cannot install '$file' to a directory not ending in $libdir"
 
 	  if test -n "$inst_prefix_dir"; then
 	    # Stick the inst_prefix_dir data into the link command.
@@ -2973,29 +4294,36 @@ func_mode_install ()
 	    relink_command=`$ECHO "$relink_command" | $SED "s%@inst_prefix_dir@%%"`
 	  fi
 
-	  func_warning "relinking \`$file'"
+	  func_warning "relinking '$file'"
 	  func_show_eval "$relink_command" \
-	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	    'func_fatal_error "error: relink '\''$file'\'' with the above command before installing it"'
 	fi
 
 	# See the names of the shared library.
 	set dummy $library_names; shift
 	if test -n "$1"; then
-	  realname="$1"
+	  realname=$1
 	  shift
 
-	  srcname="$realname"
-	  test -n "$relink_command" && srcname="$realname"T
+	  srcname=$realname
+	  test -n "$relink_command" && srcname=${realname}T
 
 	  # Install the shared library and build the symlinks.
 	  func_show_eval "$install_shared_prog $dir/$srcname $destdir/$realname" \
 	      'exit $?'
-	  tstripme="$stripme"
+	  tstripme=$stripme
 	  case $host_os in
 	  cygwin* | mingw* | pw32* | cegcc*)
 	    case $realname in
 	    *.dll.a)
-	      tstripme=""
+	      tstripme=
+	      ;;
+	    esac
+	    ;;
+	  os2*)
+	    case $realname in
+	    *_dll.a)
+	      tstripme=
 	      ;;
 	    esac
 	    ;;
@@ -3006,7 +4334,7 @@ func_mode_install ()
 
 	  if test "$#" -gt 0; then
 	    # Delete the old symlinks, and create new ones.
-	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # Try 'ln -sf' first, because the 'ln' binary might depend on
 	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
 	    # so we also need to try rm && ln -s.
 	    for linkname
@@ -3017,14 +4345,14 @@ func_mode_install ()
 	  fi
 
 	  # Do each command in the postinstall commands.
-	  lib="$destdir/$realname"
+	  lib=$destdir/$realname
 	  func_execute_cmds "$postinstall_cmds" 'exit $?'
 	fi
 
 	# Install the pseudo-library for information purposes.
 	func_basename "$file"
-	name="$func_basename_result"
-	instname="$dir/$name"i
+	name=$func_basename_result
+	instname=$dir/${name}i
 	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
 
 	# Maybe install the static library, too.
@@ -3036,11 +4364,11 @@ func_mode_install ()
 
 	# Figure out destination file name, if it wasn't already specified.
 	if test -n "$destname"; then
-	  destfile="$destdir/$destname"
+	  destfile=$destdir/$destname
 	else
 	  func_basename "$file"
-	  destfile="$func_basename_result"
-	  destfile="$destdir/$destfile"
+	  destfile=$func_basename_result
+	  destfile=$destdir/$destfile
 	fi
 
 	# Deduce the name of the destination old-style object file.
@@ -3050,11 +4378,11 @@ func_mode_install ()
 	  staticdest=$func_lo2o_result
 	  ;;
 	*.$objext)
-	  staticdest="$destfile"
+	  staticdest=$destfile
 	  destfile=
 	  ;;
 	*)
-	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  func_fatal_help "cannot copy a libtool object to '$destfile'"
 	  ;;
 	esac
 
@@ -3063,7 +4391,7 @@ func_mode_install ()
 	  func_show_eval "$install_prog $file $destfile" 'exit $?'
 
 	# Install the old object if enabled.
-	if test "$build_old_libs" = yes; then
+	if test yes = "$build_old_libs"; then
 	  # Deduce the name of the old-style object file.
 	  func_lo2o "$file"
 	  staticobj=$func_lo2o_result
@@ -3075,23 +4403,23 @@ func_mode_install ()
       *)
 	# Figure out destination file name, if it wasn't already specified.
 	if test -n "$destname"; then
-	  destfile="$destdir/$destname"
+	  destfile=$destdir/$destname
 	else
 	  func_basename "$file"
-	  destfile="$func_basename_result"
-	  destfile="$destdir/$destfile"
+	  destfile=$func_basename_result
+	  destfile=$destdir/$destfile
 	fi
 
 	# If the file is missing, and there is a .exe on the end, strip it
 	# because it is most likely a libtool script we actually want to
 	# install
-	stripped_ext=""
+	stripped_ext=
 	case $file in
 	  *.exe)
 	    if test ! -f "$file"; then
 	      func_stripname '' '.exe' "$file"
 	      file=$func_stripname_result
-	      stripped_ext=".exe"
+	      stripped_ext=.exe
 	    fi
 	    ;;
 	esac
@@ -3119,19 +4447,19 @@ func_mode_install ()
 
 	  # Check the variables that should have been set.
 	  test -z "$generated_by_libtool_version" && \
-	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+	    func_fatal_error "invalid libtool wrapper script '$wrapper'"
 
-	  finalize=yes
+	  finalize=:
 	  for lib in $notinst_deplibs; do
 	    # Check to see that each library is installed.
 	    libdir=
 	    if test -f "$lib"; then
 	      func_source "$lib"
 	    fi
-	    libfile="$libdir/"`$ECHO "$lib" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    libfile=$libdir/`$ECHO "$lib" | $SED 's%^.*/%%g'`
 	    if test -n "$libdir" && test ! -f "$libfile"; then
-	      func_warning "\`$lib' has not been installed in \`$libdir'"
-	      finalize=no
+	      func_warning "'$lib' has not been installed in '$libdir'"
+	      finalize=false
 	    fi
 	  done
 
@@ -3139,29 +4467,29 @@ func_mode_install ()
 	  func_source "$wrapper"
 
 	  outputname=
-	  if test "$fast_install" = no && test -n "$relink_command"; then
+	  if test no = "$fast_install" && test -n "$relink_command"; then
 	    $opt_dry_run || {
-	      if test "$finalize" = yes; then
+	      if $finalize; then
 	        tmpdir=`func_mktempdir`
 		func_basename "$file$stripped_ext"
-		file="$func_basename_result"
-	        outputname="$tmpdir/$file"
+		file=$func_basename_result
+	        outputname=$tmpdir/$file
 	        # Replace the output file specification.
 	        relink_command=`$ECHO "$relink_command" | $SED 's%@OUTPUT@%'"$outputname"'%g'`
 
-	        $opt_silent || {
+	        $opt_quiet || {
 	          func_quote_for_expand "$relink_command"
 		  eval "func_echo $func_quote_for_expand_result"
 	        }
 	        if eval "$relink_command"; then :
 	          else
-		  func_error "error: relink \`$file' with the above command before installing it"
+		  func_error "error: relink '$file' with the above command before installing it"
 		  $opt_dry_run || ${RM}r "$tmpdir"
 		  continue
 	        fi
-	        file="$outputname"
+	        file=$outputname
 	      else
-	        func_warning "cannot relink \`$file'"
+	        func_warning "cannot relink '$file'"
 	      fi
 	    }
 	  else
@@ -3198,10 +4526,10 @@ func_mode_install ()
 
     for file in $staticlibs; do
       func_basename "$file"
-      name="$func_basename_result"
+      name=$func_basename_result
 
       # Set up the ranlib parameters.
-      oldlib="$destdir/$name"
+      oldlib=$destdir/$name
       func_to_tool_file "$oldlib" func_convert_file_msys_to_w32
       tool_oldlib=$func_to_tool_file_result
 
@@ -3216,18 +4544,18 @@ func_mode_install ()
     done
 
     test -n "$future_libdirs" && \
-      func_warning "remember to run \`$progname --finish$future_libdirs'"
+      func_warning "remember to run '$progname --finish$future_libdirs'"
 
     if test -n "$current_libdirs"; then
       # Maybe just do a dry run.
       $opt_dry_run && current_libdirs=" -n$current_libdirs"
-      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+      exec_cmd='$SHELL "$progpath" $preserve_args --finish$current_libdirs'
     else
       exit $EXIT_SUCCESS
     fi
 }
 
-test "$opt_mode" = install && func_mode_install ${1+"$@"}
+test install = "$opt_mode" && func_mode_install ${1+"$@"}
 
 
 # func_generate_dlsyms outputname originator pic_p
@@ -3235,16 +4563,17 @@ test "$opt_mode" = install && func_mode_install ${1+"$@"}
 # a dlpreopen symbol table.
 func_generate_dlsyms ()
 {
-    $opt_debug
-    my_outputname="$1"
-    my_originator="$2"
-    my_pic_p="${3-no}"
-    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    $debug_cmd
+
+    my_outputname=$1
+    my_originator=$2
+    my_pic_p=${3-false}
+    my_prefix=`$ECHO "$my_originator" | $SED 's%[^a-zA-Z0-9]%_%g'`
     my_dlsyms=
 
-    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+    if test -n "$dlfiles$dlprefiles" || test no != "$dlself"; then
       if test -n "$NM" && test -n "$global_symbol_pipe"; then
-	my_dlsyms="${my_outputname}S.c"
+	my_dlsyms=${my_outputname}S.c
       else
 	func_error "not configured to extract global symbols from dlpreopened files"
       fi
@@ -3255,7 +4584,7 @@ func_generate_dlsyms ()
       "") ;;
       *.c)
 	# Discover the nlist of each of the dlfiles.
-	nlist="$output_objdir/${my_outputname}.nm"
+	nlist=$output_objdir/$my_outputname.nm
 
 	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
 
@@ -3263,34 +4592,36 @@ func_generate_dlsyms ()
 	func_verbose "creating $output_objdir/$my_dlsyms"
 
 	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
-/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
-/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+/* $my_dlsyms - symbol resolution table for '$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE) $VERSION */
 
 #ifdef __cplusplus
 extern \"C\" {
 #endif
 
-#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))
+#if defined __GNUC__ && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))
 #pragma GCC diagnostic ignored \"-Wstrict-prototypes\"
 #endif
 
 /* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
-#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
-/* DATA imports from DLLs on WIN32 con't be const, because runtime
+#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE
+/* DATA imports from DLLs on WIN32 can't be const, because runtime
    relocations are performed -- see ld's documentation on pseudo-relocs.  */
 # define LT_DLSYM_CONST
-#elif defined(__osf__)
+#elif defined __osf__
 /* This system does not cope well with relocations in const data.  */
 # define LT_DLSYM_CONST
 #else
 # define LT_DLSYM_CONST const
 #endif
 
+#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)
+
 /* External symbol declarations for the compiler. */\
 "
 
-	if test "$dlself" = yes; then
-	  func_verbose "generating symbol list for \`$output'"
+	if test yes = "$dlself"; then
+	  func_verbose "generating symbol list for '$output'"
 
 	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
 
@@ -3298,7 +4629,7 @@ extern \"C\" {
 	  progfiles=`$ECHO "$objs$old_deplibs" | $SP2NL | $SED "$lo2o" | $NL2SP`
 	  for progfile in $progfiles; do
 	    func_to_tool_file "$progfile" func_convert_file_msys_to_w32
-	    func_verbose "extracting global C symbols from \`$func_to_tool_file_result'"
+	    func_verbose "extracting global C symbols from '$func_to_tool_file_result'"
 	    $opt_dry_run || eval "$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'"
 	  done
 
@@ -3318,10 +4649,10 @@ extern \"C\" {
 
 	  # Prepare the list of exported symbols
 	  if test -z "$export_symbols"; then
-	    export_symbols="$output_objdir/$outputname.exp"
+	    export_symbols=$output_objdir/$outputname.exp
 	    $opt_dry_run || {
 	      $RM $export_symbols
-	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      eval "$SED -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
 	      case $host in
 	      *cygwin* | *mingw* | *cegcc* )
                 eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
@@ -3331,7 +4662,7 @@ extern \"C\" {
 	    }
 	  else
 	    $opt_dry_run || {
-	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval "$SED -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
 	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
 	      eval '$MV "$nlist"T "$nlist"'
 	      case $host in
@@ -3345,22 +4676,22 @@ extern \"C\" {
 	fi
 
 	for dlprefile in $dlprefiles; do
-	  func_verbose "extracting global C symbols from \`$dlprefile'"
+	  func_verbose "extracting global C symbols from '$dlprefile'"
 	  func_basename "$dlprefile"
-	  name="$func_basename_result"
+	  name=$func_basename_result
           case $host in
 	    *cygwin* | *mingw* | *cegcc* )
 	      # if an import library, we need to obtain dlname
 	      if func_win32_import_lib_p "$dlprefile"; then
 	        func_tr_sh "$dlprefile"
 	        eval "curr_lafile=\$libfile_$func_tr_sh_result"
-	        dlprefile_dlbasename=""
+	        dlprefile_dlbasename=
 	        if test -n "$curr_lafile" && func_lalib_p "$curr_lafile"; then
 	          # Use subshell, to avoid clobbering current variable values
 	          dlprefile_dlname=`source "$curr_lafile" && echo "$dlname"`
-	          if test -n "$dlprefile_dlname" ; then
+	          if test -n "$dlprefile_dlname"; then
 	            func_basename "$dlprefile_dlname"
-	            dlprefile_dlbasename="$func_basename_result"
+	            dlprefile_dlbasename=$func_basename_result
 	          else
 	            # no lafile. user explicitly requested -dlpreopen <import library>.
 	            $sharedlib_from_linklib_cmd "$dlprefile"
@@ -3368,7 +4699,7 @@ extern \"C\" {
 	          fi
 	        fi
 	        $opt_dry_run || {
-	          if test -n "$dlprefile_dlbasename" ; then
+	          if test -n "$dlprefile_dlbasename"; then
 	            eval '$ECHO ": $dlprefile_dlbasename" >> "$nlist"'
 	          else
 	            func_warning "Could not compute DLL name from $name"
@@ -3424,6 +4755,11 @@ extern \"C\" {
 	    echo '/* NONE */' >> "$output_objdir/$my_dlsyms"
 	  fi
 
+	  func_show_eval '$RM "${nlist}I"'
+	  if test -n "$global_symbol_to_import"; then
+	    eval "$global_symbol_to_import"' < "$nlist"S > "$nlist"I'
+	  fi
+
 	  echo >> "$output_objdir/$my_dlsyms" "\
 
 /* The mapping between symbol names and symbols.  */
@@ -3432,11 +4768,30 @@ typedef struct {
   void *address;
 } lt_dlsymlist;
 extern LT_DLSYM_CONST lt_dlsymlist
-lt_${my_prefix}_LTX_preloaded_symbols[];
+lt_${my_prefix}_LTX_preloaded_symbols[];\
+"
+
+	  if test -s "$nlist"I; then
+	    echo >> "$output_objdir/$my_dlsyms" "\
+static void lt_syminit(void)
+{
+  LT_DLSYM_CONST lt_dlsymlist *symbol = lt_${my_prefix}_LTX_preloaded_symbols;
+  for (; symbol->name; ++symbol)
+    {"
+	    $SED 's/.*/      if (STREQ (symbol->name, \"&\")) symbol->address = (void *) \&&;/' < "$nlist"I >> "$output_objdir/$my_dlsyms"
+	    echo >> "$output_objdir/$my_dlsyms" "\
+    }
+}"
+	  fi
+	  echo >> "$output_objdir/$my_dlsyms" "\
 LT_DLSYM_CONST lt_dlsymlist
 lt_${my_prefix}_LTX_preloaded_symbols[] =
-{\
-  { \"$my_originator\", (void *) 0 },"
+{ {\"$my_originator\", (void *) 0},"
+
+	  if test -s "$nlist"I; then
+	    echo >> "$output_objdir/$my_dlsyms" "\
+  {\"@INIT@\", (void *) &lt_syminit},"
+	  fi
 
 	  case $need_lib_prefix in
 	  no)
@@ -3478,9 +4833,7 @@ static const void *lt_preloaded_setup() {
 	  *-*-hpux*)
 	    pic_flag_for_symtable=" $pic_flag"  ;;
 	  *)
-	    if test "X$my_pic_p" != Xno; then
-	      pic_flag_for_symtable=" $pic_flag"
-	    fi
+	    $my_pic_p && pic_flag_for_symtable=" $pic_flag"
 	    ;;
 	  esac
 	  ;;
@@ -3497,10 +4850,10 @@ static const void *lt_preloaded_setup() {
 	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
 
 	# Clean up the generated files.
-	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T" "${nlist}I"'
 
 	# Transform the symbol file into the correct name.
-	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	symfileobj=$output_objdir/${my_outputname}S.$objext
 	case $host in
 	*cygwin* | *mingw* | *cegcc* )
 	  if test -f "$output_objdir/$my_outputname.def"; then
@@ -3518,7 +4871,7 @@ static const void *lt_preloaded_setup() {
 	esac
 	;;
       *)
-	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	func_fatal_error "unknown suffix for '$my_dlsyms'"
 	;;
       esac
     else
@@ -3532,6 +4885,32 @@ static const void *lt_preloaded_setup() {
     fi
 }
 
+# func_cygming_gnu_implib_p ARG
+# This predicate returns with zero status (TRUE) if
+# ARG is a GNU/binutils-style import library. Returns
+# with nonzero status (FALSE) otherwise.
+func_cygming_gnu_implib_p ()
+{
+  $debug_cmd
+
+  func_to_tool_file "$1" func_convert_file_msys_to_w32
+  func_cygming_gnu_implib_tmp=`$NM "$func_to_tool_file_result" | eval "$global_symbol_pipe" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`
+  test -n "$func_cygming_gnu_implib_tmp"
+}
+
+# func_cygming_ms_implib_p ARG
+# This predicate returns with zero status (TRUE) if
+# ARG is an MS-style import library. Returns
+# with nonzero status (FALSE) otherwise.
+func_cygming_ms_implib_p ()
+{
+  $debug_cmd
+
+  func_to_tool_file "$1" func_convert_file_msys_to_w32
+  func_cygming_ms_implib_tmp=`$NM "$func_to_tool_file_result" | eval "$global_symbol_pipe" | $GREP '_NULL_IMPORT_DESCRIPTOR'`
+  test -n "$func_cygming_ms_implib_tmp"
+}
+
 # func_win32_libid arg
 # return the library type of file 'arg'
 #
@@ -3541,8 +4920,9 @@ static const void *lt_preloaded_setup() {
 # Despite the name, also deal with 64 bit binaries.
 func_win32_libid ()
 {
-  $opt_debug
-  win32_libid_type="unknown"
+  $debug_cmd
+
+  win32_libid_type=unknown
   win32_fileres=`file -L $1 2>/dev/null`
   case $win32_fileres in
   *ar\ archive\ import\ library*) # definitely import
@@ -3552,16 +4932,29 @@ func_win32_libid ()
     # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.
     if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
        $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then
-      func_to_tool_file "$1" func_convert_file_msys_to_w32
-      win32_nmres=`eval $NM -f posix -A \"$func_to_tool_file_result\" |
-	$SED -n -e '
+      case $nm_interface in
+      "MS dumpbin")
+	if func_cygming_ms_implib_p "$1" ||
+	   func_cygming_gnu_implib_p "$1"
+	then
+	  win32_nmres=import
+	else
+	  win32_nmres=
+	fi
+	;;
+      *)
+	func_to_tool_file "$1" func_convert_file_msys_to_w32
+	win32_nmres=`eval $NM -f posix -A \"$func_to_tool_file_result\" |
+	  $SED -n -e '
 	    1,100{
 		/ I /{
-		    s,.*,import,
+		    s|.*|import|
 		    p
 		    q
 		}
 	    }'`
+	;;
+      esac
       case $win32_nmres in
       import*)  win32_libid_type="x86 archive import";;
       *)        win32_libid_type="x86 archive static";;
@@ -3593,7 +4986,8 @@ func_win32_libid ()
 #    $sharedlib_from_linklib_result
 func_cygming_dll_for_implib ()
 {
-  $opt_debug
+  $debug_cmd
+
   sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify "$1"`
 }
 
@@ -3610,7 +5004,8 @@ func_cygming_dll_for_implib ()
 # specified import library.
 func_cygming_dll_for_implib_fallback_core ()
 {
-  $opt_debug
+  $debug_cmd
+
   match_literal=`$ECHO "$1" | $SED "$sed_make_literal_regex"`
   $OBJDUMP -s --section "$1" "$2" 2>/dev/null |
     $SED '/^Contents of section '"$match_literal"':/{
@@ -3646,8 +5041,8 @@ func_cygming_dll_for_implib_fallback_core ()
       /./p' |
     # we now have a list, one entry per line, of the stringified
     # contents of the appropriate section of all members of the
-    # archive which possess that section. Heuristic: eliminate
-    # all those which have a first or second character that is
+    # archive that possess that section. Heuristic: eliminate
+    # all those that have a first or second character that is
     # a '.' (that is, objdump's representation of an unprintable
     # character.) This should work for all archives with less than
     # 0x302f exports -- but will fail for DLLs whose name actually
@@ -3658,30 +5053,6 @@ func_cygming_dll_for_implib_fallback_core ()
     $SED -e '/^\./d;/^.\./d;q'
 }
 
-# func_cygming_gnu_implib_p ARG
-# This predicate returns with zero status (TRUE) if
-# ARG is a GNU/binutils-style import library. Returns
-# with nonzero status (FALSE) otherwise.
-func_cygming_gnu_implib_p ()
-{
-  $opt_debug
-  func_to_tool_file "$1" func_convert_file_msys_to_w32
-  func_cygming_gnu_implib_tmp=`$NM "$func_to_tool_file_result" | eval "$global_symbol_pipe" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`
-  test -n "$func_cygming_gnu_implib_tmp"
-}
-
-# func_cygming_ms_implib_p ARG
-# This predicate returns with zero status (TRUE) if
-# ARG is an MS-style import library. Returns
-# with nonzero status (FALSE) otherwise.
-func_cygming_ms_implib_p ()
-{
-  $opt_debug
-  func_to_tool_file "$1" func_convert_file_msys_to_w32
-  func_cygming_ms_implib_tmp=`$NM "$func_to_tool_file_result" | eval "$global_symbol_pipe" | $GREP '_NULL_IMPORT_DESCRIPTOR'`
-  test -n "$func_cygming_ms_implib_tmp"
-}
-
 # func_cygming_dll_for_implib_fallback ARG
 # Platform-specific function to extract the
 # name of the DLL associated with the specified
@@ -3695,16 +5066,17 @@ func_cygming_ms_implib_p ()
 #    $sharedlib_from_linklib_result
 func_cygming_dll_for_implib_fallback ()
 {
-  $opt_debug
-  if func_cygming_gnu_implib_p "$1" ; then
+  $debug_cmd
+
+  if func_cygming_gnu_implib_p "$1"; then
     # binutils import library
     sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' "$1"`
-  elif func_cygming_ms_implib_p "$1" ; then
+  elif func_cygming_ms_implib_p "$1"; then
     # ms-generated import library
     sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' "$1"`
   else
     # unknown
-    sharedlib_from_linklib_result=""
+    sharedlib_from_linklib_result=
   fi
 }
 
@@ -3712,10 +5084,11 @@ func_cygming_dll_for_implib_fallback ()
 # func_extract_an_archive dir oldlib
 func_extract_an_archive ()
 {
-    $opt_debug
-    f_ex_an_ar_dir="$1"; shift
-    f_ex_an_ar_oldlib="$1"
-    if test "$lock_old_archive_extraction" = yes; then
+    $debug_cmd
+
+    f_ex_an_ar_dir=$1; shift
+    f_ex_an_ar_oldlib=$1
+    if test yes = "$lock_old_archive_extraction"; then
       lockfile=$f_ex_an_ar_oldlib.lock
       until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
 	func_echo "Waiting for $lockfile to be removed"
@@ -3724,7 +5097,7 @@ func_extract_an_archive ()
     fi
     func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" \
 		   'stat=$?; rm -f "$lockfile"; exit $stat'
-    if test "$lock_old_archive_extraction" = yes; then
+    if test yes = "$lock_old_archive_extraction"; then
       $opt_dry_run || rm -f "$lockfile"
     fi
     if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
@@ -3738,22 +5111,23 @@ func_extract_an_archive ()
 # func_extract_archives gentop oldlib ...
 func_extract_archives ()
 {
-    $opt_debug
-    my_gentop="$1"; shift
+    $debug_cmd
+
+    my_gentop=$1; shift
     my_oldlibs=${1+"$@"}
-    my_oldobjs=""
-    my_xlib=""
-    my_xabs=""
-    my_xdir=""
+    my_oldobjs=
+    my_xlib=
+    my_xabs=
+    my_xdir=
 
     for my_xlib in $my_oldlibs; do
       # Extract the objects.
       case $my_xlib in
-	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs=$my_xlib ;;
 	*) my_xabs=`pwd`"/$my_xlib" ;;
       esac
       func_basename "$my_xlib"
-      my_xlib="$func_basename_result"
+      my_xlib=$func_basename_result
       my_xlib_u=$my_xlib
       while :; do
         case " $extracted_archives " in
@@ -3765,7 +5139,7 @@ func_extract_archives ()
 	esac
       done
       extracted_archives="$extracted_archives $my_xlib_u"
-      my_xdir="$my_gentop/$my_xlib_u"
+      my_xdir=$my_gentop/$my_xlib_u
 
       func_mkdir_p "$my_xdir"
 
@@ -3778,22 +5152,23 @@ func_extract_archives ()
 	  cd $my_xdir || exit $?
 	  darwin_archive=$my_xabs
 	  darwin_curdir=`pwd`
-	  darwin_base_archive=`basename "$darwin_archive"`
+	  func_basename "$darwin_archive"
+	  darwin_base_archive=$func_basename_result
 	  darwin_arches=`$LIPO -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
 	  if test -n "$darwin_arches"; then
 	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
 	    darwin_arch=
 	    func_verbose "$darwin_base_archive has multiple architectures $darwin_arches"
-	    for darwin_arch in  $darwin_arches ; do
-	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
-	      $LIPO -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
-	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
-	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	    for darwin_arch in  $darwin_arches; do
+	      func_mkdir_p "unfat-$$/$darwin_base_archive-$darwin_arch"
+	      $LIPO -thin $darwin_arch -output "unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive" "$darwin_archive"
+	      cd "unfat-$$/$darwin_base_archive-$darwin_arch"
+	      func_extract_an_archive "`pwd`" "$darwin_base_archive"
 	      cd "$darwin_curdir"
-	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	      $RM "unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive"
 	    done # $darwin_arches
             ## Okay now we've a bunch of thin objects, gotta fatten them up :)
-	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$basename" | sort -u`
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$sed_basename" | sort -u`
 	    darwin_file=
 	    darwin_files=
 	    for darwin_file in $darwin_filelist; do
@@ -3815,7 +5190,7 @@ func_extract_archives ()
       my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | sort | $NL2SP`
     done
 
-    func_extract_archives_result="$my_oldobjs"
+    func_extract_archives_result=$my_oldobjs
 }
 
 
@@ -3830,7 +5205,7 @@ func_extract_archives ()
 #
 # ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR
 # variable will take.  If 'yes', then the emitted script
-# will assume that the directory in which it is stored is
+# will assume that the directory where it is stored is
 # the $objdir directory.  This is a cygwin/mingw-specific
 # behavior.
 func_emit_wrapper ()
@@ -3841,7 +5216,7 @@ func_emit_wrapper ()
 #! $SHELL
 
 # $output - temporary wrapper script for $objdir/$outputname
-# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+# Generated by $PROGRAM (GNU $PACKAGE) $VERSION
 #
 # The $output program cannot be directly executed until all the libtool
 # libraries that it depends on are installed.
@@ -3898,9 +5273,9 @@ _LTECHO_EOF'
 
 # Very basic option parsing. These options are (a) specific to
 # the libtool wrapper, (b) are identical between the wrapper
-# /script/ and the wrapper /executable/ which is used only on
+# /script/ and the wrapper /executable/ that is used only on
 # windows platforms, and (c) all begin with the string "--lt-"
-# (application programs are unlikely to have options which match
+# (application programs are unlikely to have options that match
 # this pattern).
 #
 # There are only two supported options: --lt-debug and
@@ -3933,7 +5308,7 @@ func_parse_lt_options ()
 
   # Print the debug banner immediately:
   if test -n \"\$lt_option_debug\"; then
-    echo \"${outputname}:${output}:\${LINENO}: libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\" 1>&2
+    echo \"$outputname:$output:\$LINENO: libtool wrapper (GNU $PACKAGE) $VERSION\" 1>&2
   fi
 }
 
@@ -3944,7 +5319,7 @@ func_lt_dump_args ()
   lt_dump_args_N=1;
   for lt_arg
   do
-    \$ECHO \"${outputname}:${output}:\${LINENO}: newargv[\$lt_dump_args_N]: \$lt_arg\"
+    \$ECHO \"$outputname:$output:\$LINENO: newargv[\$lt_dump_args_N]: \$lt_arg\"
     lt_dump_args_N=\`expr \$lt_dump_args_N + 1\`
   done
 }
@@ -3958,7 +5333,7 @@ func_exec_program_core ()
   *-*-mingw | *-*-os2* | *-cegcc*)
     $ECHO "\
       if test -n \"\$lt_option_debug\"; then
-        \$ECHO \"${outputname}:${output}:\${LINENO}: newargv[0]: \$progdir\\\\\$program\" 1>&2
+        \$ECHO \"$outputname:$output:\$LINENO: newargv[0]: \$progdir\\\\\$program\" 1>&2
         func_lt_dump_args \${1+\"\$@\"} 1>&2
       fi
       exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
@@ -3968,7 +5343,7 @@ func_exec_program_core ()
   *)
     $ECHO "\
       if test -n \"\$lt_option_debug\"; then
-        \$ECHO \"${outputname}:${output}:\${LINENO}: newargv[0]: \$progdir/\$program\" 1>&2
+        \$ECHO \"$outputname:$output:\$LINENO: newargv[0]: \$progdir/\$program\" 1>&2
         func_lt_dump_args \${1+\"\$@\"} 1>&2
       fi
       exec \"\$progdir/\$program\" \${1+\"\$@\"}
@@ -4043,13 +5418,13 @@ func_exec_program ()
   test -n \"\$absdir\" && thisdir=\"\$absdir\"
 "
 
-	if test "$fast_install" = yes; then
+	if test yes = "$fast_install"; then
 	  $ECHO "\
   program=lt-'$outputname'$exeext
   progdir=\"\$thisdir/$objdir\"
 
   if test ! -f \"\$progdir/\$program\" ||
-     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | $SED 1q\`; \\
        test \"X\$file\" != \"X\$progdir/\$program\"; }; then
 
     file=\"\$\$-\$program\"
@@ -4066,7 +5441,7 @@ func_exec_program ()
     if test -n \"\$relink_command\"; then
       if relink_command_output=\`eval \$relink_command 2>&1\`; then :
       else
-	$ECHO \"\$relink_command_output\" >&2
+	\$ECHO \"\$relink_command_output\" >&2
 	$RM \"\$progdir/\$file\"
 	exit 1
       fi
@@ -4101,7 +5476,7 @@ func_exec_program ()
 	fi
 
 	# Export our shlibpath_var if we have one.
-	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	if test yes = "$shlibpath_overrides_runpath" && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
 	  $ECHO "\
     # Add our own library path to $shlibpath_var
     $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
@@ -4121,7 +5496,7 @@ func_exec_program ()
     fi
   else
     # The program doesn't exist.
-    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"\$0: error: '\$progdir/\$program' does not exist\" 1>&2
     \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
     \$ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
     exit 1
@@ -4140,7 +5515,7 @@ func_emit_cwrapperexe_src ()
 	cat <<EOF
 
 /* $cwrappersource - temporary wrapper executable for $objdir/$outputname
-   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+   Generated by $PROGRAM (GNU $PACKAGE) $VERSION
 
    The $output program cannot be directly executed until all the libtool
    libraries that it depends on are installed.
@@ -4175,47 +5550,45 @@ EOF
 #include <fcntl.h>
 #include <sys/stat.h>
 
+#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)
+
 /* declarations of non-ANSI functions */
-#if defined(__MINGW32__)
+#if defined __MINGW32__
 # ifdef __STRICT_ANSI__
 int _putenv (const char *);
 # endif
-#elif defined(__CYGWIN__)
+#elif defined __CYGWIN__
 # ifdef __STRICT_ANSI__
 char *realpath (const char *, char *);
 int putenv (char *);
 int setenv (const char *, const char *, int);
 # endif
-/* #elif defined (other platforms) ... */
+/* #elif defined other_platform || defined ... */
 #endif
 
 /* portability defines, excluding path handling macros */
-#if defined(_MSC_VER)
+#if defined _MSC_VER
 # define setmode _setmode
 # define stat    _stat
 # define chmod   _chmod
 # define getcwd  _getcwd
 # define putenv  _putenv
 # define S_IXUSR _S_IEXEC
-# ifndef _INTPTR_T_DEFINED
-#  define _INTPTR_T_DEFINED
-#  define intptr_t int
-# endif
-#elif defined(__MINGW32__)
+#elif defined __MINGW32__
 # define setmode _setmode
 # define stat    _stat
 # define chmod   _chmod
 # define getcwd  _getcwd
 # define putenv  _putenv
-#elif defined(__CYGWIN__)
+#elif defined __CYGWIN__
 # define HAVE_SETENV
 # define FOPEN_WB "wb"
-/* #elif defined (other platforms) ... */
+/* #elif defined other platforms ... */
 #endif
 
-#if defined(PATH_MAX)
+#if defined PATH_MAX
 # define LT_PATHMAX PATH_MAX
-#elif defined(MAXPATHLEN)
+#elif defined MAXPATHLEN
 # define LT_PATHMAX MAXPATHLEN
 #else
 # define LT_PATHMAX 1024
@@ -4234,8 +5607,8 @@ int setenv (const char *, const char *, int);
 # define PATH_SEPARATOR ':'
 #endif
 
-#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
-  defined (__OS2__)
+#if defined _WIN32 || defined __MSDOS__ || defined __DJGPP__ || \
+  defined __OS2__
 # define HAVE_DOS_BASED_FILE_SYSTEM
 # define FOPEN_WB "wb"
 # ifndef DIR_SEPARATOR_2
@@ -4268,10 +5641,10 @@ int setenv (const char *, const char *, int);
 
 #define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
 #define XFREE(stale) do { \
-  if (stale) { free ((void *) stale); stale = 0; } \
+  if (stale) { free (stale); stale = 0; } \
 } while (0)
 
-#if defined(LT_DEBUGWRAPPER)
+#if defined LT_DEBUGWRAPPER
 static int lt_debug = 1;
 #else
 static int lt_debug = 0;
@@ -4300,11 +5673,16 @@ void lt_dump_script (FILE *f);
 EOF
 
 	    cat <<EOF
-volatile const char * MAGIC_EXE = "$magic_exe";
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5)
+# define externally_visible volatile
+#else
+# define externally_visible __attribute__((externally_visible)) volatile
+#endif
+externally_visible const char * MAGIC_EXE = "$magic_exe";
 const char * LIB_PATH_VARNAME = "$shlibpath_var";
 EOF
 
-	    if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	    if test yes = "$shlibpath_overrides_runpath" && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
               func_to_host_path "$temp_rpath"
 	      cat <<EOF
 const char * LIB_PATH_VALUE   = "$func_to_host_path_result";
@@ -4328,7 +5706,7 @@ const char * EXE_PATH_VALUE   = "";
 EOF
 	    fi
 
-	    if test "$fast_install" = yes; then
+	    if test yes = "$fast_install"; then
 	      cat <<EOF
 const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
 EOF
@@ -4357,12 +5735,12 @@ main (int argc, char *argv[])
   char *actual_cwrapper_name;
   char *target_name;
   char *lt_argv_zero;
-  intptr_t rval = 127;
+  int rval = 127;
 
   int i;
 
   program_name = (char *) xstrdup (base_name (argv[0]));
-  newargz = XMALLOC (char *, argc + 1);
+  newargz = XMALLOC (char *, (size_t) argc + 1);
 
   /* very simple arg parsing; don't want to rely on getopt
    * also, copy all non cwrapper options to newargz, except
@@ -4371,10 +5749,10 @@ main (int argc, char *argv[])
   newargc=0;
   for (i = 1; i < argc; i++)
     {
-      if (strcmp (argv[i], dumpscript_opt) == 0)
+      if (STREQ (argv[i], dumpscript_opt))
 	{
 EOF
-	    case "$host" in
+	    case $host in
 	      *mingw* | *cygwin* )
 		# make stdout use "unix" line endings
 		echo "          setmode(1,_O_BINARY);"
@@ -4385,12 +5763,12 @@ EOF
 	  lt_dump_script (stdout);
 	  return 0;
 	}
-      if (strcmp (argv[i], debug_opt) == 0)
+      if (STREQ (argv[i], debug_opt))
 	{
           lt_debug = 1;
           continue;
 	}
-      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)
+      if (STREQ (argv[i], ltwrapper_option_prefix))
         {
           /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX
              namespace, but it is not one of the ones we know about and
@@ -4413,7 +5791,7 @@ EOF
 EOF
 	    cat <<EOF
   /* The GNU banner must be the first non-error debug message */
-  lt_debugprintf (__FILE__, __LINE__, "libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\n");
+  lt_debugprintf (__FILE__, __LINE__, "libtool wrapper (GNU $PACKAGE) $VERSION\n");
 EOF
 	    cat <<"EOF"
   lt_debugprintf (__FILE__, __LINE__, "(main) argv[0]: %s\n", argv[0]);
@@ -4524,7 +5902,7 @@ EOF
 		cat <<"EOF"
   /* execv doesn't actually work on mingw as expected on unix */
   newargz = prepare_spawn (newargz);
-  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
+  rval = (int) _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
   if (rval == -1)
     {
       /* failed to start process */
@@ -4569,7 +5947,7 @@ base_name (const char *name)
 {
   const char *base;
 
-#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+#if defined HAVE_DOS_BASED_FILE_SYSTEM
   /* Skip over the disk name in MSDOS pathnames. */
   if (isalpha ((unsigned char) name[0]) && name[1] == ':')
     name += 2;
@@ -4628,7 +6006,7 @@ find_executable (const char *wrapper)
   const char *p_next;
   /* static buffer for getcwd */
   char tmp[LT_PATHMAX + 1];
-  int tmp_len;
+  size_t tmp_len;
   char *concat_name;
 
   lt_debugprintf (__FILE__, __LINE__, "(find_executable): %s\n",
@@ -4638,7 +6016,7 @@ find_executable (const char *wrapper)
     return NULL;
 
   /* Absolute path? */
-#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+#if defined HAVE_DOS_BASED_FILE_SYSTEM
   if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')
     {
       concat_name = xstrdup (wrapper);
@@ -4656,7 +6034,7 @@ find_executable (const char *wrapper)
 	    return concat_name;
 	  XFREE (concat_name);
 	}
-#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+#if defined HAVE_DOS_BASED_FILE_SYSTEM
     }
 #endif
 
@@ -4679,7 +6057,7 @@ find_executable (const char *wrapper)
 	      for (q = p; *q; q++)
 		if (IS_PATH_SEPARATOR (*q))
 		  break;
-	      p_len = q - p;
+	      p_len = (size_t) (q - p);
 	      p_next = (*q == '\0' ? q : q + 1);
 	      if (p_len == 0)
 		{
@@ -4798,7 +6176,7 @@ strendzap (char *str, const char *pat)
   if (patlen <= len)
     {
       str += len - patlen;
-      if (strcmp (str, pat) == 0)
+      if (STREQ (str, pat))
 	*str = '\0';
     }
   return str;
@@ -4863,7 +6241,7 @@ lt_setenv (const char *name, const char *value)
     char *str = xstrdup (value);
     setenv (name, str, 1);
 #else
-    int len = strlen (name) + 1 + strlen (value) + 1;
+    size_t len = strlen (name) + 1 + strlen (value) + 1;
     char *str = XMALLOC (char, len);
     sprintf (str, "%s=%s", name, value);
     if (putenv (str) != EXIT_SUCCESS)
@@ -4880,8 +6258,8 @@ lt_extend_str (const char *orig_value, const char *add, int to_end)
   char *new_value;
   if (orig_value && *orig_value)
     {
-      int orig_value_len = strlen (orig_value);
-      int add_len = strlen (add);
+      size_t orig_value_len = strlen (orig_value);
+      size_t add_len = strlen (add);
       new_value = XMALLOC (char, add_len + orig_value_len + 1);
       if (to_end)
         {
@@ -4912,10 +6290,10 @@ lt_update_exe_path (const char *name, const char *value)
     {
       char *new_value = lt_extend_str (getenv (name), value, 0);
       /* some systems can't cope with a ':'-terminated path #' */
-      int len = strlen (new_value);
-      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
+      size_t len = strlen (new_value);
+      while ((len > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
         {
-          new_value[len-1] = '\0';
+          new_value[--len] = '\0';
         }
       lt_setenv (name, new_value);
       XFREE (new_value);
@@ -5082,27 +6460,47 @@ EOF
 # True if ARG is an import lib, as indicated by $file_magic_cmd
 func_win32_import_lib_p ()
 {
-    $opt_debug
+    $debug_cmd
+
     case `eval $file_magic_cmd \"\$1\" 2>/dev/null | $SED -e 10q` in
     *import*) : ;;
     *) false ;;
     esac
 }
 
+# func_suncc_cstd_abi
+# !!ONLY CALL THIS FOR SUN CC AFTER $compile_command IS FULLY EXPANDED!!
+# Several compiler flags select an ABI that is incompatible with the
+# Cstd library. Avoid specifying it if any are in CXXFLAGS.
+func_suncc_cstd_abi ()
+{
+    $debug_cmd
+
+    case " $compile_command " in
+    *" -compat=g "*|*\ -std=c++[0-9][0-9]\ *|*" -library=stdcxx4 "*|*" -library=stlport4 "*)
+      suncc_use_cstd_abi=no
+      ;;
+    *)
+      suncc_use_cstd_abi=yes
+      ;;
+    esac
+}
+
 # func_mode_link arg...
 func_mode_link ()
 {
-    $opt_debug
+    $debug_cmd
+
     case $host in
     *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
       # It is impossible to link a dll without this setting, and
       # we shouldn't force the makefile maintainer to figure out
-      # which system we are compiling for in order to pass an extra
+      # what system we are compiling for in order to pass an extra
       # flag for every libtool invocation.
       # allow_undefined=no
 
       # FIXME: Unfortunately, there are problems with the above when trying
-      # to make a dll which has undefined symbols, in which case not
+      # to make a dll that has undefined symbols, in which case not
       # even a static library is built.  For now, we need to specify
       # -no-undefined on the libtool link line when we can be certain
       # that all symbols are satisfied, otherwise we get a static library.
@@ -5146,10 +6544,11 @@ func_mode_link ()
     module=no
     no_install=no
     objs=
+    os2dllname=
     non_pic_objects=
     precious_files_regex=
     prefer_static_libs=no
-    preload=no
+    preload=false
     prev=
     prevarg=
     release=
@@ -5161,7 +6560,7 @@ func_mode_link ()
     vinfo=
     vinfo_number=no
     weak_libs=
-    single_module="${wl}-single_module"
+    single_module=$wl-single_module
     func_infer_tag $base_compile
 
     # We need to know -static, to get the right output filenames.
@@ -5169,15 +6568,15 @@ func_mode_link ()
     do
       case $arg in
       -shared)
-	test "$build_libtool_libs" != yes && \
-	  func_fatal_configuration "can not build a shared library"
+	test yes != "$build_libtool_libs" \
+	  && func_fatal_configuration "cannot build a shared library"
 	build_old_libs=no
 	break
 	;;
       -all-static | -static | -static-libtool-libs)
 	case $arg in
 	-all-static)
-	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	  if test yes = "$build_libtool_libs" && test -z "$link_static_flag"; then
 	    func_warning "complete static linking is impossible in this configuration"
 	  fi
 	  if test -n "$link_static_flag"; then
@@ -5210,7 +6609,7 @@ func_mode_link ()
 
     # Go through the arguments, transforming them on the way.
     while test "$#" -gt 0; do
-      arg="$1"
+      arg=$1
       shift
       func_quote_for_eval "$arg"
       qarg=$func_quote_for_eval_unquoted_result
@@ -5227,21 +6626,21 @@ func_mode_link ()
 
 	case $prev in
 	bindir)
-	  bindir="$arg"
+	  bindir=$arg
 	  prev=
 	  continue
 	  ;;
 	dlfiles|dlprefiles)
-	  if test "$preload" = no; then
+	  $preload || {
 	    # Add the symbol object into the linking commands.
 	    func_append compile_command " @SYMFILE@"
 	    func_append finalize_command " @SYMFILE@"
-	    preload=yes
-	  fi
+	    preload=:
+	  }
 	  case $arg in
 	  *.la | *.lo) ;;  # We handle these cases below.
 	  force)
-	    if test "$dlself" = no; then
+	    if test no = "$dlself"; then
 	      dlself=needless
 	      export_dynamic=yes
 	    fi
@@ -5249,9 +6648,9 @@ func_mode_link ()
 	    continue
 	    ;;
 	  self)
-	    if test "$prev" = dlprefiles; then
+	    if test dlprefiles = "$prev"; then
 	      dlself=yes
-	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	    elif test dlfiles = "$prev" && test yes != "$dlopen_self"; then
 	      dlself=yes
 	    else
 	      dlself=needless
@@ -5261,7 +6660,7 @@ func_mode_link ()
 	    continue
 	    ;;
 	  *)
-	    if test "$prev" = dlfiles; then
+	    if test dlfiles = "$prev"; then
 	      func_append dlfiles " $arg"
 	    else
 	      func_append dlprefiles " $arg"
@@ -5272,14 +6671,14 @@ func_mode_link ()
 	  esac
 	  ;;
 	expsyms)
-	  export_symbols="$arg"
+	  export_symbols=$arg
 	  test -f "$arg" \
-	    || func_fatal_error "symbol file \`$arg' does not exist"
+	    || func_fatal_error "symbol file '$arg' does not exist"
 	  prev=
 	  continue
 	  ;;
 	expsyms_regex)
-	  export_symbols_regex="$arg"
+	  export_symbols_regex=$arg
 	  prev=
 	  continue
 	  ;;
@@ -5297,7 +6696,13 @@ func_mode_link ()
 	  continue
 	  ;;
 	inst_prefix)
-	  inst_prefix_dir="$arg"
+	  inst_prefix_dir=$arg
+	  prev=
+	  continue
+	  ;;
+	mllvm)
+	  # Clang does not use LLVM to link, so we can simply discard any
+	  # '-mllvm $arg' options when doing the link step.
 	  prev=
 	  continue
 	  ;;
@@ -5321,21 +6726,21 @@ func_mode_link ()
 
 		if test -z "$pic_object" ||
 		   test -z "$non_pic_object" ||
-		   test "$pic_object" = none &&
-		   test "$non_pic_object" = none; then
-		  func_fatal_error "cannot find name of object for \`$arg'"
+		   test none = "$pic_object" &&
+		   test none = "$non_pic_object"; then
+		  func_fatal_error "cannot find name of object for '$arg'"
 		fi
 
 		# Extract subdirectory from the argument.
 		func_dirname "$arg" "/" ""
-		xdir="$func_dirname_result"
+		xdir=$func_dirname_result
 
-		if test "$pic_object" != none; then
+		if test none != "$pic_object"; then
 		  # Prepend the subdirectory the object is found in.
-		  pic_object="$xdir$pic_object"
+		  pic_object=$xdir$pic_object
 
-		  if test "$prev" = dlfiles; then
-		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		  if test dlfiles = "$prev"; then
+		    if test yes = "$build_libtool_libs" && test yes = "$dlopen_support"; then
 		      func_append dlfiles " $pic_object"
 		      prev=
 		      continue
@@ -5346,7 +6751,7 @@ func_mode_link ()
 		  fi
 
 		  # CHECK ME:  I think I busted this.  -Ossama
-		  if test "$prev" = dlprefiles; then
+		  if test dlprefiles = "$prev"; then
 		    # Preload the old-style object.
 		    func_append dlprefiles " $pic_object"
 		    prev=
@@ -5354,23 +6759,23 @@ func_mode_link ()
 
 		  # A PIC object.
 		  func_append libobjs " $pic_object"
-		  arg="$pic_object"
+		  arg=$pic_object
 		fi
 
 		# Non-PIC object.
-		if test "$non_pic_object" != none; then
+		if test none != "$non_pic_object"; then
 		  # Prepend the subdirectory the object is found in.
-		  non_pic_object="$xdir$non_pic_object"
+		  non_pic_object=$xdir$non_pic_object
 
 		  # A standard non-PIC object
 		  func_append non_pic_objects " $non_pic_object"
-		  if test -z "$pic_object" || test "$pic_object" = none ; then
-		    arg="$non_pic_object"
+		  if test -z "$pic_object" || test none = "$pic_object"; then
+		    arg=$non_pic_object
 		  fi
 		else
 		  # If the PIC object exists, use it instead.
 		  # $xdir was prepended to $pic_object above.
-		  non_pic_object="$pic_object"
+		  non_pic_object=$pic_object
 		  func_append non_pic_objects " $non_pic_object"
 		fi
 	      else
@@ -5378,7 +6783,7 @@ func_mode_link ()
 		if $opt_dry_run; then
 		  # Extract subdirectory from the argument.
 		  func_dirname "$arg" "/" ""
-		  xdir="$func_dirname_result"
+		  xdir=$func_dirname_result
 
 		  func_lo2o "$arg"
 		  pic_object=$xdir$objdir/$func_lo2o_result
@@ -5386,24 +6791,29 @@ func_mode_link ()
 		  func_append libobjs " $pic_object"
 		  func_append non_pic_objects " $non_pic_object"
 	        else
-		  func_fatal_error "\`$arg' is not a valid libtool object"
+		  func_fatal_error "'$arg' is not a valid libtool object"
 		fi
 	      fi
 	    done
 	  else
-	    func_fatal_error "link input file \`$arg' does not exist"
+	    func_fatal_error "link input file '$arg' does not exist"
 	  fi
 	  arg=$save_arg
 	  prev=
 	  continue
 	  ;;
+	os2dllname)
+	  os2dllname=$arg
+	  prev=
+	  continue
+	  ;;
 	precious_regex)
-	  precious_files_regex="$arg"
+	  precious_files_regex=$arg
 	  prev=
 	  continue
 	  ;;
 	release)
-	  release="-$arg"
+	  release=-$arg
 	  prev=
 	  continue
 	  ;;
@@ -5415,7 +6825,7 @@ func_mode_link ()
 	    func_fatal_error "only absolute run-paths are allowed"
 	    ;;
 	  esac
-	  if test "$prev" = rpath; then
+	  if test rpath = "$prev"; then
 	    case "$rpath " in
 	    *" $arg "*) ;;
 	    *) func_append rpath " $arg" ;;
@@ -5430,7 +6840,7 @@ func_mode_link ()
 	  continue
 	  ;;
 	shrext)
-	  shrext_cmds="$arg"
+	  shrext_cmds=$arg
 	  prev=
 	  continue
 	  ;;
@@ -5470,7 +6880,7 @@ func_mode_link ()
 	esac
       fi # test -n "$prev"
 
-      prevarg="$arg"
+      prevarg=$arg
 
       case $arg in
       -all-static)
@@ -5484,7 +6894,7 @@ func_mode_link ()
 
       -allow-undefined)
 	# FIXME: remove this flag sometime in the future.
-	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	func_fatal_error "'-allow-undefined' must not be used because it is the default"
 	;;
 
       -avoid-version)
@@ -5516,7 +6926,7 @@ func_mode_link ()
 	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
 	  func_fatal_error "more than one -exported-symbols argument is not allowed"
 	fi
-	if test "X$arg" = "X-export-symbols"; then
+	if test X-export-symbols = "X$arg"; then
 	  prev=expsyms
 	else
 	  prev=expsyms_regex
@@ -5550,9 +6960,9 @@ func_mode_link ()
 	func_stripname "-L" '' "$arg"
 	if test -z "$func_stripname_result"; then
 	  if test "$#" -gt 0; then
-	    func_fatal_error "require no space between \`-L' and \`$1'"
+	    func_fatal_error "require no space between '-L' and '$1'"
 	  else
-	    func_fatal_error "need path for \`-L' option"
+	    func_fatal_error "need path for '-L' option"
 	  fi
 	fi
 	func_resolve_sysroot "$func_stripname_result"
@@ -5563,8 +6973,8 @@ func_mode_link ()
 	*)
 	  absdir=`cd "$dir" && pwd`
 	  test -z "$absdir" && \
-	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
-	  dir="$absdir"
+	    func_fatal_error "cannot determine absolute directory name of '$dir'"
+	  dir=$absdir
 	  ;;
 	esac
 	case "$deplibs " in
@@ -5599,7 +7009,7 @@ func_mode_link ()
 	;;
 
       -l*)
-	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	if test X-lc = "X$arg" || test X-lm = "X$arg"; then
 	  case $host in
 	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)
 	    # These systems don't actually have a C or math library (as such)
@@ -5607,11 +7017,11 @@ func_mode_link ()
 	    ;;
 	  *-*-os2*)
 	    # These systems don't actually have a C library (as such)
-	    test "X$arg" = "X-lc" && continue
+	    test X-lc = "X$arg" && continue
 	    ;;
-	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)
 	    # Do not include libc due to us having libc/libc_r.
-	    test "X$arg" = "X-lc" && continue
+	    test X-lc = "X$arg" && continue
 	    ;;
 	  *-*-rhapsody* | *-*-darwin1.[012])
 	    # Rhapsody C and math libraries are in the System framework
@@ -5620,16 +7030,16 @@ func_mode_link ()
 	    ;;
 	  *-*-sco3.2v5* | *-*-sco5v6*)
 	    # Causes problems with __ctype
-	    test "X$arg" = "X-lc" && continue
+	    test X-lc = "X$arg" && continue
 	    ;;
 	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
 	    # Compiler inserts libc in the correct place for threads to work
-	    test "X$arg" = "X-lc" && continue
+	    test X-lc = "X$arg" && continue
 	    ;;
 	  esac
-	elif test "X$arg" = "X-lc_r"; then
+	elif test X-lc_r = "X$arg"; then
 	 case $host in
-	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)
 	   # Do not include libc_r directly, use -pthread flag.
 	   continue
 	   ;;
@@ -5639,6 +7049,11 @@ func_mode_link ()
 	continue
 	;;
 
+      -mllvm)
+	prev=mllvm
+	continue
+	;;
+
       -module)
 	module=yes
 	continue
@@ -5668,7 +7083,7 @@ func_mode_link ()
 	;;
 
       -multi_module)
-	single_module="${wl}-multi_module"
+	single_module=$wl-multi_module
 	continue
 	;;
 
@@ -5682,8 +7097,8 @@ func_mode_link ()
 	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)
 	  # The PATH hackery in wrapper scripts is required on Windows
 	  # and Darwin in order for the loader to find any dlls it needs.
-	  func_warning "\`-no-install' is ignored for $host"
-	  func_warning "assuming \`-no-fast-install' instead"
+	  func_warning "'-no-install' is ignored for $host"
+	  func_warning "assuming '-no-fast-install' instead"
 	  fast_install=no
 	  ;;
 	*) no_install=yes ;;
@@ -5701,6 +7116,11 @@ func_mode_link ()
 	continue
 	;;
 
+      -os2dllname)
+	prev=os2dllname
+	continue
+	;;
+
       -o) prev=output ;;
 
       -precious-files-regex)
@@ -5788,14 +7208,14 @@ func_mode_link ()
 	func_stripname '-Wc,' '' "$arg"
 	args=$func_stripname_result
 	arg=
-	save_ifs="$IFS"; IFS=','
+	save_ifs=$IFS; IFS=,
 	for flag in $args; do
-	  IFS="$save_ifs"
+	  IFS=$save_ifs
           func_quote_for_eval "$flag"
 	  func_append arg " $func_quote_for_eval_result"
 	  func_append compiler_flags " $func_quote_for_eval_result"
 	done
-	IFS="$save_ifs"
+	IFS=$save_ifs
 	func_stripname ' ' '' "$arg"
 	arg=$func_stripname_result
 	;;
@@ -5804,15 +7224,15 @@ func_mode_link ()
 	func_stripname '-Wl,' '' "$arg"
 	args=$func_stripname_result
 	arg=
-	save_ifs="$IFS"; IFS=','
+	save_ifs=$IFS; IFS=,
 	for flag in $args; do
-	  IFS="$save_ifs"
+	  IFS=$save_ifs
           func_quote_for_eval "$flag"
 	  func_append arg " $wl$func_quote_for_eval_result"
 	  func_append compiler_flags " $wl$func_quote_for_eval_result"
 	  func_append linker_flags " $func_quote_for_eval_result"
 	done
-	IFS="$save_ifs"
+	IFS=$save_ifs
 	func_stripname ' ' '' "$arg"
 	arg=$func_stripname_result
 	;;
@@ -5835,7 +7255,7 @@ func_mode_link ()
       # -msg_* for osf cc
       -msg_*)
 	func_quote_for_eval "$arg"
-	arg="$func_quote_for_eval_result"
+	arg=$func_quote_for_eval_result
 	;;
 
       # Flags to be passed through unchanged, with rationale:
@@ -5847,25 +7267,49 @@ func_mode_link ()
       # -m*, -t[45]*, -txscale* architecture-specific flags for GCC
       # -F/path              path to uninstalled frameworks, gcc on darwin
       # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC
+      # -fstack-protector*   stack protector flags for GCC
       # @file                GCC response files
       # -tp=*                Portland pgcc target processor selection
       # --sysroot=*          for sysroot support
-      # -O*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization
+      # -O*, -g*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization
+      # -specs=*             GCC specs files
+      # -stdlib=*            select c++ std lib with clang
+      # -fsanitize=*         Clang/GCC memory and address sanitizer
       -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
       -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \
-      -O*|-flto*|-fwhopr*|-fuse-linker-plugin)
+      -O*|-g*|-flto*|-fwhopr*|-fuse-linker-plugin|-fstack-protector*|-stdlib=*| \
+      -specs=*|-fsanitize=*)
         func_quote_for_eval "$arg"
-	arg="$func_quote_for_eval_result"
+	arg=$func_quote_for_eval_result
         func_append compile_command " $arg"
         func_append finalize_command " $arg"
         func_append compiler_flags " $arg"
         continue
         ;;
 
+      -Z*)
+        if test os2 = "`expr $host : '.*\(os2\)'`"; then
+          # OS/2 uses -Zxxx to specify OS/2-specific options
+	  compiler_flags="$compiler_flags $arg"
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  case $arg in
+	  -Zlinker | -Zstack)
+	    prev=xcompiler
+	    ;;
+	  esac
+	  continue
+        else
+	  # Otherwise treat like 'Some other compiler flag' below
+	  func_quote_for_eval "$arg"
+	  arg=$func_quote_for_eval_result
+        fi
+	;;
+
       # Some other compiler flag.
       -* | +*)
         func_quote_for_eval "$arg"
-	arg="$func_quote_for_eval_result"
+	arg=$func_quote_for_eval_result
 	;;
 
       *.$objext)
@@ -5886,21 +7330,21 @@ func_mode_link ()
 
 	  if test -z "$pic_object" ||
 	     test -z "$non_pic_object" ||
-	     test "$pic_object" = none &&
-	     test "$non_pic_object" = none; then
-	    func_fatal_error "cannot find name of object for \`$arg'"
+	     test none = "$pic_object" &&
+	     test none = "$non_pic_object"; then
+	    func_fatal_error "cannot find name of object for '$arg'"
 	  fi
 
 	  # Extract subdirectory from the argument.
 	  func_dirname "$arg" "/" ""
-	  xdir="$func_dirname_result"
+	  xdir=$func_dirname_result
 
-	  if test "$pic_object" != none; then
+	  test none = "$pic_object" || {
 	    # Prepend the subdirectory the object is found in.
-	    pic_object="$xdir$pic_object"
+	    pic_object=$xdir$pic_object
 
-	    if test "$prev" = dlfiles; then
-	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+	    if test dlfiles = "$prev"; then
+	      if test yes = "$build_libtool_libs" && test yes = "$dlopen_support"; then
 		func_append dlfiles " $pic_object"
 		prev=
 		continue
@@ -5911,7 +7355,7 @@ func_mode_link ()
 	    fi
 
 	    # CHECK ME:  I think I busted this.  -Ossama
-	    if test "$prev" = dlprefiles; then
+	    if test dlprefiles = "$prev"; then
 	      # Preload the old-style object.
 	      func_append dlprefiles " $pic_object"
 	      prev=
@@ -5919,23 +7363,23 @@ func_mode_link ()
 
 	    # A PIC object.
 	    func_append libobjs " $pic_object"
-	    arg="$pic_object"
-	  fi
+	    arg=$pic_object
+	  }
 
 	  # Non-PIC object.
-	  if test "$non_pic_object" != none; then
+	  if test none != "$non_pic_object"; then
 	    # Prepend the subdirectory the object is found in.
-	    non_pic_object="$xdir$non_pic_object"
+	    non_pic_object=$xdir$non_pic_object
 
 	    # A standard non-PIC object
 	    func_append non_pic_objects " $non_pic_object"
-	    if test -z "$pic_object" || test "$pic_object" = none ; then
-	      arg="$non_pic_object"
+	    if test -z "$pic_object" || test none = "$pic_object"; then
+	      arg=$non_pic_object
 	    fi
 	  else
 	    # If the PIC object exists, use it instead.
 	    # $xdir was prepended to $pic_object above.
-	    non_pic_object="$pic_object"
+	    non_pic_object=$pic_object
 	    func_append non_pic_objects " $non_pic_object"
 	  fi
 	else
@@ -5943,7 +7387,7 @@ func_mode_link ()
 	  if $opt_dry_run; then
 	    # Extract subdirectory from the argument.
 	    func_dirname "$arg" "/" ""
-	    xdir="$func_dirname_result"
+	    xdir=$func_dirname_result
 
 	    func_lo2o "$arg"
 	    pic_object=$xdir$objdir/$func_lo2o_result
@@ -5951,7 +7395,7 @@ func_mode_link ()
 	    func_append libobjs " $pic_object"
 	    func_append non_pic_objects " $non_pic_object"
 	  else
-	    func_fatal_error "\`$arg' is not a valid libtool object"
+	    func_fatal_error "'$arg' is not a valid libtool object"
 	  fi
 	fi
 	;;
@@ -5967,11 +7411,11 @@ func_mode_link ()
 	# A libtool-controlled library.
 
 	func_resolve_sysroot "$arg"
-	if test "$prev" = dlfiles; then
+	if test dlfiles = "$prev"; then
 	  # This library was specified with -dlopen.
 	  func_append dlfiles " $func_resolve_sysroot_result"
 	  prev=
-	elif test "$prev" = dlprefiles; then
+	elif test dlprefiles = "$prev"; then
 	  # The library was specified with -dlpreopen.
 	  func_append dlprefiles " $func_resolve_sysroot_result"
 	  prev=
@@ -5986,7 +7430,7 @@ func_mode_link ()
 	# Unknown arguments in both finalize_command and compile_command need
 	# to be aesthetically quoted because they are evaled later.
 	func_quote_for_eval "$arg"
-	arg="$func_quote_for_eval_result"
+	arg=$func_quote_for_eval_result
 	;;
       esac # arg
 
@@ -5998,9 +7442,9 @@ func_mode_link ()
     done # argument parsing loop
 
     test -n "$prev" && \
-      func_fatal_help "the \`$prevarg' option requires an argument"
+      func_fatal_help "the '$prevarg' option requires an argument"
 
-    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+    if test yes = "$export_dynamic" && test -n "$export_dynamic_flag_spec"; then
       eval arg=\"$export_dynamic_flag_spec\"
       func_append compile_command " $arg"
       func_append finalize_command " $arg"
@@ -6009,20 +7453,23 @@ func_mode_link ()
     oldlibs=
     # calculate the name of the file, without its directory
     func_basename "$output"
-    outputname="$func_basename_result"
-    libobjs_save="$libobjs"
+    outputname=$func_basename_result
+    libobjs_save=$libobjs
 
     if test -n "$shlibpath_var"; then
       # get the directories listed in $shlibpath_var
-      eval shlib_search_path=\`\$ECHO \"\${$shlibpath_var}\" \| \$SED \'s/:/ /g\'\`
+      eval shlib_search_path=\`\$ECHO \"\$$shlibpath_var\" \| \$SED \'s/:/ /g\'\`
     else
       shlib_search_path=
     fi
     eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
     eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
 
+    # Definition is injected by LT_CONFIG during libtool generation.
+    func_munge_path_list sys_lib_dlsearch_path "$LT_SYS_LIBRARY_PATH"
+
     func_dirname "$output" "/" ""
-    output_objdir="$func_dirname_result$objdir"
+    output_objdir=$func_dirname_result$objdir
     func_to_tool_file "$output_objdir/"
     tool_output_objdir=$func_to_tool_file_result
     # Create the object directory.
@@ -6045,7 +7492,7 @@ func_mode_link ()
     # Find all interdependent deplibs by searching for libraries
     # that are linked more than once (e.g. -la -lb -la)
     for deplib in $deplibs; do
-      if $opt_preserve_dup_deps ; then
+      if $opt_preserve_dup_deps; then
 	case "$libs " in
 	*" $deplib "*) func_append specialdeplibs " $deplib" ;;
 	esac
@@ -6053,7 +7500,7 @@ func_mode_link ()
       func_append libs " $deplib"
     done
 
-    if test "$linkmode" = lib; then
+    if test lib = "$linkmode"; then
       libs="$predeps $libs $compiler_lib_search_path $postdeps"
 
       # Compute libraries that are listed more than once in $predeps
@@ -6085,7 +7532,7 @@ func_mode_link ()
 	  case $file in
 	  *.la) ;;
 	  *)
-	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    func_fatal_help "libraries can '-dlopen' only libtool libraries: $file"
 	    ;;
 	  esac
 	done
@@ -6093,7 +7540,7 @@ func_mode_link ()
     prog)
 	compile_deplibs=
 	finalize_deplibs=
-	alldeplibs=no
+	alldeplibs=false
 	newdlfiles=
 	newdlprefiles=
 	passes="conv scan dlopen dlpreopen link"
@@ -6105,32 +7552,32 @@ func_mode_link ()
     for pass in $passes; do
       # The preopen pass in lib mode reverses $deplibs; put it back here
       # so that -L comes before libs that need it for instance...
-      if test "$linkmode,$pass" = "lib,link"; then
+      if test lib,link = "$linkmode,$pass"; then
 	## FIXME: Find the place where the list is rebuilt in the wrong
 	##        order, and fix it there properly
         tmp_deplibs=
 	for deplib in $deplibs; do
 	  tmp_deplibs="$deplib $tmp_deplibs"
 	done
-	deplibs="$tmp_deplibs"
+	deplibs=$tmp_deplibs
       fi
 
-      if test "$linkmode,$pass" = "lib,link" ||
-	 test "$linkmode,$pass" = "prog,scan"; then
-	libs="$deplibs"
+      if test lib,link = "$linkmode,$pass" ||
+	 test prog,scan = "$linkmode,$pass"; then
+	libs=$deplibs
 	deplibs=
       fi
-      if test "$linkmode" = prog; then
+      if test prog = "$linkmode"; then
 	case $pass in
-	dlopen) libs="$dlfiles" ;;
-	dlpreopen) libs="$dlprefiles" ;;
+	dlopen) libs=$dlfiles ;;
+	dlpreopen) libs=$dlprefiles ;;
 	link)
 	  libs="$deplibs %DEPLIBS%"
 	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
 	  ;;
 	esac
       fi
-      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+      if test lib,dlpreopen = "$linkmode,$pass"; then
 	# Collect and forward deplibs of preopened libtool libs
 	for lib in $dlprefiles; do
 	  # Ignore non-libtool-libs
@@ -6151,26 +7598,26 @@ func_mode_link ()
 	    esac
 	  done
 	done
-	libs="$dlprefiles"
+	libs=$dlprefiles
       fi
-      if test "$pass" = dlopen; then
+      if test dlopen = "$pass"; then
 	# Collect dlpreopened libraries
-	save_deplibs="$deplibs"
+	save_deplibs=$deplibs
 	deplibs=
       fi
 
       for deplib in $libs; do
 	lib=
-	found=no
+	found=false
 	case $deplib in
 	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \
         |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)
-	  if test "$linkmode,$pass" = "prog,link"; then
+	  if test prog,link = "$linkmode,$pass"; then
 	    compile_deplibs="$deplib $compile_deplibs"
 	    finalize_deplibs="$deplib $finalize_deplibs"
 	  else
 	    func_append compiler_flags " $deplib"
-	    if test "$linkmode" = lib ; then
+	    if test lib = "$linkmode"; then
 		case "$new_inherited_linker_flags " in
 		    *" $deplib "*) ;;
 		    * ) func_append new_inherited_linker_flags " $deplib" ;;
@@ -6180,13 +7627,13 @@ func_mode_link ()
 	  continue
 	  ;;
 	-l*)
-	  if test "$linkmode" != lib && test "$linkmode" != prog; then
-	    func_warning "\`-l' is ignored for archives/objects"
+	  if test lib != "$linkmode" && test prog != "$linkmode"; then
+	    func_warning "'-l' is ignored for archives/objects"
 	    continue
 	  fi
 	  func_stripname '-l' '' "$deplib"
 	  name=$func_stripname_result
-	  if test "$linkmode" = lib; then
+	  if test lib = "$linkmode"; then
 	    searchdirs="$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path"
 	  else
 	    searchdirs="$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path"
@@ -6194,31 +7641,22 @@ func_mode_link ()
 	  for searchdir in $searchdirs; do
 	    for search_ext in .la $std_shrext .so .a; do
 	      # Search the libtool library
-	      lib="$searchdir/lib${name}${search_ext}"
+	      lib=$searchdir/lib$name$search_ext
 	      if test -f "$lib"; then
-		if test "$search_ext" = ".la"; then
-		  found=yes
+		if test .la = "$search_ext"; then
+		  found=:
 		else
-		  found=no
+		  found=false
 		fi
 		break 2
 	      fi
 	    done
 	  done
-	  if test "$found" != yes; then
-	    # deplib doesn't seem to be a libtool library
-	    if test "$linkmode,$pass" = "prog,link"; then
-	      compile_deplibs="$deplib $compile_deplibs"
-	      finalize_deplibs="$deplib $finalize_deplibs"
-	    else
-	      deplibs="$deplib $deplibs"
-	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
-	    fi
-	    continue
-	  else # deplib is a libtool library
+	  if $found; then
+	    # deplib is a libtool library
 	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
 	    # We need to do some special things here, and not later.
-	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    if test yes = "$allow_libtool_libs_with_static_runtimes"; then
 	      case " $predeps $postdeps " in
 	      *" $deplib "*)
 		if func_lalib_p "$lib"; then
@@ -6226,19 +7664,19 @@ func_mode_link ()
 		  old_library=
 		  func_source "$lib"
 		  for l in $old_library $library_names; do
-		    ll="$l"
+		    ll=$l
 		  done
-		  if test "X$ll" = "X$old_library" ; then # only static version available
-		    found=no
+		  if test "X$ll" = "X$old_library"; then # only static version available
+		    found=false
 		    func_dirname "$lib" "" "."
-		    ladir="$func_dirname_result"
+		    ladir=$func_dirname_result
 		    lib=$ladir/$old_library
-		    if test "$linkmode,$pass" = "prog,link"; then
+		    if test prog,link = "$linkmode,$pass"; then
 		      compile_deplibs="$deplib $compile_deplibs"
 		      finalize_deplibs="$deplib $finalize_deplibs"
 		    else
 		      deplibs="$deplib $deplibs"
-		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		      test lib = "$linkmode" && newdependency_libs="$deplib $newdependency_libs"
 		    fi
 		    continue
 		  fi
@@ -6247,15 +7685,25 @@ func_mode_link ()
 	      *) ;;
 	      esac
 	    fi
+	  else
+	    # deplib doesn't seem to be a libtool library
+	    if test prog,link = "$linkmode,$pass"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test lib = "$linkmode" && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
 	  fi
 	  ;; # -l
 	*.ltframework)
-	  if test "$linkmode,$pass" = "prog,link"; then
+	  if test prog,link = "$linkmode,$pass"; then
 	    compile_deplibs="$deplib $compile_deplibs"
 	    finalize_deplibs="$deplib $finalize_deplibs"
 	  else
 	    deplibs="$deplib $deplibs"
-	    if test "$linkmode" = lib ; then
+	    if test lib = "$linkmode"; then
 		case "$new_inherited_linker_flags " in
 		    *" $deplib "*) ;;
 		    * ) func_append new_inherited_linker_flags " $deplib" ;;
@@ -6268,18 +7716,18 @@ func_mode_link ()
 	  case $linkmode in
 	  lib)
 	    deplibs="$deplib $deplibs"
-	    test "$pass" = conv && continue
+	    test conv = "$pass" && continue
 	    newdependency_libs="$deplib $newdependency_libs"
 	    func_stripname '-L' '' "$deplib"
 	    func_resolve_sysroot "$func_stripname_result"
 	    func_append newlib_search_path " $func_resolve_sysroot_result"
 	    ;;
 	  prog)
-	    if test "$pass" = conv; then
+	    if test conv = "$pass"; then
 	      deplibs="$deplib $deplibs"
 	      continue
 	    fi
-	    if test "$pass" = scan; then
+	    if test scan = "$pass"; then
 	      deplibs="$deplib $deplibs"
 	    else
 	      compile_deplibs="$deplib $compile_deplibs"
@@ -6290,13 +7738,13 @@ func_mode_link ()
 	    func_append newlib_search_path " $func_resolve_sysroot_result"
 	    ;;
 	  *)
-	    func_warning "\`-L' is ignored for archives/objects"
+	    func_warning "'-L' is ignored for archives/objects"
 	    ;;
 	  esac # linkmode
 	  continue
 	  ;; # -L
 	-R*)
-	  if test "$pass" = link; then
+	  if test link = "$pass"; then
 	    func_stripname '-R' '' "$deplib"
 	    func_resolve_sysroot "$func_stripname_result"
 	    dir=$func_resolve_sysroot_result
@@ -6314,7 +7762,7 @@ func_mode_link ()
 	  lib=$func_resolve_sysroot_result
 	  ;;
 	*.$libext)
-	  if test "$pass" = conv; then
+	  if test conv = "$pass"; then
 	    deplibs="$deplib $deplibs"
 	    continue
 	  fi
@@ -6325,21 +7773,26 @@ func_mode_link ()
 	    case " $dlpreconveniencelibs " in
 	    *" $deplib "*) ;;
 	    *)
-	      valid_a_lib=no
+	      valid_a_lib=false
 	      case $deplibs_check_method in
 		match_pattern*)
 		  set dummy $deplibs_check_method; shift
 		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
 		  if eval "\$ECHO \"$deplib\"" 2>/dev/null | $SED 10q \
 		    | $EGREP "$match_pattern_regex" > /dev/null; then
-		    valid_a_lib=yes
+		    valid_a_lib=:
 		  fi
 		;;
 		pass_all)
-		  valid_a_lib=yes
+		  valid_a_lib=:
 		;;
 	      esac
-	      if test "$valid_a_lib" != yes; then
+	      if $valid_a_lib; then
+		echo
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      else
 		echo
 		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
 		echo "*** I have the capability to make that library automatically link in when"
@@ -6347,18 +7800,13 @@ func_mode_link ()
 		echo "*** shared version of the library, which you do not appear to have"
 		echo "*** because the file extensions .$libext of this argument makes me believe"
 		echo "*** that it is just a static archive that I should not use here."
-	      else
-		echo
-		$ECHO "*** Warning: Linking the shared library $output against the"
-		$ECHO "*** static library $deplib is not portable!"
-		deplibs="$deplib $deplibs"
 	      fi
 	      ;;
 	    esac
 	    continue
 	    ;;
 	  prog)
-	    if test "$pass" != link; then
+	    if test link != "$pass"; then
 	      deplibs="$deplib $deplibs"
 	    else
 	      compile_deplibs="$deplib $compile_deplibs"
@@ -6369,10 +7817,10 @@ func_mode_link ()
 	  esac # linkmode
 	  ;; # *.$libext
 	*.lo | *.$objext)
-	  if test "$pass" = conv; then
+	  if test conv = "$pass"; then
 	    deplibs="$deplib $deplibs"
-	  elif test "$linkmode" = prog; then
-	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	  elif test prog = "$linkmode"; then
+	    if test dlpreopen = "$pass" || test yes != "$dlopen_support" || test no = "$build_libtool_libs"; then
 	      # If there is no dlopen support or we're linking statically,
 	      # we need to preload.
 	      func_append newdlprefiles " $deplib"
@@ -6385,22 +7833,20 @@ func_mode_link ()
 	  continue
 	  ;;
 	%DEPLIBS%)
-	  alldeplibs=yes
+	  alldeplibs=:
 	  continue
 	  ;;
 	esac # case $deplib
 
-	if test "$found" = yes || test -f "$lib"; then :
-	else
-	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
-	fi
+	$found || test -f "$lib" \
+	  || func_fatal_error "cannot find the library '$lib' or unhandled argument '$deplib'"
 
 	# Check to see that this really is a libtool archive.
 	func_lalib_unsafe_p "$lib" \
-	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+	  || func_fatal_error "'$lib' is not a valid libtool archive"
 
 	func_dirname "$lib" "" "."
-	ladir="$func_dirname_result"
+	ladir=$func_dirname_result
 
 	dlname=
 	dlopen=
@@ -6430,19 +7876,19 @@ func_mode_link ()
 	  done
 	fi
 	dependency_libs=`$ECHO " $dependency_libs" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
-	if test "$linkmode,$pass" = "lib,link" ||
-	   test "$linkmode,$pass" = "prog,scan" ||
-	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	if test lib,link = "$linkmode,$pass" ||
+	   test prog,scan = "$linkmode,$pass" ||
+	   { test prog != "$linkmode" && test lib != "$linkmode"; }; then
 	  test -n "$dlopen" && func_append dlfiles " $dlopen"
 	  test -n "$dlpreopen" && func_append dlprefiles " $dlpreopen"
 	fi
 
-	if test "$pass" = conv; then
+	if test conv = "$pass"; then
 	  # Only check for convenience libraries
 	  deplibs="$lib $deplibs"
 	  if test -z "$libdir"; then
 	    if test -z "$old_library"; then
-	      func_fatal_error "cannot find name of link library for \`$lib'"
+	      func_fatal_error "cannot find name of link library for '$lib'"
 	    fi
 	    # It is a libtool convenience library, so add in its objects.
 	    func_append convenience " $ladir/$objdir/$old_library"
@@ -6450,15 +7896,15 @@ func_mode_link ()
 	    tmp_libs=
 	    for deplib in $dependency_libs; do
 	      deplibs="$deplib $deplibs"
-	      if $opt_preserve_dup_deps ; then
+	      if $opt_preserve_dup_deps; then
 		case "$tmp_libs " in
 		*" $deplib "*) func_append specialdeplibs " $deplib" ;;
 		esac
 	      fi
 	      func_append tmp_libs " $deplib"
 	    done
-	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
-	    func_fatal_error "\`$lib' is not a convenience library"
+	  elif test prog != "$linkmode" && test lib != "$linkmode"; then
+	    func_fatal_error "'$lib' is not a convenience library"
 	  fi
 	  continue
 	fi # $pass = conv
@@ -6467,26 +7913,26 @@ func_mode_link ()
 	# Get the name of the library we link against.
 	linklib=
 	if test -n "$old_library" &&
-	   { test "$prefer_static_libs" = yes ||
-	     test "$prefer_static_libs,$installed" = "built,no"; }; then
+	   { test yes = "$prefer_static_libs" ||
+	     test built,no = "$prefer_static_libs,$installed"; }; then
 	  linklib=$old_library
 	else
 	  for l in $old_library $library_names; do
-	    linklib="$l"
+	    linklib=$l
 	  done
 	fi
 	if test -z "$linklib"; then
-	  func_fatal_error "cannot find name of link library for \`$lib'"
+	  func_fatal_error "cannot find name of link library for '$lib'"
 	fi
 
 	# This library was specified with -dlopen.
-	if test "$pass" = dlopen; then
-	  if test -z "$libdir"; then
-	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
-	  fi
+	if test dlopen = "$pass"; then
+	  test -z "$libdir" \
+	    && func_fatal_error "cannot -dlopen a convenience library: '$lib'"
 	  if test -z "$dlname" ||
-	     test "$dlopen_support" != yes ||
-	     test "$build_libtool_libs" = no; then
+	     test yes != "$dlopen_support" ||
+	     test no = "$build_libtool_libs"
+	  then
 	    # If there is no dlname, no dlopen support or we're linking
 	    # statically, we need to preload.  We also need to preload any
 	    # dependent libraries so libltdl's deplib preloader doesn't
@@ -6500,40 +7946,40 @@ func_mode_link ()
 
 	# We need an absolute path.
 	case $ladir in
-	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir=$ladir ;;
 	*)
 	  abs_ladir=`cd "$ladir" && pwd`
 	  if test -z "$abs_ladir"; then
-	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "cannot determine absolute directory name of '$ladir'"
 	    func_warning "passing it literally to the linker, although it might fail"
-	    abs_ladir="$ladir"
+	    abs_ladir=$ladir
 	  fi
 	  ;;
 	esac
 	func_basename "$lib"
-	laname="$func_basename_result"
+	laname=$func_basename_result
 
 	# Find the relevant object directory and library name.
-	if test "X$installed" = Xyes; then
+	if test yes = "$installed"; then
 	  if test ! -f "$lt_sysroot$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
-	    func_warning "library \`$lib' was moved."
-	    dir="$ladir"
-	    absdir="$abs_ladir"
-	    libdir="$abs_ladir"
+	    func_warning "library '$lib' was moved."
+	    dir=$ladir
+	    absdir=$abs_ladir
+	    libdir=$abs_ladir
 	  else
-	    dir="$lt_sysroot$libdir"
-	    absdir="$lt_sysroot$libdir"
+	    dir=$lt_sysroot$libdir
+	    absdir=$lt_sysroot$libdir
 	  fi
-	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	  test yes = "$hardcode_automatic" && avoidtemprpath=yes
 	else
 	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
-	    dir="$ladir"
-	    absdir="$abs_ladir"
+	    dir=$ladir
+	    absdir=$abs_ladir
 	    # Remove this search path later
 	    func_append notinst_path " $abs_ladir"
 	  else
-	    dir="$ladir/$objdir"
-	    absdir="$abs_ladir/$objdir"
+	    dir=$ladir/$objdir
+	    absdir=$abs_ladir/$objdir
 	    # Remove this search path later
 	    func_append notinst_path " $abs_ladir"
 	  fi
@@ -6542,11 +7988,11 @@ func_mode_link ()
 	name=$func_stripname_result
 
 	# This library was specified with -dlpreopen.
-	if test "$pass" = dlpreopen; then
-	  if test -z "$libdir" && test "$linkmode" = prog; then
-	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	if test dlpreopen = "$pass"; then
+	  if test -z "$libdir" && test prog = "$linkmode"; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: '$lib'"
 	  fi
-	  case "$host" in
+	  case $host in
 	    # special handling for platforms with PE-DLLs.
 	    *cygwin* | *mingw* | *cegcc* )
 	      # Linker will automatically link against shared library if both
@@ -6590,9 +8036,9 @@ func_mode_link ()
 
 	if test -z "$libdir"; then
 	  # Link the convenience library
-	  if test "$linkmode" = lib; then
+	  if test lib = "$linkmode"; then
 	    deplibs="$dir/$old_library $deplibs"
-	  elif test "$linkmode,$pass" = "prog,link"; then
+	  elif test prog,link = "$linkmode,$pass"; then
 	    compile_deplibs="$dir/$old_library $compile_deplibs"
 	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
 	  else
@@ -6602,14 +8048,14 @@ func_mode_link ()
 	fi
 
 
-	if test "$linkmode" = prog && test "$pass" != link; then
+	if test prog = "$linkmode" && test link != "$pass"; then
 	  func_append newlib_search_path " $ladir"
 	  deplibs="$lib $deplibs"
 
-	  linkalldeplibs=no
-	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
-	     test "$build_libtool_libs" = no; then
-	    linkalldeplibs=yes
+	  linkalldeplibs=false
+	  if test no != "$link_all_deplibs" || test -z "$library_names" ||
+	     test no = "$build_libtool_libs"; then
+	    linkalldeplibs=:
 	  fi
 
 	  tmp_libs=
@@ -6621,14 +8067,14 @@ func_mode_link ()
 		 ;;
 	    esac
 	    # Need to link against all dependency_libs?
-	    if test "$linkalldeplibs" = yes; then
+	    if $linkalldeplibs; then
 	      deplibs="$deplib $deplibs"
 	    else
 	      # Need to hardcode shared library paths
 	      # or/and link against static libraries
 	      newdependency_libs="$deplib $newdependency_libs"
 	    fi
-	    if $opt_preserve_dup_deps ; then
+	    if $opt_preserve_dup_deps; then
 	      case "$tmp_libs " in
 	      *" $deplib "*) func_append specialdeplibs " $deplib" ;;
 	      esac
@@ -6638,15 +8084,15 @@ func_mode_link ()
 	  continue
 	fi # $linkmode = prog...
 
-	if test "$linkmode,$pass" = "prog,link"; then
+	if test prog,link = "$linkmode,$pass"; then
 	  if test -n "$library_names" &&
-	     { { test "$prefer_static_libs" = no ||
-	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	     { { test no = "$prefer_static_libs" ||
+	         test built,yes = "$prefer_static_libs,$installed"; } ||
 	       test -z "$old_library"; }; then
 	    # We need to hardcode the library path
-	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath"; then
 	      # Make sure the rpath contains only unique directories.
-	      case "$temp_rpath:" in
+	      case $temp_rpath: in
 	      *"$absdir:"*) ;;
 	      *) func_append temp_rpath "$absdir:" ;;
 	      esac
@@ -6675,9 +8121,9 @@ func_mode_link ()
 	    esac
 	  fi # $linkmode,$pass = prog,link...
 
-	  if test "$alldeplibs" = yes &&
-	     { test "$deplibs_check_method" = pass_all ||
-	       { test "$build_libtool_libs" = yes &&
+	  if $alldeplibs &&
+	     { test pass_all = "$deplibs_check_method" ||
+	       { test yes = "$build_libtool_libs" &&
 		 test -n "$library_names"; }; }; then
 	    # We only need to search for static libraries
 	    continue
@@ -6686,19 +8132,19 @@ func_mode_link ()
 
 	link_static=no # Whether the deplib will be linked statically
 	use_static_libs=$prefer_static_libs
-	if test "$use_static_libs" = built && test "$installed" = yes; then
+	if test built = "$use_static_libs" && test yes = "$installed"; then
 	  use_static_libs=no
 	fi
 	if test -n "$library_names" &&
-	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	   { test no = "$use_static_libs" || test -z "$old_library"; }; then
 	  case $host in
-	  *cygwin* | *mingw* | *cegcc*)
+	  *cygwin* | *mingw* | *cegcc* | *os2*)
 	      # No point in relinking DLLs because paths are not encoded
 	      func_append notinst_deplibs " $lib"
 	      need_relink=no
 	    ;;
 	  *)
-	    if test "$installed" = no; then
+	    if test no = "$installed"; then
 	      func_append notinst_deplibs " $lib"
 	      need_relink=yes
 	    fi
@@ -6708,24 +8154,24 @@ func_mode_link ()
 
 	  # Warn about portability, can't link against -module's on some
 	  # systems (darwin).  Don't bleat about dlopened modules though!
-	  dlopenmodule=""
+	  dlopenmodule=
 	  for dlpremoduletest in $dlprefiles; do
 	    if test "X$dlpremoduletest" = "X$lib"; then
-	      dlopenmodule="$dlpremoduletest"
+	      dlopenmodule=$dlpremoduletest
 	      break
 	    fi
 	  done
-	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	  if test -z "$dlopenmodule" && test yes = "$shouldnotlink" && test link = "$pass"; then
 	    echo
-	    if test "$linkmode" = prog; then
+	    if test prog = "$linkmode"; then
 	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
 	    else
 	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
 	    fi
 	    $ECHO "*** $linklib is not portable!"
 	  fi
-	  if test "$linkmode" = lib &&
-	     test "$hardcode_into_libs" = yes; then
+	  if test lib = "$linkmode" &&
+	     test yes = "$hardcode_into_libs"; then
 	    # Hardcode the library path.
 	    # Skip directories that are in the system default run-time
 	    # search path.
@@ -6753,43 +8199,43 @@ func_mode_link ()
 	    # figure out the soname
 	    set dummy $library_names
 	    shift
-	    realname="$1"
+	    realname=$1
 	    shift
 	    libname=`eval "\\$ECHO \"$libname_spec\""`
 	    # use dlname if we got it. it's perfectly good, no?
 	    if test -n "$dlname"; then
-	      soname="$dlname"
+	      soname=$dlname
 	    elif test -n "$soname_spec"; then
 	      # bleh windows
 	      case $host in
-	      *cygwin* | mingw* | *cegcc*)
+	      *cygwin* | mingw* | *cegcc* | *os2*)
 	        func_arith $current - $age
 		major=$func_arith_result
-		versuffix="-$major"
+		versuffix=-$major
 		;;
 	      esac
 	      eval soname=\"$soname_spec\"
 	    else
-	      soname="$realname"
+	      soname=$realname
 	    fi
 
 	    # Make a new name for the extract_expsyms_cmds to use
-	    soroot="$soname"
+	    soroot=$soname
 	    func_basename "$soroot"
-	    soname="$func_basename_result"
+	    soname=$func_basename_result
 	    func_stripname 'lib' '.dll' "$soname"
 	    newlib=libimp-$func_stripname_result.a
 
 	    # If the library has no export list, then create one now
 	    if test -f "$output_objdir/$soname-def"; then :
 	    else
-	      func_verbose "extracting exported symbol list from \`$soname'"
+	      func_verbose "extracting exported symbol list from '$soname'"
 	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
 	    fi
 
 	    # Create $newlib
 	    if test -f "$output_objdir/$newlib"; then :; else
-	      func_verbose "generating import library for \`$soname'"
+	      func_verbose "generating import library for '$soname'"
 	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
 	    fi
 	    # make sure the library variables are pointing to the new library
@@ -6797,58 +8243,58 @@ func_mode_link ()
 	    linklib=$newlib
 	  fi # test -n "$old_archive_from_expsyms_cmds"
 
-	  if test "$linkmode" = prog || test "$opt_mode" != relink; then
+	  if test prog = "$linkmode" || test relink != "$opt_mode"; then
 	    add_shlibpath=
 	    add_dir=
 	    add=
 	    lib_linked=yes
 	    case $hardcode_action in
 	    immediate | unsupported)
-	      if test "$hardcode_direct" = no; then
-		add="$dir/$linklib"
+	      if test no = "$hardcode_direct"; then
+		add=$dir/$linklib
 		case $host in
-		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
-		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sco3.2v5.0.[024]*) add_dir=-L$dir ;;
+		  *-*-sysv4*uw2*) add_dir=-L$dir ;;
 		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
-		    *-*-unixware7*) add_dir="-L$dir" ;;
+		    *-*-unixware7*) add_dir=-L$dir ;;
 		  *-*-darwin* )
-		    # if the lib is a (non-dlopened) module then we can not
+		    # if the lib is a (non-dlopened) module then we cannot
 		    # link against it, someone is ignoring the earlier warnings
 		    if /usr/bin/file -L $add 2> /dev/null |
-			 $GREP ": [^:]* bundle" >/dev/null ; then
+			 $GREP ": [^:]* bundle" >/dev/null; then
 		      if test "X$dlopenmodule" != "X$lib"; then
 			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
-			if test -z "$old_library" ; then
+			if test -z "$old_library"; then
 			  echo
 			  echo "*** And there doesn't seem to be a static archive available"
 			  echo "*** The link will probably fail, sorry"
 			else
-			  add="$dir/$old_library"
+			  add=$dir/$old_library
 			fi
 		      elif test -n "$old_library"; then
-			add="$dir/$old_library"
+			add=$dir/$old_library
 		      fi
 		    fi
 		esac
-	      elif test "$hardcode_minus_L" = no; then
+	      elif test no = "$hardcode_minus_L"; then
 		case $host in
-		*-*-sunos*) add_shlibpath="$dir" ;;
+		*-*-sunos*) add_shlibpath=$dir ;;
 		esac
-		add_dir="-L$dir"
-		add="-l$name"
-	      elif test "$hardcode_shlibpath_var" = no; then
-		add_shlibpath="$dir"
-		add="-l$name"
+		add_dir=-L$dir
+		add=-l$name
+	      elif test no = "$hardcode_shlibpath_var"; then
+		add_shlibpath=$dir
+		add=-l$name
 	      else
 		lib_linked=no
 	      fi
 	      ;;
 	    relink)
-	      if test "$hardcode_direct" = yes &&
-	         test "$hardcode_direct_absolute" = no; then
-		add="$dir/$linklib"
-	      elif test "$hardcode_minus_L" = yes; then
-		add_dir="-L$absdir"
+	      if test yes = "$hardcode_direct" &&
+	         test no = "$hardcode_direct_absolute"; then
+		add=$dir/$linklib
+	      elif test yes = "$hardcode_minus_L"; then
+		add_dir=-L$absdir
 		# Try looking first in the location we're being installed to.
 		if test -n "$inst_prefix_dir"; then
 		  case $libdir in
@@ -6857,10 +8303,10 @@ func_mode_link ()
 		      ;;
 		  esac
 		fi
-		add="-l$name"
-	      elif test "$hardcode_shlibpath_var" = yes; then
-		add_shlibpath="$dir"
-		add="-l$name"
+		add=-l$name
+	      elif test yes = "$hardcode_shlibpath_var"; then
+		add_shlibpath=$dir
+		add=-l$name
 	      else
 		lib_linked=no
 	      fi
@@ -6868,7 +8314,7 @@ func_mode_link ()
 	    *) lib_linked=no ;;
 	    esac
 
-	    if test "$lib_linked" != yes; then
+	    if test yes != "$lib_linked"; then
 	      func_fatal_configuration "unsupported hardcode properties"
 	    fi
 
@@ -6878,15 +8324,15 @@ func_mode_link ()
 	      *) func_append compile_shlibpath "$add_shlibpath:" ;;
 	      esac
 	    fi
-	    if test "$linkmode" = prog; then
+	    if test prog = "$linkmode"; then
 	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
 	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
 	    else
 	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
 	      test -n "$add" && deplibs="$add $deplibs"
-	      if test "$hardcode_direct" != yes &&
-		 test "$hardcode_minus_L" != yes &&
-		 test "$hardcode_shlibpath_var" = yes; then
+	      if test yes != "$hardcode_direct" &&
+		 test yes != "$hardcode_minus_L" &&
+		 test yes = "$hardcode_shlibpath_var"; then
 		case :$finalize_shlibpath: in
 		*":$libdir:"*) ;;
 		*) func_append finalize_shlibpath "$libdir:" ;;
@@ -6895,33 +8341,33 @@ func_mode_link ()
 	    fi
 	  fi
 
-	  if test "$linkmode" = prog || test "$opt_mode" = relink; then
+	  if test prog = "$linkmode" || test relink = "$opt_mode"; then
 	    add_shlibpath=
 	    add_dir=
 	    add=
 	    # Finalize command for both is simple: just hardcode it.
-	    if test "$hardcode_direct" = yes &&
-	       test "$hardcode_direct_absolute" = no; then
-	      add="$libdir/$linklib"
-	    elif test "$hardcode_minus_L" = yes; then
-	      add_dir="-L$libdir"
-	      add="-l$name"
-	    elif test "$hardcode_shlibpath_var" = yes; then
+	    if test yes = "$hardcode_direct" &&
+	       test no = "$hardcode_direct_absolute"; then
+	      add=$libdir/$linklib
+	    elif test yes = "$hardcode_minus_L"; then
+	      add_dir=-L$libdir
+	      add=-l$name
+	    elif test yes = "$hardcode_shlibpath_var"; then
 	      case :$finalize_shlibpath: in
 	      *":$libdir:"*) ;;
 	      *) func_append finalize_shlibpath "$libdir:" ;;
 	      esac
-	      add="-l$name"
-	    elif test "$hardcode_automatic" = yes; then
+	      add=-l$name
+	    elif test yes = "$hardcode_automatic"; then
 	      if test -n "$inst_prefix_dir" &&
-		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
-		add="$inst_prefix_dir$libdir/$linklib"
+		 test -f "$inst_prefix_dir$libdir/$linklib"; then
+		add=$inst_prefix_dir$libdir/$linklib
 	      else
-		add="$libdir/$linklib"
+		add=$libdir/$linklib
 	      fi
 	    else
 	      # We cannot seem to hardcode it, guess we'll fake it.
-	      add_dir="-L$libdir"
+	      add_dir=-L$libdir
 	      # Try looking first in the location we're being installed to.
 	      if test -n "$inst_prefix_dir"; then
 		case $libdir in
@@ -6930,10 +8376,10 @@ func_mode_link ()
 		    ;;
 		esac
 	      fi
-	      add="-l$name"
+	      add=-l$name
 	    fi
 
-	    if test "$linkmode" = prog; then
+	    if test prog = "$linkmode"; then
 	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
 	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
 	    else
@@ -6941,43 +8387,43 @@ func_mode_link ()
 	      test -n "$add" && deplibs="$add $deplibs"
 	    fi
 	  fi
-	elif test "$linkmode" = prog; then
+	elif test prog = "$linkmode"; then
 	  # Here we assume that one of hardcode_direct or hardcode_minus_L
 	  # is not unsupported.  This is valid on all known static and
 	  # shared platforms.
-	  if test "$hardcode_direct" != unsupported; then
-	    test -n "$old_library" && linklib="$old_library"
+	  if test unsupported != "$hardcode_direct"; then
+	    test -n "$old_library" && linklib=$old_library
 	    compile_deplibs="$dir/$linklib $compile_deplibs"
 	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
 	  else
 	    compile_deplibs="-l$name -L$dir $compile_deplibs"
 	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
 	  fi
-	elif test "$build_libtool_libs" = yes; then
+	elif test yes = "$build_libtool_libs"; then
 	  # Not a shared library
-	  if test "$deplibs_check_method" != pass_all; then
+	  if test pass_all != "$deplibs_check_method"; then
 	    # We're trying link a shared library against a static one
 	    # but the system doesn't support it.
 
 	    # Just print a warning and add the library to dependency_libs so
 	    # that the program can be linked against the static library.
 	    echo
-	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    $ECHO "*** Warning: This system cannot link to static lib archive $lib."
 	    echo "*** I have the capability to make that library automatically link in when"
 	    echo "*** you link to this library.  But I can only do this if you have a"
 	    echo "*** shared version of the library, which you do not appear to have."
-	    if test "$module" = yes; then
+	    if test yes = "$module"; then
 	      echo "*** But as you try to build a module library, libtool will still create "
 	      echo "*** a static module, that should work as long as the dlopening application"
 	      echo "*** is linked with the -dlopen flag to resolve symbols at runtime."
 	      if test -z "$global_symbol_pipe"; then
 		echo
 		echo "*** However, this would only work if libtool was able to extract symbol"
-		echo "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		echo "*** lists from a program, using 'nm' or equivalent, but libtool could"
 		echo "*** not find such a program.  So, this module is probably useless."
-		echo "*** \`nm' from GNU binutils and a full rebuild may help."
+		echo "*** 'nm' from GNU binutils and a full rebuild may help."
 	      fi
-	      if test "$build_old_libs" = no; then
+	      if test no = "$build_old_libs"; then
 		build_libtool_libs=module
 		build_old_libs=yes
 	      else
@@ -6990,11 +8436,11 @@ func_mode_link ()
 	  fi
 	fi # link shared/static library?
 
-	if test "$linkmode" = lib; then
+	if test lib = "$linkmode"; then
 	  if test -n "$dependency_libs" &&
-	     { test "$hardcode_into_libs" != yes ||
-	       test "$build_old_libs" = yes ||
-	       test "$link_static" = yes; }; then
+	     { test yes != "$hardcode_into_libs" ||
+	       test yes = "$build_old_libs" ||
+	       test yes = "$link_static"; }; then
 	    # Extract -R from dependency_libs
 	    temp_deplibs=
 	    for libdir in $dependency_libs; do
@@ -7008,12 +8454,12 @@ func_mode_link ()
 	      *) func_append temp_deplibs " $libdir";;
 	      esac
 	    done
-	    dependency_libs="$temp_deplibs"
+	    dependency_libs=$temp_deplibs
 	  fi
 
 	  func_append newlib_search_path " $absdir"
 	  # Link against this library
-	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  test no = "$link_static" && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
 	  # ... and its dependency_libs
 	  tmp_libs=
 	  for deplib in $dependency_libs; do
@@ -7023,7 +8469,7 @@ func_mode_link ()
                    func_resolve_sysroot "$func_stripname_result";;
               *) func_resolve_sysroot "$deplib" ;;
             esac
-	    if $opt_preserve_dup_deps ; then
+	    if $opt_preserve_dup_deps; then
 	      case "$tmp_libs " in
 	      *" $func_resolve_sysroot_result "*)
                 func_append specialdeplibs " $func_resolve_sysroot_result" ;;
@@ -7032,12 +8478,12 @@ func_mode_link ()
 	    func_append tmp_libs " $func_resolve_sysroot_result"
 	  done
 
-	  if test "$link_all_deplibs" != no; then
+	  if test no != "$link_all_deplibs"; then
 	    # Add the search paths of all dependency libraries
 	    for deplib in $dependency_libs; do
 	      path=
 	      case $deplib in
-	      -L*) path="$deplib" ;;
+	      -L*) path=$deplib ;;
 	      *.la)
 	        func_resolve_sysroot "$deplib"
 	        deplib=$func_resolve_sysroot_result
@@ -7045,12 +8491,12 @@ func_mode_link ()
 		dir=$func_dirname_result
 		# We need an absolute path.
 		case $dir in
-		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		[\\/]* | [A-Za-z]:[\\/]*) absdir=$dir ;;
 		*)
 		  absdir=`cd "$dir" && pwd`
 		  if test -z "$absdir"; then
-		    func_warning "cannot determine absolute directory name of \`$dir'"
-		    absdir="$dir"
+		    func_warning "cannot determine absolute directory name of '$dir'"
+		    absdir=$dir
 		  fi
 		  ;;
 		esac
@@ -7058,35 +8504,35 @@ func_mode_link ()
 		case $host in
 		*-*-darwin*)
 		  depdepl=
-		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
-		  if test -n "$deplibrary_names" ; then
-		    for tmp in $deplibrary_names ; do
+		  eval deplibrary_names=`$SED -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names"; then
+		    for tmp in $deplibrary_names; do
 		      depdepl=$tmp
 		    done
-		    if test -f "$absdir/$objdir/$depdepl" ; then
-		      depdepl="$absdir/$objdir/$depdepl"
-		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
+		    if test -f "$absdir/$objdir/$depdepl"; then
+		      depdepl=$absdir/$objdir/$depdepl
+		      darwin_install_name=`$OTOOL -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
                       if test -z "$darwin_install_name"; then
-                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
+                          darwin_install_name=`$OTOOL64 -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
                       fi
-		      func_append compiler_flags " ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
-		      func_append linker_flags " -dylib_file ${darwin_install_name}:${depdepl}"
+		      func_append compiler_flags " $wl-dylib_file $wl$darwin_install_name:$depdepl"
+		      func_append linker_flags " -dylib_file $darwin_install_name:$depdepl"
 		      path=
 		    fi
 		  fi
 		  ;;
 		*)
-		  path="-L$absdir/$objdir"
+		  path=-L$absdir/$objdir
 		  ;;
 		esac
 		else
-		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  eval libdir=`$SED -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
 		  test -z "$libdir" && \
-		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		    func_fatal_error "'$deplib' is not a valid libtool archive"
 		  test "$absdir" != "$libdir" && \
-		    func_warning "\`$deplib' seems to be moved"
+		    func_warning "'$deplib' seems to be moved"
 
-		  path="-L$absdir"
+		  path=-L$absdir
 		fi
 		;;
 	      esac
@@ -7098,23 +8544,23 @@ func_mode_link ()
 	  fi # link_all_deplibs != no
 	fi # linkmode = lib
       done # for deplib in $libs
-      if test "$pass" = link; then
-	if test "$linkmode" = "prog"; then
+      if test link = "$pass"; then
+	if test prog = "$linkmode"; then
 	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
 	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
 	else
 	  compiler_flags="$compiler_flags "`$ECHO " $new_inherited_linker_flags" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
 	fi
       fi
-      dependency_libs="$newdependency_libs"
-      if test "$pass" = dlpreopen; then
+      dependency_libs=$newdependency_libs
+      if test dlpreopen = "$pass"; then
 	# Link the dlpreopened libraries before other libraries
 	for deplib in $save_deplibs; do
 	  deplibs="$deplib $deplibs"
 	done
       fi
-      if test "$pass" != dlopen; then
-	if test "$pass" != conv; then
+      if test dlopen != "$pass"; then
+	test conv = "$pass" || {
 	  # Make sure lib_search_path contains only unique directories.
 	  lib_search_path=
 	  for dir in $newlib_search_path; do
@@ -7124,12 +8570,12 @@ func_mode_link ()
 	    esac
 	  done
 	  newlib_search_path=
-	fi
+	}
 
-	if test "$linkmode,$pass" != "prog,link"; then
-	  vars="deplibs"
-	else
+	if test prog,link = "$linkmode,$pass"; then
 	  vars="compile_deplibs finalize_deplibs"
+	else
+	  vars=deplibs
 	fi
 	for var in $vars dependency_libs; do
 	  # Add libraries to $var in reverse order
@@ -7187,62 +8633,93 @@ func_mode_link ()
 	  eval $var=\"$tmp_libs\"
 	done # for var
       fi
+
+      # Add Sun CC postdeps if required:
+      test CXX = "$tagname" && {
+        case $host_os in
+        linux*)
+          case `$CC -V 2>&1 | sed 5q` in
+          *Sun\ C*) # Sun C++ 5.9
+            func_suncc_cstd_abi
+
+            if test no != "$suncc_use_cstd_abi"; then
+              func_append postdeps ' -library=Cstd -library=Crun'
+            fi
+            ;;
+          esac
+          ;;
+
+        solaris*)
+          func_cc_basename "$CC"
+          case $func_cc_basename_result in
+          CC* | sunCC*)
+            func_suncc_cstd_abi
+
+            if test no != "$suncc_use_cstd_abi"; then
+              func_append postdeps ' -library=Cstd -library=Crun'
+            fi
+            ;;
+          esac
+          ;;
+        esac
+      }
+
       # Last step: remove runtime libs from dependency_libs
       # (they stay in deplibs)
       tmp_libs=
-      for i in $dependency_libs ; do
+      for i in $dependency_libs; do
 	case " $predeps $postdeps $compiler_lib_search_path " in
 	*" $i "*)
-	  i=""
+	  i=
 	  ;;
 	esac
-	if test -n "$i" ; then
+	if test -n "$i"; then
 	  func_append tmp_libs " $i"
 	fi
       done
       dependency_libs=$tmp_libs
     done # for pass
-    if test "$linkmode" = prog; then
-      dlfiles="$newdlfiles"
+    if test prog = "$linkmode"; then
+      dlfiles=$newdlfiles
     fi
-    if test "$linkmode" = prog || test "$linkmode" = lib; then
-      dlprefiles="$newdlprefiles"
+    if test prog = "$linkmode" || test lib = "$linkmode"; then
+      dlprefiles=$newdlprefiles
     fi
 
     case $linkmode in
     oldlib)
-      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
-	func_warning "\`-dlopen' is ignored for archives"
+      if test -n "$dlfiles$dlprefiles" || test no != "$dlself"; then
+	func_warning "'-dlopen' is ignored for archives"
       fi
 
       case " $deplibs" in
       *\ -l* | *\ -L*)
-	func_warning "\`-l' and \`-L' are ignored for archives" ;;
+	func_warning "'-l' and '-L' are ignored for archives" ;;
       esac
 
       test -n "$rpath" && \
-	func_warning "\`-rpath' is ignored for archives"
+	func_warning "'-rpath' is ignored for archives"
 
       test -n "$xrpath" && \
-	func_warning "\`-R' is ignored for archives"
+	func_warning "'-R' is ignored for archives"
 
       test -n "$vinfo" && \
-	func_warning "\`-version-info/-version-number' is ignored for archives"
+	func_warning "'-version-info/-version-number' is ignored for archives"
 
       test -n "$release" && \
-	func_warning "\`-release' is ignored for archives"
+	func_warning "'-release' is ignored for archives"
 
       test -n "$export_symbols$export_symbols_regex" && \
-	func_warning "\`-export-symbols' is ignored for archives"
+	func_warning "'-export-symbols' is ignored for archives"
 
       # Now set the variables for building old libraries.
       build_libtool_libs=no
-      oldlibs="$output"
+      oldlibs=$output
       func_append objs "$old_deplibs"
       ;;
 
     lib)
-      # Make sure we only generate libraries of the form `libNAME.la'.
+      # Make sure we only generate libraries of the form 'libNAME.la'.
       case $outputname in
       lib*)
 	func_stripname 'lib' '.la' "$outputname"
@@ -7251,10 +8728,10 @@ func_mode_link ()
 	eval libname=\"$libname_spec\"
 	;;
       *)
-	test "$module" = no && \
-	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+	test no = "$module" \
+	  && func_fatal_help "libtool library '$output' must begin with 'lib'"
 
-	if test "$need_lib_prefix" != no; then
+	if test no != "$need_lib_prefix"; then
 	  # Add the "lib" prefix for modules if required
 	  func_stripname '' '.la' "$outputname"
 	  name=$func_stripname_result
@@ -7268,8 +8745,8 @@ func_mode_link ()
       esac
 
       if test -n "$objs"; then
-	if test "$deplibs_check_method" != pass_all; then
-	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	if test pass_all != "$deplibs_check_method"; then
+	  func_fatal_error "cannot build libtool library '$output' from non-libtool objects on this host:$objs"
 	else
 	  echo
 	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
@@ -7278,21 +8755,21 @@ func_mode_link ()
 	fi
       fi
 
-      test "$dlself" != no && \
-	func_warning "\`-dlopen self' is ignored for libtool libraries"
+      test no = "$dlself" \
+	|| func_warning "'-dlopen self' is ignored for libtool libraries"
 
       set dummy $rpath
       shift
-      test "$#" -gt 1 && \
-	func_warning "ignoring multiple \`-rpath's for a libtool library"
+      test 1 -lt "$#" \
+	&& func_warning "ignoring multiple '-rpath's for a libtool library"
 
-      install_libdir="$1"
+      install_libdir=$1
 
       oldlibs=
       if test -z "$rpath"; then
-	if test "$build_libtool_libs" = yes; then
+	if test yes = "$build_libtool_libs"; then
 	  # Building a libtool convenience library.
-	  # Some compilers have problems with a `.al' extension so
+	  # Some compilers have problems with a '.al' extension so
 	  # convenience libraries should have the same extension an
 	  # archive normally would.
 	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
@@ -7301,20 +8778,20 @@ func_mode_link ()
 	fi
 
 	test -n "$vinfo" && \
-	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+	  func_warning "'-version-info/-version-number' is ignored for convenience libraries"
 
 	test -n "$release" && \
-	  func_warning "\`-release' is ignored for convenience libraries"
+	  func_warning "'-release' is ignored for convenience libraries"
       else
 
 	# Parse the version information argument.
-	save_ifs="$IFS"; IFS=':'
+	save_ifs=$IFS; IFS=:
 	set dummy $vinfo 0 0 0
 	shift
-	IFS="$save_ifs"
+	IFS=$save_ifs
 
 	test -n "$7" && \
-	  func_fatal_help "too many parameters to \`-version-info'"
+	  func_fatal_help "too many parameters to '-version-info'"
 
 	# convert absolute version numbers to libtool ages
 	# this retains compatibility with .la files and attempts
@@ -7322,45 +8799,45 @@ func_mode_link ()
 
 	case $vinfo_number in
 	yes)
-	  number_major="$1"
-	  number_minor="$2"
-	  number_revision="$3"
+	  number_major=$1
+	  number_minor=$2
+	  number_revision=$3
 	  #
 	  # There are really only two kinds -- those that
 	  # use the current revision as the major version
 	  # and those that subtract age and use age as
 	  # a minor version.  But, then there is irix
-	  # which has an extra 1 added just for fun
+	  # that has an extra 1 added just for fun
 	  #
 	  case $version_type in
 	  # correct linux to gnu/linux during the next big refactor
-	  darwin|linux|osf|windows|none)
+	  darwin|freebsd-elf|linux|osf|windows|none)
 	    func_arith $number_major + $number_minor
 	    current=$func_arith_result
-	    age="$number_minor"
-	    revision="$number_revision"
+	    age=$number_minor
+	    revision=$number_revision
 	    ;;
-	  freebsd-aout|freebsd-elf|qnx|sunos)
-	    current="$number_major"
-	    revision="$number_minor"
-	    age="0"
+	  freebsd-aout|qnx|sunos)
+	    current=$number_major
+	    revision=$number_minor
+	    age=0
 	    ;;
 	  irix|nonstopux)
 	    func_arith $number_major + $number_minor
 	    current=$func_arith_result
-	    age="$number_minor"
-	    revision="$number_minor"
+	    age=$number_minor
+	    revision=$number_minor
 	    lt_irix_increment=no
 	    ;;
 	  *)
-	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    func_fatal_configuration "$modename: unknown library version type '$version_type'"
 	    ;;
 	  esac
 	  ;;
 	no)
-	  current="$1"
-	  revision="$2"
-	  age="$3"
+	  current=$1
+	  revision=$2
+	  age=$3
 	  ;;
 	esac
 
@@ -7368,30 +8845,30 @@ func_mode_link ()
 	case $current in
 	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
 	*)
-	  func_error "CURRENT \`$current' must be a nonnegative integer"
-	  func_fatal_error "\`$vinfo' is not valid version information"
+	  func_error "CURRENT '$current' must be a nonnegative integer"
+	  func_fatal_error "'$vinfo' is not valid version information"
 	  ;;
 	esac
 
 	case $revision in
 	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
 	*)
-	  func_error "REVISION \`$revision' must be a nonnegative integer"
-	  func_fatal_error "\`$vinfo' is not valid version information"
+	  func_error "REVISION '$revision' must be a nonnegative integer"
+	  func_fatal_error "'$vinfo' is not valid version information"
 	  ;;
 	esac
 
 	case $age in
 	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
 	*)
-	  func_error "AGE \`$age' must be a nonnegative integer"
-	  func_fatal_error "\`$vinfo' is not valid version information"
+	  func_error "AGE '$age' must be a nonnegative integer"
+	  func_fatal_error "'$vinfo' is not valid version information"
 	  ;;
 	esac
 
 	if test "$age" -gt "$current"; then
-	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
-	  func_fatal_error "\`$vinfo' is not valid version information"
+	  func_error "AGE '$age' is greater than the current interface number '$current'"
+	  func_fatal_error "'$vinfo' is not valid version information"
 	fi
 
 	# Calculate the version variables.
@@ -7406,26 +8883,36 @@ func_mode_link ()
 	  # verstring for coding it into the library header
 	  func_arith $current - $age
 	  major=.$func_arith_result
-	  versuffix="$major.$age.$revision"
+	  versuffix=$major.$age.$revision
 	  # Darwin ld doesn't like 0 for these options...
 	  func_arith $current + 1
 	  minor_current=$func_arith_result
-	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  xlcverstring="$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision"
 	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+          # On Darwin other compilers
+          case $CC in
+              nagfor*)
+                  verstring="$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision"
+                  ;;
+              *)
+                  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+                  ;;
+          esac
 	  ;;
 
 	freebsd-aout)
-	  major=".$current"
-	  versuffix=".$current.$revision";
+	  major=.$current
+	  versuffix=.$current.$revision
 	  ;;
 
 	freebsd-elf)
-	  major=".$current"
-	  versuffix=".$current"
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix=$major.$age.$revision
 	  ;;
 
 	irix | nonstopux)
-	  if test "X$lt_irix_increment" = "Xno"; then
+	  if test no = "$lt_irix_increment"; then
 	    func_arith $current - $age
 	  else
 	    func_arith $current - $age + 1
@@ -7436,69 +8923,74 @@ func_mode_link ()
 	    nonstopux) verstring_prefix=nonstopux ;;
 	    *)         verstring_prefix=sgi ;;
 	  esac
-	  verstring="$verstring_prefix$major.$revision"
+	  verstring=$verstring_prefix$major.$revision
 
 	  # Add in all the interfaces that we are compatible with.
 	  loop=$revision
-	  while test "$loop" -ne 0; do
+	  while test 0 -ne "$loop"; do
 	    func_arith $revision - $loop
 	    iface=$func_arith_result
 	    func_arith $loop - 1
 	    loop=$func_arith_result
-	    verstring="$verstring_prefix$major.$iface:$verstring"
+	    verstring=$verstring_prefix$major.$iface:$verstring
 	  done
 
-	  # Before this point, $major must not contain `.'.
+	  # Before this point, $major must not contain '.'.
 	  major=.$major
-	  versuffix="$major.$revision"
+	  versuffix=$major.$revision
 	  ;;
 
 	linux) # correct to gnu/linux during the next big refactor
 	  func_arith $current - $age
 	  major=.$func_arith_result
-	  versuffix="$major.$age.$revision"
+	  versuffix=$major.$age.$revision
 	  ;;
 
 	osf)
 	  func_arith $current - $age
 	  major=.$func_arith_result
-	  versuffix=".$current.$age.$revision"
-	  verstring="$current.$age.$revision"
+	  versuffix=.$current.$age.$revision
+	  verstring=$current.$age.$revision
 
 	  # Add in all the interfaces that we are compatible with.
 	  loop=$age
-	  while test "$loop" -ne 0; do
+	  while test 0 -ne "$loop"; do
 	    func_arith $current - $loop
 	    iface=$func_arith_result
 	    func_arith $loop - 1
 	    loop=$func_arith_result
-	    verstring="$verstring:${iface}.0"
+	    verstring=$verstring:$iface.0
 	  done
 
 	  # Make executables depend on our current version.
-	  func_append verstring ":${current}.0"
+	  func_append verstring ":$current.0"
 	  ;;
 
 	qnx)
-	  major=".$current"
-	  versuffix=".$current"
+	  major=.$current
+	  versuffix=.$current
+	  ;;
+
+	sco)
+	  major=.$current
+	  versuffix=.$current
 	  ;;
 
 	sunos)
-	  major=".$current"
-	  versuffix=".$current.$revision"
+	  major=.$current
+	  versuffix=.$current.$revision
 	  ;;
 
 	windows)
 	  # Use '-' rather than '.', since we only want one
-	  # extension on DOS 8.3 filesystems.
+	  # extension on DOS 8.3 file systems.
 	  func_arith $current - $age
 	  major=$func_arith_result
-	  versuffix="-$major"
+	  versuffix=-$major
 	  ;;
 
 	*)
-	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  func_fatal_configuration "unknown library version type '$version_type'"
 	  ;;
 	esac
 
@@ -7512,42 +9004,45 @@ func_mode_link ()
 	    verstring=
 	    ;;
 	  *)
-	    verstring="0.0"
+	    verstring=0.0
 	    ;;
 	  esac
-	  if test "$need_version" = no; then
+	  if test no = "$need_version"; then
 	    versuffix=
 	  else
-	    versuffix=".0.0"
+	    versuffix=.0.0
 	  fi
 	fi
 
 	# Remove version info from name if versioning should be avoided
-	if test "$avoid_version" = yes && test "$need_version" = no; then
+	if test yes,no = "$avoid_version,$need_version"; then
 	  major=
 	  versuffix=
-	  verstring=""
+	  verstring=
 	fi
 
 	# Check to see if the archive will have undefined symbols.
-	if test "$allow_undefined" = yes; then
-	  if test "$allow_undefined_flag" = unsupported; then
-	    func_warning "undefined symbols not allowed in $host shared libraries"
-	    build_libtool_libs=no
-	    build_old_libs=yes
+	if test yes = "$allow_undefined"; then
+	  if test unsupported = "$allow_undefined_flag"; then
+	    if test yes = "$build_old_libs"; then
+	      func_warning "undefined symbols not allowed in $host shared libraries; building static only"
+	      build_libtool_libs=no
+	    else
+	      func_fatal_error "can't build $host shared library unless -no-undefined is specified"
+	    fi
 	  fi
 	else
 	  # Don't allow undefined symbols.
-	  allow_undefined_flag="$no_undefined_flag"
+	  allow_undefined_flag=$no_undefined_flag
 	fi
 
       fi
 
-      func_generate_dlsyms "$libname" "$libname" "yes"
+      func_generate_dlsyms "$libname" "$libname" :
       func_append libobjs " $symfileobj"
-      test "X$libobjs" = "X " && libobjs=
+      test " " = "$libobjs" && libobjs=
 
-      if test "$opt_mode" != relink; then
+      if test relink != "$opt_mode"; then
 	# Remove our outputs, but don't remove object files since they
 	# may have been created when compiling PIC objects.
 	removelist=
@@ -7556,8 +9051,8 @@ func_mode_link ()
 	  case $p in
 	    *.$objext | *.gcno)
 	       ;;
-	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
-	       if test "X$precious_files_regex" != "X"; then
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/$libname$release.*)
+	       if test -n "$precious_files_regex"; then
 		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
 		 then
 		   continue
@@ -7573,11 +9068,11 @@ func_mode_link ()
       fi
 
       # Now set the variables for building old libraries.
-      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+      if test yes = "$build_old_libs" && test convenience != "$build_libtool_libs"; then
 	func_append oldlibs " $output_objdir/$libname.$libext"
 
 	# Transform .lo files to .o files.
-	oldobjs="$objs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; $lo2o" | $NL2SP`
+	oldobjs="$objs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.$libext$/d; $lo2o" | $NL2SP`
       fi
 
       # Eliminate all temporary directories.
@@ -7598,13 +9093,13 @@ func_mode_link ()
 	  *) func_append finalize_rpath " $libdir" ;;
 	  esac
 	done
-	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	if test yes != "$hardcode_into_libs" || test yes = "$build_old_libs"; then
 	  dependency_libs="$temp_xrpath $dependency_libs"
 	fi
       fi
 
       # Make sure dlfiles contains only unique files that won't be dlpreopened
-      old_dlfiles="$dlfiles"
+      old_dlfiles=$dlfiles
       dlfiles=
       for lib in $old_dlfiles; do
 	case " $dlprefiles $dlfiles " in
@@ -7614,7 +9109,7 @@ func_mode_link ()
       done
 
       # Make sure dlprefiles contains only unique files
-      old_dlprefiles="$dlprefiles"
+      old_dlprefiles=$dlprefiles
       dlprefiles=
       for lib in $old_dlprefiles; do
 	case "$dlprefiles " in
@@ -7623,7 +9118,7 @@ func_mode_link ()
 	esac
       done
 
-      if test "$build_libtool_libs" = yes; then
+      if test yes = "$build_libtool_libs"; then
 	if test -n "$rpath"; then
 	  case $host in
 	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)
@@ -7647,7 +9142,7 @@ func_mode_link ()
 	    ;;
 	  *)
 	    # Add libc to deplibs on all other systems if necessary.
-	    if test "$build_libtool_need_lc" = "yes"; then
+	    if test yes = "$build_libtool_need_lc"; then
 	      func_append deplibs " -lc"
 	    fi
 	    ;;
@@ -7663,9 +9158,9 @@ func_mode_link ()
 	# I'm not sure if I'm treating the release correctly.  I think
 	# release should show up in the -l (ie -lgmp5) so we don't want to
 	# add it in twice.  Is that correct?
-	release=""
-	versuffix=""
-	major=""
+	release=
+	versuffix=
+	major=
 	newdeplibs=
 	droppeddeps=no
 	case $deplibs_check_method in
@@ -7694,20 +9189,20 @@ EOF
 	      -l*)
 		func_stripname -l '' "$i"
 		name=$func_stripname_result
-		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		if test yes = "$allow_libtool_libs_with_static_runtimes"; then
 		  case " $predeps $postdeps " in
 		  *" $i "*)
 		    func_append newdeplibs " $i"
-		    i=""
+		    i=
 		    ;;
 		  esac
 		fi
-		if test -n "$i" ; then
+		if test -n "$i"; then
 		  libname=`eval "\\$ECHO \"$libname_spec\""`
 		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
 		  set dummy $deplib_matches; shift
 		  deplib_match=$1
-		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0; then
 		    func_append newdeplibs " $i"
 		  else
 		    droppeddeps=yes
@@ -7737,20 +9232,20 @@ EOF
 		$opt_dry_run || $RM conftest
 		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
 		  ldd_output=`ldd conftest`
-		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  if test yes = "$allow_libtool_libs_with_static_runtimes"; then
 		    case " $predeps $postdeps " in
 		    *" $i "*)
 		      func_append newdeplibs " $i"
-		      i=""
+		      i=
 		      ;;
 		    esac
 		  fi
-		  if test -n "$i" ; then
+		  if test -n "$i"; then
 		    libname=`eval "\\$ECHO \"$libname_spec\""`
 		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
 		    set dummy $deplib_matches; shift
 		    deplib_match=$1
-		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0; then
 		      func_append newdeplibs " $i"
 		    else
 		      droppeddeps=yes
@@ -7787,24 +9282,24 @@ EOF
 	    -l*)
 	      func_stripname -l '' "$a_deplib"
 	      name=$func_stripname_result
-	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      if test yes = "$allow_libtool_libs_with_static_runtimes"; then
 		case " $predeps $postdeps " in
 		*" $a_deplib "*)
 		  func_append newdeplibs " $a_deplib"
-		  a_deplib=""
+		  a_deplib=
 		  ;;
 		esac
 	      fi
-	      if test -n "$a_deplib" ; then
+	      if test -n "$a_deplib"; then
 		libname=`eval "\\$ECHO \"$libname_spec\""`
 		if test -n "$file_magic_glob"; then
 		  libnameglob=`func_echo_all "$libname" | $SED -e $file_magic_glob`
 		else
 		  libnameglob=$libname
 		fi
-		test "$want_nocaseglob" = yes && nocaseglob=`shopt -p nocaseglob`
+		test yes = "$want_nocaseglob" && nocaseglob=`shopt -p nocaseglob`
 		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
-		  if test "$want_nocaseglob" = yes; then
+		  if test yes = "$want_nocaseglob"; then
 		    shopt -s nocaseglob
 		    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`
 		    $nocaseglob
@@ -7822,25 +9317,25 @@ EOF
 		      # We might still enter an endless loop, since a link
 		      # loop can be closed while we follow links,
 		      # but so what?
-		      potlib="$potent_lib"
+		      potlib=$potent_lib
 		      while test -h "$potlib" 2>/dev/null; do
-			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			potliblink=`ls -ld $potlib | $SED 's/.* -> //'`
 			case $potliblink in
-			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
-			*) potlib=`$ECHO "$potlib" | $SED 's,[^/]*$,,'`"$potliblink";;
+			[\\/]* | [A-Za-z]:[\\/]*) potlib=$potliblink;;
+			*) potlib=`$ECHO "$potlib" | $SED 's|[^/]*$||'`"$potliblink";;
 			esac
 		      done
 		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
 			 $SED -e 10q |
 			 $EGREP "$file_magic_regex" > /dev/null; then
 			func_append newdeplibs " $a_deplib"
-			a_deplib=""
+			a_deplib=
 			break 2
 		      fi
 		  done
 		done
 	      fi
-	      if test -n "$a_deplib" ; then
+	      if test -n "$a_deplib"; then
 		droppeddeps=yes
 		echo
 		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
@@ -7848,7 +9343,7 @@ EOF
 		echo "*** you link to this library.  But I can only do this if you have a"
 		echo "*** shared version of the library, which you do not appear to have"
 		echo "*** because I did check the linker path looking for a file starting"
-		if test -z "$potlib" ; then
+		if test -z "$potlib"; then
 		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
 		else
 		  $ECHO "*** with $libname and none of the candidates passed a file format test"
@@ -7871,30 +9366,30 @@ EOF
 	    -l*)
 	      func_stripname -l '' "$a_deplib"
 	      name=$func_stripname_result
-	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      if test yes = "$allow_libtool_libs_with_static_runtimes"; then
 		case " $predeps $postdeps " in
 		*" $a_deplib "*)
 		  func_append newdeplibs " $a_deplib"
-		  a_deplib=""
+		  a_deplib=
 		  ;;
 		esac
 	      fi
-	      if test -n "$a_deplib" ; then
+	      if test -n "$a_deplib"; then
 		libname=`eval "\\$ECHO \"$libname_spec\""`
 		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
 		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
 		  for potent_lib in $potential_libs; do
-		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    potlib=$potent_lib # see symlink-check above in file_magic test
 		    if eval "\$ECHO \"$potent_lib\"" 2>/dev/null | $SED 10q | \
 		       $EGREP "$match_pattern_regex" > /dev/null; then
 		      func_append newdeplibs " $a_deplib"
-		      a_deplib=""
+		      a_deplib=
 		      break 2
 		    fi
 		  done
 		done
 	      fi
-	      if test -n "$a_deplib" ; then
+	      if test -n "$a_deplib"; then
 		droppeddeps=yes
 		echo
 		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
@@ -7902,7 +9397,7 @@ EOF
 		echo "*** you link to this library.  But I can only do this if you have a"
 		echo "*** shared version of the library, which you do not appear to have"
 		echo "*** because I did check the linker path looking for a file starting"
-		if test -z "$potlib" ; then
+		if test -z "$potlib"; then
 		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
 		else
 		  $ECHO "*** with $libname and none of the candidates passed a file format test"
@@ -7918,18 +9413,18 @@ EOF
 	  done # Gone through all deplibs.
 	  ;;
 	none | unknown | *)
-	  newdeplibs=""
+	  newdeplibs=
 	  tmp_deplibs=`$ECHO " $deplibs" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`
-	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
-	    for i in $predeps $postdeps ; do
+	  if test yes = "$allow_libtool_libs_with_static_runtimes"; then
+	    for i in $predeps $postdeps; do
 	      # can't use Xsed below, because $i might contain '/'
-	      tmp_deplibs=`$ECHO " $tmp_deplibs" | $SED "s,$i,,"`
+	      tmp_deplibs=`$ECHO " $tmp_deplibs" | $SED "s|$i||"`
 	    done
 	  fi
 	  case $tmp_deplibs in
 	  *[!\	\ ]*)
 	    echo
-	    if test "X$deplibs_check_method" = "Xnone"; then
+	    if test none = "$deplibs_check_method"; then
 	      echo "*** Warning: inter-library dependencies are not supported in this platform."
 	    else
 	      echo "*** Warning: inter-library dependencies are not known to be supported."
@@ -7953,8 +9448,8 @@ EOF
 	  ;;
 	esac
 
-	if test "$droppeddeps" = yes; then
-	  if test "$module" = yes; then
+	if test yes = "$droppeddeps"; then
+	  if test yes = "$module"; then
 	    echo
 	    echo "*** Warning: libtool could not satisfy all declared inter-library"
 	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
@@ -7963,12 +9458,12 @@ EOF
 	    if test -z "$global_symbol_pipe"; then
 	      echo
 	      echo "*** However, this would only work if libtool was able to extract symbol"
-	      echo "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      echo "*** lists from a program, using 'nm' or equivalent, but libtool could"
 	      echo "*** not find such a program.  So, this module is probably useless."
-	      echo "*** \`nm' from GNU binutils and a full rebuild may help."
+	      echo "*** 'nm' from GNU binutils and a full rebuild may help."
 	    fi
-	    if test "$build_old_libs" = no; then
-	      oldlibs="$output_objdir/$libname.$libext"
+	    if test no = "$build_old_libs"; then
+	      oldlibs=$output_objdir/$libname.$libext
 	      build_libtool_libs=module
 	      build_old_libs=yes
 	    else
@@ -7979,14 +9474,14 @@ EOF
 	    echo "*** automatically added whenever a program is linked with this library"
 	    echo "*** or is declared to -dlopen it."
 
-	    if test "$allow_undefined" = no; then
+	    if test no = "$allow_undefined"; then
 	      echo
 	      echo "*** Since this library must not contain undefined symbols,"
 	      echo "*** because either the platform does not support them or"
 	      echo "*** it was explicitly requested with -no-undefined,"
 	      echo "*** libtool will only create a static version of it."
-	      if test "$build_old_libs" = no; then
-		oldlibs="$output_objdir/$libname.$libext"
+	      if test no = "$build_old_libs"; then
+		oldlibs=$output_objdir/$libname.$libext
 		build_libtool_libs=module
 		build_old_libs=yes
 	      else
@@ -8032,7 +9527,7 @@ EOF
 	*) func_append new_libs " $deplib" ;;
 	esac
       done
-      deplibs="$new_libs"
+      deplibs=$new_libs
 
       # All the library-specific variables (install_libdir is set above).
       library_names=
@@ -8040,25 +9535,25 @@ EOF
       dlname=
 
       # Test again, we may have decided not to build it any more
-      if test "$build_libtool_libs" = yes; then
-	# Remove ${wl} instances when linking with ld.
+      if test yes = "$build_libtool_libs"; then
+	# Remove $wl instances when linking with ld.
 	# FIXME: should test the right _cmds variable.
 	case $archive_cmds in
 	  *\$LD\ *) wl= ;;
         esac
-	if test "$hardcode_into_libs" = yes; then
+	if test yes = "$hardcode_into_libs"; then
 	  # Hardcode the library paths
 	  hardcode_libdirs=
 	  dep_rpath=
-	  rpath="$finalize_rpath"
-	  test "$opt_mode" != relink && rpath="$compile_rpath$rpath"
+	  rpath=$finalize_rpath
+	  test relink = "$opt_mode" || rpath=$compile_rpath$rpath
 	  for libdir in $rpath; do
 	    if test -n "$hardcode_libdir_flag_spec"; then
 	      if test -n "$hardcode_libdir_separator"; then
 		func_replace_sysroot "$libdir"
 		libdir=$func_replace_sysroot_result
 		if test -z "$hardcode_libdirs"; then
-		  hardcode_libdirs="$libdir"
+		  hardcode_libdirs=$libdir
 		else
 		  # Just accumulate the unique libdirs.
 		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
@@ -8083,7 +9578,7 @@ EOF
 	  # Substitute the hardcoded libdirs into the rpath.
 	  if test -n "$hardcode_libdir_separator" &&
 	     test -n "$hardcode_libdirs"; then
-	    libdir="$hardcode_libdirs"
+	    libdir=$hardcode_libdirs
 	    eval "dep_rpath=\"$hardcode_libdir_flag_spec\""
 	  fi
 	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
@@ -8097,8 +9592,8 @@ EOF
 	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
 	fi
 
-	shlibpath="$finalize_shlibpath"
-	test "$opt_mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	shlibpath=$finalize_shlibpath
+	test relink = "$opt_mode" || shlibpath=$compile_shlibpath$shlibpath
 	if test -n "$shlibpath"; then
 	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
 	fi
@@ -8108,19 +9603,19 @@ EOF
 	eval library_names=\"$library_names_spec\"
 	set dummy $library_names
 	shift
-	realname="$1"
+	realname=$1
 	shift
 
 	if test -n "$soname_spec"; then
 	  eval soname=\"$soname_spec\"
 	else
-	  soname="$realname"
+	  soname=$realname
 	fi
 	if test -z "$dlname"; then
 	  dlname=$soname
 	fi
 
-	lib="$output_objdir/$realname"
+	lib=$output_objdir/$realname
 	linknames=
 	for link
 	do
@@ -8134,7 +9629,7 @@ EOF
 	delfiles=
 	if test -n "$export_symbols" && test -n "$include_expsyms"; then
 	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
-	  export_symbols="$output_objdir/$libname.uexp"
+	  export_symbols=$output_objdir/$libname.uexp
 	  func_append delfiles " $export_symbols"
 	fi
 
@@ -8143,31 +9638,31 @@ EOF
 	cygwin* | mingw* | cegcc*)
 	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
 	    # exporting using user supplied symfile
-	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	    func_dll_def_p "$export_symbols" || {
 	      # and it's NOT already a .def file. Must figure out
 	      # which of the given symbols are data symbols and tag
 	      # them as such. So, trigger use of export_symbols_cmds.
 	      # export_symbols gets reassigned inside the "prepare
 	      # the list of exported symbols" if statement, so the
 	      # include_expsyms logic still works.
-	      orig_export_symbols="$export_symbols"
+	      orig_export_symbols=$export_symbols
 	      export_symbols=
 	      always_export_symbols=yes
-	    fi
+	    }
 	  fi
 	  ;;
 	esac
 
 	# Prepare the list of exported symbols
 	if test -z "$export_symbols"; then
-	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
-	    func_verbose "generating symbol list for \`$libname.la'"
-	    export_symbols="$output_objdir/$libname.exp"
+	  if test yes = "$always_export_symbols" || test -n "$export_symbols_regex"; then
+	    func_verbose "generating symbol list for '$libname.la'"
+	    export_symbols=$output_objdir/$libname.exp
 	    $opt_dry_run || $RM $export_symbols
 	    cmds=$export_symbols_cmds
-	    save_ifs="$IFS"; IFS='~'
+	    save_ifs=$IFS; IFS='~'
 	    for cmd1 in $cmds; do
-	      IFS="$save_ifs"
+	      IFS=$save_ifs
 	      # Take the normal branch if the nm_file_list_spec branch
 	      # doesn't work or if tool conversion is not needed.
 	      case $nm_file_list_spec~$to_tool_file_cmd in
@@ -8181,7 +9676,7 @@ EOF
 		  try_normal_branch=no
 		  ;;
 	      esac
-	      if test "$try_normal_branch" = yes \
+	      if test yes = "$try_normal_branch" \
 		 && { test "$len" -lt "$max_cmd_len" \
 		      || test "$max_cmd_len" -le -1; }
 	      then
@@ -8192,7 +9687,7 @@ EOF
 		output_la=$func_basename_result
 		save_libobjs=$libobjs
 		save_output=$output
-		output=${output_objdir}/${output_la}.nm
+		output=$output_objdir/$output_la.nm
 		func_to_tool_file "$output"
 		libobjs=$nm_file_list_spec$func_to_tool_file_result
 		func_append delfiles " $output"
@@ -8215,8 +9710,8 @@ EOF
 		break
 	      fi
 	    done
-	    IFS="$save_ifs"
-	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	    IFS=$save_ifs
+	    if test -n "$export_symbols_regex" && test : != "$skipped_export"; then
 	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
 	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
 	    fi
@@ -8224,16 +9719,16 @@ EOF
 	fi
 
 	if test -n "$export_symbols" && test -n "$include_expsyms"; then
-	  tmp_export_symbols="$export_symbols"
-	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  tmp_export_symbols=$export_symbols
+	  test -n "$orig_export_symbols" && tmp_export_symbols=$orig_export_symbols
 	  $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
 	fi
 
-	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	if test : != "$skipped_export" && test -n "$orig_export_symbols"; then
 	  # The given exports_symbols file has to be filtered, so filter it.
-	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	  func_verbose "filter symbol list for '$libname.la' to tag DATA exports"
 	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
-	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # 's' commands, which not all seds can handle. GNU sed should be fine
 	  # though. Also, the filter scales superlinearly with the number of
 	  # global variables. join(1) would be nice here, but unfortunately
 	  # isn't a blessed tool.
@@ -8252,11 +9747,11 @@ EOF
 	    ;;
 	  esac
 	done
-	deplibs="$tmp_deplibs"
+	deplibs=$tmp_deplibs
 
 	if test -n "$convenience"; then
 	  if test -n "$whole_archive_flag_spec" &&
-	    test "$compiler_needs_object" = yes &&
+	    test yes = "$compiler_needs_object" &&
 	    test -z "$libobjs"; then
 	    # extract the archives, so we have objects to list.
 	    # TODO: could optimize this to just extract one archive.
@@ -8267,7 +9762,7 @@ EOF
 	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
 	    test "X$libobjs" = "X " && libobjs=
 	  else
-	    gentop="$output_objdir/${outputname}x"
+	    gentop=$output_objdir/${outputname}x
 	    func_append generated " $gentop"
 
 	    func_extract_archives $gentop $convenience
@@ -8276,18 +9771,18 @@ EOF
 	  fi
 	fi
 
-	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	if test yes = "$thread_safe" && test -n "$thread_safe_flag_spec"; then
 	  eval flag=\"$thread_safe_flag_spec\"
 	  func_append linker_flags " $flag"
 	fi
 
 	# Make a backup of the uninstalled library when relinking
-	if test "$opt_mode" = relink; then
+	if test relink = "$opt_mode"; then
 	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
 	fi
 
 	# Do each of the archive commands.
-	if test "$module" = yes && test -n "$module_cmds" ; then
+	if test yes = "$module" && test -n "$module_cmds"; then
 	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
 	    eval test_cmds=\"$module_expsym_cmds\"
 	    cmds=$module_expsym_cmds
@@ -8305,7 +9800,7 @@ EOF
 	  fi
 	fi
 
-	if test "X$skipped_export" != "X:" &&
+	if test : != "$skipped_export" &&
 	   func_len " $test_cmds" &&
 	   len=$func_len_result &&
 	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
@@ -8338,8 +9833,8 @@ EOF
 	  last_robj=
 	  k=1
 
-	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
-	    output=${output_objdir}/${output_la}.lnkscript
+	  if test -n "$save_libobjs" && test : != "$skipped_export" && test yes = "$with_gnu_ld"; then
+	    output=$output_objdir/$output_la.lnkscript
 	    func_verbose "creating GNU ld script: $output"
 	    echo 'INPUT (' > $output
 	    for obj in $save_libobjs
@@ -8351,14 +9846,14 @@ EOF
 	    func_append delfiles " $output"
 	    func_to_tool_file "$output"
 	    output=$func_to_tool_file_result
-	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
-	    output=${output_objdir}/${output_la}.lnk
+	  elif test -n "$save_libobjs" && test : != "$skipped_export" && test -n "$file_list_spec"; then
+	    output=$output_objdir/$output_la.lnk
 	    func_verbose "creating linker input file list: $output"
 	    : > $output
 	    set x $save_libobjs
 	    shift
 	    firstobj=
-	    if test "$compiler_needs_object" = yes; then
+	    if test yes = "$compiler_needs_object"; then
 	      firstobj="$1 "
 	      shift
 	    fi
@@ -8373,7 +9868,7 @@ EOF
 	  else
 	    if test -n "$save_libobjs"; then
 	      func_verbose "creating reloadable object files..."
-	      output=$output_objdir/$output_la-${k}.$objext
+	      output=$output_objdir/$output_la-$k.$objext
 	      eval test_cmds=\"$reload_cmds\"
 	      func_len " $test_cmds"
 	      len0=$func_len_result
@@ -8385,13 +9880,13 @@ EOF
 		func_len " $obj"
 		func_arith $len + $func_len_result
 		len=$func_arith_result
-		if test "X$objlist" = X ||
+		if test -z "$objlist" ||
 		   test "$len" -lt "$max_cmd_len"; then
 		  func_append objlist " $obj"
 		else
 		  # The command $test_cmds is almost too long, add a
 		  # command to the queue.
-		  if test "$k" -eq 1 ; then
+		  if test 1 -eq "$k"; then
 		    # The first file doesn't have a previous command to add.
 		    reload_objs=$objlist
 		    eval concat_cmds=\"$reload_cmds\"
@@ -8401,10 +9896,10 @@ EOF
 		    reload_objs="$objlist $last_robj"
 		    eval concat_cmds=\"\$concat_cmds~$reload_cmds~\$RM $last_robj\"
 		  fi
-		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  last_robj=$output_objdir/$output_la-$k.$objext
 		  func_arith $k + 1
 		  k=$func_arith_result
-		  output=$output_objdir/$output_la-${k}.$objext
+		  output=$output_objdir/$output_la-$k.$objext
 		  objlist=" $obj"
 		  func_len " $last_robj"
 		  func_arith $len0 + $func_len_result
@@ -8416,9 +9911,9 @@ EOF
 	      # files will link in the last one created.
 	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
 	      reload_objs="$objlist $last_robj"
-	      eval concat_cmds=\"\${concat_cmds}$reload_cmds\"
+	      eval concat_cmds=\"\$concat_cmds$reload_cmds\"
 	      if test -n "$last_robj"; then
-	        eval concat_cmds=\"\${concat_cmds}~\$RM $last_robj\"
+	        eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
 	      fi
 	      func_append delfiles " $output"
 
@@ -8426,9 +9921,9 @@ EOF
 	      output=
 	    fi
 
-	    if ${skipped_export-false}; then
-	      func_verbose "generating symbol list for \`$libname.la'"
-	      export_symbols="$output_objdir/$libname.exp"
+	    ${skipped_export-false} && {
+	      func_verbose "generating symbol list for '$libname.la'"
+	      export_symbols=$output_objdir/$libname.exp
 	      $opt_dry_run || $RM $export_symbols
 	      libobjs=$output
 	      # Append the command to create the export file.
@@ -8437,16 +9932,16 @@ EOF
 	      if test -n "$last_robj"; then
 		eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
 	      fi
-	    fi
+	    }
 
 	    test -n "$save_libobjs" &&
 	      func_verbose "creating a temporary reloadable object file: $output"
 
 	    # Loop through the commands generated above and execute them.
-	    save_ifs="$IFS"; IFS='~'
+	    save_ifs=$IFS; IFS='~'
 	    for cmd in $concat_cmds; do
-	      IFS="$save_ifs"
-	      $opt_silent || {
+	      IFS=$save_ifs
+	      $opt_quiet || {
 		  func_quote_for_expand "$cmd"
 		  eval "func_echo $func_quote_for_expand_result"
 	      }
@@ -8454,7 +9949,7 @@ EOF
 		lt_exit=$?
 
 		# Restore the uninstalled library and exit
-		if test "$opt_mode" = relink; then
+		if test relink = "$opt_mode"; then
 		  ( cd "$output_objdir" && \
 		    $RM "${realname}T" && \
 		    $MV "${realname}U" "$realname" )
@@ -8463,7 +9958,7 @@ EOF
 		exit $lt_exit
 	      }
 	    done
-	    IFS="$save_ifs"
+	    IFS=$save_ifs
 
 	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
 	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
@@ -8471,18 +9966,18 @@ EOF
 	    fi
 	  fi
 
-          if ${skipped_export-false}; then
+          ${skipped_export-false} && {
 	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
-	      tmp_export_symbols="$export_symbols"
-	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      tmp_export_symbols=$export_symbols
+	      test -n "$orig_export_symbols" && tmp_export_symbols=$orig_export_symbols
 	      $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
 	    fi
 
 	    if test -n "$orig_export_symbols"; then
 	      # The given exports_symbols file has to be filtered, so filter it.
-	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	      func_verbose "filter symbol list for '$libname.la' to tag DATA exports"
 	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
-	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # 's' commands, which not all seds can handle. GNU sed should be fine
 	      # though. Also, the filter scales superlinearly with the number of
 	      # global variables. join(1) would be nice here, but unfortunately
 	      # isn't a blessed tool.
@@ -8491,7 +9986,7 @@ EOF
 	      export_symbols=$output_objdir/$libname.def
 	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
 	    fi
-	  fi
+	  }
 
 	  libobjs=$output
 	  # Restore the value of output.
@@ -8505,7 +10000,7 @@ EOF
 	  # value of $libobjs for piecewise linking.
 
 	  # Do each of the archive commands.
-	  if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test yes = "$module" && test -n "$module_cmds"; then
 	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
 	      cmds=$module_expsym_cmds
 	    else
@@ -8527,7 +10022,7 @@ EOF
 
 	# Add any objects from preloaded convenience libraries
 	if test -n "$dlprefiles"; then
-	  gentop="$output_objdir/${outputname}x"
+	  gentop=$output_objdir/${outputname}x
 	  func_append generated " $gentop"
 
 	  func_extract_archives $gentop $dlprefiles
@@ -8535,11 +10030,12 @@ EOF
 	  test "X$libobjs" = "X " && libobjs=
 	fi
 
-	save_ifs="$IFS"; IFS='~'
+	save_ifs=$IFS; IFS='~'
 	for cmd in $cmds; do
-	  IFS="$save_ifs"
+	  IFS=$sp$nl
 	  eval cmd=\"$cmd\"
-	  $opt_silent || {
+	  IFS=$save_ifs
+	  $opt_quiet || {
 	    func_quote_for_expand "$cmd"
 	    eval "func_echo $func_quote_for_expand_result"
 	  }
@@ -8547,7 +10043,7 @@ EOF
 	    lt_exit=$?
 
 	    # Restore the uninstalled library and exit
-	    if test "$opt_mode" = relink; then
+	    if test relink = "$opt_mode"; then
 	      ( cd "$output_objdir" && \
 	        $RM "${realname}T" && \
 		$MV "${realname}U" "$realname" )
@@ -8556,10 +10052,10 @@ EOF
 	    exit $lt_exit
 	  }
 	done
-	IFS="$save_ifs"
+	IFS=$save_ifs
 
 	# Restore the uninstalled library and exit
-	if test "$opt_mode" = relink; then
+	if test relink = "$opt_mode"; then
 	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
 
 	  if test -n "$convenience"; then
@@ -8579,39 +10075,39 @@ EOF
 	done
 
 	# If -module or -export-dynamic was specified, set the dlname.
-	if test "$module" = yes || test "$export_dynamic" = yes; then
+	if test yes = "$module" || test yes = "$export_dynamic"; then
 	  # On all known operating systems, these are identical.
-	  dlname="$soname"
+	  dlname=$soname
 	fi
       fi
       ;;
 
     obj)
-      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
-	func_warning "\`-dlopen' is ignored for objects"
+      if test -n "$dlfiles$dlprefiles" || test no != "$dlself"; then
+	func_warning "'-dlopen' is ignored for objects"
       fi
 
       case " $deplibs" in
       *\ -l* | *\ -L*)
-	func_warning "\`-l' and \`-L' are ignored for objects" ;;
+	func_warning "'-l' and '-L' are ignored for objects" ;;
       esac
 
       test -n "$rpath" && \
-	func_warning "\`-rpath' is ignored for objects"
+	func_warning "'-rpath' is ignored for objects"
 
       test -n "$xrpath" && \
-	func_warning "\`-R' is ignored for objects"
+	func_warning "'-R' is ignored for objects"
 
       test -n "$vinfo" && \
-	func_warning "\`-version-info' is ignored for objects"
+	func_warning "'-version-info' is ignored for objects"
 
       test -n "$release" && \
-	func_warning "\`-release' is ignored for objects"
+	func_warning "'-release' is ignored for objects"
 
       case $output in
       *.lo)
 	test -n "$objs$old_deplibs" && \
-	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+	  func_fatal_error "cannot build library object '$output' from non-libtool objects"
 
 	libobj=$output
 	func_lo2o "$libobj"
@@ -8619,7 +10115,7 @@ EOF
 	;;
       *)
 	libobj=
-	obj="$output"
+	obj=$output
 	;;
       esac
 
@@ -8632,17 +10128,19 @@ EOF
       # the extraction.
       reload_conv_objs=
       gentop=
-      # reload_cmds runs $LD directly, so let us get rid of
-      # -Wl from whole_archive_flag_spec and hope we can get by with
-      # turning comma into space..
-      wl=
-
+      # if reload_cmds runs $LD directly, get rid of -Wl from
+      # whole_archive_flag_spec and hope we can get by with turning comma
+      # into space.
+      case $reload_cmds in
+        *\$LD[\ \$]*) wl= ;;
+      esac
       if test -n "$convenience"; then
 	if test -n "$whole_archive_flag_spec"; then
 	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
-	  reload_conv_objs=$reload_objs\ `$ECHO "$tmp_whole_archive_flags" | $SED 's|,| |g'`
+	  test -n "$wl" || tmp_whole_archive_flags=`$ECHO "$tmp_whole_archive_flags" | $SED 's|,| |g'`
+	  reload_conv_objs=$reload_objs\ $tmp_whole_archive_flags
 	else
-	  gentop="$output_objdir/${obj}x"
+	  gentop=$output_objdir/${obj}x
 	  func_append generated " $gentop"
 
 	  func_extract_archives $gentop $convenience
@@ -8651,12 +10149,12 @@ EOF
       fi
 
       # If we're not building shared, we need to use non_pic_objs
-      test "$build_libtool_libs" != yes && libobjs="$non_pic_objects"
+      test yes = "$build_libtool_libs" || libobjs=$non_pic_objects
 
       # Create the old-style object.
-      reload_objs="$objs$old_deplibs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; /\.lib$/d; $lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+      reload_objs=$objs$old_deplibs' '`$ECHO "$libobjs" | $SP2NL | $SED "/\.$libext$/d; /\.lib$/d; $lo2o" | $NL2SP`' '$reload_conv_objs
 
-      output="$obj"
+      output=$obj
       func_execute_cmds "$reload_cmds" 'exit $?'
 
       # Exit if we aren't doing a library object file.
@@ -8668,7 +10166,7 @@ EOF
 	exit $EXIT_SUCCESS
       fi
 
-      if test "$build_libtool_libs" != yes; then
+      test yes = "$build_libtool_libs" || {
 	if test -n "$gentop"; then
 	  func_show_eval '${RM}r "$gentop"'
 	fi
@@ -8678,12 +10176,12 @@ EOF
 	# $show "echo timestamp > $libobj"
 	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
 	exit $EXIT_SUCCESS
-      fi
+      }
 
-      if test -n "$pic_flag" || test "$pic_mode" != default; then
+      if test -n "$pic_flag" || test default != "$pic_mode"; then
 	# Only do commands if we really have different PIC objects.
 	reload_objs="$libobjs $reload_conv_objs"
-	output="$libobj"
+	output=$libobj
 	func_execute_cmds "$reload_cmds" 'exit $?'
       fi
 
@@ -8700,16 +10198,14 @@ EOF
 	          output=$func_stripname_result.exe;;
       esac
       test -n "$vinfo" && \
-	func_warning "\`-version-info' is ignored for programs"
+	func_warning "'-version-info' is ignored for programs"
 
       test -n "$release" && \
-	func_warning "\`-release' is ignored for programs"
+	func_warning "'-release' is ignored for programs"
 
-      test "$preload" = yes \
-        && test "$dlopen_support" = unknown \
-	&& test "$dlopen_self" = unknown \
-	&& test "$dlopen_self_static" = unknown && \
-	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+      $preload \
+	&& test unknown,unknown,unknown = "$dlopen_support,$dlopen_self,$dlopen_self_static" \
+	&& func_warning "'LT_INIT([dlopen])' not used. Assuming no dlopen support."
 
       case $host in
       *-*-rhapsody* | *-*-darwin1.[012])
@@ -8723,11 +10219,11 @@ EOF
       *-*-darwin*)
 	# Don't allow lazy linking, it breaks C++ global constructors
 	# But is supposedly fixed on 10.4 or later (yay!).
-	if test "$tagname" = CXX ; then
+	if test CXX = "$tagname"; then
 	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
 	    10.[0123])
-	      func_append compile_command " ${wl}-bind_at_load"
-	      func_append finalize_command " ${wl}-bind_at_load"
+	      func_append compile_command " $wl-bind_at_load"
+	      func_append finalize_command " $wl-bind_at_load"
 	    ;;
 	  esac
 	fi
@@ -8763,7 +10259,7 @@ EOF
 	*) func_append new_libs " $deplib" ;;
 	esac
       done
-      compile_deplibs="$new_libs"
+      compile_deplibs=$new_libs
 
 
       func_append compile_command " $compile_deplibs"
@@ -8787,7 +10283,7 @@ EOF
 	if test -n "$hardcode_libdir_flag_spec"; then
 	  if test -n "$hardcode_libdir_separator"; then
 	    if test -z "$hardcode_libdirs"; then
-	      hardcode_libdirs="$libdir"
+	      hardcode_libdirs=$libdir
 	    else
 	      # Just accumulate the unique libdirs.
 	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
@@ -8810,7 +10306,7 @@ EOF
 	fi
 	case $host in
 	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
-	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  testbindir=`$ECHO "$libdir" | $SED -e 's*/lib$*/bin*'`
 	  case :$dllsearchpath: in
 	  *":$libdir:"*) ;;
 	  ::) dllsearchpath=$libdir;;
@@ -8827,10 +10323,10 @@ EOF
       # Substitute the hardcoded libdirs into the rpath.
       if test -n "$hardcode_libdir_separator" &&
 	 test -n "$hardcode_libdirs"; then
-	libdir="$hardcode_libdirs"
+	libdir=$hardcode_libdirs
 	eval rpath=\" $hardcode_libdir_flag_spec\"
       fi
-      compile_rpath="$rpath"
+      compile_rpath=$rpath
 
       rpath=
       hardcode_libdirs=
@@ -8838,7 +10334,7 @@ EOF
 	if test -n "$hardcode_libdir_flag_spec"; then
 	  if test -n "$hardcode_libdir_separator"; then
 	    if test -z "$hardcode_libdirs"; then
-	      hardcode_libdirs="$libdir"
+	      hardcode_libdirs=$libdir
 	    else
 	      # Just accumulate the unique libdirs.
 	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
@@ -8863,45 +10359,43 @@ EOF
       # Substitute the hardcoded libdirs into the rpath.
       if test -n "$hardcode_libdir_separator" &&
 	 test -n "$hardcode_libdirs"; then
-	libdir="$hardcode_libdirs"
+	libdir=$hardcode_libdirs
 	eval rpath=\" $hardcode_libdir_flag_spec\"
       fi
-      finalize_rpath="$rpath"
+      finalize_rpath=$rpath
 
-      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+      if test -n "$libobjs" && test yes = "$build_old_libs"; then
 	# Transform all the library objects into standard objects.
 	compile_command=`$ECHO "$compile_command" | $SP2NL | $SED "$lo2o" | $NL2SP`
 	finalize_command=`$ECHO "$finalize_command" | $SP2NL | $SED "$lo2o" | $NL2SP`
       fi
 
-      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+      func_generate_dlsyms "$outputname" "@PROGRAM@" false
 
       # template prelinking step
       if test -n "$prelink_cmds"; then
 	func_execute_cmds "$prelink_cmds" 'exit $?'
       fi
 
-      wrappers_required=yes
+      wrappers_required=:
       case $host in
       *cegcc* | *mingw32ce*)
         # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.
-        wrappers_required=no
+        wrappers_required=false
         ;;
       *cygwin* | *mingw* )
-        if test "$build_libtool_libs" != yes; then
-          wrappers_required=no
-        fi
+        test yes = "$build_libtool_libs" || wrappers_required=false
         ;;
       *)
-        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
-          wrappers_required=no
+        if test no = "$need_relink" || test yes != "$build_libtool_libs"; then
+          wrappers_required=false
         fi
         ;;
       esac
-      if test "$wrappers_required" = no; then
+      $wrappers_required || {
 	# Replace the output file specification.
 	compile_command=`$ECHO "$compile_command" | $SED 's%@OUTPUT@%'"$output"'%g'`
-	link_command="$compile_command$compile_rpath"
+	link_command=$compile_command$compile_rpath
 
 	# We have no uninstalled library dependencies, so finalize right now.
 	exit_status=0
@@ -8914,12 +10408,12 @@ EOF
 	fi
 
 	# Delete the generated files.
-	if test -f "$output_objdir/${outputname}S.${objext}"; then
-	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	if test -f "$output_objdir/${outputname}S.$objext"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.$objext"'
 	fi
 
 	exit $exit_status
-      fi
+      }
 
       if test -n "$compile_shlibpath$finalize_shlibpath"; then
 	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
@@ -8949,9 +10443,9 @@ EOF
 	fi
       fi
 
-      if test "$no_install" = yes; then
+      if test yes = "$no_install"; then
 	# We don't need to create a wrapper script.
-	link_command="$compile_var$compile_command$compile_rpath"
+	link_command=$compile_var$compile_command$compile_rpath
 	# Replace the output file specification.
 	link_command=`$ECHO "$link_command" | $SED 's%@OUTPUT@%'"$output"'%g'`
 	# Delete the old output file.
@@ -8968,27 +10462,28 @@ EOF
 	exit $EXIT_SUCCESS
       fi
 
-      if test "$hardcode_action" = relink; then
-	# Fast installation is not supported
-	link_command="$compile_var$compile_command$compile_rpath"
-	relink_command="$finalize_var$finalize_command$finalize_rpath"
+      case $hardcode_action,$fast_install in
+        relink,*)
+	  # Fast installation is not supported
+	  link_command=$compile_var$compile_command$compile_rpath
+	  relink_command=$finalize_var$finalize_command$finalize_rpath
 
-	func_warning "this platform does not like uninstalled shared libraries"
-	func_warning "\`$output' will be relinked during installation"
-      else
-	if test "$fast_install" != no; then
-	  link_command="$finalize_var$compile_command$finalize_rpath"
-	  if test "$fast_install" = yes; then
-	    relink_command=`$ECHO "$compile_var$compile_command$compile_rpath" | $SED 's%@OUTPUT@%\$progdir/\$file%g'`
-	  else
-	    # fast_install is set to needless
-	    relink_command=
-	  fi
-	else
-	  link_command="$compile_var$compile_command$compile_rpath"
-	  relink_command="$finalize_var$finalize_command$finalize_rpath"
-	fi
-      fi
+	  func_warning "this platform does not like uninstalled shared libraries"
+	  func_warning "'$output' will be relinked during installation"
+	  ;;
+        *,yes)
+	  link_command=$finalize_var$compile_command$finalize_rpath
+	  relink_command=`$ECHO "$compile_var$compile_command$compile_rpath" | $SED 's%@OUTPUT@%\$progdir/\$file%g'`
+          ;;
+	*,no)
+	  link_command=$compile_var$compile_command$compile_rpath
+	  relink_command=$finalize_var$finalize_command$finalize_rpath
+          ;;
+	*,needless)
+	  link_command=$finalize_var$compile_command$finalize_rpath
+	  relink_command=
+          ;;
+      esac
 
       # Replace the output file specification.
       link_command=`$ECHO "$link_command" | $SED 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
@@ -9045,8 +10540,8 @@ EOF
 	    func_dirname_and_basename "$output" "" "."
 	    output_name=$func_basename_result
 	    output_path=$func_dirname_result
-	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
-	    cwrapper="$output_path/$output_name.exe"
+	    cwrappersource=$output_path/$objdir/lt-$output_name.c
+	    cwrapper=$output_path/$output_name.exe
 	    $RM $cwrappersource $cwrapper
 	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
 
@@ -9067,7 +10562,7 @@ EOF
 	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
 	    $opt_dry_run || {
 	      # note: this script will not be executed, so do not chmod.
-	      if test "x$build" = "x$host" ; then
+	      if test "x$build" = "x$host"; then
 		$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result
 	      else
 		func_emit_wrapper no > $func_ltwrapper_scriptname_result
@@ -9090,25 +10585,27 @@ EOF
     # See if we need to build an old-fashioned archive.
     for oldlib in $oldlibs; do
 
-      if test "$build_libtool_libs" = convenience; then
-	oldobjs="$libobjs_save $symfileobj"
-	addlibs="$convenience"
-	build_libtool_libs=no
-      else
-	if test "$build_libtool_libs" = module; then
-	  oldobjs="$libobjs_save"
+      case $build_libtool_libs in
+        convenience)
+	  oldobjs="$libobjs_save $symfileobj"
+	  addlibs=$convenience
 	  build_libtool_libs=no
-	else
+	  ;;
+	module)
+	  oldobjs=$libobjs_save
+	  addlibs=$old_convenience
+	  build_libtool_libs=no
+          ;;
+	*)
 	  oldobjs="$old_deplibs $non_pic_objects"
-	  if test "$preload" = yes && test -f "$symfileobj"; then
-	    func_append oldobjs " $symfileobj"
-	  fi
-	fi
-	addlibs="$old_convenience"
-      fi
+	  $preload && test -f "$symfileobj" \
+	    && func_append oldobjs " $symfileobj"
+	  addlibs=$old_convenience
+	  ;;
+      esac
 
       if test -n "$addlibs"; then
-	gentop="$output_objdir/${outputname}x"
+	gentop=$output_objdir/${outputname}x
 	func_append generated " $gentop"
 
 	func_extract_archives $gentop $addlibs
@@ -9116,13 +10613,13 @@ EOF
       fi
 
       # Do each command in the archive commands.
-      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+      if test -n "$old_archive_from_new_cmds" && test yes = "$build_libtool_libs"; then
 	cmds=$old_archive_from_new_cmds
       else
 
 	# Add any objects from preloaded convenience libraries
 	if test -n "$dlprefiles"; then
-	  gentop="$output_objdir/${outputname}x"
+	  gentop=$output_objdir/${outputname}x
 	  func_append generated " $gentop"
 
 	  func_extract_archives $gentop $dlprefiles
@@ -9143,7 +10640,7 @@ EOF
 	  :
 	else
 	  echo "copying selected object files to avoid basename conflicts..."
-	  gentop="$output_objdir/${outputname}x"
+	  gentop=$output_objdir/${outputname}x
 	  func_append generated " $gentop"
 	  func_mkdir_p "$gentop"
 	  save_oldobjs=$oldobjs
@@ -9152,7 +10649,7 @@ EOF
 	  for obj in $save_oldobjs
 	  do
 	    func_basename "$obj"
-	    objbase="$func_basename_result"
+	    objbase=$func_basename_result
 	    case " $oldobjs " in
 	    " ") oldobjs=$obj ;;
 	    *[\ /]"$objbase "*)
@@ -9221,18 +10718,18 @@ EOF
 	    else
 	      # the above command should be used before it gets too long
 	      oldobjs=$objlist
-	      if test "$obj" = "$last_oldobj" ; then
+	      if test "$obj" = "$last_oldobj"; then
 		RANLIB=$save_RANLIB
 	      fi
 	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
-	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      eval concat_cmds=\"\$concat_cmds$old_archive_cmds\"
 	      objlist=
 	      len=$len0
 	    fi
 	  done
 	  RANLIB=$save_RANLIB
 	  oldobjs=$objlist
-	  if test "X$oldobjs" = "X" ; then
+	  if test -z "$oldobjs"; then
 	    eval cmds=\"\$concat_cmds\"
 	  else
 	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
@@ -9249,7 +10746,7 @@ EOF
     case $output in
     *.la)
       old_library=
-      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      test yes = "$build_old_libs" && old_library=$libname.$libext
       func_verbose "creating $output"
 
       # Preserve any variables that may affect compiler behavior
@@ -9264,31 +10761,31 @@ EOF
 	fi
       done
       # Quote the link command for shipping.
-      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command="(cd `pwd`; $SHELL \"$progpath\" $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
       relink_command=`$ECHO "$relink_command" | $SED "$sed_quote_subst"`
-      if test "$hardcode_automatic" = yes ; then
+      if test yes = "$hardcode_automatic"; then
 	relink_command=
       fi
 
       # Only create the output if not a dry run.
       $opt_dry_run || {
 	for installed in no yes; do
-	  if test "$installed" = yes; then
+	  if test yes = "$installed"; then
 	    if test -z "$install_libdir"; then
 	      break
 	    fi
-	    output="$output_objdir/$outputname"i
+	    output=$output_objdir/${outputname}i
 	    # Replace all uninstalled libtool libraries with the installed ones
 	    newdependency_libs=
 	    for deplib in $dependency_libs; do
 	      case $deplib in
 	      *.la)
 		func_basename "$deplib"
-		name="$func_basename_result"
+		name=$func_basename_result
 		func_resolve_sysroot "$deplib"
-		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $func_resolve_sysroot_result`
+		eval libdir=`$SED -n -e 's/^libdir=\(.*\)$/\1/p' $func_resolve_sysroot_result`
 		test -z "$libdir" && \
-		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  func_fatal_error "'$deplib' is not a valid libtool archive"
 		func_append newdependency_libs " ${lt_sysroot:+=}$libdir/$name"
 		;;
 	      -L*)
@@ -9304,23 +10801,23 @@ EOF
 	      *) func_append newdependency_libs " $deplib" ;;
 	      esac
 	    done
-	    dependency_libs="$newdependency_libs"
+	    dependency_libs=$newdependency_libs
 	    newdlfiles=
 
 	    for lib in $dlfiles; do
 	      case $lib in
 	      *.la)
 	        func_basename "$lib"
-		name="$func_basename_result"
-		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		name=$func_basename_result
+		eval libdir=`$SED -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
 		test -z "$libdir" && \
-		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		  func_fatal_error "'$lib' is not a valid libtool archive"
 		func_append newdlfiles " ${lt_sysroot:+=}$libdir/$name"
 		;;
 	      *) func_append newdlfiles " $lib" ;;
 	      esac
 	    done
-	    dlfiles="$newdlfiles"
+	    dlfiles=$newdlfiles
 	    newdlprefiles=
 	    for lib in $dlprefiles; do
 	      case $lib in
@@ -9330,34 +10827,34 @@ EOF
 		# didn't already link the preopened objects directly into
 		# the library:
 		func_basename "$lib"
-		name="$func_basename_result"
-		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		name=$func_basename_result
+		eval libdir=`$SED -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
 		test -z "$libdir" && \
-		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		  func_fatal_error "'$lib' is not a valid libtool archive"
 		func_append newdlprefiles " ${lt_sysroot:+=}$libdir/$name"
 		;;
 	      esac
 	    done
-	    dlprefiles="$newdlprefiles"
+	    dlprefiles=$newdlprefiles
 	  else
 	    newdlfiles=
 	    for lib in $dlfiles; do
 	      case $lib in
-		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		[\\/]* | [A-Za-z]:[\\/]*) abs=$lib ;;
 		*) abs=`pwd`"/$lib" ;;
 	      esac
 	      func_append newdlfiles " $abs"
 	    done
-	    dlfiles="$newdlfiles"
+	    dlfiles=$newdlfiles
 	    newdlprefiles=
 	    for lib in $dlprefiles; do
 	      case $lib in
-		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		[\\/]* | [A-Za-z]:[\\/]*) abs=$lib ;;
 		*) abs=`pwd`"/$lib" ;;
 	      esac
 	      func_append newdlprefiles " $abs"
 	    done
-	    dlprefiles="$newdlprefiles"
+	    dlprefiles=$newdlprefiles
 	  fi
 	  $RM $output
 	  # place dlname in correct position for cygwin
@@ -9373,10 +10870,9 @@ EOF
 	  case $host,$output,$installed,$module,$dlname in
 	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)
 	      # If a -bindir argument was supplied, place the dll there.
-	      if test "x$bindir" != x ;
-	      then
+	      if test -n "$bindir"; then
 		func_relative_path "$install_libdir" "$bindir"
-		tdlname=$func_relative_path_result$dlname
+		tdlname=$func_relative_path_result/$dlname
 	      else
 		# Otherwise fall back on heuristic.
 		tdlname=../bin/$dlname
@@ -9385,7 +10881,7 @@ EOF
 	  esac
 	  $ECHO > $output "\
 # $outputname - a libtool library file
-# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+# Generated by $PROGRAM (GNU $PACKAGE) $VERSION
 #
 # Please DO NOT delete this file!
 # It is necessary for linking the library.
@@ -9399,7 +10895,7 @@ library_names='$library_names'
 # The name of the static archive.
 old_library='$old_library'
 
-# Linker flags that can not go in dependency_libs.
+# Linker flags that cannot go in dependency_libs.
 inherited_linker_flags='$new_inherited_linker_flags'
 
 # Libraries that this one depends upon.
@@ -9425,7 +10921,7 @@ dlpreopen='$dlprefiles'
 
 # Directory that this library needs to be installed in:
 libdir='$install_libdir'"
-	  if test "$installed" = no && test "$need_relink" = yes; then
+	  if test no,yes = "$installed,$need_relink"; then
 	    $ECHO >> $output "\
 relink_command=\"$relink_command\""
 	  fi
@@ -9440,27 +10936,29 @@ relink_command=\"$relink_command\""
     exit $EXIT_SUCCESS
 }
 
-{ test "$opt_mode" = link || test "$opt_mode" = relink; } &&
-    func_mode_link ${1+"$@"}
+if test link = "$opt_mode" || test relink = "$opt_mode"; then
+  func_mode_link ${1+"$@"}
+fi
 
 
 # func_mode_uninstall arg...
 func_mode_uninstall ()
 {
-    $opt_debug
-    RM="$nonopt"
+    $debug_cmd
+
+    RM=$nonopt
     files=
-    rmforce=
+    rmforce=false
     exit_status=0
 
     # This variable tells wrapper scripts just to set variables rather
     # than running their programs.
-    libtool_install_magic="$magic"
+    libtool_install_magic=$magic
 
     for arg
     do
       case $arg in
-      -f) func_append RM " $arg"; rmforce=yes ;;
+      -f) func_append RM " $arg"; rmforce=: ;;
       -*) func_append RM " $arg" ;;
       *) func_append files " $arg" ;;
       esac
@@ -9473,18 +10971,18 @@ func_mode_uninstall ()
 
     for file in $files; do
       func_dirname "$file" "" "."
-      dir="$func_dirname_result"
-      if test "X$dir" = X.; then
-	odir="$objdir"
+      dir=$func_dirname_result
+      if test . = "$dir"; then
+	odir=$objdir
       else
-	odir="$dir/$objdir"
+	odir=$dir/$objdir
       fi
       func_basename "$file"
-      name="$func_basename_result"
-      test "$opt_mode" = uninstall && odir="$dir"
+      name=$func_basename_result
+      test uninstall = "$opt_mode" && odir=$dir
 
       # Remember odir for removal later, being careful to avoid duplicates
-      if test "$opt_mode" = clean; then
+      if test clean = "$opt_mode"; then
 	case " $rmdirs " in
 	  *" $odir "*) ;;
 	  *) func_append rmdirs " $odir" ;;
@@ -9499,11 +10997,11 @@ func_mode_uninstall ()
       elif test -d "$file"; then
 	exit_status=1
 	continue
-      elif test "$rmforce" = yes; then
+      elif $rmforce; then
 	continue
       fi
 
-      rmfiles="$file"
+      rmfiles=$file
 
       case $name in
       *.la)
@@ -9517,7 +11015,7 @@ func_mode_uninstall ()
 	  done
 	  test -n "$old_library" && func_append rmfiles " $odir/$old_library"
 
-	  case "$opt_mode" in
+	  case $opt_mode in
 	  clean)
 	    case " $library_names " in
 	    *" $dlname "*) ;;
@@ -9528,12 +11026,12 @@ func_mode_uninstall ()
 	  uninstall)
 	    if test -n "$library_names"; then
 	      # Do each command in the postuninstall commands.
-	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	      func_execute_cmds "$postuninstall_cmds" '$rmforce || exit_status=1'
 	    fi
 
 	    if test -n "$old_library"; then
 	      # Do each command in the old_postuninstall commands.
-	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	      func_execute_cmds "$old_postuninstall_cmds" '$rmforce || exit_status=1'
 	    fi
 	    # FIXME: should reinstall the best remaining shared library.
 	    ;;
@@ -9549,21 +11047,19 @@ func_mode_uninstall ()
 	  func_source $dir/$name
 
 	  # Add PIC object to the list of files to remove.
-	  if test -n "$pic_object" &&
-	     test "$pic_object" != none; then
+	  if test -n "$pic_object" && test none != "$pic_object"; then
 	    func_append rmfiles " $dir/$pic_object"
 	  fi
 
 	  # Add non-PIC object to the list of files to remove.
-	  if test -n "$non_pic_object" &&
-	     test "$non_pic_object" != none; then
+	  if test -n "$non_pic_object" && test none != "$non_pic_object"; then
 	    func_append rmfiles " $dir/$non_pic_object"
 	  fi
 	fi
 	;;
 
       *)
-	if test "$opt_mode" = clean ; then
+	if test clean = "$opt_mode"; then
 	  noexename=$name
 	  case $file in
 	  *.exe)
@@ -9590,12 +11086,12 @@ func_mode_uninstall ()
 
 	    # note $name still contains .exe if it was in $file originally
 	    # as does the version of $file that was added into $rmfiles
-	    func_append rmfiles " $odir/$name $odir/${name}S.${objext}"
-	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	    func_append rmfiles " $odir/$name $odir/${name}S.$objext"
+	    if test yes = "$fast_install" && test -n "$relink_command"; then
 	      func_append rmfiles " $odir/lt-$name"
 	    fi
-	    if test "X$noexename" != "X$name" ; then
-	      func_append rmfiles " $odir/lt-${noexename}.c"
+	    if test "X$noexename" != "X$name"; then
+	      func_append rmfiles " $odir/lt-$noexename.c"
 	    fi
 	  fi
 	fi
@@ -9604,7 +11100,7 @@ func_mode_uninstall ()
       func_show_eval "$RM $rmfiles" 'exit_status=1'
     done
 
-    # Try to remove the ${objdir}s in the directories where we deleted files
+    # Try to remove the $objdir's in the directories where we deleted files
     for dir in $rmdirs; do
       if test -d "$dir"; then
 	func_show_eval "rmdir $dir >/dev/null 2>&1"
@@ -9614,16 +11110,17 @@ func_mode_uninstall ()
     exit $exit_status
 }
 
-{ test "$opt_mode" = uninstall || test "$opt_mode" = clean; } &&
-    func_mode_uninstall ${1+"$@"}
+if test uninstall = "$opt_mode" || test clean = "$opt_mode"; then
+  func_mode_uninstall ${1+"$@"}
+fi
 
 test -z "$opt_mode" && {
-  help="$generic_help"
+  help=$generic_help
   func_fatal_help "you must specify a MODE"
 }
 
 test -z "$exec_cmd" && \
-  func_fatal_help "invalid operation mode \`$opt_mode'"
+  func_fatal_help "invalid operation mode '$opt_mode'"
 
 if test -n "$exec_cmd"; then
   eval exec "$exec_cmd"
@@ -9634,7 +11131,7 @@ exit $exit_status
 
 
 # The TAGs below are defined such that we never get into a situation
-# in which we disable both kinds of libraries.  Given conflicting
+# where we disable both kinds of libraries.  Given conflicting
 # choices, we go for a static library, that is the most portable,
 # since we can't tell whether shared libraries were disabled because
 # the user asked for that or because the platform doesn't support
@@ -9657,5 +11154,3 @@ build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
 # mode:shell-script
 # sh-indentation:2
 # End:
-# vi:sw=2
-
diff --git a/lib/Analysis/isl/m4/ax_cxx_compile_stdcxx.m4 b/lib/Analysis/isl/m4/ax_cxx_compile_stdcxx.m4
new file mode 100644
index 0000000..5032bba
--- /dev/null
+++ b/lib/Analysis/isl/m4/ax_cxx_compile_stdcxx.m4
@@ -0,0 +1,982 @@
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_COMPILE_STDCXX(VERSION, [ext|noext], [mandatory|optional])
+#
+# DESCRIPTION
+#
+#   Check for baseline language coverage in the compiler for the specified
+#   version of the C++ standard.  If necessary, add switches to CXX and
+#   CXXCPP to enable support.  VERSION may be '11' (for the C++11 standard)
+#   or '14' (for the C++14 standard).
+#
+#   The second argument, if specified, indicates whether you insist on an
+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
+#   -std=c++11).  If neither is specified, you get whatever works, with
+#   preference for an extended mode.
+#
+#   The third argument, if specified 'mandatory' or if left unspecified,
+#   indicates that baseline support for the specified C++ standard is
+#   required and that the macro should error out if no mode with that
+#   support is found.  If specified 'optional', then configuration proceeds
+#   regardless, after defining HAVE_CXX${VERSION} if and only if a
+#   supporting mode is found.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
+#   Copyright (c) 2016 Krzesimir Nowak <qdlacz@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 7
+
+dnl  This macro is based on the code from the AX_CXX_COMPILE_STDCXX_11 macro
+dnl  (serial version number 13).
+
+AX_REQUIRE_DEFINED([AC_MSG_WARN])
+AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl
+  m4_if([$1], [11], [ax_cxx_compile_alternatives="11 0x"],
+        [$1], [14], [ax_cxx_compile_alternatives="14 1y"],
+        [$1], [17], [ax_cxx_compile_alternatives="17 1z"],
+        [m4_fatal([invalid first argument `$1' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$2], [], [],
+        [$2], [ext], [],
+        [$2], [noext], [],
+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX])])dnl
+  m4_if([$3], [], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [mandatory], [ax_cxx_compile_cxx$1_required=true],
+        [$3], [optional], [ax_cxx_compile_cxx$1_required=false],
+        [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])
+  AC_LANG_PUSH([C++])dnl
+  ac_success=no
+  AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,
+  ax_cv_cxx_compile_cxx$1,
+  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+    [ax_cv_cxx_compile_cxx$1=yes],
+    [ax_cv_cxx_compile_cxx$1=no])])
+  if test x$ax_cv_cxx_compile_cxx$1 = xyes; then
+    ac_success=yes
+  fi
+
+  m4_if([$2], [noext], [], [dnl
+  if test x$ac_success = xno; then
+    for alternative in ${ax_cxx_compile_alternatives}; do
+      switch="-std=gnu++${alternative}"
+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+      AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                     $cachevar,
+        [ac_save_CXX="$CXX"
+         CXX="$CXX $switch"
+         AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+          [eval $cachevar=yes],
+          [eval $cachevar=no])
+         CXX="$ac_save_CXX"])
+      if eval test x\$$cachevar = xyes; then
+        CXX="$CXX $switch"
+        if test -n "$CXXCPP" ; then
+          CXXCPP="$CXXCPP $switch"
+        fi
+        ac_success=yes
+        break
+      fi
+    done
+  fi])
+
+  m4_if([$2], [ext], [], [dnl
+  if test x$ac_success = xno; then
+    dnl HP's aCC needs +std=c++11 according to:
+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
+    dnl Cray's crayCC needs "-h std=c++11"
+    for alternative in ${ax_cxx_compile_alternatives}; do
+      for switch in -std=c++${alternative} +std=c++${alternative} "-h std=c++${alternative}"; do
+        cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])
+        AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,
+                       $cachevar,
+          [ac_save_CXX="$CXX"
+           CXX="$CXX $switch"
+           AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],
+            [eval $cachevar=yes],
+            [eval $cachevar=no])
+           CXX="$ac_save_CXX"])
+        if eval test x\$$cachevar = xyes; then
+          CXX="$CXX $switch"
+          if test -n "$CXXCPP" ; then
+            CXXCPP="$CXXCPP $switch"
+          fi
+          ac_success=yes
+          break
+        fi
+      done
+      if test x$ac_success = xyes; then
+        break
+      fi
+    done
+  fi])
+  AC_LANG_POP([C++])
+  if test x$ax_cxx_compile_cxx$1_required = xtrue; then
+    if test x$ac_success = xno; then
+      AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])
+    fi
+  fi
+  if test x$ac_success = xno; then
+    HAVE_CXX$1=0
+    AC_MSG_NOTICE([No compiler with C++$1 support was found])
+  else
+    HAVE_CXX$1=1
+    AC_DEFINE(HAVE_CXX$1,1,
+              [define if the compiler supports basic C++$1 syntax])
+  fi
+  AC_SUBST(HAVE_CXX$1)
+  m4_if([$1], [17], [AC_MSG_WARN([C++17 is not yet standardized, so the checks may change in incompatible ways anytime])])
+])
+
+
+dnl  Test body for checking C++11 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_11],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+)
+
+
+dnl  Test body for checking C++14 support
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_14],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
+)
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_17],
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_11
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_14
+  _AX_CXX_COMPILE_STDCXX_testbody_new_in_17
+)
+
+dnl  Tests for new features in C++11
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_11], [[
+
+// If the compiler admits that it is not ready for C++11, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201103L
+
+#error "This is not a C++11 compiler"
+
+#else
+
+namespace cxx11
+{
+
+  namespace test_static_assert
+  {
+
+    template <typename T>
+    struct check
+    {
+      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+    };
+
+  }
+
+  namespace test_final_override
+  {
+
+    struct Base
+    {
+      virtual void f() {}
+    };
+
+    struct Derived : public Base
+    {
+      virtual void f() override {}
+    };
+
+  }
+
+  namespace test_double_right_angle_brackets
+  {
+
+    template < typename T >
+    struct check {};
+
+    typedef check<void> single_type;
+    typedef check<check<void>> double_type;
+    typedef check<check<check<void>>> triple_type;
+    typedef check<check<check<check<void>>>> quadruple_type;
+
+  }
+
+  namespace test_decltype
+  {
+
+    int
+    f()
+    {
+      int a = 1;
+      decltype(a) b = 2;
+      return a + b;
+    }
+
+  }
+
+  namespace test_type_deduction
+  {
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static const bool value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static const bool value = true;
+    };
+
+    template < typename T1, typename T2 >
+    auto
+    add(T1 a1, T2 a2) -> decltype(a1 + a2)
+    {
+      return a1 + a2;
+    }
+
+    int
+    test(const int c, volatile int v)
+    {
+      static_assert(is_same<int, decltype(0)>::value == true, "");
+      static_assert(is_same<int, decltype(c)>::value == false, "");
+      static_assert(is_same<int, decltype(v)>::value == false, "");
+      auto ac = c;
+      auto av = v;
+      auto sumi = ac + av + 'x';
+      auto sumf = ac + av + 1.0;
+      static_assert(is_same<int, decltype(ac)>::value == true, "");
+      static_assert(is_same<int, decltype(av)>::value == true, "");
+      static_assert(is_same<int, decltype(sumi)>::value == true, "");
+      static_assert(is_same<int, decltype(sumf)>::value == false, "");
+      static_assert(is_same<int, decltype(add(c, v))>::value == true, "");
+      return (sumf > 0.0) ? sumi : add(c, v);
+    }
+
+  }
+
+  namespace test_noexcept
+  {
+
+    int f() { return 0; }
+    int g() noexcept { return 0; }
+
+    static_assert(noexcept(f()) == false, "");
+    static_assert(noexcept(g()) == true, "");
+
+  }
+
+  namespace test_constexpr
+  {
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept
+    {
+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;
+    }
+
+    template < typename CharT >
+    unsigned long constexpr
+    strlen_c(const CharT *const s) noexcept
+    {
+      return strlen_c_r(s, 0UL);
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("1") == 1UL, "");
+    static_assert(strlen_c("example") == 7UL, "");
+    static_assert(strlen_c("another\0example") == 7UL, "");
+
+  }
+
+  namespace test_rvalue_references
+  {
+
+    template < int N >
+    struct answer
+    {
+      static constexpr int value = N;
+    };
+
+    answer<1> f(int&)       { return answer<1>(); }
+    answer<2> f(const int&) { return answer<2>(); }
+    answer<3> f(int&&)      { return answer<3>(); }
+
+    void
+    test()
+    {
+      int i = 0;
+      const int c = 0;
+      static_assert(decltype(f(i))::value == 1, "");
+      static_assert(decltype(f(c))::value == 2, "");
+      static_assert(decltype(f(0))::value == 3, "");
+    }
+
+  }
+
+  namespace test_uniform_initialization
+  {
+
+    struct test
+    {
+      static const int zero {};
+      static const int one {1};
+    };
+
+    static_assert(test::zero == 0, "");
+    static_assert(test::one == 1, "");
+
+  }
+
+  namespace test_lambdas
+  {
+
+    void
+    test1()
+    {
+      auto lambda1 = [](){};
+      auto lambda2 = lambda1;
+      lambda1();
+      lambda2();
+    }
+
+    int
+    test2()
+    {
+      auto a = [](int i, int j){ return i + j; }(1, 2);
+      auto b = []() -> int { return '0'; }();
+      auto c = [=](){ return a + b; }();
+      auto d = [&](){ return c; }();
+      auto e = [a, &b](int x) mutable {
+        const auto identity = [](int y){ return y; };
+        for (auto i = 0; i < a; ++i)
+          a += b--;
+        return x + identity(a + b);
+      }(0);
+      return a + b + c + d + e;
+    }
+
+    int
+    test3()
+    {
+      const auto nullary = [](){ return 0; };
+      const auto unary = [](int x){ return x; };
+      using nullary_t = decltype(nullary);
+      using unary_t = decltype(unary);
+      const auto higher1st = [](nullary_t f){ return f(); };
+      const auto higher2nd = [unary](nullary_t f1){
+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };
+      };
+      return higher1st(nullary) + higher2nd(nullary)(unary);
+    }
+
+  }
+
+  namespace test_variadic_templates
+  {
+
+    template <int...>
+    struct sum;
+
+    template <int N0, int... N1toN>
+    struct sum<N0, N1toN...>
+    {
+      static constexpr auto value = N0 + sum<N1toN...>::value;
+    };
+
+    template <>
+    struct sum<>
+    {
+      static constexpr auto value = 0;
+    };
+
+    static_assert(sum<>::value == 0, "");
+    static_assert(sum<1>::value == 1, "");
+    static_assert(sum<23>::value == 23, "");
+    static_assert(sum<1, 2>::value == 3, "");
+    static_assert(sum<5, 5, 11>::value == 21, "");
+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, "");
+
+  }
+
+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae
+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function
+  // because of this.
+  namespace test_template_alias_sfinae
+  {
+
+    struct foo {};
+
+    template<typename T>
+    using member = typename T::member_type;
+
+    template<typename T>
+    void func(...) {}
+
+    template<typename T>
+    void func(member<T>*) {}
+
+    void test();
+
+    void test() { func<foo>(0); }
+
+  }
+
+}  // namespace cxx11
+
+#endif  // __cplusplus >= 201103L
+
+]])
+
+
+dnl  Tests for new features in C++14
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_14], [[
+
+// If the compiler admits that it is not ready for C++14, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus < 201402L
+
+#error "This is not a C++14 compiler"
+
+#else
+
+namespace cxx14
+{
+
+  namespace test_polymorphic_lambdas
+  {
+
+    int
+    test()
+    {
+      const auto lambda = [](auto&&... args){
+        const auto istiny = [](auto x){
+          return (sizeof(x) == 1UL) ? 1 : 0;
+        };
+        const int aretiny[] = { istiny(args)... };
+        return aretiny[0];
+      };
+      return lambda(1, 1L, 1.0f, '1');
+    }
+
+  }
+
+  namespace test_binary_literals
+  {
+
+    constexpr auto ivii = 0b0000000000101010;
+    static_assert(ivii == 42, "wrong value");
+
+  }
+
+  namespace test_generalized_constexpr
+  {
+
+    template < typename CharT >
+    constexpr unsigned long
+    strlen_c(const CharT *const s) noexcept
+    {
+      auto length = 0UL;
+      for (auto p = s; *p; ++p)
+        ++length;
+      return length;
+    }
+
+    static_assert(strlen_c("") == 0UL, "");
+    static_assert(strlen_c("x") == 1UL, "");
+    static_assert(strlen_c("test") == 4UL, "");
+    static_assert(strlen_c("another\0test") == 7UL, "");
+
+  }
+
+  namespace test_lambda_init_capture
+  {
+
+    int
+    test()
+    {
+      auto x = 0;
+      const auto lambda1 = [a = x](int b){ return a + b; };
+      const auto lambda2 = [a = lambda1(x)](){ return a; };
+      return lambda2();
+    }
+
+  }
+
+  namespace test_digit_separators
+  {
+
+    constexpr auto ten_million = 100'000'000;
+    static_assert(ten_million == 100000000, "");
+
+  }
+
+  namespace test_return_type_deduction
+  {
+
+    auto f(int& x) { return x; }
+    decltype(auto) g(int& x) { return x; }
+
+    template < typename T1, typename T2 >
+    struct is_same
+    {
+      static constexpr auto value = false;
+    };
+
+    template < typename T >
+    struct is_same<T, T>
+    {
+      static constexpr auto value = true;
+    };
+
+    int
+    test()
+    {
+      auto x = 0;
+      static_assert(is_same<int, decltype(f(x))>::value, "");
+      static_assert(is_same<int&, decltype(g(x))>::value, "");
+      return x;
+    }
+
+  }
+
+}  // namespace cxx14
+
+#endif  // __cplusplus >= 201402L
+
+]])
+
+
+dnl  Tests for new features in C++17
+
+m4_define([_AX_CXX_COMPILE_STDCXX_testbody_new_in_17], [[
+
+// If the compiler admits that it is not ready for C++17, why torture it?
+// Hopefully, this will speed up the test.
+
+#ifndef __cplusplus
+
+#error "This is not a C++ compiler"
+
+#elif __cplusplus <= 201402L
+
+#error "This is not a C++17 compiler"
+
+#else
+
+#if defined(__clang__)
+  #define REALLY_CLANG
+#else
+  #if defined(__GNUC__)
+    #define REALLY_GCC
+  #endif
+#endif
+
+#include <initializer_list>
+#include <utility>
+#include <type_traits>
+
+namespace cxx17
+{
+
+#if !defined(REALLY_CLANG)
+  namespace test_constexpr_lambdas
+  {
+
+    // TODO: test it with clang++ from git
+
+    constexpr int foo = [](){return 42;}();
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test::nested_namespace::definitions
+  {
+
+  }
+
+  namespace test_fold_expression
+  {
+
+    template<typename... Args>
+    int multiply(Args... args)
+    {
+      return (args * ... * 1);
+    }
+
+    template<typename... Args>
+    bool all(Args... args)
+    {
+      return (args && ...);
+    }
+
+  }
+
+  namespace test_extended_static_assert
+  {
+
+    static_assert (true);
+
+  }
+
+  namespace test_auto_brace_init_list
+  {
+
+    auto foo = {5};
+    auto bar {5};
+
+    static_assert(std::is_same<std::initializer_list<int>, decltype(foo)>::value);
+    static_assert(std::is_same<int, decltype(bar)>::value);
+  }
+
+  namespace test_typename_in_template_template_parameter
+  {
+
+    template<template<typename> typename X> struct D;
+
+  }
+
+  namespace test_fallthrough_nodiscard_maybe_unused_attributes
+  {
+
+    int f1()
+    {
+      return 42;
+    }
+
+    [[nodiscard]] int f2()
+    {
+      [[maybe_unused]] auto unused = f1();
+
+      switch (f1())
+      {
+      case 17:
+        f1();
+        [[fallthrough]];
+      case 42:
+        f1();
+      }
+      return f1();
+    }
+
+  }
+
+  namespace test_extended_aggregate_initialization
+  {
+
+    struct base1
+    {
+      int b1, b2 = 42;
+    };
+
+    struct base2
+    {
+      base2() {
+        b3 = 42;
+      }
+      int b3;
+    };
+
+    struct derived : base1, base2
+    {
+        int d;
+    };
+
+    derived d1 {{1, 2}, {}, 4};  // full initialization
+    derived d2 {{}, {}, 4};      // value-initialized bases
+
+  }
+
+  namespace test_general_range_based_for_loop
+  {
+
+    struct iter
+    {
+      int i;
+
+      int& operator* ()
+      {
+        return i;
+      }
+
+      const int& operator* () const
+      {
+        return i;
+      }
+
+      iter& operator++()
+      {
+        ++i;
+        return *this;
+      }
+    };
+
+    struct sentinel
+    {
+      int i;
+    };
+
+    bool operator== (const iter& i, const sentinel& s)
+    {
+      return i.i == s.i;
+    }
+
+    bool operator!= (const iter& i, const sentinel& s)
+    {
+      return !(i == s);
+    }
+
+    struct range
+    {
+      iter begin() const
+      {
+        return {0};
+      }
+
+      sentinel end() const
+      {
+        return {5};
+      }
+    };
+
+    void f()
+    {
+      range r {};
+
+      for (auto i : r)
+      {
+        [[maybe_unused]] auto v = i;
+      }
+    }
+
+  }
+
+  namespace test_lambda_capture_asterisk_this_by_value
+  {
+
+    struct t
+    {
+      int i;
+      int foo()
+      {
+        return [*this]()
+        {
+          return i;
+        }();
+      }
+    };
+
+  }
+
+  namespace test_enum_class_construction
+  {
+
+    enum class byte : unsigned char
+    {};
+
+    byte foo {42};
+
+  }
+
+  namespace test_constexpr_if
+  {
+
+    template <bool cond>
+    int f ()
+    {
+      if constexpr(cond)
+      {
+        return 13;
+      }
+      else
+      {
+        return 42;
+      }
+    }
+
+  }
+
+  namespace test_selection_statement_with_initializer
+  {
+
+    int f()
+    {
+      return 13;
+    }
+
+    int f2()
+    {
+      if (auto i = f(); i > 0)
+      {
+        return 3;
+      }
+
+      switch (auto i = f(); i + 4)
+      {
+      case 17:
+        return 2;
+
+      default:
+        return 1;
+      }
+    }
+
+  }
+
+#if !defined(REALLY_CLANG)
+  namespace test_template_argument_deduction_for_class_templates
+  {
+
+    // TODO: test it with clang++ from git
+
+    template <typename T1, typename T2>
+    struct pair
+    {
+      pair (T1 p1, T2 p2)
+        : m1 {p1},
+          m2 {p2}
+      {}
+
+      T1 m1;
+      T2 m2;
+    };
+
+    void f()
+    {
+      [[maybe_unused]] auto p = pair{13, 42u};
+    }
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test_non_type_auto_template_parameters
+  {
+
+    template <auto n>
+    struct B
+    {};
+
+    B<5> b1;
+    B<'a'> b2;
+
+  }
+
+#if !defined(REALLY_CLANG)
+  namespace test_structured_bindings
+  {
+
+    // TODO: test it with clang++ from git
+
+    int arr[2] = { 1, 2 };
+    std::pair<int, int> pr = { 1, 2 };
+
+    auto f1() -> int(&)[2]
+    {
+      return arr;
+    }
+
+    auto f2() -> std::pair<int, int>&
+    {
+      return pr;
+    }
+
+    struct S
+    {
+      int x1 : 2;
+      volatile double y1;
+    };
+
+    S f3()
+    {
+      return {};
+    }
+
+    auto [ x1, y1 ] = f1();
+    auto& [ xr1, yr1 ] = f1();
+    auto [ x2, y2 ] = f2();
+    auto& [ xr2, yr2 ] = f2();
+    const auto [ x3, y3 ] = f3();
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+#if !defined(REALLY_CLANG)
+  namespace test_exception_spec_type_system
+  {
+
+    // TODO: test it with clang++ from git
+
+    struct Good {};
+    struct Bad {};
+
+    void g1() noexcept;
+    void g2();
+
+    template<typename T>
+    Bad
+    f(T*, T*);
+
+    template<typename T1, typename T2>
+    Good
+    f(T1*, T2*);
+
+    static_assert (std::is_same_v<Good, decltype(f(g1, g2))>);
+
+  }
+#endif // !defined(REALLY_CLANG)
+
+  namespace test_inline_variables
+  {
+
+    template<class T> void f(T)
+    {}
+
+    template<class T> inline T g(T)
+    {
+      return T{};
+    }
+
+    template<> inline void f<>(int)
+    {}
+
+    template<> int g<>(int)
+    {
+      return 5;
+    }
+
+  }
+
+}  // namespace cxx17
+
+#endif  // __cplusplus <= 201402L
+
+]])
diff --git a/lib/Analysis/isl/m4/ax_cxx_compile_stdcxx_11.m4 b/lib/Analysis/isl/m4/ax_cxx_compile_stdcxx_11.m4
new file mode 100644
index 0000000..0aadeaf
--- /dev/null
+++ b/lib/Analysis/isl/m4/ax_cxx_compile_stdcxx_11.m4
@@ -0,0 +1,39 @@
+# ============================================================================
+#  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_11.html
+# ============================================================================
+#
+# SYNOPSIS
+#
+#   AX_CXX_COMPILE_STDCXX_11([ext|noext], [mandatory|optional])
+#
+# DESCRIPTION
+#
+#   Check for baseline language coverage in the compiler for the C++11
+#   standard; if necessary, add switches to CXX and CXXCPP to enable
+#   support.
+#
+#   This macro is a convenience alias for calling the AX_CXX_COMPILE_STDCXX
+#   macro with the version set to C++11.  The two optional arguments are
+#   forwarded literally as the second and third argument respectively.
+#   Please see the documentation for the AX_CXX_COMPILE_STDCXX macro for
+#   more information.  If you want to use this macro, you also need to
+#   download the ax_cxx_compile_stdcxx.m4 file.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
+#   Copyright (c) 2015 Paul Norman <penorman@mac.com>
+#   Copyright (c) 2015 Moritz Klammler <moritz@klammler.eu>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 17
+
+AX_REQUIRE_DEFINED([AX_CXX_COMPILE_STDCXX])
+AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [AX_CXX_COMPILE_STDCXX([11], [$1], [$2])])
diff --git a/lib/Analysis/isl/m4/ax_detect_clang.m4 b/lib/Analysis/isl/m4/ax_detect_clang.m4
new file mode 100644
index 0000000..d3021e0
--- /dev/null
+++ b/lib/Analysis/isl/m4/ax_detect_clang.m4
@@ -0,0 +1,168 @@
+AC_DEFUN([AX_DETECT_CLANG], [
+AC_SUBST(CLANG_CXXFLAGS)
+AC_SUBST(CLANG_LDFLAGS)
+AC_SUBST(CLANG_LIBS)
+AC_PROG_GREP
+AC_PROG_SED
+llvm_config="llvm-config"
+AC_CHECK_PROG([llvm_config_found], ["$llvm_config"], [yes])
+if test "x$with_clang_prefix" != "x"; then
+	llvm_config="$with_clang_prefix/bin/llvm-config"
+	if test -x "$llvm_config"; then
+		llvm_config_found=yes
+	fi
+fi
+if test "$llvm_config_found" != yes; then
+	AC_MSG_ERROR([llvm-config not found])
+fi
+CLANG_CXXFLAGS=`$llvm_config --cxxflags | \
+	$SED -e 's/-Wcovered-switch-default//;s/-gsplit-dwarf//'`
+CLANG_LDFLAGS=`$llvm_config --ldflags`
+targets=`$llvm_config --targets-built`
+components="$targets asmparser bitreader support mc"
+$llvm_config --components | $GREP option > /dev/null 2> /dev/null
+if test $? -eq 0; then
+	components="$components option"
+fi
+CLANG_LIBS=`$llvm_config --libs $components`
+systemlibs=`$llvm_config --system-libs 2> /dev/null | tail -1`
+if test $? -eq 0; then
+	CLANG_LIBS="$CLANG_LIBS $systemlibs"
+fi
+CLANG_PREFIX=`$llvm_config --prefix`
+AC_DEFINE_UNQUOTED(CLANG_PREFIX, ["$CLANG_PREFIX"], [Clang installation prefix])
+
+SAVE_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CLANG_CXXFLAGS $CPPFLAGS"
+AC_LANG_PUSH(C++)
+AC_CHECK_HEADER([clang/Basic/SourceLocation.h], [],
+	[AC_ERROR([clang header file not found])])
+AC_EGREP_HEADER([getDefaultTargetTriple], [llvm/Support/Host.h], [],
+	[AC_DEFINE([getDefaultTargetTriple], [getHostTriple],
+	[Define to getHostTriple for older versions of clang])])
+AC_EGREP_HEADER([getExpansionLineNumber], [clang/Basic/SourceLocation.h], [],
+	[AC_DEFINE([getExpansionLineNumber], [getInstantiationLineNumber],
+	[Define to getInstantiationLineNumber for older versions of clang])])
+AC_EGREP_HEADER([DiagnosticsEngine], [clang/Basic/Diagnostic.h], [],
+	[AC_DEFINE([DiagnosticsEngine], [Diagnostic],
+	[Define to Diagnostic for older versions of clang])])
+AC_EGREP_HEADER([ArrayRef], [clang/Driver/Driver.h],
+	[AC_DEFINE([USE_ARRAYREF], [],
+		[Define if Driver::BuildCompilation takes ArrayRef])])
+AC_EGREP_HEADER([CXXIsProduction], [clang/Driver/Driver.h],
+	[AC_DEFINE([HAVE_CXXISPRODUCTION], [],
+		[Define if Driver constructor takes CXXIsProduction argument])])
+AC_EGREP_HEADER([ IsProduction], [clang/Driver/Driver.h],
+	[AC_DEFINE([HAVE_ISPRODUCTION], [],
+		[Define if Driver constructor takes IsProduction argument])])
+AC_TRY_COMPILE([#include <clang/Driver/Driver.h>], [
+	using namespace clang;
+	DiagnosticsEngine *Diags;
+	new driver::Driver("", "", "", *Diags);
+], [AC_DEFINE([DRIVER_CTOR_TAKES_DEFAULTIMAGENAME], [],
+	      [Define if Driver constructor takes default image name])])
+AC_EGREP_HEADER([void HandleTopLevelDecl\(], [clang/AST/ASTConsumer.h],
+	[AC_DEFINE([HandleTopLevelDeclReturn], [void],
+		   [Return type of HandleTopLevelDeclReturn])
+	 AC_DEFINE([HandleTopLevelDeclContinue], [],
+		   [Return type of HandleTopLevelDeclReturn])],
+	[AC_DEFINE([HandleTopLevelDeclReturn], [bool],
+		   [Return type of HandleTopLevelDeclReturn])
+	 AC_DEFINE([HandleTopLevelDeclContinue], [true],
+		   [Return type of HandleTopLevelDeclReturn])])
+AC_CHECK_HEADER([clang/Basic/DiagnosticOptions.h],
+	[AC_DEFINE([HAVE_BASIC_DIAGNOSTICOPTIONS_H], [],
+		   [Define if clang/Basic/DiagnosticOptions.h exists])])
+AC_CHECK_HEADER([clang/Lex/PreprocessorOptions.h],
+	[AC_DEFINE([HAVE_LEX_PREPROCESSOROPTIONS_H], [],
+		   [Define if clang/Lex/PreprocessorOptions.h exists])], [],
+	[#include <clang/Basic/LLVM.h>])
+AC_TRY_COMPILE([#include <clang/Basic/TargetInfo.h>], [
+	using namespace clang;
+	std::shared_ptr<TargetOptions> TO;
+	DiagnosticsEngine *Diags;
+	TargetInfo::CreateTargetInfo(*Diags, TO);
+], [AC_DEFINE([CREATETARGETINFO_TAKES_SHARED_PTR], [],
+	      [Define if TargetInfo::CreateTargetInfo takes shared_ptr])])
+AC_TRY_COMPILE([#include <clang/Basic/TargetInfo.h>], [
+	using namespace clang;
+	TargetOptions *TO;
+	DiagnosticsEngine *Diags;
+	TargetInfo::CreateTargetInfo(*Diags, TO);
+], [AC_DEFINE([CREATETARGETINFO_TAKES_POINTER], [],
+	      [Define if TargetInfo::CreateTargetInfo takes pointer])])
+AC_TRY_COMPILE([#include <clang/Frontend/CompilerInstance.h>], [
+	using namespace clang;
+	DiagnosticConsumer *client;
+	CompilerInstance *Clang;
+	Clang->createDiagnostics(client);
+], [], [AC_DEFINE([CREATEDIAGNOSTICS_TAKES_ARG], [],
+	[Define if CompilerInstance::createDiagnostics takes argc and argv])])
+AC_TRY_COMPILE([#include <clang/Lex/HeaderSearchOptions.h>], [
+	using namespace clang;
+	HeaderSearchOptions HSO;
+	HSO.AddPath("", frontend::Angled, false, false);
+], [AC_DEFINE([ADDPATH_TAKES_4_ARGUMENTS], [],
+	[Define if HeaderSearchOptions::AddPath takes 4 arguments])])
+AC_EGREP_HEADER([getNumParams],
+	[clang/AST/CanonicalType.h],
+	[AC_DEFINE([getNumArgs], [getNumParams],
+	    [Define to getNumParams for newer versions of clang])
+	 AC_DEFINE([getArgType], [getParamType],
+	    [Define to getParamType for newer versions of clang])])
+AC_EGREP_HEADER([getReturnType],
+	[clang/AST/CanonicalType.h], [],
+	[AC_DEFINE([getReturnType], [getResultType],
+	    [Define to getResultType for older versions of clang])])
+AC_TRY_COMPILE([#include <clang/Frontend/CompilerInstance.h>], [
+	using namespace clang;
+	CompilerInstance *Clang;
+	Clang->createPreprocessor(TU_Complete);
+], [AC_DEFINE([CREATEPREPROCESSOR_TAKES_TUKIND], [],
+[Define if CompilerInstance::createPreprocessor takes TranslationUnitKind])])
+AC_EGREP_HEADER([setMainFileID], [clang/Basic/SourceManager.h],
+	[AC_DEFINE([HAVE_SETMAINFILEID], [],
+	[Define if SourceManager has a setMainFileID method])])
+AC_CHECK_HEADER([llvm/ADT/OwningPtr.h],
+	[AC_DEFINE([HAVE_ADT_OWNINGPTR_H], [],
+		   [Define if llvm/ADT/OwningPtr.h exists])])
+AC_EGREP_HEADER([initializeBuiltins],
+	[clang/Basic/Builtins.h], [],
+	[AC_DEFINE([initializeBuiltins], [InitializeBuiltins],
+		[Define to InitializeBuiltins for older versions of clang])])
+AC_EGREP_HEADER([IK_C], [clang/Frontend/FrontendOptions.h], [],
+	 [AC_DEFINE([IK_C], [InputKind::C],
+	    [Define to InputKind::C for newer versions of clang])])
+AC_TRY_COMPILE([
+	#include <clang/Basic/TargetOptions.h>
+	#include <clang/Lex/PreprocessorOptions.h>
+	#include <clang/Frontend/CompilerInstance.h>
+], [
+	using namespace clang;
+	CompilerInstance *Clang;
+	TargetOptions TO;
+	llvm::Triple T(TO.Triple);
+	PreprocessorOptions PO;
+	CompilerInvocation::setLangDefaults(Clang->getLangOpts(), IK_C,
+			T, PO, LangStandard::lang_unspecified);
+], [AC_DEFINE([SETLANGDEFAULTS_TAKES_5_ARGUMENTS], [],
+	[Define if CompilerInvocation::setLangDefaults takes 5 arguments])])
+AC_TRY_COMPILE([
+	#include <clang/Frontend/CompilerInstance.h>
+	#include <clang/Frontend/CompilerInvocation.h>
+], [
+	using namespace clang;
+	CompilerInvocation *invocation;
+	CompilerInstance *Clang;
+	Clang->setInvocation(std::make_shared<CompilerInvocation>(*invocation));
+], [AC_DEFINE([SETINVOCATION_TAKES_SHARED_PTR], [],
+	[Defined if CompilerInstance::setInvocation takes a shared_ptr])])
+AC_LANG_POP
+CPPFLAGS="$SAVE_CPPFLAGS"
+
+SAVE_LDFLAGS="$LDFLAGS"
+LDFLAGS="$CLANG_LDFLAGS $LDFLAGS"
+AC_SUBST(LIB_CLANG_EDIT)
+AC_CHECK_LIB([clangEdit], [main], [LIB_CLANG_EDIT=-lclangEdit], [])
+LDFLAGS="$SAVE_LDFLAGS"
+])
diff --git a/lib/Analysis/isl/m4/libtool.m4 b/lib/Analysis/isl/m4/libtool.m4
index d7c043f..ee80844 100644
--- a/lib/Analysis/isl/m4/libtool.m4
+++ b/lib/Analysis/isl/m4/libtool.m4
@@ -1,8 +1,6 @@
 # libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
 #
-#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
-#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-#                 Foundation, Inc.
+#   Copyright (C) 1996-2001, 2003-2015 Free Software Foundation, Inc.
 #   Written by Gordon Matzigkeit, 1996
 #
 # This file is free software; the Free Software Foundation gives
@@ -10,36 +8,30 @@
 # modifications, as long as this notice is preserved.
 
 m4_define([_LT_COPYING], [dnl
-#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
-#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-#                 Foundation, Inc.
-#   Written by Gordon Matzigkeit, 1996
-#
-#   This file is part of GNU Libtool.
-#
-# GNU Libtool is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
+# Copyright (C) 2014 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of of the License, or
+# (at your option) any later version.
 #
-# As a special exception to the GNU General Public License,
-# if you distribute this file as part of a program or library that
-# is built using GNU Libtool, you may include this file under the
-# same distribution terms that you use for the rest of that program.
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program or library that is built
+# using GNU Libtool, you may include this file under the  same
+# distribution terms that you use for the rest of that program.
 #
-# GNU Libtool is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with GNU Libtool; see the file COPYING.  If not, a copy
-# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
-# obtained by writing to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ])
 
-# serial 57 LT_INIT
+# serial 58 LT_INIT
 
 
 # LT_PREREQ(VERSION)
@@ -67,7 +59,7 @@ esac
 # LT_INIT([OPTIONS])
 # ------------------
 AC_DEFUN([LT_INIT],
-[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT
+[AC_PREREQ([2.62])dnl We use AC_PATH_PROGS_FEATURE_CHECK
 AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
 AC_BEFORE([$0], [LT_LANG])dnl
 AC_BEFORE([$0], [LT_OUTPUT])dnl
@@ -91,7 +83,7 @@ dnl Parse OPTIONS
 _LT_SET_OPTIONS([$0], [$1])
 
 # This can be used to rebuild libtool when needed
-LIBTOOL_DEPS="$ltmain"
+LIBTOOL_DEPS=$ltmain
 
 # Always use our own libtool.
 LIBTOOL='$(SHELL) $(top_builddir)/libtool'
@@ -111,26 +103,43 @@ dnl AC_DEFUN([AC_PROG_LIBTOOL], [])
 dnl AC_DEFUN([AM_PROG_LIBTOOL], [])
 
 
+# _LT_PREPARE_CC_BASENAME
+# -----------------------
+m4_defun([_LT_PREPARE_CC_BASENAME], [
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+func_cc_basename ()
+{
+    for cc_temp in @S|@*""; do
+      case $cc_temp in
+        compile | *[[\\/]]compile | ccache | *[[\\/]]ccache ) ;;
+        distcc | *[[\\/]]distcc | purify | *[[\\/]]purify ) ;;
+        \-*) ;;
+        *) break;;
+      esac
+    done
+    func_cc_basename_result=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+}
+])# _LT_PREPARE_CC_BASENAME
+
+
 # _LT_CC_BASENAME(CC)
 # -------------------
-# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+# It would be clearer to call AC_REQUIREs from _LT_PREPARE_CC_BASENAME,
+# but that macro is also expanded into generated libtool script, which
+# arranges for $SED and $ECHO to be set by different means.
 m4_defun([_LT_CC_BASENAME],
-[for cc_temp in $1""; do
-  case $cc_temp in
-    compile | *[[\\/]]compile | ccache | *[[\\/]]ccache ) ;;
-    distcc | *[[\\/]]distcc | purify | *[[\\/]]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+[m4_require([_LT_PREPARE_CC_BASENAME])dnl
+AC_REQUIRE([_LT_DECL_SED])dnl
+AC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl
+func_cc_basename $1
+cc_basename=$func_cc_basename_result
 ])
 
 
 # _LT_FILEUTILS_DEFAULTS
 # ----------------------
 # It is okay to use these file commands and assume they have been set
-# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.
+# sensibly after 'm4_require([_LT_FILEUTILS_DEFAULTS])'.
 m4_defun([_LT_FILEUTILS_DEFAULTS],
 [: ${CP="cp -f"}
 : ${MV="mv -f"}
@@ -177,15 +186,16 @@ m4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl
 m4_require([_LT_CMD_OLD_ARCHIVE])dnl
 m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
 m4_require([_LT_WITH_SYSROOT])dnl
+m4_require([_LT_CMD_TRUNCATE])dnl
 
 _LT_CONFIG_LIBTOOL_INIT([
-# See if we are running on zsh, and set the options which allow our
+# See if we are running on zsh, and set the options that allow our
 # commands through without removal of \ escapes INIT.
-if test -n "\${ZSH_VERSION+set}" ; then
+if test -n "\${ZSH_VERSION+set}"; then
    setopt NO_GLOB_SUBST
 fi
 ])
-if test -n "${ZSH_VERSION+set}" ; then
+if test -n "${ZSH_VERSION+set}"; then
    setopt NO_GLOB_SUBST
 fi
 
@@ -198,7 +208,7 @@ aix3*)
   # AIX sometimes has problems with the GCC collect2 program.  For some
   # reason, if we set the COLLECT_NAMES environment variable, the problems
   # vanish in a puff of smoke.
-  if test "X${COLLECT_NAMES+set}" != Xset; then
+  if test set != "${COLLECT_NAMES+set}"; then
     COLLECT_NAMES=
     export COLLECT_NAMES
   fi
@@ -209,14 +219,14 @@ esac
 ofile=libtool
 can_build_shared=yes
 
-# All known linkers require a `.a' archive for static linking (except MSVC,
+# All known linkers require a '.a' archive for static linking (except MSVC,
 # which needs '.lib').
 libext=a
 
-with_gnu_ld="$lt_cv_prog_gnu_ld"
+with_gnu_ld=$lt_cv_prog_gnu_ld
 
-old_CC="$CC"
-old_CFLAGS="$CFLAGS"
+old_CC=$CC
+old_CFLAGS=$CFLAGS
 
 # Set sane defaults for various variables
 test -z "$CC" && CC=cc
@@ -269,14 +279,14 @@ no_glob_subst='s/\*/\\\*/g'
 
 # _LT_PROG_LTMAIN
 # ---------------
-# Note that this code is called both from `configure', and `config.status'
+# Note that this code is called both from 'configure', and 'config.status'
 # now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,
-# `config.status' has no value for ac_aux_dir unless we are using Automake,
+# 'config.status' has no value for ac_aux_dir unless we are using Automake,
 # so we pass a copy along to make sure it has a sensible value anyway.
 m4_defun([_LT_PROG_LTMAIN],
 [m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl
 _LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])
-ltmain="$ac_aux_dir/ltmain.sh"
+ltmain=$ac_aux_dir/ltmain.sh
 ])# _LT_PROG_LTMAIN
 
 
@@ -286,7 +296,7 @@ ltmain="$ac_aux_dir/ltmain.sh"
 
 # So that we can recreate a full libtool script including additional
 # tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS
-# in macros and then make a single call at the end using the `libtool'
+# in macros and then make a single call at the end using the 'libtool'
 # label.
 
 
@@ -421,8 +431,8 @@ m4_define([_lt_decl_all_varnames],
 
 # _LT_CONFIG_STATUS_DECLARE([VARNAME])
 # ------------------------------------
-# Quote a variable value, and forward it to `config.status' so that its
-# declaration there will have the same value as in `configure'.  VARNAME
+# Quote a variable value, and forward it to 'config.status' so that its
+# declaration there will have the same value as in 'configure'.  VARNAME
 # must have a single quote delimited value for this to work.
 m4_define([_LT_CONFIG_STATUS_DECLARE],
 [$1='`$ECHO "$][$1" | $SED "$delay_single_quote_subst"`'])
@@ -446,7 +456,7 @@ m4_defun([_LT_CONFIG_STATUS_DECLARATIONS],
 # Output comment and list of tags supported by the script
 m4_defun([_LT_LIBTOOL_TAGS],
 [_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl
-available_tags="_LT_TAGS"dnl
+available_tags='_LT_TAGS'dnl
 ])
 
 
@@ -474,7 +484,7 @@ m4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl
 # _LT_LIBTOOL_CONFIG_VARS
 # -----------------------
 # Produce commented declarations of non-tagged libtool config variables
-# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'
+# suitable for insertion in the LIBTOOL CONFIG section of the 'libtool'
 # script.  Tagged libtool config variables (even for the LIBTOOL CONFIG
 # section) are produced by _LT_LIBTOOL_TAG_VARS.
 m4_defun([_LT_LIBTOOL_CONFIG_VARS],
@@ -500,8 +510,8 @@ m4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])
 # Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of
 # variables for single and double quote escaping we saved from calls
 # to _LT_DECL, we can put quote escaped variables declarations
-# into `config.status', and then the shell code to quote escape them in
-# for loops in `config.status'.  Finally, any additional code accumulated
+# into 'config.status', and then the shell code to quote escape them in
+# for loops in 'config.status'.  Finally, any additional code accumulated
 # from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.
 m4_defun([_LT_CONFIG_COMMANDS],
 [AC_PROVIDE_IFELSE([LT_OUTPUT],
@@ -547,7 +557,7 @@ for var in lt_decl_all_varnames([[ \
 ]], lt_decl_quote_varnames); do
     case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
     *[[\\\\\\\`\\"\\\$]]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\"" ## exclude from sc_prohibit_nested_quotes
       ;;
     *)
       eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
@@ -560,7 +570,7 @@ for var in lt_decl_all_varnames([[ \
 ]], lt_decl_dquote_varnames); do
     case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
     *[[\\\\\\\`\\"\\\$]]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\"" ## exclude from sc_prohibit_nested_quotes
       ;;
     *)
       eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
@@ -576,7 +586,7 @@ _LT_OUTPUT_LIBTOOL_INIT
 # Generate a child script FILE with all initialization necessary to
 # reuse the environment learned by the parent script, and make the
 # file executable.  If COMMENT is supplied, it is inserted after the
-# `#!' sequence but before initialization text begins.  After this
+# '#!' sequence but before initialization text begins.  After this
 # macro, additional text can be appended to FILE to form the body of
 # the child script.  The macro ends with non-zero status if the
 # file could not be fully written (such as if the disk is full).
@@ -598,7 +608,7 @@ AS_SHELL_SANITIZE
 _AS_PREPARE
 exec AS_MESSAGE_FD>&1
 _ASEOF
-test $lt_write_fail = 0 && chmod +x $1[]dnl
+test 0 = "$lt_write_fail" && chmod +x $1[]dnl
 m4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT
 
 # LT_OUTPUT
@@ -621,7 +631,7 @@ exec AS_MESSAGE_LOG_FD>>config.log
 } >&AS_MESSAGE_LOG_FD
 
 lt_cl_help="\
-\`$as_me' creates a local libtool stub from the current configuration,
+'$as_me' creates a local libtool stub from the current configuration,
 for use in further configure time tests before the real libtool is
 generated.
 
@@ -643,7 +653,7 @@ Copyright (C) 2011 Free Software Foundation, Inc.
 This config.lt script is free software; the Free Software Foundation
 gives unlimited permision to copy, distribute and modify it."
 
-while test $[#] != 0
+while test 0 != $[#]
 do
   case $[1] in
     --version | --v* | -V )
@@ -656,10 +666,10 @@ do
       lt_cl_silent=: ;;
 
     -*) AC_MSG_ERROR([unrecognized option: $[1]
-Try \`$[0] --help' for more information.]) ;;
+Try '$[0] --help' for more information.]) ;;
 
     *) AC_MSG_ERROR([unrecognized argument: $[1]
-Try \`$[0] --help' for more information.]) ;;
+Try '$[0] --help' for more information.]) ;;
   esac
   shift
 done
@@ -685,7 +695,7 @@ chmod +x "$CONFIG_LT"
 # open by configure.  Here we exec the FD to /dev/null, effectively closing
 # config.log, so it can be properly (re)opened and appended to by config.lt.
 lt_cl_success=:
-test "$silent" = yes &&
+test yes = "$silent" &&
   lt_config_lt_args="$lt_config_lt_args --quiet"
 exec AS_MESSAGE_LOG_FD>/dev/null
 $SHELL "$CONFIG_LT" $lt_config_lt_args || lt_cl_success=false
@@ -705,27 +715,30 @@ m4_defun([_LT_CONFIG],
 _LT_CONFIG_SAVE_COMMANDS([
   m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl
   m4_if(_LT_TAG, [C], [
-    # See if we are running on zsh, and set the options which allow our
+    # See if we are running on zsh, and set the options that allow our
     # commands through without removal of \ escapes.
-    if test -n "${ZSH_VERSION+set}" ; then
+    if test -n "${ZSH_VERSION+set}"; then
       setopt NO_GLOB_SUBST
     fi
 
-    cfgfile="${ofile}T"
+    cfgfile=${ofile}T
     trap "$RM \"$cfgfile\"; exit 1" 1 2 15
     $RM "$cfgfile"
 
     cat <<_LT_EOF >> "$cfgfile"
 #! $SHELL
-
-# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
-# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
-# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# Generated automatically by $as_me ($PACKAGE) $VERSION
 # NOTE: Changes made to this file will be lost: look at ltmain.sh.
-#
+
+# Provide generalized library-building support services.
+# Written by Gordon Matzigkeit, 1996
+
 _LT_COPYING
 _LT_LIBTOOL_TAGS
 
+# Configured defaults for sys_lib_dlsearch_path munging.
+: \${LT_SYS_LIBRARY_PATH="$configure_time_lt_sys_library_path"}
+
 # ### BEGIN LIBTOOL CONFIG
 _LT_LIBTOOL_CONFIG_VARS
 _LT_LIBTOOL_TAG_VARS
@@ -733,13 +746,24 @@ _LT_LIBTOOL_TAG_VARS
 
 _LT_EOF
 
+    cat <<'_LT_EOF' >> "$cfgfile"
+
+# ### BEGIN FUNCTIONS SHARED WITH CONFIGURE
+
+_LT_PREPARE_MUNGE_PATH_LIST
+_LT_PREPARE_CC_BASENAME
+
+# ### END FUNCTIONS SHARED WITH CONFIGURE
+
+_LT_EOF
+
   case $host_os in
   aix3*)
     cat <<\_LT_EOF >> "$cfgfile"
 # AIX sometimes has problems with the GCC collect2 program.  For some
 # reason, if we set the COLLECT_NAMES environment variable, the problems
 # vanish in a puff of smoke.
-if test "X${COLLECT_NAMES+set}" != Xset; then
+if test set != "${COLLECT_NAMES+set}"; then
   COLLECT_NAMES=
   export COLLECT_NAMES
 fi
@@ -756,8 +780,6 @@ _LT_EOF
   sed '$q' "$ltmain" >> "$cfgfile" \
      || (rm -f "$cfgfile"; exit 1)
 
-  _LT_PROG_REPLACE_SHELLFNS
-
    mv -f "$cfgfile" "$ofile" ||
     (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
   chmod +x "$ofile"
@@ -775,7 +797,6 @@ _LT_EOF
 [m4_if([$1], [], [
     PACKAGE='$PACKAGE'
     VERSION='$VERSION'
-    TIMESTAMP='$TIMESTAMP'
     RM='$RM'
     ofile='$ofile'], [])
 ])dnl /_LT_CONFIG_SAVE_COMMANDS
@@ -974,7 +995,7 @@ m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
 
     AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],
       [lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
+      if test -z "$LT_MULTI_MODULE"; then
 	# By default we will add the -single_module flag. You can override
 	# by either setting the environment variable LT_MULTI_MODULE
 	# non-empty at configure time, or by adding -multi_module to the
@@ -992,7 +1013,7 @@ m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
 	  cat conftest.err >&AS_MESSAGE_LOG_FD
 	# Otherwise, if the output was created with a 0 exit code from
 	# the compiler, it worked.
-	elif test -f libconftest.dylib && test $_lt_result -eq 0; then
+	elif test -f libconftest.dylib && test 0 = "$_lt_result"; then
 	  lt_cv_apple_cc_single_mod=yes
 	else
 	  cat conftest.err >&AS_MESSAGE_LOG_FD
@@ -1010,7 +1031,7 @@ m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
       AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
 	[lt_cv_ld_exported_symbols_list=yes],
 	[lt_cv_ld_exported_symbols_list=no])
-	LDFLAGS="$save_LDFLAGS"
+	LDFLAGS=$save_LDFLAGS
     ])
 
     AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],
@@ -1032,7 +1053,7 @@ _LT_EOF
       _lt_result=$?
       if test -s conftest.err && $GREP force_load conftest.err; then
 	cat conftest.err >&AS_MESSAGE_LOG_FD
-      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then
+      elif test -f conftest && test 0 = "$_lt_result" && $GREP forced_load conftest >/dev/null 2>&1; then
 	lt_cv_ld_force_load=yes
       else
 	cat conftest.err >&AS_MESSAGE_LOG_FD
@@ -1042,32 +1063,32 @@ _LT_EOF
     ])
     case $host_os in
     rhapsody* | darwin1.[[012]])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+      _lt_dar_allow_undefined='$wl-undefined ${wl}suppress' ;;
     darwin1.*)
-      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+      _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;
     darwin*) # darwin 5.x on
       # if running on 10.5 or later, the deployment target defaults
       # to the OS version, if on x86, and 10.4, the deployment
       # target defaults to 10.4. Don't you love it?
       case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
 	10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-	10.[[012]]*)
-	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;
+	10.[[012]][[,.]]*)
+	  _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;
 	10.*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;
       esac
     ;;
   esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+    if test yes = "$lt_cv_apple_cc_single_mod"; then
       _lt_dar_single_mod='$single_module'
     fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    if test yes = "$lt_cv_ld_exported_symbols_list"; then
+      _lt_dar_export_syms=' $wl-exported_symbols_list,$output_objdir/$libname-symbols.expsym'
     else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/$libname-symbols.expsym $lib'
     fi
-    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+    if test : != "$DSYMUTIL" && test no = "$lt_cv_ld_force_load"; then
       _lt_dsymutil='~$DSYMUTIL $lib || :'
     else
       _lt_dsymutil=
@@ -1087,29 +1108,29 @@ m4_defun([_LT_DARWIN_LINKER_FEATURES],
   _LT_TAGVAR(hardcode_direct, $1)=no
   _LT_TAGVAR(hardcode_automatic, $1)=yes
   _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  if test yes = "$lt_cv_ld_force_load"; then
+    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience $wl-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
     m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],
                   [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])
   else
     _LT_TAGVAR(whole_archive_flag_spec, $1)=''
   fi
   _LT_TAGVAR(link_all_deplibs, $1)=yes
-  _LT_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
+  _LT_TAGVAR(allow_undefined_flag, $1)=$_lt_dar_allow_undefined
   case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
+     ifort*|nagfor*) _lt_dar_can_shared=yes ;;
      *) _lt_dar_can_shared=$GCC ;;
   esac
-  if test "$_lt_dar_can_shared" = "yes"; then
+  if test yes = "$_lt_dar_can_shared"; then
     output_verbose_link_cmd=func_echo_all
-    _LT_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    _LT_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+    _LT_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod$_lt_dsymutil"
+    _LT_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags$_lt_dsymutil"
+    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod$_lt_dar_export_syms$_lt_dsymutil"
+    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags$_lt_dar_export_syms$_lt_dsymutil"
     m4_if([$1], [CXX],
-[   if test "$lt_cv_apple_cc_single_mod" != "yes"; then
-      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
-      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+[   if test yes != "$lt_cv_apple_cc_single_mod"; then
+      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \$lib-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$lib-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring$_lt_dsymutil"
+      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's|^|_|' < \$export_symbols > \$output_objdir/\$libname-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \$lib-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$lib-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring$_lt_dar_export_syms$_lt_dsymutil"
     fi
 ],[])
   else
@@ -1129,7 +1150,7 @@ m4_defun([_LT_DARWIN_LINKER_FEATURES],
 # Allow to override them for all tags through lt_cv_aix_libpath.
 m4_defun([_LT_SYS_MODULE_PATH_AIX],
 [m4_require([_LT_DECL_SED])dnl
-if test "${lt_cv_aix_libpath+set}" = set; then
+if test set = "${lt_cv_aix_libpath+set}"; then
   aix_libpath=$lt_cv_aix_libpath
 else
   AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],
@@ -1147,7 +1168,7 @@ else
     _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
   fi],[])
   if test -z "$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])"; then
-    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])="/usr/lib:/lib"
+    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=/usr/lib:/lib
   fi
   ])
   aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])
@@ -1167,8 +1188,8 @@ m4_define([_LT_SHELL_INIT],
 # -----------------------
 # Find how we can fake an echo command that does not interpret backslash.
 # In particular, with Autoconf 2.60 or later we add some code to the start
-# of the generated configure script which will find a shell with a builtin
-# printf (which we can use as an echo command).
+# of the generated configure script that will find a shell with a builtin
+# printf (that we can use as an echo command).
 m4_defun([_LT_PROG_ECHO_BACKSLASH],
 [ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
 ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
@@ -1196,10 +1217,10 @@ fi
 # Invoke $ECHO with all args, space-separated.
 func_echo_all ()
 {
-    $ECHO "$*" 
+    $ECHO "$*"
 }
 
-case "$ECHO" in
+case $ECHO in
   printf*) AC_MSG_RESULT([printf]) ;;
   print*) AC_MSG_RESULT([print -r]) ;;
   *) AC_MSG_RESULT([cat]) ;;
@@ -1225,16 +1246,17 @@ _LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])
 AC_DEFUN([_LT_WITH_SYSROOT],
 [AC_MSG_CHECKING([for sysroot])
 AC_ARG_WITH([sysroot],
-[  --with-sysroot[=DIR] Search for dependent libraries within DIR
-                        (or the compiler's sysroot if not specified).],
+[AS_HELP_STRING([--with-sysroot@<:@=DIR@:>@],
+  [Search for dependent libraries within DIR (or the compiler's sysroot
+   if not specified).])],
 [], [with_sysroot=no])
 
 dnl lt_sysroot will always be passed unquoted.  We quote it here
 dnl in case the user passed a directory name.
 lt_sysroot=
-case ${with_sysroot} in #(
+case $with_sysroot in #(
  yes)
-   if test "$GCC" = yes; then
+   if test yes = "$GCC"; then
      lt_sysroot=`$CC --print-sysroot 2>/dev/null`
    fi
    ;; #(
@@ -1244,14 +1266,14 @@ case ${with_sysroot} in #(
  no|'')
    ;; #(
  *)
-   AC_MSG_RESULT([${with_sysroot}])
+   AC_MSG_RESULT([$with_sysroot])
    AC_MSG_ERROR([The sysroot must be an absolute path.])
    ;;
 esac
 
  AC_MSG_RESULT([${lt_sysroot:-no}])
 _LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl
-[dependent libraries, and in which our libraries should be installed.])])
+[dependent libraries, and where our libraries should be installed.])])
 
 # _LT_ENABLE_LOCK
 # ---------------
@@ -1259,31 +1281,33 @@ m4_defun([_LT_ENABLE_LOCK],
 [AC_ARG_ENABLE([libtool-lock],
   [AS_HELP_STRING([--disable-libtool-lock],
     [avoid locking (might break parallel builds)])])
-test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+test no = "$enable_libtool_lock" || enable_libtool_lock=yes
 
 # Some flags need to be propagated to the compiler or linker for good
 # libtool support.
 case $host in
 ia64-*-hpux*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set mode
+  # options accordingly.
   echo 'int i;' > conftest.$ac_ext
   if AC_TRY_EVAL(ac_compile); then
     case `/usr/bin/file conftest.$ac_objext` in
       *ELF-32*)
-	HPUX_IA64_MODE="32"
+	HPUX_IA64_MODE=32
 	;;
       *ELF-64*)
-	HPUX_IA64_MODE="64"
+	HPUX_IA64_MODE=64
 	;;
     esac
   fi
   rm -rf conftest*
   ;;
 *-*-irix6*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.
   echo '[#]line '$LINENO' "configure"' > conftest.$ac_ext
   if AC_TRY_EVAL(ac_compile); then
-    if test "$lt_cv_prog_gnu_ld" = yes; then
+    if test yes = "$lt_cv_prog_gnu_ld"; then
       case `/usr/bin/file conftest.$ac_objext` in
 	*32-bit*)
 	  LD="${LD-ld} -melf32bsmip"
@@ -1312,9 +1336,46 @@ ia64-*-hpux*)
   rm -rf conftest*
   ;;
 
+mips64*-*linux*)
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.
+  echo '[#]line '$LINENO' "configure"' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    emul=elf
+    case `/usr/bin/file conftest.$ac_objext` in
+      *32-bit*)
+	emul="${emul}32"
+	;;
+      *64-bit*)
+	emul="${emul}64"
+	;;
+    esac
+    case `/usr/bin/file conftest.$ac_objext` in
+      *MSB*)
+	emul="${emul}btsmip"
+	;;
+      *LSB*)
+	emul="${emul}ltsmip"
+	;;
+    esac
+    case `/usr/bin/file conftest.$ac_objext` in
+      *N32*)
+	emul="${emul}n32"
+	;;
+    esac
+    LD="${LD-ld} -m $emul"
+  fi
+  rm -rf conftest*
+  ;;
+
 x86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \
 s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.  Note that the listed cases only cover the
+  # situations where additional linker options are needed (such as when
+  # doing 32-bit compilation for a host where ld defaults to 64-bit, or
+  # vice versa); the common cases where no linker options are needed do
+  # not appear in the list.
   echo 'int i;' > conftest.$ac_ext
   if AC_TRY_EVAL(ac_compile); then
     case `/usr/bin/file conftest.o` in
@@ -1333,10 +1394,10 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
 		;;
 	    esac
 	    ;;
-	  powerpc64le-*)
+	  powerpc64le-*linux*)
 	    LD="${LD-ld} -m elf32lppclinux"
 	    ;;
-	  powerpc64-*)
+	  powerpc64-*linux*)
 	    LD="${LD-ld} -m elf32ppclinux"
 	    ;;
 	  s390x-*linux*)
@@ -1355,10 +1416,10 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
 	  x86_64-*linux*)
 	    LD="${LD-ld} -m elf_x86_64"
 	    ;;
-	  powerpcle-*)
+	  powerpcle-*linux*)
 	    LD="${LD-ld} -m elf64lppc"
 	    ;;
-	  powerpc-*)
+	  powerpc-*linux*)
 	    LD="${LD-ld} -m elf64ppc"
 	    ;;
 	  s390*-*linux*|s390*-*tpf*)
@@ -1376,19 +1437,20 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
 
 *-*-sco3.2v5*)
   # On SCO OpenServer 5, we need -belf to get full-featured binaries.
-  SAVE_CFLAGS="$CFLAGS"
+  SAVE_CFLAGS=$CFLAGS
   CFLAGS="$CFLAGS -belf"
   AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,
     [AC_LANG_PUSH(C)
      AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])
      AC_LANG_POP])
-  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+  if test yes != "$lt_cv_cc_needs_belf"; then
     # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
-    CFLAGS="$SAVE_CFLAGS"
+    CFLAGS=$SAVE_CFLAGS
   fi
   ;;
 *-*solaris*)
-  # Find out which ABI we are using.
+  # Find out what ABI is being produced by ac_compile, and set linker
+  # options accordingly.
   echo 'int i;' > conftest.$ac_ext
   if AC_TRY_EVAL(ac_compile); then
     case `/usr/bin/file conftest.o` in
@@ -1396,7 +1458,7 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
       case $lt_cv_prog_gnu_ld in
       yes*)
         case $host in
-        i?86-*-solaris*)
+        i?86-*-solaris*|x86_64-*-solaris*)
           LD="${LD-ld} -m elf_x86_64"
           ;;
         sparc*-*-solaris*)
@@ -1405,7 +1467,7 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
         esac
         # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.
         if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then
-          LD="${LD-ld}_sol2"
+          LD=${LD-ld}_sol2
         fi
         ;;
       *)
@@ -1421,7 +1483,7 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
   ;;
 esac
 
-need_locks="$enable_libtool_lock"
+need_locks=$enable_libtool_lock
 ])# _LT_ENABLE_LOCK
 
 
@@ -1440,11 +1502,11 @@ AC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],
      [echo conftest.$ac_objext > conftest.lst
       lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'
       AC_TRY_EVAL([lt_ar_try])
-      if test "$ac_status" -eq 0; then
+      if test 0 -eq "$ac_status"; then
 	# Ensure the archiver fails upon bogus file names.
 	rm -f conftest.$ac_objext libconftest.a
 	AC_TRY_EVAL([lt_ar_try])
-	if test "$ac_status" -ne 0; then
+	if test 0 -ne "$ac_status"; then
           lt_cv_ar_at_file=@
         fi
       fi
@@ -1452,7 +1514,7 @@ AC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],
      ])
   ])
 
-if test "x$lt_cv_ar_at_file" = xno; then
+if test no = "$lt_cv_ar_at_file"; then
   archiver_list_spec=
 else
   archiver_list_spec=$lt_cv_ar_at_file
@@ -1483,7 +1545,7 @@ old_postuninstall_cmds=
 
 if test -n "$RANLIB"; then
   case $host_os in
-  openbsd*)
+  bitrig* | openbsd*)
     old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$tool_oldlib"
     ;;
   *)
@@ -1519,7 +1581,7 @@ AC_CACHE_CHECK([$1], [$2],
   [$2=no
    m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])
    echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$3"
+   lt_compiler_flag="$3"  ## exclude from sc_useless_quotes_in_assignment
    # Insert the option either (1) after the last *FLAGS variable, or
    # (2) before a word containing "conftest.", or (3) at the end.
    # Note that $ac_compile itself does not contain backslashes and begins
@@ -1546,7 +1608,7 @@ AC_CACHE_CHECK([$1], [$2],
    $RM conftest*
 ])
 
-if test x"[$]$2" = xyes; then
+if test yes = "[$]$2"; then
     m4_if([$5], , :, [$5])
 else
     m4_if([$6], , :, [$6])
@@ -1568,7 +1630,7 @@ AC_DEFUN([_LT_LINKER_OPTION],
 m4_require([_LT_DECL_SED])dnl
 AC_CACHE_CHECK([$1], [$2],
   [$2=no
-   save_LDFLAGS="$LDFLAGS"
+   save_LDFLAGS=$LDFLAGS
    LDFLAGS="$LDFLAGS $3"
    echo "$lt_simple_link_test_code" > conftest.$ac_ext
    if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
@@ -1587,10 +1649,10 @@ AC_CACHE_CHECK([$1], [$2],
      fi
    fi
    $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+   LDFLAGS=$save_LDFLAGS
 ])
 
-if test x"[$]$2" = xyes; then
+if test yes = "[$]$2"; then
     m4_if([$4], , :, [$4])
 else
     m4_if([$5], , :, [$5])
@@ -1611,7 +1673,7 @@ AC_DEFUN([LT_CMD_MAX_LEN],
 AC_MSG_CHECKING([the maximum length of command line arguments])
 AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
   i=0
-  teststring="ABCD"
+  teststring=ABCD
 
   case $build_os in
   msdosdjgpp*)
@@ -1651,7 +1713,7 @@ AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+  bitrig* | darwin* | dragonfly* | freebsd* | netbsd* | openbsd*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
       lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
@@ -1702,22 +1764,22 @@ AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
   *)
     lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
     if test -n "$lt_cv_sys_max_cmd_len" && \
-	test undefined != "$lt_cv_sys_max_cmd_len"; then
+       test undefined != "$lt_cv_sys_max_cmd_len"; then
       lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
       lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
     else
       # Make teststring a little bigger before we do anything with it.
       # a 1K string should be a reasonable start.
-      for i in 1 2 3 4 5 6 7 8 ; do
+      for i in 1 2 3 4 5 6 7 8; do
         teststring=$teststring$teststring
       done
       SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
       # If test is not a shell built-in, we'll probably end up computing a
       # maximum length that is only half of the actual maximum length, but
       # we can't tell.
-      while { test "X"`env echo "$teststring$teststring" 2>/dev/null` \
+      while { test X`env echo "$teststring$teststring" 2>/dev/null` \
 	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
-	      test $i != 17 # 1/2 MB should be enough
+	      test 17 != "$i" # 1/2 MB should be enough
       do
         i=`expr $i + 1`
         teststring=$teststring$teststring
@@ -1733,7 +1795,7 @@ AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
     ;;
   esac
 ])
-if test -n $lt_cv_sys_max_cmd_len ; then
+if test -n "$lt_cv_sys_max_cmd_len"; then
   AC_MSG_RESULT($lt_cv_sys_max_cmd_len)
 else
   AC_MSG_RESULT(none)
@@ -1761,7 +1823,7 @@ m4_defun([_LT_HEADER_DLFCN],
 # ----------------------------------------------------------------
 m4_defun([_LT_TRY_DLOPEN_SELF],
 [m4_require([_LT_HEADER_DLFCN])dnl
-if test "$cross_compiling" = yes; then :
+if test yes = "$cross_compiling"; then :
   [$4]
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
@@ -1808,9 +1870,9 @@ else
 #  endif
 #endif
 
-/* When -fvisbility=hidden is used, assume the code has been annotated
+/* When -fvisibility=hidden is used, assume the code has been annotated
    correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+#if defined __GNUC__ && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
 int fnord () __attribute__((visibility("default")));
 #endif
 
@@ -1836,7 +1898,7 @@ int main ()
   return status;
 }]
 _LT_EOF
-  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then
+  if AC_TRY_EVAL(ac_link) && test -s "conftest$ac_exeext" 2>/dev/null; then
     (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -1857,7 +1919,7 @@ rm -fr conftest*
 # ------------------
 AC_DEFUN([LT_SYS_DLOPEN_SELF],
 [m4_require([_LT_HEADER_DLFCN])dnl
-if test "x$enable_dlopen" != xyes; then
+if test yes != "$enable_dlopen"; then
   enable_dlopen=unknown
   enable_dlopen_self=unknown
   enable_dlopen_self_static=unknown
@@ -1867,44 +1929,52 @@ else
 
   case $host_os in
   beos*)
-    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen=load_add_on
     lt_cv_dlopen_libs=
     lt_cv_dlopen_self=yes
     ;;
 
   mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen=LoadLibrary
     lt_cv_dlopen_libs=
     ;;
 
   cygwin*)
-    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen=dlopen
     lt_cv_dlopen_libs=
     ;;
 
   darwin*)
-  # if libdl is installed we need to link against it
+    # if libdl is installed we need to link against it
     AC_CHECK_LIB([dl], [dlopen],
-		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],[
-    lt_cv_dlopen="dyld"
+		[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],[
+    lt_cv_dlopen=dyld
     lt_cv_dlopen_libs=
     lt_cv_dlopen_self=yes
     ])
     ;;
 
+  tpf*)
+    # Don't try to run any link tests for TPF.  We know it's impossible
+    # because TPF is a cross-compiler, and we know how we open DSOs.
+    lt_cv_dlopen=dlopen
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=no
+    ;;
+
   *)
     AC_CHECK_FUNC([shl_load],
-	  [lt_cv_dlopen="shl_load"],
+	  [lt_cv_dlopen=shl_load],
       [AC_CHECK_LIB([dld], [shl_load],
-	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"],
+	    [lt_cv_dlopen=shl_load lt_cv_dlopen_libs=-ldld],
 	[AC_CHECK_FUNC([dlopen],
-	      [lt_cv_dlopen="dlopen"],
+	      [lt_cv_dlopen=dlopen],
 	  [AC_CHECK_LIB([dl], [dlopen],
-		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],
+		[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],
 	    [AC_CHECK_LIB([svld], [dlopen],
-		  [lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"],
+		  [lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-lsvld],
 	      [AC_CHECK_LIB([dld], [dld_link],
-		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"])
+		    [lt_cv_dlopen=dld_link lt_cv_dlopen_libs=-ldld])
 	      ])
 	    ])
 	  ])
@@ -1913,21 +1983,21 @@ else
     ;;
   esac
 
-  if test "x$lt_cv_dlopen" != xno; then
-    enable_dlopen=yes
-  else
+  if test no = "$lt_cv_dlopen"; then
     enable_dlopen=no
+  else
+    enable_dlopen=yes
   fi
 
   case $lt_cv_dlopen in
   dlopen)
-    save_CPPFLAGS="$CPPFLAGS"
-    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+    save_CPPFLAGS=$CPPFLAGS
+    test yes = "$ac_cv_header_dlfcn_h" && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
 
-    save_LDFLAGS="$LDFLAGS"
+    save_LDFLAGS=$LDFLAGS
     wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
 
-    save_LIBS="$LIBS"
+    save_LIBS=$LIBS
     LIBS="$lt_cv_dlopen_libs $LIBS"
 
     AC_CACHE_CHECK([whether a program can dlopen itself],
@@ -1937,7 +2007,7 @@ else
 	    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)
     ])
 
-    if test "x$lt_cv_dlopen_self" = xyes; then
+    if test yes = "$lt_cv_dlopen_self"; then
       wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
       AC_CACHE_CHECK([whether a statically linked program can dlopen itself],
 	  lt_cv_dlopen_self_static, [dnl
@@ -1947,9 +2017,9 @@ else
       ])
     fi
 
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
+    CPPFLAGS=$save_CPPFLAGS
+    LDFLAGS=$save_LDFLAGS
+    LIBS=$save_LIBS
     ;;
   esac
 
@@ -2041,8 +2111,8 @@ m4_defun([_LT_COMPILER_FILE_LOCKS],
 m4_require([_LT_FILEUTILS_DEFAULTS])dnl
 _LT_COMPILER_C_O([$1])
 
-hard_links="nottested"
-if test "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" = no && test "$need_locks" != no; then
+hard_links=nottested
+if test no = "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" && test no != "$need_locks"; then
   # do not overwrite the value of need_locks provided by the user
   AC_MSG_CHECKING([if we can lock with hard links])
   hard_links=yes
@@ -2052,8 +2122,8 @@ if test "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" = no && test "$need_locks" !=
   ln conftest.a conftest.b 2>&5 || hard_links=no
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
   AC_MSG_RESULT([$hard_links])
-  if test "$hard_links" = no; then
-    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])
+  if test no = "$hard_links"; then
+    AC_MSG_WARN(['$CC' does not support '-c -o', so 'make -j' may be unsafe])
     need_locks=warn
   fi
 else
@@ -2080,8 +2150,8 @@ objdir=$lt_cv_objdir
 _LT_DECL([], [objdir], [0],
          [The name of the directory that contains temporary libtool files])dnl
 m4_pattern_allow([LT_OBJDIR])dnl
-AC_DEFINE_UNQUOTED(LT_OBJDIR, "$lt_cv_objdir/",
-  [Define to the sub-directory in which libtool stores uninstalled libraries.])
+AC_DEFINE_UNQUOTED([LT_OBJDIR], "$lt_cv_objdir/",
+  [Define to the sub-directory where libtool stores uninstalled libraries.])
 ])# _LT_CHECK_OBJDIR
 
 
@@ -2093,15 +2163,15 @@ m4_defun([_LT_LINKER_HARDCODE_LIBPATH],
 _LT_TAGVAR(hardcode_action, $1)=
 if test -n "$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)" ||
    test -n "$_LT_TAGVAR(runpath_var, $1)" ||
-   test "X$_LT_TAGVAR(hardcode_automatic, $1)" = "Xyes" ; then
+   test yes = "$_LT_TAGVAR(hardcode_automatic, $1)"; then
 
   # We can hardcode non-existent directories.
-  if test "$_LT_TAGVAR(hardcode_direct, $1)" != no &&
+  if test no != "$_LT_TAGVAR(hardcode_direct, $1)" &&
      # If the only mechanism to avoid hardcoding is shlibpath_var, we
      # have to relink, otherwise we might link with an installed library
      # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, $1)" != no &&
-     test "$_LT_TAGVAR(hardcode_minus_L, $1)" != no; then
+     ## test no != "$_LT_TAGVAR(hardcode_shlibpath_var, $1)" &&
+     test no != "$_LT_TAGVAR(hardcode_minus_L, $1)"; then
     # Linking always hardcodes the temporary library directory.
     _LT_TAGVAR(hardcode_action, $1)=relink
   else
@@ -2115,12 +2185,12 @@ else
 fi
 AC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])
 
-if test "$_LT_TAGVAR(hardcode_action, $1)" = relink ||
-   test "$_LT_TAGVAR(inherit_rpath, $1)" = yes; then
+if test relink = "$_LT_TAGVAR(hardcode_action, $1)" ||
+   test yes = "$_LT_TAGVAR(inherit_rpath, $1)"; then
   # Fast installation is not supported
   enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
+elif test yes = "$shlibpath_overrides_runpath" ||
+     test no = "$enable_shared"; then
   # Fast installation is not necessary
   enable_fast_install=needless
 fi
@@ -2144,7 +2214,7 @@ else
 # FIXME - insert some real tests, host_os isn't really good enough
   case $host_os in
   darwin*)
-    if test -n "$STRIP" ; then
+    if test -n "$STRIP"; then
       striplib="$STRIP -x"
       old_striplib="$STRIP -S"
       AC_MSG_RESULT([yes])
@@ -2162,6 +2232,47 @@ _LT_DECL([], [striplib], [1])
 ])# _LT_CMD_STRIPLIB
 
 
+# _LT_PREPARE_MUNGE_PATH_LIST
+# ---------------------------
+# Make sure func_munge_path_list() is defined correctly.
+m4_defun([_LT_PREPARE_MUNGE_PATH_LIST],
+[[# func_munge_path_list VARIABLE PATH
+# -----------------------------------
+# VARIABLE is name of variable containing _space_ separated list of
+# directories to be munged by the contents of PATH, which is string
+# having a format:
+# "DIR[:DIR]:"
+#       string "DIR[ DIR]" will be prepended to VARIABLE
+# ":DIR[:DIR]"
+#       string "DIR[ DIR]" will be appended to VARIABLE
+# "DIRP[:DIRP]::[DIRA:]DIRA"
+#       string "DIRP[ DIRP]" will be prepended to VARIABLE and string
+#       "DIRA[ DIRA]" will be appended to VARIABLE
+# "DIR[:DIR]"
+#       VARIABLE will be replaced by "DIR[ DIR]"
+func_munge_path_list ()
+{
+    case x@S|@2 in
+    x)
+        ;;
+    *:)
+        eval @S|@1=\"`$ECHO @S|@2 | $SED 's/:/ /g'` \@S|@@S|@1\"
+        ;;
+    x:*)
+        eval @S|@1=\"\@S|@@S|@1 `$ECHO @S|@2 | $SED 's/:/ /g'`\"
+        ;;
+    *::*)
+        eval @S|@1=\"\@S|@@S|@1\ `$ECHO @S|@2 | $SED -e 's/.*:://' -e 's/:/ /g'`\"
+        eval @S|@1=\"`$ECHO @S|@2 | $SED -e 's/::.*//' -e 's/:/ /g'`\ \@S|@@S|@1\"
+        ;;
+    *)
+        eval @S|@1=\"`$ECHO @S|@2 | $SED 's/:/ /g'`\"
+        ;;
+    esac
+}
+]])# _LT_PREPARE_PATH_LIST
+
+
 # _LT_SYS_DYNAMIC_LINKER([TAG])
 # -----------------------------
 # PORTME Fill in your ld.so characteristics
@@ -2172,17 +2283,18 @@ m4_require([_LT_FILEUTILS_DEFAULTS])dnl
 m4_require([_LT_DECL_OBJDUMP])dnl
 m4_require([_LT_DECL_SED])dnl
 m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+m4_require([_LT_PREPARE_MUNGE_PATH_LIST])dnl
 AC_MSG_CHECKING([dynamic linker characteristics])
 m4_if([$1],
 	[], [
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   case $host_os in
-    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
-    *) lt_awk_arg="/^libraries:/" ;;
+    darwin*) lt_awk_arg='/^libraries:/,/LR/' ;;
+    *) lt_awk_arg='/^libraries:/' ;;
   esac
   case $host_os in
-    mingw* | cegcc*) lt_sed_strip_eq="s,=\([[A-Za-z]]:\),\1,g" ;;
-    *) lt_sed_strip_eq="s,=/,/,g" ;;
+    mingw* | cegcc*) lt_sed_strip_eq='s|=\([[A-Za-z]]:\)|\1|g' ;;
+    *) lt_sed_strip_eq='s|=/|/|g' ;;
   esac
   lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
   case $lt_search_path_spec in
@@ -2198,28 +2310,35 @@ if test "$GCC" = yes; then
     ;;
   esac
   # Ok, now we have the path, separated by spaces, we can step through it
-  # and add multilib dir if necessary.
+  # and add multilib dir if necessary...
   lt_tmp_lt_search_path_spec=
-  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  lt_multi_os_dir=/`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  # ...but if some path component already ends with the multilib dir we assume
+  # that all is fine and trust -print-search-dirs as is (GCC 4.2? or newer).
+  case "$lt_multi_os_dir; $lt_search_path_spec " in
+  "/; "* | "/.; "* | "/./; "* | *"$lt_multi_os_dir "* | *"$lt_multi_os_dir/ "*)
+    lt_multi_os_dir=
+    ;;
+  esac
   for lt_sys_path in $lt_search_path_spec; do
-    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
-      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
-    else
+    if test -d "$lt_sys_path$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path$lt_multi_os_dir"
+    elif test -n "$lt_multi_os_dir"; then
       test -d "$lt_sys_path" && \
 	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
     fi
   done
   lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
-BEGIN {RS=" "; FS="/|\n";} {
-  lt_foo="";
-  lt_count=0;
+BEGIN {RS = " "; FS = "/|\n";} {
+  lt_foo = "";
+  lt_count = 0;
   for (lt_i = NF; lt_i > 0; lt_i--) {
     if ($lt_i != "" && $lt_i != ".") {
       if ($lt_i == "..") {
         lt_count++;
       } else {
         if (lt_count == 0) {
-          lt_foo="/" $lt_i lt_foo;
+          lt_foo = "/" $lt_i lt_foo;
         } else {
           lt_count--;
         }
@@ -2233,7 +2352,7 @@ BEGIN {RS=" "; FS="/|\n";} {
   # for these hosts.
   case $host_os in
     mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
-      $SED 's,/\([[A-Za-z]]:\),\1,g'` ;;
+      $SED 's|/\([[A-Za-z]]:\)|\1|g'` ;;
   esac
   sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
 else
@@ -2242,7 +2361,7 @@ fi])
 library_names_spec=
 libname_spec='lib$name'
 soname_spec=
-shrext_cmds=".so"
+shrext_cmds=.so
 postinstall_cmds=
 postuninstall_cmds=
 finish_cmds=
@@ -2259,14 +2378,17 @@ hardcode_into_libs=no
 # flags to be left without arguments
 need_version=unknown
 
+AC_ARG_VAR([LT_SYS_LIBRARY_PATH],
+[User-defined run-time library search path.])
+
 case $host_os in
 aix3*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname.a'
   shlibpath_var=LIBPATH
 
   # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
+  soname_spec='$libname$release$shared_ext$major'
   ;;
 
 aix[[4-9]]*)
@@ -2274,41 +2396,91 @@ aix[[4-9]]*)
   need_lib_prefix=no
   need_version=no
   hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
+  if test ia64 = "$host_cpu"; then
     # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    library_names_spec='$libname$release$shared_ext$major $libname$release$shared_ext$versuffix $libname$shared_ext'
     shlibpath_var=LD_LIBRARY_PATH
   else
     # With GCC up to 2.95.x, collect2 would create an import file
     # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
+    # the line '#! .'.  This would cause the generated library to
+    # depend on '.', always an invalid library.  This was fixed in
     # development snapshots of GCC prior to 3.0.
     case $host_os in
       aix4 | aix4.[[01]] | aix4.[[01]].*)
       if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
 	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	   echo '#endif'; } | $CC -E - | $GREP yes > /dev/null; then
 	:
       else
 	can_build_shared=no
       fi
       ;;
     esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # Using Import Files as archive members, it is possible to support
+    # filename-based versioning of shared library archives on AIX. While
+    # this would work for both with and without runtime linking, it will
+    # prevent static linking of such archives. So we do filename-based
+    # shared library versioning with .so extension only, which is used
+    # when both runtime linking and shared linking is enabled.
+    # Unfortunately, runtime linking may impact performance, so we do
+    # not want this to be the default eventually. Also, we use the
+    # versioned .so libs for executables only if there is the -brtl
+    # linker flag in LDFLAGS as well, or --with-aix-soname=svr4 only.
+    # To allow for filename-based versioning support, we need to create
+    # libNAME.so.V as an archive file, containing:
+    # *) an Import File, referring to the versioned filename of the
+    #    archive as well as the shared archive member, telling the
+    #    bitwidth (32 or 64) of that shared object, and providing the
+    #    list of exported symbols of that shared object, eventually
+    #    decorated with the 'weak' keyword
+    # *) the shared object with the F_LOADONLY flag set, to really avoid
+    #    it being seen by the linker.
+    # At run time we better use the real file rather than another symlink,
+    # but for link time we create the symlink libNAME.so -> libNAME.so.V
+
+    case $with_aix_soname,$aix_use_runtimelinking in
+    # AIX (on Power*) has no versioning support, so currently we cannot hardcode correct
     # soname into executable. Probably we can add versioning support to
     # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
+    aix,yes) # traditional libtool
+      dynamic_linker='AIX unversionable lib.so'
       # If using run time linking (on AIX 4.2 or later) use lib<name>.so
       # instead of lib<name>.a to let people know that these are not
       # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+      ;;
+    aix,no) # traditional AIX only
+      dynamic_linker='AIX lib.a[(]lib.so.V[)]'
       # We preserve .a as extension for shared libraries through AIX4.2
       # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
+      library_names_spec='$libname$release.a $libname.a'
+      soname_spec='$libname$release$shared_ext$major'
+      ;;
+    svr4,*) # full svr4 only
+      dynamic_linker="AIX lib.so.V[(]$shared_archive_member_spec.o[)]"
+      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'
+      # We do not specify a path in Import Files, so LIBPATH fires.
+      shlibpath_overrides_runpath=yes
+      ;;
+    *,yes) # both, prefer svr4
+      dynamic_linker="AIX lib.so.V[(]$shared_archive_member_spec.o[)], lib.a[(]lib.so.V[)]"
+      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'
+      # unpreferred sharedlib libNAME.a needs extra handling
+      postinstall_cmds='test -n "$linkname" || linkname="$realname"~func_stripname "" ".so" "$linkname"~$install_shared_prog "$dir/$func_stripname_result.$libext" "$destdir/$func_stripname_result.$libext"~test -z "$tstripme" || test -z "$striplib" || $striplib "$destdir/$func_stripname_result.$libext"'
+      postuninstall_cmds='for n in $library_names $old_library; do :; done~func_stripname "" ".so" "$n"~test "$func_stripname_result" = "$n" || func_append rmfiles " $odir/$func_stripname_result.$libext"'
+      # We do not specify a path in Import Files, so LIBPATH fires.
+      shlibpath_overrides_runpath=yes
+      ;;
+    *,no) # both, prefer aix
+      dynamic_linker="AIX lib.a[(]lib.so.V[)], lib.so.V[(]$shared_archive_member_spec.o[)]"
+      library_names_spec='$libname$release.a $libname.a'
+      soname_spec='$libname$release$shared_ext$major'
+      # unpreferred sharedlib libNAME.so.V and symlink libNAME.so need extra handling
+      postinstall_cmds='test -z "$dlname" || $install_shared_prog $dir/$dlname $destdir/$dlname~test -z "$tstripme" || test -z "$striplib" || $striplib $destdir/$dlname~test -n "$linkname" || linkname=$realname~func_stripname "" ".a" "$linkname"~(cd "$destdir" && $LN_S -f $dlname $func_stripname_result.so)'
+      postuninstall_cmds='test -z "$dlname" || func_append rmfiles " $odir/$dlname"~for n in $old_library $library_names; do :; done~func_stripname "" ".a" "$n"~func_append rmfiles " $odir/$func_stripname_result.so"'
+      ;;
+    esac
     shlibpath_var=LIBPATH
   fi
   ;;
@@ -2318,18 +2490,18 @@ amigaos*)
   powerpc)
     # Since July 2007 AmigaOS4 officially supports .so libraries.
     # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
     ;;
   m68k)
     library_names_spec='$libname.ixlibrary $libname.a'
     # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
     ;;
   esac
   ;;
 
 beos*)
-  library_names_spec='${libname}${shared_ext}'
+  library_names_spec='$libname$shared_ext'
   dynamic_linker="$host_os ld.so"
   shlibpath_var=LIBRARY_PATH
   ;;
@@ -2337,8 +2509,8 @@ beos*)
 bsdi[[45]]*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
@@ -2350,7 +2522,7 @@ bsdi[[45]]*)
 
 cygwin* | mingw* | pw32* | cegcc*)
   version_type=windows
-  shrext_cmds=".dll"
+  shrext_cmds=.dll
   need_version=no
   need_lib_prefix=no
 
@@ -2359,8 +2531,8 @@ cygwin* | mingw* | pw32* | cegcc*)
     # gcc
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+    postinstall_cmds='base_file=`basename \$file`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; echo \$dlname'\''`~
       dldir=$destdir/`dirname \$dlpath`~
       test -d \$dldir || mkdir -p \$dldir~
       $install_prog $dir/$dlname \$dldir/$dlname~
@@ -2376,17 +2548,17 @@ cygwin* | mingw* | pw32* | cegcc*)
     case $host_os in
     cygwin*)
       # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      soname_spec='`echo $libname | sed -e 's/^lib/cyg/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'
 m4_if([$1], [],[
       sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"])
       ;;
     mingw* | cegcc*)
       # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'
       ;;
     pw32*)
       # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      library_names_spec='`echo $libname | sed -e 's/^lib/pw/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'
       ;;
     esac
     dynamic_linker='Win32 ld.exe'
@@ -2395,8 +2567,8 @@ m4_if([$1], [],[
   *,cl*)
     # Native MSVC
     libname_spec='$name'
-    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
-    library_names_spec='${libname}.dll.lib'
+    soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'
+    library_names_spec='$libname.dll.lib'
 
     case $build_os in
     mingw*)
@@ -2423,7 +2595,7 @@ m4_if([$1], [],[
       sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
       ;;
     *)
-      sys_lib_search_path_spec="$LIB"
+      sys_lib_search_path_spec=$LIB
       if $ECHO "$sys_lib_search_path_spec" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then
         # It is most probably a Windows format PATH.
         sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
@@ -2436,8 +2608,8 @@ m4_if([$1], [],[
     esac
 
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+    postinstall_cmds='base_file=`basename \$file`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; echo \$dlname'\''`~
       dldir=$destdir/`dirname \$dlpath`~
       test -d \$dldir || mkdir -p \$dldir~
       $install_prog $dir/$dlname \$dldir/$dlname'
@@ -2450,7 +2622,7 @@ m4_if([$1], [],[
 
   *)
     # Assume MSVC wrapper
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    library_names_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext $libname.lib'
     dynamic_linker='Win32 ld.exe'
     ;;
   esac
@@ -2463,8 +2635,8 @@ darwin* | rhapsody*)
   version_type=darwin
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
+  library_names_spec='$libname$release$major$shared_ext $libname$shared_ext'
+  soname_spec='$libname$release$major$shared_ext'
   shlibpath_overrides_runpath=yes
   shlibpath_var=DYLD_LIBRARY_PATH
   shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
@@ -2477,8 +2649,8 @@ dgux*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
@@ -2496,12 +2668,13 @@ freebsd* | dragonfly*)
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+      soname_spec='$libname$release$shared_ext$major'
       need_version=no
       need_lib_prefix=no
       ;;
     freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
       need_version=yes
       ;;
   esac
@@ -2531,10 +2704,10 @@ haiku*)
   need_lib_prefix=no
   need_version=no
   dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
+  shlibpath_overrides_runpath=no
   sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
   hardcode_into_libs=yes
   ;;
@@ -2552,14 +2725,15 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.so"
     shlibpath_var=LD_LIBRARY_PATH
     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
+    if test 32 = "$HPUX_IA64_MODE"; then
       sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+      sys_lib_dlsearch_path_spec=/usr/lib/hpux32
     else
       sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+      sys_lib_dlsearch_path_spec=/usr/lib/hpux64
     fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
     ;;
   hppa*64*)
     shrext_cmds='.sl'
@@ -2567,8 +2741,8 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.sl"
     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
     ;;
@@ -2577,8 +2751,8 @@ hpux9* | hpux10* | hpux11*)
     dynamic_linker="$host_os dld.sl"
     shlibpath_var=SHLIB_PATH
     shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     ;;
   esac
   # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
@@ -2591,8 +2765,8 @@ interix[[3-9]]*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
@@ -2603,7 +2777,7 @@ irix5* | irix6* | nonstopux*)
   case $host_os in
     nonstopux*) version_type=nonstopux ;;
     *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
+	if test yes = "$lt_cv_prog_gnu_ld"; then
 		version_type=linux # correct to gnu/linux during the next big refactor
 	else
 		version_type=irix
@@ -2611,8 +2785,8 @@ irix5* | irix6* | nonstopux*)
   esac
   need_lib_prefix=no
   need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='$libname$release$shared_ext$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$release$shared_ext $libname$shared_ext'
   case $host_os in
   irix5* | nonstopux*)
     libsuff= shlibsuff=
@@ -2631,8 +2805,8 @@ irix5* | irix6* | nonstopux*)
   esac
   shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
   shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  sys_lib_search_path_spec="/usr/lib$libsuff /lib$libsuff /usr/local/lib$libsuff"
+  sys_lib_dlsearch_path_spec="/usr/lib$libsuff /lib$libsuff"
   hardcode_into_libs=yes
   ;;
 
@@ -2641,13 +2815,33 @@ linux*oldld* | linux*aout* | linux*coff*)
   dynamic_linker=no
   ;;
 
+linux*android*)
+  version_type=none # Android doesn't support versioned libraries.
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='$libname$release$shared_ext'
+  soname_spec='$libname$release$shared_ext'
+  finish_cmds=
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  dynamic_linker='Android linker'
+  # Don't embed -rpath directories since the linker doesn't support them.
+  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+  ;;
+
 # This must be glibc/ELF.
 linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
@@ -2672,7 +2866,12 @@ linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
   # before this can be enabled.
   hardcode_into_libs=yes
 
-  # Append ld.so.conf contents to the search path
+  # Ideally, we could use ldconfig to report *all* directores which are
+  # searched for libraries, however this is still not possible.  Aside from not
+  # being certain /sbin/ldconfig is available, command
+  # 'ldconfig -N -X -v | grep ^/' on 64bit Fedora does not report /usr/lib64,
+  # even though it is searched at run-time.  Try to do the best guess by
+  # appending ld.so.conf contents (and includes) to the search path.
   if test -f /etc/ld.so.conf; then
     lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
     sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
@@ -2704,12 +2903,12 @@ netbsd*)
   need_lib_prefix=no
   need_version=no
   if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
     finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
     dynamic_linker='NetBSD (a.out) ld.so'
   else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
+    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+    soname_spec='$libname$release$shared_ext$major'
     dynamic_linker='NetBSD ld.elf_so'
   fi
   shlibpath_var=LD_LIBRARY_PATH
@@ -2719,7 +2918,7 @@ netbsd*)
 
 newsos6)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   ;;
@@ -2728,58 +2927,68 @@ newsos6)
   version_type=qnx
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
   hardcode_into_libs=yes
   dynamic_linker='ldqnx.so'
   ;;
 
-openbsd*)
+openbsd* | bitrig*)
   version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
+  sys_lib_dlsearch_path_spec=/usr/lib
   need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[[89]] | openbsd2.[[89]].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`"; then
+    need_version=no
   else
-    shlibpath_overrides_runpath=yes
+    need_version=yes
   fi
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
   ;;
 
 os2*)
   libname_spec='$name'
-  shrext_cmds=".dll"
+  version_type=windows
+  shrext_cmds=.dll
+  need_version=no
   need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
+  # OS/2 can only load a DLL with a base name of 8 characters or less.
+  soname_spec='`test -n "$os2dllname" && libname="$os2dllname";
+    v=$($ECHO $release$versuffix | tr -d .-);
+    n=$($ECHO $libname | cut -b -$((8 - ${#v})) | tr . _);
+    $ECHO $n$v`$shared_ext'
+  library_names_spec='${libname}_dll.$libext'
   dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
+  shlibpath_var=BEGINLIBPATH
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+  postinstall_cmds='base_file=`basename \$file`~
+    dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\$base_file'\''i; $ECHO \$dlname'\''`~
+    dldir=$destdir/`dirname \$dlpath`~
+    test -d \$dldir || mkdir -p \$dldir~
+    $install_prog $dir/$dlname \$dldir/$dlname~
+    chmod a+x \$dldir/$dlname~
+    if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+      eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+    fi'
+  postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; $ECHO \$dlname'\''`~
+    dlpath=$dir/\$dldll~
+    $RM \$dlpath'
   ;;
 
 osf3* | osf4* | osf5*)
   version_type=osf
   need_lib_prefix=no
   need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='$libname$release$shared_ext$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
   ;;
 
 rdos*)
@@ -2790,8 +2999,8 @@ solaris*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   hardcode_into_libs=yes
@@ -2801,11 +3010,11 @@ solaris*)
 
 sunos4*)
   version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'
   finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     need_lib_prefix=no
   fi
   need_version=yes
@@ -2813,8 +3022,8 @@ sunos4*)
 
 sysv4 | sysv4.3*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   case $host_vendor in
     sni)
@@ -2835,24 +3044,24 @@ sysv4 | sysv4.3*)
   ;;
 
 sysv4*MP*)
-  if test -d /usr/nec ;then
+  if test -d /usr/nec; then
     version_type=linux # correct to gnu/linux during the next big refactor
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
+    library_names_spec='$libname$shared_ext.$versuffix $libname$shared_ext.$major $libname$shared_ext'
+    soname_spec='$libname$shared_ext.$major'
     shlibpath_var=LD_LIBRARY_PATH
   fi
   ;;
 
 sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
+  version_type=sco
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=yes
   hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
   else
     sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
@@ -2870,7 +3079,7 @@ tpf*)
   version_type=linux # correct to gnu/linux during the next big refactor
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
   hardcode_into_libs=yes
@@ -2878,8 +3087,8 @@ tpf*)
 
 uts4*)
   version_type=linux # correct to gnu/linux during the next big refactor
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'
+  soname_spec='$libname$release$shared_ext$major'
   shlibpath_var=LD_LIBRARY_PATH
   ;;
 
@@ -2888,20 +3097,30 @@ uts4*)
   ;;
 esac
 AC_MSG_RESULT([$dynamic_linker])
-test "$dynamic_linker" = no && can_build_shared=no
+test no = "$dynamic_linker" && can_build_shared=no
 
 variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
 fi
 
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+if test set = "${lt_cv_sys_lib_search_path_spec+set}"; then
+  sys_lib_search_path_spec=$lt_cv_sys_lib_search_path_spec
 fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+
+if test set = "${lt_cv_sys_lib_dlsearch_path_spec+set}"; then
+  sys_lib_dlsearch_path_spec=$lt_cv_sys_lib_dlsearch_path_spec
 fi
 
+# remember unaugmented sys_lib_dlsearch_path content for libtool script decls...
+configure_time_dlsearch_path=$sys_lib_dlsearch_path_spec
+
+# ... but it needs LT_SYS_LIBRARY_PATH munging for other configure-time code
+func_munge_path_list sys_lib_dlsearch_path_spec "$LT_SYS_LIBRARY_PATH"
+
+# to be used as default LT_SYS_LIBRARY_PATH value in generated libtool
+configure_time_lt_sys_library_path=$LT_SYS_LIBRARY_PATH
+
 _LT_DECL([], [variables_saved_for_relink], [1],
     [Variables whose values should be saved in libtool wrapper scripts and
     restored at link time])
@@ -2934,39 +3153,41 @@ _LT_DECL([], [hardcode_into_libs], [0],
     [Whether we should hardcode library paths into libraries])
 _LT_DECL([], [sys_lib_search_path_spec], [2],
     [Compile-time system search path for libraries])
-_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],
-    [Run-time system search path for libraries])
+_LT_DECL([sys_lib_dlsearch_path_spec], [configure_time_dlsearch_path], [2],
+    [Detected run-time system search path for libraries])
+_LT_DECL([], [configure_time_lt_sys_library_path], [2],
+    [Explicit LT_SYS_LIBRARY_PATH set during ./configure time])
 ])# _LT_SYS_DYNAMIC_LINKER
 
 
 # _LT_PATH_TOOL_PREFIX(TOOL)
 # --------------------------
-# find a file program which can recognize shared library
+# find a file program that can recognize shared library
 AC_DEFUN([_LT_PATH_TOOL_PREFIX],
 [m4_require([_LT_DECL_EGREP])dnl
 AC_MSG_CHECKING([for $1])
 AC_CACHE_VAL(lt_cv_path_MAGIC_CMD,
 [case $MAGIC_CMD in
 [[\\/*] |  ?:[\\/]*])
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  lt_cv_path_MAGIC_CMD=$MAGIC_CMD # Let the user override the test with a path.
   ;;
 *)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  lt_save_MAGIC_CMD=$MAGIC_CMD
+  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
 dnl $ac_dummy forces splitting on constant user-supplied paths.
 dnl POSIX.2 word splitting is done only on the output of word expansions,
 dnl not every word.  This closes a longstanding sh security hole.
   ac_dummy="m4_if([$2], , $PATH, [$2])"
   for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
     test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$1; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/$1"
+    if test -f "$ac_dir/$1"; then
+      lt_cv_path_MAGIC_CMD=$ac_dir/"$1"
       if test -n "$file_magic_test_file"; then
 	case $deplibs_check_method in
 	"file_magic "*)
 	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  MAGIC_CMD=$lt_cv_path_MAGIC_CMD
 	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
 	    $EGREP "$file_magic_regex" > /dev/null; then
 	    :
@@ -2989,11 +3210,11 @@ _LT_EOF
       break
     fi
   done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  IFS=$lt_save_ifs
+  MAGIC_CMD=$lt_save_MAGIC_CMD
   ;;
 esac])
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+MAGIC_CMD=$lt_cv_path_MAGIC_CMD
 if test -n "$MAGIC_CMD"; then
   AC_MSG_RESULT($MAGIC_CMD)
 else
@@ -3011,7 +3232,7 @@ dnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])
 
 # _LT_PATH_MAGIC
 # --------------
-# find a file program which can recognize a shared library
+# find a file program that can recognize a shared library
 m4_defun([_LT_PATH_MAGIC],
 [_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)
 if test -z "$lt_cv_path_MAGIC_CMD"; then
@@ -3038,16 +3259,16 @@ m4_require([_LT_PROG_ECHO_BACKSLASH])dnl
 AC_ARG_WITH([gnu-ld],
     [AS_HELP_STRING([--with-gnu-ld],
 	[assume the C compiler uses GNU ld @<:@default=no@:>@])],
-    [test "$withval" = no || with_gnu_ld=yes],
+    [test no = "$withval" || with_gnu_ld=yes],
     [with_gnu_ld=no])dnl
 
 ac_prog=ld
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   # Check if gcc -print-prog-name=ld gives a path.
   AC_MSG_CHECKING([for ld used by $CC])
   case $host in
   *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
+    # gcc leaves a trailing carriage return, which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
     ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
@@ -3061,7 +3282,7 @@ if test "$GCC" = yes; then
       while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
 	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
       done
-      test -z "$LD" && LD="$ac_prog"
+      test -z "$LD" && LD=$ac_prog
       ;;
   "")
     # If it fails, then pretend we aren't using GCC.
@@ -3072,37 +3293,37 @@ if test "$GCC" = yes; then
     with_gnu_ld=unknown
     ;;
   esac
-elif test "$with_gnu_ld" = yes; then
+elif test yes = "$with_gnu_ld"; then
   AC_MSG_CHECKING([for GNU ld])
 else
   AC_MSG_CHECKING([for non-GNU ld])
 fi
 AC_CACHE_VAL(lt_cv_path_LD,
 [if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
   for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
     test -z "$ac_dir" && ac_dir=.
     if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
+      lt_cv_path_LD=$ac_dir/$ac_prog
       # Check to see if the program is GNU ld.  I'd rather use --version,
       # but apparently some variants of GNU ld only accept -v.
       # Break only if it was the GNU/non-GNU ld that we prefer.
       case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
       *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
+	test no != "$with_gnu_ld" && break
 	;;
       *)
-	test "$with_gnu_ld" != yes && break
+	test yes != "$with_gnu_ld" && break
 	;;
       esac
     fi
   done
-  IFS="$lt_save_ifs"
+  IFS=$lt_save_ifs
 else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+  lt_cv_path_LD=$LD # Let the user override the test with a path.
 fi])
-LD="$lt_cv_path_LD"
+LD=$lt_cv_path_LD
 if test -n "$LD"; then
   AC_MSG_RESULT($LD)
 else
@@ -3156,13 +3377,13 @@ esac
 reload_cmds='$LD$reload_flag -o $output$reload_objs'
 case $host_os in
   cygwin* | mingw* | pw32* | cegcc*)
-    if test "$GCC" != yes; then
+    if test yes != "$GCC"; then
       reload_cmds=false
     fi
     ;;
   darwin*)
-    if test "$GCC" = yes; then
-      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    if test yes = "$GCC"; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib $wl-r -o $output$reload_objs'
     else
       reload_cmds='$LD$reload_flag -o $output$reload_objs'
     fi
@@ -3173,6 +3394,43 @@ _LT_TAGDECL([], [reload_cmds], [2])dnl
 ])# _LT_CMD_RELOAD
 
 
+# _LT_PATH_DD
+# -----------
+# find a working dd
+m4_defun([_LT_PATH_DD],
+[AC_CACHE_CHECK([for a working dd], [ac_cv_path_lt_DD],
+[printf 0123456789abcdef0123456789abcdef >conftest.i
+cat conftest.i conftest.i >conftest2.i
+: ${lt_DD:=$DD}
+AC_PATH_PROGS_FEATURE_CHECK([lt_DD], [dd],
+[if "$ac_path_lt_DD" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then
+  cmp -s conftest.i conftest.out \
+  && ac_cv_path_lt_DD="$ac_path_lt_DD" ac_path_lt_DD_found=:
+fi])
+rm -f conftest.i conftest2.i conftest.out])
+])# _LT_PATH_DD
+
+
+# _LT_CMD_TRUNCATE
+# ----------------
+# find command to truncate a binary pipe
+m4_defun([_LT_CMD_TRUNCATE],
+[m4_require([_LT_PATH_DD])
+AC_CACHE_CHECK([how to truncate binary pipes], [lt_cv_truncate_bin],
+[printf 0123456789abcdef0123456789abcdef >conftest.i
+cat conftest.i conftest.i >conftest2.i
+lt_cv_truncate_bin=
+if "$ac_cv_path_lt_DD" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then
+  cmp -s conftest.i conftest.out \
+  && lt_cv_truncate_bin="$ac_cv_path_lt_DD bs=4096 count=1"
+fi
+rm -f conftest.i conftest2.i conftest.out
+test -z "$lt_cv_truncate_bin" && lt_cv_truncate_bin="$SED -e 4q"])
+_LT_DECL([lt_truncate_bin], [lt_cv_truncate_bin], [1],
+  [Command to truncate a binary pipe])
+])# _LT_CMD_TRUNCATE
+
+
 # _LT_CHECK_MAGIC_METHOD
 # ----------------------
 # how to check for library dependencies
@@ -3188,13 +3446,13 @@ lt_cv_deplibs_check_method='unknown'
 # Need to set the preceding variable on all platforms that support
 # interlibrary dependencies.
 # 'none' -- dependencies not supported.
-# `unknown' -- same as none, but documents that we really don't know.
+# 'unknown' -- same as none, but documents that we really don't know.
 # 'pass_all' -- all dependencies passed with no checks.
 # 'test_compile' -- check by making test program.
 # 'file_magic [[regex]]' -- check by looking for files in library path
-# which responds to the $file_magic_cmd with a given extended regex.
-# If you have `file' or equivalent on your system and you're not sure
-# whether `pass_all' will *always* work, you probably want this one.
+# that responds to the $file_magic_cmd with a given extended regex.
+# If you have 'file' or equivalent on your system and you're not sure
+# whether 'pass_all' will *always* work, you probably want this one.
 
 case $host_os in
 aix[[4-9]]*)
@@ -3221,8 +3479,7 @@ mingw* | pw32*)
   # Base MSYS/MinGW do not provide the 'file' command needed by
   # func_win32_libid shell function, so use a weaker test based on 'objdump',
   # unless we find 'file', for example because we are cross-compiling.
-  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
-  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+  if ( file / ) >/dev/null 2>&1; then
     lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
     lt_cv_file_magic_cmd='func_win32_libid'
   else
@@ -3318,8 +3575,8 @@ newos6*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-openbsd*)
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+openbsd* | bitrig*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`"; then
     lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|\.so|_pic\.a)$'
   else
     lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
@@ -3372,6 +3629,9 @@ sysv4 | sysv4.3*)
 tpf*)
   lt_cv_deplibs_check_method=pass_all
   ;;
+os2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 esac
 ])
 
@@ -3412,33 +3672,38 @@ AC_DEFUN([LT_PATH_NM],
 AC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,
 [if test -n "$NM"; then
   # Let the user override the test.
-  lt_cv_path_NM="$NM"
+  lt_cv_path_NM=$NM
 else
-  lt_nm_to_check="${ac_tool_prefix}nm"
+  lt_nm_to_check=${ac_tool_prefix}nm
   if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
     lt_nm_to_check="$lt_nm_to_check nm"
   fi
   for lt_tmp_nm in $lt_nm_to_check; do
-    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR
     for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       test -z "$ac_dir" && ac_dir=.
-      tmp_nm="$ac_dir/$lt_tmp_nm"
-      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+      tmp_nm=$ac_dir/$lt_tmp_nm
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext"; then
 	# Check to see if the nm accepts a BSD-compat flag.
-	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	# Adding the 'sed 1q' prevents false positives on HP-UX, which says:
 	#   nm: unknown option "B" ignored
 	# Tru64's nm complains that /dev/null is an invalid object file
-	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
-	*/dev/null* | *'Invalid file or object type'*)
+	# MSYS converts /dev/null to NUL, MinGW nm treats NUL as empty
+	case $build_os in
+	mingw*) lt_bad_file=conftest.nm/nofile ;;
+	*) lt_bad_file=/dev/null ;;
+	esac
+	case `"$tmp_nm" -B $lt_bad_file 2>&1 | sed '1q'` in
+	*$lt_bad_file* | *'Invalid file or object type'*)
 	  lt_cv_path_NM="$tmp_nm -B"
-	  break
+	  break 2
 	  ;;
 	*)
 	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
 	  */dev/null*)
 	    lt_cv_path_NM="$tmp_nm -p"
-	    break
+	    break 2
 	    ;;
 	  *)
 	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
@@ -3449,21 +3714,21 @@ else
 	esac
       fi
     done
-    IFS="$lt_save_ifs"
+    IFS=$lt_save_ifs
   done
   : ${lt_cv_path_NM=no}
 fi])
-if test "$lt_cv_path_NM" != "no"; then
-  NM="$lt_cv_path_NM"
+if test no != "$lt_cv_path_NM"; then
+  NM=$lt_cv_path_NM
 else
   # Didn't find any BSD compatible name lister, look for dumpbin.
   if test -n "$DUMPBIN"; then :
     # Let the user override the test.
   else
     AC_CHECK_TOOLS(DUMPBIN, [dumpbin "link -dump"], :)
-    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    case `$DUMPBIN -symbols -headers /dev/null 2>&1 | sed '1q'` in
     *COFF*)
-      DUMPBIN="$DUMPBIN -symbols"
+      DUMPBIN="$DUMPBIN -symbols -headers"
       ;;
     *)
       DUMPBIN=:
@@ -3471,8 +3736,8 @@ else
     esac
   fi
   AC_SUBST([DUMPBIN])
-  if test "$DUMPBIN" != ":"; then
-    NM="$DUMPBIN"
+  if test : != "$DUMPBIN"; then
+    NM=$DUMPBIN
   fi
 fi
 test -z "$NM" && NM=nm
@@ -3518,8 +3783,8 @@ lt_cv_sharedlib_from_linklib_cmd,
 
 case $host_os in
 cygwin* | mingw* | pw32* | cegcc*)
-  # two different shell functions defined in ltmain.sh
-  # decide which to use based on capabilities of $DLLTOOL
+  # two different shell functions defined in ltmain.sh;
+  # decide which one to use based on capabilities of $DLLTOOL
   case `$DLLTOOL --help 2>&1` in
   *--identify-strict*)
     lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib
@@ -3531,7 +3796,7 @@ cygwin* | mingw* | pw32* | cegcc*)
   ;;
 *)
   # fallback: assume linklib IS sharedlib
-  lt_cv_sharedlib_from_linklib_cmd="$ECHO"
+  lt_cv_sharedlib_from_linklib_cmd=$ECHO
   ;;
 esac
 ])
@@ -3558,13 +3823,28 @@ AC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool
     lt_cv_path_mainfest_tool=yes
   fi
   rm -f conftest*])
-if test "x$lt_cv_path_mainfest_tool" != xyes; then
+if test yes != "$lt_cv_path_mainfest_tool"; then
   MANIFEST_TOOL=:
 fi
 _LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl
 ])# _LT_PATH_MANIFEST_TOOL
 
 
+# _LT_DLL_DEF_P([FILE])
+# ---------------------
+# True iff FILE is a Windows DLL '.def' file.
+# Keep in sync with func_dll_def_p in the libtool script
+AC_DEFUN([_LT_DLL_DEF_P],
+[dnl
+  test DEF = "`$SED -n dnl
+    -e '\''s/^[[	 ]]*//'\'' dnl Strip leading whitespace
+    -e '\''/^\(;.*\)*$/d'\'' dnl      Delete empty lines and comments
+    -e '\''s/^\(EXPORTS\|LIBRARY\)\([[	 ]].*\)*$/DEF/p'\'' dnl
+    -e q dnl                          Only consider the first "real" line
+    $1`" dnl
+])# _LT_DLL_DEF_P
+
+
 # LT_LIB_M
 # --------
 # check for math library
@@ -3576,11 +3856,11 @@ case $host in
   # These system don't have libm, or don't need it
   ;;
 *-ncr-sysv4.3*)
-  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM="-lmw")
+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=-lmw)
   AC_CHECK_LIB(m, cos, LIBM="$LIBM -lm")
   ;;
 *)
-  AC_CHECK_LIB(m, cos, LIBM="-lm")
+  AC_CHECK_LIB(m, cos, LIBM=-lm)
   ;;
 esac
 AC_SUBST([LIBM])
@@ -3599,7 +3879,7 @@ m4_defun([_LT_COMPILER_NO_RTTI],
 
 _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
 
-if test "$GCC" = yes; then
+if test yes = "$GCC"; then
   case $cc_basename in
   nvcc*)
     _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;
@@ -3651,7 +3931,7 @@ cygwin* | mingw* | pw32* | cegcc*)
   symcode='[[ABCDGISTW]]'
   ;;
 hpux*)
-  if test "$host_cpu" = ia64; then
+  if test ia64 = "$host_cpu"; then
     symcode='[[ABCDEGRST]]'
   fi
   ;;
@@ -3684,14 +3964,44 @@ case `$NM -V 2>&1` in
   symcode='[[ABCDGIRSTW]]' ;;
 esac
 
+if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+  # Gets list of data symbols to import.
+  lt_cv_sys_global_symbol_to_import="sed -n -e 's/^I .* \(.*\)$/\1/p'"
+  # Adjust the below global symbol transforms to fixup imported variables.
+  lt_cdecl_hook=" -e 's/^I .* \(.*\)$/extern __declspec(dllimport) char \1;/p'"
+  lt_c_name_hook=" -e 's/^I .* \(.*\)$/  {\"\1\", (void *) 0},/p'"
+  lt_c_name_lib_hook="\
+  -e 's/^I .* \(lib.*\)$/  {\"\1\", (void *) 0},/p'\
+  -e 's/^I .* \(.*\)$/  {\"lib\1\", (void *) 0},/p'"
+else
+  # Disable hooks by default.
+  lt_cv_sys_global_symbol_to_import=
+  lt_cdecl_hook=
+  lt_c_name_hook=
+  lt_c_name_lib_hook=
+fi
+
 # Transform an extracted symbol line into a proper C declaration.
 # Some systems (esp. on ia64) link data and code symbols differently,
 # so use this general approach.
-lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+lt_cv_sys_global_symbol_to_cdecl="sed -n"\
+$lt_cdecl_hook\
+" -e 's/^T .* \(.*\)$/extern int \1();/p'"\
+" -e 's/^$symcode$symcode* .* \(.*\)$/extern char \1;/p'"
 
 # Transform an extracted symbol line into symbol name and symbol address
-lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([[^ ]]*\)[[ ]]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p'"
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([[^ ]]*\)[[ ]]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \(lib[[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address="sed -n"\
+$lt_c_name_hook\
+" -e 's/^: \(.*\) .*$/  {\"\1\", (void *) 0},/p'"\
+" -e 's/^$symcode$symcode* .* \(.*\)$/  {\"\1\", (void *) \&\1},/p'"
+
+# Transform an extracted symbol line into symbol name with lib prefix and
+# symbol address.
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n"\
+$lt_c_name_lib_hook\
+" -e 's/^: \(.*\) .*$/  {\"\1\", (void *) 0},/p'"\
+" -e 's/^$symcode$symcode* .* \(lib.*\)$/  {\"\1\", (void *) \&\1},/p'"\
+" -e 's/^$symcode$symcode* .* \(.*\)$/  {\"lib\1\", (void *) \&\1},/p'"
 
 # Handle CRLF in mingw tool chain
 opt_cr=
@@ -3709,21 +4019,24 @@ for ac_symprfx in "" "_"; do
 
   # Write the raw and C identifiers.
   if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-    # Fake it for dumpbin and say T for any non-static function
-    # and D for any global variable.
+    # Fake it for dumpbin and say T for any non-static function,
+    # D for any global variable and I for any imported variable.
     # Also find C++ and __fastcall symbols from MSVC++,
     # which start with @ or ?.
     lt_cv_sys_global_symbol_pipe="$AWK ['"\
 "     {last_section=section; section=\$ 3};"\
 "     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};"\
 "     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     /^ *Symbol name *: /{split(\$ 0,sn,\":\"); si=substr(sn[2],2)};"\
+"     /^ *Type *: code/{print \"T\",si,substr(si,length(prfx))};"\
+"     /^ *Type *: data/{print \"I\",si,substr(si,length(prfx))};"\
 "     \$ 0!~/External *\|/{next};"\
 "     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
 "     {if(hide[section]) next};"\
-"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
-"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
-"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
-"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     {f=\"D\"}; \$ 0~/\(\).*\|/{f=\"T\"};"\
+"     {split(\$ 0,a,/\||\r/); split(a[2],s)};"\
+"     s[1]~/^[@?]/{print f,s[1],s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print f,t[1],substr(t[1],length(prfx))}"\
 "     ' prfx=^$ac_symprfx]"
   else
     lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[[	 ]]\($symcode$symcode*\)[[	 ]][[	 ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
@@ -3763,11 +4076,11 @@ _LT_EOF
 	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
 	  cat <<_LT_EOF > conftest.$ac_ext
 /* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
-#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
-/* DATA imports from DLLs on WIN32 con't be const, because runtime
+#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE
+/* DATA imports from DLLs on WIN32 can't be const, because runtime
    relocations are performed -- see ld's documentation on pseudo-relocs.  */
 # define LT@&t@_DLSYM_CONST
-#elif defined(__osf__)
+#elif defined __osf__
 /* This system does not cope well with relocations in const data.  */
 # define LT@&t@_DLSYM_CONST
 #else
@@ -3793,7 +4106,7 @@ lt__PROGRAM__LTX_preloaded_symbols[[]] =
 {
   { "@PROGRAM@", (void *) 0 },
 _LT_EOF
-	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  $SED "s/^$symcode$symcode* .* \(.*\)$/  {\"\1\", (void *) \&\1},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
 	  cat <<\_LT_EOF >> conftest.$ac_ext
   {0, (void *) 0}
 };
@@ -3813,9 +4126,9 @@ _LT_EOF
 	  mv conftest.$ac_objext conftstm.$ac_objext
 	  lt_globsym_save_LIBS=$LIBS
 	  lt_globsym_save_CFLAGS=$CFLAGS
-	  LIBS="conftstm.$ac_objext"
+	  LIBS=conftstm.$ac_objext
 	  CFLAGS="$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)"
-	  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then
+	  if AC_TRY_EVAL(ac_link) && test -s conftest$ac_exeext; then
 	    pipe_works=yes
 	  fi
 	  LIBS=$lt_globsym_save_LIBS
@@ -3836,7 +4149,7 @@ _LT_EOF
   rm -rf conftest* conftst*
 
   # Do not use the global_symbol_pipe unless it works.
-  if test "$pipe_works" = yes; then
+  if test yes = "$pipe_works"; then
     break
   else
     lt_cv_sys_global_symbol_pipe=
@@ -3863,12 +4176,16 @@ _LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],
     [Take the output of nm and produce a listing of raw symbols and C names])
 _LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],
     [Transform the output of nm in a proper C declaration])
+_LT_DECL([global_symbol_to_import], [lt_cv_sys_global_symbol_to_import], [1],
+    [Transform the output of nm into a list of symbols to manually relocate])
 _LT_DECL([global_symbol_to_c_name_address],
     [lt_cv_sys_global_symbol_to_c_name_address], [1],
     [Transform the output of nm in a C name address pair])
 _LT_DECL([global_symbol_to_c_name_address_lib_prefix],
     [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],
     [Transform the output of nm in a C name address pair when lib prefix is needed])
+_LT_DECL([nm_interface], [lt_cv_nm_interface], [1],
+    [The name lister interface])
 _LT_DECL([], [nm_file_list_spec], [1],
     [Specify filename containing input files for $NM])
 ]) # _LT_CMD_GLOBAL_SYMBOLS
@@ -3884,17 +4201,18 @@ _LT_TAGVAR(lt_prog_compiler_static, $1)=
 
 m4_if([$1], [CXX], [
   # C++ specific cases for pic, static, wl, etc.
-  if test "$GXX" = yes; then
+  if test yes = "$GXX"; then
     _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
     _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
 
     case $host_os in
     aix*)
       # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# AIX 5 now supports IA64 processor
 	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
       fi
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
       ;;
 
     amigaos*)
@@ -3905,8 +4223,8 @@ m4_if([$1], [CXX], [
         ;;
       m68k)
             # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
+            # adding the '-m68020' flag to GCC prevents building anything better,
+            # like '-m68040'.
             _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
         ;;
       esac
@@ -3922,6 +4240,11 @@ m4_if([$1], [CXX], [
       # (--disable-auto-import) libraries
       m4_if([$1], [GCJ], [],
 	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      case $host_os in
+      os2*)
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'
+	;;
+      esac
       ;;
     darwin* | rhapsody*)
       # PIC is the default on this platform
@@ -3971,7 +4294,7 @@ m4_if([$1], [CXX], [
     case $host_os in
       aix[[4-9]]*)
 	# All AIX code is PIC.
-	if test "$host_cpu" = ia64; then
+	if test ia64 = "$host_cpu"; then
 	  # AIX 5 now supports IA64 processor
 	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
 	else
@@ -4012,14 +4335,14 @@ m4_if([$1], [CXX], [
 	case $cc_basename in
 	  CC*)
 	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
-	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
-	    if test "$host_cpu" != ia64; then
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'
+	    if test ia64 != "$host_cpu"; then
 	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
 	    fi
 	    ;;
 	  aCC*)
 	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
-	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'
 	    case $host_cpu in
 	    hppa*64*|ia64*)
 	      # +Z the default
@@ -4056,7 +4379,7 @@ m4_if([$1], [CXX], [
 	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
 	    ;;
 	  ecpc* )
-	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    # old Intel C++ for x86_64, which still supported -KPIC.
 	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
 	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
 	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
@@ -4201,17 +4524,18 @@ m4_if([$1], [CXX], [
   fi
 ],
 [
-  if test "$GCC" = yes; then
+  if test yes = "$GCC"; then
     _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
     _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
 
     case $host_os in
       aix*)
       # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# AIX 5 now supports IA64 processor
 	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
       fi
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
       ;;
 
     amigaos*)
@@ -4222,8 +4546,8 @@ m4_if([$1], [CXX], [
         ;;
       m68k)
             # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
+            # adding the '-m68020' flag to GCC prevents building anything better,
+            # like '-m68040'.
             _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
         ;;
       esac
@@ -4240,6 +4564,11 @@ m4_if([$1], [CXX], [
       # (--disable-auto-import) libraries
       m4_if([$1], [GCJ], [],
 	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      case $host_os in
+      os2*)
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'
+	;;
+      esac
       ;;
 
     darwin* | rhapsody*)
@@ -4310,7 +4639,7 @@ m4_if([$1], [CXX], [
     case $host_os in
     aix*)
       _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# AIX 5 now supports IA64 processor
 	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
       else
@@ -4318,11 +4647,30 @@ m4_if([$1], [CXX], [
       fi
       ;;
 
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      case $cc_basename in
+      nagfor*)
+        # NAG Fortran compiler
+        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+        _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+        ;;
+      esac
+      ;;
+
     mingw* | cygwin* | pw32* | os2* | cegcc*)
       # This hack is so that the source file can tell whether it is being
       # built for inclusion in a dll (and should export symbols for example).
       m4_if([$1], [GCJ], [],
 	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      case $host_os in
+      os2*)
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'
+	;;
+      esac
       ;;
 
     hpux9* | hpux10* | hpux11*)
@@ -4338,7 +4686,7 @@ m4_if([$1], [CXX], [
 	;;
       esac
       # Is there a better lt_prog_compiler_static that works with the bundled CC?
-      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'
       ;;
 
     irix5* | irix6* | nonstopux*)
@@ -4349,7 +4697,7 @@ m4_if([$1], [CXX], [
 
     linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
       case $cc_basename in
-      # old Intel for x86_64 which still supported -KPIC.
+      # old Intel for x86_64, which still supported -KPIC.
       ecc*)
 	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
 	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
@@ -4374,6 +4722,12 @@ m4_if([$1], [CXX], [
 	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
 	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
 	;;
+      tcc*)
+	# Fabrice Bellard et al's Tiny C Compiler
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	;;
       pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
         # Portland Group compilers (*not* the Pentium gcc compiler,
 	# which looks to be a dead project)
@@ -4471,7 +4825,7 @@ m4_if([$1], [CXX], [
       ;;
 
     sysv4*MP*)
-      if test -d /usr/nec ;then
+      if test -d /usr/nec; then
 	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'
 	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
       fi
@@ -4500,7 +4854,7 @@ m4_if([$1], [CXX], [
   fi
 ])
 case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
+  # For platforms that do not support PIC, -DPIC is meaningless:
   *djgpp*)
     _LT_TAGVAR(lt_prog_compiler_pic, $1)=
     ;;
@@ -4566,17 +4920,21 @@ m4_if([$1], [CXX], [
   case $host_os in
   aix[[4-9]]*)
     # If we're using GNU nm, then we don't want the "-C" option.
-    # -C means demangle to AIX nm, but means don't demangle with GNU nm
-    # Also, AIX nm treats weak defined symbols like other global defined
-    # symbols, whereas GNU nm marks them as "W".
+    # -C means demangle to GNU nm, but means don't demangle to AIX nm.
+    # Without the "-l" option, or with the "-B" option, AIX nm treats
+    # weak defined symbols like other global defined symbols, whereas
+    # GNU nm marks them as "W".
+    # While the 'weak' keyword is ignored in the Export File, we need
+    # it in the Import File for the 'aix-soname' feature, so we have
+    # to replace the "-B" option with "-P" for AIX nm.
     if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { if (\$ 2 == "W") { print \$ 3 " weak" } else { print \$ 3 } } }'\'' | sort -u > $export_symbols'
     else
-      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+      _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\''s/B\([[^B]]*\)$/P\1/'\''` -PCpgl $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) && ([substr](\$ 1,1,1) != ".")) { if ((\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) { print \$ 1 " weak" } else { print \$ 1 } } }'\'' | sort -u > $export_symbols'
     fi
     ;;
   pw32*)
-    _LT_TAGVAR(export_symbols_cmds, $1)="$ltdll_cmds"
+    _LT_TAGVAR(export_symbols_cmds, $1)=$ltdll_cmds
     ;;
   cygwin* | mingw* | cegcc*)
     case $cc_basename in
@@ -4625,9 +4983,9 @@ m4_if([$1], [CXX], [
   # included in the symbol list
   _LT_TAGVAR(include_expsyms, $1)=
   # exclude_expsyms can be an extended regexp of symbols to exclude
-  # it will be wrapped by ` (' and `)$', so one must not match beginning or
-  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
-  # as well as any symbol that contains `d'.
+  # it will be wrapped by ' (' and ')$', so one must not match beginning or
+  # end of line.  Example: 'a|bc|.*d.*' will exclude the symbols 'a' and 'bc',
+  # as well as any symbol that contains 'd'.
   _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
   # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
   # platforms (ab)use it in PIC code, but their linkers get confused if
@@ -4643,7 +5001,7 @@ dnl Note also adjust exclude_expsyms for C++ above.
     # FIXME: the MSVC++ port hasn't been tested in a loooong time
     # When not using gcc, we currently assume that we are using
     # Microsoft Visual C++.
-    if test "$GCC" != yes; then
+    if test yes != "$GCC"; then
       with_gnu_ld=no
     fi
     ;;
@@ -4651,7 +5009,7 @@ dnl Note also adjust exclude_expsyms for C++ above.
     # we just hope/assume this is gcc and not c89 (= MSVC++)
     with_gnu_ld=yes
     ;;
-  openbsd*)
+  openbsd* | bitrig*)
     with_gnu_ld=no
     ;;
   linux* | k*bsd*-gnu | gnu*)
@@ -4664,7 +5022,7 @@ dnl Note also adjust exclude_expsyms for C++ above.
   # On some targets, GNU ld is compatible enough with the native linker
   # that we're better off using the native interface for both.
   lt_use_gnu_ld_interface=no
-  if test "$with_gnu_ld" = yes; then
+  if test yes = "$with_gnu_ld"; then
     case $host_os in
       aix*)
 	# The AIX port of GNU ld has always aspired to compatibility
@@ -4686,24 +5044,24 @@ dnl Note also adjust exclude_expsyms for C++ above.
     esac
   fi
 
-  if test "$lt_use_gnu_ld_interface" = yes; then
+  if test yes = "$lt_use_gnu_ld_interface"; then
     # If archive_cmds runs LD, not CC, wlarc should be empty
-    wlarc='${wl}'
+    wlarc='$wl'
 
     # Set some defaults for GNU ld with shared library support. These
     # are reset later if shared libraries are not supported. Putting them
     # here allows them to be overridden if necessary.
     runpath_var=LD_RUN_PATH
-    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
-    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
+    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'
     # ancient GNU ld didn't support --whole-archive et. al.
     if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
-      _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'
     else
       _LT_TAGVAR(whole_archive_flag_spec, $1)=
     fi
     supports_anon_versioning=no
-    case `$LD -v 2>&1` in
+    case `$LD -v | $SED -e 's/([^)]\+)\s\+//' 2>&1` in
       *GNU\ gold*) supports_anon_versioning=yes ;;
       *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.10.*) ;; # catch versions < 2.11
       *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
@@ -4716,7 +5074,7 @@ dnl Note also adjust exclude_expsyms for C++ above.
     case $host_os in
     aix[[3-9]]*)
       # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
+      if test ia64 != "$host_cpu"; then
 	_LT_TAGVAR(ld_shlibs, $1)=no
 	cat <<_LT_EOF 1>&2
 
@@ -4735,7 +5093,7 @@ _LT_EOF
       case $host_cpu in
       powerpc)
             # see comment about AmigaOS4 .so support
-            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
             _LT_TAGVAR(archive_expsym_cmds, $1)=''
         ;;
       m68k)
@@ -4751,7 +5109,7 @@ _LT_EOF
 	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
 	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
 	# support --undefined.  This deserves some investigation.  FIXME
-	_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
       else
 	_LT_TAGVAR(ld_shlibs, $1)=no
       fi
@@ -4761,7 +5119,7 @@ _LT_EOF
       # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
       # as there is no search path for DLLs.
       _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
-      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'
       _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
       _LT_TAGVAR(always_export_symbols, $1)=no
       _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
@@ -4769,61 +5127,89 @@ _LT_EOF
       _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']
 
       if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	# If the export-symbols file already is a .def file (1st line
-	# is EXPORTS), use it as is; otherwise, prepend...
-	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	  cp $export_symbols $output_objdir/$soname.def;
-	else
-	  echo EXPORTS > $output_objdir/$soname.def;
-	  cat $export_symbols >> $output_objdir/$soname.def;
-	fi~
-	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file, use it as
+	# is; otherwise, prepend EXPORTS...
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then
+          cp $export_symbols $output_objdir/$soname.def;
+        else
+          echo EXPORTS > $output_objdir/$soname.def;
+          cat $export_symbols >> $output_objdir/$soname.def;
+        fi~
+        $CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
       else
 	_LT_TAGVAR(ld_shlibs, $1)=no
       fi
       ;;
 
     haiku*)
-      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
       _LT_TAGVAR(link_all_deplibs, $1)=yes
       ;;
 
+    os2*)
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      shrext_cmds=.dll
+      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	emxexp $libobjs | $SED /"_DLL_InitTerm"/d >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	prefix_cmds="$SED"~
+	if test EXPORTS = "`$SED 1q $export_symbols`"; then
+	  prefix_cmds="$prefix_cmds -e 1d";
+	fi~
+	prefix_cmds="$prefix_cmds -e \"s/^\(.*\)$/_\1/g\""~
+	cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      ;;
+
     interix[[3-9]]*)
       _LT_TAGVAR(hardcode_direct, $1)=no
       _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
-      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
-      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
       # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
       # Instead, shared libraries are loaded at an image base (0x10000000 by
       # default) and relocated if they conflict, which is a slow very memory
       # consuming and fragmenting process.  To avoid this, we pick a random,
       # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
       # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s|^|_|" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
       ;;
 
     gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
       tmp_diet=no
-      if test "$host_os" = linux-dietlibc; then
+      if test linux-dietlibc = "$host_os"; then
 	case $cc_basename in
 	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
 	esac
       fi
       if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
-	 && test "$tmp_diet" = no
+	 && test no = "$tmp_diet"
       then
 	tmp_addflag=' $pic_flag'
 	tmp_sharedflag='-shared'
 	case $cc_basename,$host_cpu in
         pgcc*)				# Portland Group C compiler
-	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  tmp_addflag=' $pic_flag'
 	  ;;
 	pgf77* | pgf90* | pgf95* | pgfortran*)
 					# Portland Group f77 and f90 compilers
-	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  tmp_addflag=' $pic_flag -Mnomain' ;;
 	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
 	  tmp_addflag=' -i_dynamic' ;;
@@ -4834,42 +5220,47 @@ _LT_EOF
 	lf95*)				# Lahey Fortran 8.1
 	  _LT_TAGVAR(whole_archive_flag_spec, $1)=
 	  tmp_sharedflag='--shared' ;;
+        nagfor*)                        # NAGFOR 5.3
+          tmp_sharedflag='-Wl,-shared' ;;
 	xl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)
 	  tmp_sharedflag='-qmkshrobj'
 	  tmp_addflag= ;;
 	nvcc*)	# Cuda Compiler Driver 2.2
-	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  _LT_TAGVAR(compiler_needs_object, $1)=yes
 	  ;;
 	esac
 	case `$CC -V 2>&1 | sed 5q` in
 	*Sun\ C*)			# Sun C 5.9
-	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	  _LT_TAGVAR(compiler_needs_object, $1)=yes
 	  tmp_sharedflag='-G' ;;
 	*Sun\ F*)			# Sun Fortran 8.3
 	  tmp_sharedflag='-G' ;;
 	esac
-	_LT_TAGVAR(archive_cmds, $1)='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
 
-        if test "x$supports_anon_versioning" = xyes; then
+        if test yes = "$supports_anon_versioning"; then
           _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
-	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	    echo "local: *; };" >> $output_objdir/$libname.ver~
-	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+            cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+            echo "local: *; };" >> $output_objdir/$libname.ver~
+            $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'
         fi
 
 	case $cc_basename in
+	tcc*)
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='-rdynamic'
+	  ;;
 	xlf* | bgf* | bgxlf* | mpixlf*)
 	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
 	  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'
-	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
 	  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
-	  if test "x$supports_anon_versioning" = xyes; then
+	  if test yes = "$supports_anon_versioning"; then
 	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
-	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	      echo "local: *; };" >> $output_objdir/$libname.ver~
-	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+              cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+              echo "local: *; };" >> $output_objdir/$libname.ver~
+              $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
 	  fi
 	  ;;
 	esac
@@ -4883,8 +5274,8 @@ _LT_EOF
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
       else
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
       fi
       ;;
 
@@ -4902,8 +5293,8 @@ _LT_EOF
 
 _LT_EOF
       elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
       else
 	_LT_TAGVAR(ld_shlibs, $1)=no
       fi
@@ -4915,7 +5306,7 @@ _LT_EOF
 	_LT_TAGVAR(ld_shlibs, $1)=no
 	cat <<_LT_EOF 1>&2
 
-*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 cannot
 *** reliably create shared libraries on SCO systems.  Therefore, libtool
 *** is disabling shared libraries support.  We urge you to upgrade GNU
 *** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
@@ -4930,9 +5321,9 @@ _LT_EOF
 	  # DT_RUNPATH tag from executables and libraries.  But doing so
 	  # requires that you compile everything twice, which is a pain.
 	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 	  else
 	    _LT_TAGVAR(ld_shlibs, $1)=no
 	  fi
@@ -4949,15 +5340,15 @@ _LT_EOF
 
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
       else
 	_LT_TAGVAR(ld_shlibs, $1)=no
       fi
       ;;
     esac
 
-    if test "$_LT_TAGVAR(ld_shlibs, $1)" = no; then
+    if test no = "$_LT_TAGVAR(ld_shlibs, $1)"; then
       runpath_var=
       _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
       _LT_TAGVAR(export_dynamic_flag_spec, $1)=
@@ -4973,7 +5364,7 @@ _LT_EOF
       # Note: this linker hardcodes the directories in LIBPATH if there
       # are no directories specified by -L.
       _LT_TAGVAR(hardcode_minus_L, $1)=yes
-      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+      if test yes = "$GCC" && test -z "$lt_prog_compiler_static"; then
 	# Neither direct hardcoding nor static linking is supported with a
 	# broken collect2.
 	_LT_TAGVAR(hardcode_direct, $1)=unsupported
@@ -4981,34 +5372,57 @@ _LT_EOF
       ;;
 
     aix[[4-9]]*)
-      if test "$host_cpu" = ia64; then
+      if test ia64 = "$host_cpu"; then
 	# On IA64, the linker does run time linking by default, so we don't
 	# have to do anything special.
 	aix_use_runtimelinking=no
 	exp_sym_flag='-Bexport'
-	no_entry_flag=""
+	no_entry_flag=
       else
 	# If we're using GNU nm, then we don't want the "-C" option.
-	# -C means demangle to AIX nm, but means don't demangle with GNU nm
-	# Also, AIX nm treats weak defined symbols like other global
-	# defined symbols, whereas GNU nm marks them as "W".
+	# -C means demangle to GNU nm, but means don't demangle to AIX nm.
+	# Without the "-l" option, or with the "-B" option, AIX nm treats
+	# weak defined symbols like other global defined symbols, whereas
+	# GNU nm marks them as "W".
+	# While the 'weak' keyword is ignored in the Export File, we need
+	# it in the Import File for the 'aix-soname' feature, so we have
+	# to replace the "-B" option with "-P" for AIX nm.
 	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { if (\$ 2 == "W") { print \$ 3 " weak" } else { print \$ 3 } } }'\'' | sort -u > $export_symbols'
 	else
-	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	  _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\''s/B\([[^B]]*\)$/P\1/'\''` -PCpgl $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) && ([substr](\$ 1,1,1) != ".")) { if ((\$ 2 == "W") || (\$ 2 == "V") || (\$ 2 == "Z")) { print \$ 1 " weak" } else { print \$ 1 } } }'\'' | sort -u > $export_symbols'
 	fi
 	aix_use_runtimelinking=no
 
 	# Test if we are trying to use run time linking or normal
 	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
-	# need to do runtime linking.
+	# have runtime linking enabled, and use it for executables.
+	# For shared libraries, we enable/disable runtime linking
+	# depending on the kind of the shared library created -
+	# when "with_aix_soname,aix_use_runtimelinking" is:
+	# "aix,no"   lib.a(lib.so.V) shared, rtl:no,  for executables
+	# "aix,yes"  lib.so          shared, rtl:yes, for executables
+	#            lib.a           static archive
+	# "both,no"  lib.so.V(shr.o) shared, rtl:yes
+	#            lib.a(lib.so.V) shared, rtl:no,  for executables
+	# "both,yes" lib.so.V(shr.o) shared, rtl:yes, for executables
+	#            lib.a(lib.so.V) shared, rtl:no
+	# "svr4,*"   lib.so.V(shr.o) shared, rtl:yes, for executables
+	#            lib.a           static archive
 	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
 	  for ld_flag in $LDFLAGS; do
-	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	  if (test x-brtl = "x$ld_flag" || test x-Wl,-brtl = "x$ld_flag"); then
 	    aix_use_runtimelinking=yes
 	    break
 	  fi
 	  done
+	  if test svr4,no = "$with_aix_soname,$aix_use_runtimelinking"; then
+	    # With aix-soname=svr4, we create the lib.so.V shared archives only,
+	    # so we don't have lib.a shared libs to link our executables.
+	    # We have to force runtime linking in this case.
+	    aix_use_runtimelinking=yes
+	    LDFLAGS="$LDFLAGS -Wl,-brtl"
+	  fi
 	  ;;
 	esac
 
@@ -5027,13 +5441,21 @@ _LT_EOF
       _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
       _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
       _LT_TAGVAR(link_all_deplibs, $1)=yes
-      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+      _LT_TAGVAR(file_list_spec, $1)='$wl-f,'
+      case $with_aix_soname,$aix_use_runtimelinking in
+      aix,*) ;; # traditional, no import file
+      svr4,* | *,yes) # use import file
+	# The Import File defines what to hardcode.
+	_LT_TAGVAR(hardcode_direct, $1)=no
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+	;;
+      esac
 
-      if test "$GCC" = yes; then
+      if test yes = "$GCC"; then
 	case $host_os in aix4.[[012]]|aix4.[[012]].*)
 	# We only want to do this on AIX 4.2 and lower, the check
 	# below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
+	  collect2name=`$CC -print-prog-name=collect2`
 	  if test -f "$collect2name" &&
 	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
 	  then
@@ -5052,62 +5474,80 @@ _LT_EOF
 	  ;;
 	esac
 	shared_flag='-shared'
-	if test "$aix_use_runtimelinking" = yes; then
-	  shared_flag="$shared_flag "'${wl}-G'
+	if test yes = "$aix_use_runtimelinking"; then
+	  shared_flag="$shared_flag "'$wl-G'
 	fi
-	_LT_TAGVAR(link_all_deplibs, $1)=no
+	# Need to ensure runtime linking is disabled for the traditional
+	# shared library, or the linker may eventually find shared libraries
+	# /with/ Import File - we do not want to mix them.
+	shared_flag_aix='-shared'
+	shared_flag_svr4='-shared $wl-G'
       else
 	# not using gcc
-	if test "$host_cpu" = ia64; then
+	if test ia64 = "$host_cpu"; then
 	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
 	# chokes on -Wl,-G. The following line is correct:
 	  shared_flag='-G'
 	else
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag='${wl}-G'
+	  if test yes = "$aix_use_runtimelinking"; then
+	    shared_flag='$wl-G'
 	  else
-	    shared_flag='${wl}-bM:SRE'
+	    shared_flag='$wl-bM:SRE'
 	  fi
+	  shared_flag_aix='$wl-bM:SRE'
+	  shared_flag_svr4='$wl-G'
 	fi
       fi
 
-      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'
       # It seems that -bexpall does not export symbols beginning with
       # underscore (_), so it is better to generate a list of symbols to export.
       _LT_TAGVAR(always_export_symbols, $1)=yes
-      if test "$aix_use_runtimelinking" = yes; then
+      if test aix,yes = "$with_aix_soname,$aix_use_runtimelinking"; then
 	# Warning - without using the other runtime loading flags (-brtl),
 	# -berok will link without error, but may produce a broken library.
 	_LT_TAGVAR(allow_undefined_flag, $1)='-berok'
         # Determine the default libpath from the value encoded in an
         # empty executable.
         _LT_SYS_MODULE_PATH_AIX([$1])
-        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
-        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'"$aix_libpath"
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n "$allow_undefined_flag"; then func_echo_all "$wl$allow_undefined_flag"; else :; fi` $wl'$exp_sym_flag:\$export_symbols' '$shared_flag
       else
-	if test "$host_cpu" = ia64; then
-	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	if test ia64 = "$host_cpu"; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'
 	  _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
-	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\$wl$no_entry_flag"' $compiler_flags $wl$allow_undefined_flag '"\$wl$exp_sym_flag:\$export_symbols"
 	else
 	 # Determine the default libpath from the value encoded in an
 	 # empty executable.
 	 _LT_SYS_MODULE_PATH_AIX([$1])
-	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'"$aix_libpath"
 	  # Warning - without using the other run time loading flags,
 	  # -berok will link without error, but may produce a broken library.
-	  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
-	  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
-	  if test "$with_gnu_ld" = yes; then
+	  _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'
+	  if test yes = "$with_gnu_ld"; then
 	    # We only use this code for GNU lds that support --whole-archive.
-	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'
 	  else
 	    # Exported symbols can be pulled into shared objects from archives
 	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
 	  fi
 	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
-	  # This is similar to how AIX traditionally builds its shared libraries.
-	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'
+	  # -brtl affects multiple linker settings, -berok does not and is overridden later
+	  compiler_flags_filtered='`func_echo_all "$compiler_flags " | $SED -e "s%-brtl\\([[, ]]\\)%-berok\\1%g"`'
+	  if test svr4 != "$with_aix_soname"; then
+	    # This is similar to how AIX traditionally builds its shared libraries.
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'
+	  fi
+	  if test aix != "$with_aix_soname"; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all "#! $soname($shared_archive_member_spec.o)"; if test shr_64 = "$shared_archive_member_spec"; then func_echo_all "# 64"; else func_echo_all "# 32"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'
+	  else
+	    # used by -dlpreopen to get the symbols
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'
+	  fi
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$RM -r $output_objdir/$realname.d'
 	fi
       fi
       ;;
@@ -5116,7 +5556,7 @@ _LT_EOF
       case $host_cpu in
       powerpc)
             # see comment about AmigaOS4 .so support
-            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
             _LT_TAGVAR(archive_expsym_cmds, $1)=''
         ;;
       m68k)
@@ -5146,16 +5586,17 @@ _LT_EOF
 	# Tell ltmain to make .lib files, not .a files.
 	libext=lib
 	# Tell ltmain to make .dll files, not .so files.
-	shrext_cmds=".dll"
+	shrext_cmds=.dll
 	# FIXME: Setting linknames here is a bad hack.
-	_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
-	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
-	  else
-	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
-	  fi~
-	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
-	  linknames='
+	_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~linknames='
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then
+            cp "$export_symbols" "$output_objdir/$soname.def";
+            echo "$tool_output_objdir$soname.def" > "$output_objdir/$soname.exp";
+          else
+            $SED -e '\''s/^/-link -EXPORT:/'\'' < $export_symbols > $output_objdir/$soname.exp;
+          fi~
+          $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+          linknames='
 	# The linker will not automatically build a static lib if we build a DLL.
 	# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
 	_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
@@ -5164,18 +5605,18 @@ _LT_EOF
 	# Don't use ranlib
 	_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'
 	_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile="@OUTPUT@"~
-	  lt_tool_outputfile="@TOOL_OUTPUT@"~
-	  case $lt_outputfile in
-	    *.exe|*.EXE) ;;
-	    *)
-	      lt_outputfile="$lt_outputfile.exe"
-	      lt_tool_outputfile="$lt_tool_outputfile.exe"
-	      ;;
-	  esac~
-	  if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
-	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
-	    $RM "$lt_outputfile.manifest";
-	  fi'
+          lt_tool_outputfile="@TOOL_OUTPUT@"~
+          case $lt_outputfile in
+            *.exe|*.EXE) ;;
+            *)
+              lt_outputfile=$lt_outputfile.exe
+              lt_tool_outputfile=$lt_tool_outputfile.exe
+              ;;
+          esac~
+          if test : != "$MANIFEST_TOOL" && test -f "$lt_outputfile.manifest"; then
+            $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+            $RM "$lt_outputfile.manifest";
+          fi'
 	;;
       *)
 	# Assume MSVC wrapper
@@ -5184,7 +5625,7 @@ _LT_EOF
 	# Tell ltmain to make .lib files, not .a files.
 	libext=lib
 	# Tell ltmain to make .dll files, not .so files.
-	shrext_cmds=".dll"
+	shrext_cmds=.dll
 	# FIXME: Setting linknames here is a bad hack.
 	_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
 	# The linker will automatically build a .lib file if we build a DLL.
@@ -5234,33 +5675,33 @@ _LT_EOF
       ;;
 
     hpux9*)
-      if test "$GCC" = yes; then
-	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      if test yes = "$GCC"; then
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
       else
-	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
       fi
-      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'
       _LT_TAGVAR(hardcode_libdir_separator, $1)=:
       _LT_TAGVAR(hardcode_direct, $1)=yes
 
       # hardcode_minus_L: Not really in the search PATH,
       # but as the default location of the library.
       _LT_TAGVAR(hardcode_minus_L, $1)=yes
-      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
       ;;
 
     hpux10*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes,no = "$GCC,$with_gnu_ld"; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
       else
 	_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
       fi
-      if test "$with_gnu_ld" = no; then
-	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      if test no = "$with_gnu_ld"; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'
 	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
 	_LT_TAGVAR(hardcode_direct, $1)=yes
 	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
-	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
 	# hardcode_minus_L: Not really in the search PATH,
 	# but as the default location of the library.
 	_LT_TAGVAR(hardcode_minus_L, $1)=yes
@@ -5268,25 +5709,25 @@ _LT_EOF
       ;;
 
     hpux11*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+      if test yes,no = "$GCC,$with_gnu_ld"; then
 	case $host_cpu in
 	hppa*64*)
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	ia64*)
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	*)
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	esac
       else
 	case $host_cpu in
 	hppa*64*)
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	ia64*)
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	*)
 	m4_if($1, [], [
@@ -5294,14 +5735,14 @@ _LT_EOF
 	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
 	  _LT_LINKER_OPTION([if $CC understands -b],
 	    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],
-	    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],
+	    [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],
 	    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],
-	  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])
+	  [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])
 	  ;;
 	esac
       fi
-      if test "$with_gnu_ld" = no; then
-	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      if test no = "$with_gnu_ld"; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'
 	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
 
 	case $host_cpu in
@@ -5312,7 +5753,7 @@ _LT_EOF
 	*)
 	  _LT_TAGVAR(hardcode_direct, $1)=yes
 	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
-	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
 
 	  # hardcode_minus_L: Not really in the search PATH,
 	  # but as the default location of the library.
@@ -5323,16 +5764,16 @@ _LT_EOF
       ;;
 
     irix5* | irix6* | nonstopux*)
-      if test "$GCC" = yes; then
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      if test yes = "$GCC"; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 	# Try to use the -exported_symbol ld option, if it does not
 	# work, assume that -exports_file does not work either and
 	# implicitly export all symbols.
 	# This should be the same for all languages, so no per-tag cache variable.
 	AC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],
 	  [lt_cv_irix_exported_symbol],
-	  [save_LDFLAGS="$LDFLAGS"
-	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+	  [save_LDFLAGS=$LDFLAGS
+	   LDFLAGS="$LDFLAGS -shared $wl-exported_symbol ${wl}foo $wl-update_registry $wl/dev/null"
 	   AC_LINK_IFELSE(
 	     [AC_LANG_SOURCE(
 	        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],
@@ -5345,21 +5786,32 @@ _LT_EOF
       end]])])],
 	      [lt_cv_irix_exported_symbol=yes],
 	      [lt_cv_irix_exported_symbol=no])
-           LDFLAGS="$save_LDFLAGS"])
-	if test "$lt_cv_irix_exported_symbol" = yes; then
-          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+           LDFLAGS=$save_LDFLAGS])
+	if test yes = "$lt_cv_irix_exported_symbol"; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations $wl-exports_file $wl$export_symbols -o $lib'
 	fi
+	_LT_TAGVAR(link_all_deplibs, $1)=no
       else
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -exports_file $export_symbols -o $lib'
       fi
       _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
-      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
       _LT_TAGVAR(hardcode_libdir_separator, $1)=:
       _LT_TAGVAR(inherit_rpath, $1)=yes
       _LT_TAGVAR(link_all_deplibs, $1)=yes
       ;;
 
+    linux*)
+      case $cc_basename in
+      tcc*)
+	# Fabrice Bellard et al's Tiny C Compiler
+	_LT_TAGVAR(ld_shlibs, $1)=yes
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	;;
+      esac
+      ;;
+
     netbsd* | netbsdelf*-gnu)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
@@ -5374,7 +5826,7 @@ _LT_EOF
     newsos6)
       _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
       _LT_TAGVAR(hardcode_direct, $1)=yes
-      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
       _LT_TAGVAR(hardcode_libdir_separator, $1)=:
       _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
       ;;
@@ -5382,27 +5834,19 @@ _LT_EOF
     *nto* | *qnx*)
       ;;
 
-    openbsd*)
+    openbsd* | bitrig*)
       if test -f /usr/libexec/ld.so; then
 	_LT_TAGVAR(hardcode_direct, $1)=yes
 	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
 	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
-	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`"; then
 	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
-	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
-	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags $wl-retain-symbols-file,$export_symbols'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
 	else
-	  case $host_os in
-	   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)
-	     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
-	     ;;
-	   *)
-	     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
-	     ;;
-	  esac
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
 	fi
       else
 	_LT_TAGVAR(ld_shlibs, $1)=no
@@ -5413,33 +5857,53 @@ _LT_EOF
       _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
       _LT_TAGVAR(hardcode_minus_L, $1)=yes
       _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
-      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
-      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      shrext_cmds=.dll
+      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	emxexp $libobjs | $SED /"_DLL_InitTerm"/d >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	$ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	$ECHO EXPORTS >> $output_objdir/$libname.def~
+	prefix_cmds="$SED"~
+	if test EXPORTS = "`$SED 1q $export_symbols`"; then
+	  prefix_cmds="$prefix_cmds -e 1d";
+	fi~
+	prefix_cmds="$prefix_cmds -e \"s/^\(.*\)$/_\1/g\""~
+	cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~
+	$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	emximp -o $lib $output_objdir/$libname.def'
+      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
       ;;
 
     osf3*)
-      if test "$GCC" = yes; then
-	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      if test yes = "$GCC"; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
       else
 	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
       fi
       _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
-      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
       _LT_TAGVAR(hardcode_libdir_separator, $1)=:
       ;;
 
     osf4* | osf5*)	# as osf3* with the addition of -msym flag
-      if test "$GCC" = yes; then
-	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      if test yes = "$GCC"; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $pic_flag $libobjs $deplibs $compiler_flags $wl-msym $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
       else
 	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
 	_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
-	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+          $CC -shared$allow_undefined_flag $wl-input $wl$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib~$RM $lib.exp'
 
 	# Both c and cxx compiler support -rpath directly
 	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
@@ -5450,24 +5914,24 @@ _LT_EOF
 
     solaris*)
       _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'
-      if test "$GCC" = yes; then
-	wlarc='${wl}'
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes = "$GCC"; then
+	wlarc='$wl'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl-z ${wl}text $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'
 	_LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+          $CC -shared $pic_flag $wl-z ${wl}text $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
       else
 	case `$CC -V 2>&1` in
 	*"Compilers 5.0"*)
 	  wlarc=''
-	  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $linker_flags'
 	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+            $LD -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
 	  ;;
 	*)
-	  wlarc='${wl}'
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  wlarc='$wl'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $compiler_flags'
 	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+            $CC -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
 	  ;;
 	esac
       fi
@@ -5477,11 +5941,11 @@ _LT_EOF
       solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
       *)
 	# The compiler driver will combine and reorder linker options,
-	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but understands '-z linker_flag'.  GCC discards it without '$wl',
 	# but is careful enough not to reorder.
 	# Supported since Solaris 2.6 (maybe 2.5.1?)
-	if test "$GCC" = yes; then
-	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	if test yes = "$GCC"; then
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'
 	else
 	  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
 	fi
@@ -5491,10 +5955,10 @@ _LT_EOF
       ;;
 
     sunos4*)
-      if test "x$host_vendor" = xsequent; then
+      if test sequent = "$host_vendor"; then
 	# Use $CC to link under sequent, because it throws in some extra .o
 	# files that make .init and .fini sections work.
-	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h $soname -o $lib $libobjs $deplibs $compiler_flags'
       else
 	_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
       fi
@@ -5543,43 +6007,43 @@ _LT_EOF
       ;;
 
     sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
-      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'
       _LT_TAGVAR(archive_cmds_need_lc, $1)=no
       _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
       runpath_var='LD_RUN_PATH'
 
-      if test "$GCC" = yes; then
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes = "$GCC"; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       else
-	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       fi
       ;;
 
     sysv5* | sco3.2v5* | sco5v6*)
-      # Note: We can NOT use -z defs as we might desire, because we do not
+      # Note: We CANNOT use -z defs as we might desire, because we do not
       # link with -lc, and that would cause any symbols used from libc to
       # always be unresolved, which means just about no library would
       # ever link correctly.  If we're not using GNU ld we use -z text
       # though, which does catch some bad symbols but isn't as heavy-handed
       # as -z defs.
-      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
-      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'
+      _LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'
       _LT_TAGVAR(archive_cmds_need_lc, $1)=no
       _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
-      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'
       _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
       _LT_TAGVAR(link_all_deplibs, $1)=yes
-      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'
       runpath_var='LD_RUN_PATH'
 
-      if test "$GCC" = yes; then
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      if test yes = "$GCC"; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       else
-	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
       fi
       ;;
 
@@ -5594,17 +6058,17 @@ _LT_EOF
       ;;
     esac
 
-    if test x$host_vendor = xsni; then
+    if test sni = "$host_vendor"; then
       case $host in
       sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Blargedynsym'
 	;;
       esac
     fi
   fi
 ])
 AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
-test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+test no = "$_LT_TAGVAR(ld_shlibs, $1)" && can_build_shared=no
 
 _LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld
 
@@ -5621,7 +6085,7 @@ x|xyes)
   # Assume -lc should be added
   _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
 
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
+  if test yes,yes = "$GCC,$enable_shared"; then
     case $_LT_TAGVAR(archive_cmds, $1) in
     *'~'*)
       # FIXME: we may have to deal with multi-command sequences.
@@ -5701,12 +6165,12 @@ _LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],
 _LT_TAGDECL([], [hardcode_libdir_separator], [1],
     [Whether we need a single "-rpath" flag with a separated argument])
 _LT_TAGDECL([], [hardcode_direct], [0],
-    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    [Set to "yes" if using DIR/libNAME$shared_ext during linking hardcodes
     DIR into the resulting binary])
 _LT_TAGDECL([], [hardcode_direct_absolute], [0],
-    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    [Set to "yes" if using DIR/libNAME$shared_ext during linking hardcodes
     DIR into the resulting binary and the resulting library dependency is
-    "absolute", i.e impossible to change by setting ${shlibpath_var} if the
+    "absolute", i.e impossible to change by setting $shlibpath_var if the
     library is relocated])
 _LT_TAGDECL([], [hardcode_minus_L], [0],
     [Set to "yes" if using the -LDIR flag during linking hardcodes DIR
@@ -5747,10 +6211,10 @@ dnl    [Compiler flag to generate thread safe objects])
 # ------------------------
 # Ensure that the configuration variables for a C compiler are suitably
 # defined.  These variables are subsequently used by _LT_CONFIG to write
-# the compiler configuration to `libtool'.
+# the compiler configuration to 'libtool'.
 m4_defun([_LT_LANG_C_CONFIG],
 [m4_require([_LT_DECL_EGREP])dnl
-lt_save_CC="$CC"
+lt_save_CC=$CC
 AC_LANG_PUSH(C)
 
 # Source file extension for C test sources.
@@ -5790,18 +6254,18 @@ if test -n "$compiler"; then
   LT_SYS_DLOPEN_SELF
   _LT_CMD_STRIPLIB
 
-  # Report which library types will actually be built
+  # Report what library types will actually be built
   AC_MSG_CHECKING([if libtool supports shared libraries])
   AC_MSG_RESULT([$can_build_shared])
 
   AC_MSG_CHECKING([whether to build shared libraries])
-  test "$can_build_shared" = "no" && enable_shared=no
+  test no = "$can_build_shared" && enable_shared=no
 
   # On AIX, shared libraries and static libraries use the same namespace, and
   # are all built from PIC.
   case $host_os in
   aix3*)
-    test "$enable_shared" = yes && enable_static=no
+    test yes = "$enable_shared" && enable_static=no
     if test -n "$RANLIB"; then
       archive_cmds="$archive_cmds~\$RANLIB \$lib"
       postinstall_cmds='$RANLIB $lib'
@@ -5809,8 +6273,12 @@ if test -n "$compiler"; then
     ;;
 
   aix[[4-9]]*)
-    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-      test "$enable_shared" = yes && enable_static=no
+    if test ia64 != "$host_cpu"; then
+      case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in
+      yes,aix,yes) ;;			# shared object as lib.so file only
+      yes,svr4,*) ;;			# shared object as lib.so archive member only
+      yes,*) enable_static=no ;;	# shared object in lib.a archive as well
+      esac
     fi
     ;;
   esac
@@ -5818,13 +6286,13 @@ if test -n "$compiler"; then
 
   AC_MSG_CHECKING([whether to build static libraries])
   # Make sure either enable_shared or enable_static is yes.
-  test "$enable_shared" = yes || enable_static=yes
+  test yes = "$enable_shared" || enable_static=yes
   AC_MSG_RESULT([$enable_static])
 
   _LT_CONFIG($1)
 fi
 AC_LANG_POP
-CC="$lt_save_CC"
+CC=$lt_save_CC
 ])# _LT_LANG_C_CONFIG
 
 
@@ -5832,14 +6300,14 @@ CC="$lt_save_CC"
 # --------------------------
 # Ensure that the configuration variables for a C++ compiler are suitably
 # defined.  These variables are subsequently used by _LT_CONFIG to write
-# the compiler configuration to `libtool'.
+# the compiler configuration to 'libtool'.
 m4_defun([_LT_LANG_CXX_CONFIG],
 [m4_require([_LT_FILEUTILS_DEFAULTS])dnl
 m4_require([_LT_DECL_EGREP])dnl
 m4_require([_LT_PATH_MANIFEST_TOOL])dnl
-if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
-    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
-    (test "X$CXX" != "Xg++"))) ; then
+if test -n "$CXX" && ( test no != "$CXX" &&
+    ( (test g++ = "$CXX" && `g++ -v >/dev/null 2>&1` ) ||
+    (test g++ != "$CXX"))); then
   AC_PROG_CXXCPP
 else
   _lt_caught_CXX_error=yes
@@ -5881,7 +6349,7 @@ _LT_TAGVAR(objext, $1)=$objext
 # the CXX compiler isn't working.  Some variables (like enable_shared)
 # are currently assumed to apply to all compilers on this platform,
 # and will be corrupted by setting them based on a non-working compiler.
-if test "$_lt_caught_CXX_error" != yes; then
+if test yes != "$_lt_caught_CXX_error"; then
   # Code to be used in simple compile tests
   lt_simple_compile_test_code="int some_variable = 0;"
 
@@ -5923,35 +6391,35 @@ if test "$_lt_caught_CXX_error" != yes; then
   if test -n "$compiler"; then
     # We don't want -fno-exception when compiling C++ code, so set the
     # no_builtin_flag separately
-    if test "$GXX" = yes; then
+    if test yes = "$GXX"; then
       _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
     else
       _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
     fi
 
-    if test "$GXX" = yes; then
+    if test yes = "$GXX"; then
       # Set up default GNU C++ configuration
 
       LT_PATH_LD
 
       # Check if GNU C++ uses GNU ld as the underlying linker, since the
       # archiving commands below assume that GNU ld is being used.
-      if test "$with_gnu_ld" = yes; then
-        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      if test yes = "$with_gnu_ld"; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 
-        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
-        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'
 
         # If archive_cmds runs LD, not CC, wlarc should be empty
         # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
         #     investigate it a little bit more. (MM)
-        wlarc='${wl}'
+        wlarc='$wl'
 
         # ancient GNU ld didn't support --whole-archive et. al.
         if eval "`$CC -print-prog-name=ld` --help 2>&1" |
 	  $GREP 'no-whole-archive' > /dev/null; then
-          _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+          _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'
         else
           _LT_TAGVAR(whole_archive_flag_spec, $1)=
         fi
@@ -5987,18 +6455,30 @@ if test "$_lt_caught_CXX_error" != yes; then
         _LT_TAGVAR(ld_shlibs, $1)=no
         ;;
       aix[[4-9]]*)
-        if test "$host_cpu" = ia64; then
+        if test ia64 = "$host_cpu"; then
           # On IA64, the linker does run time linking by default, so we don't
           # have to do anything special.
           aix_use_runtimelinking=no
           exp_sym_flag='-Bexport'
-          no_entry_flag=""
+          no_entry_flag=
         else
           aix_use_runtimelinking=no
 
           # Test if we are trying to use run time linking or normal
           # AIX style linking. If -brtl is somewhere in LDFLAGS, we
-          # need to do runtime linking.
+          # have runtime linking enabled, and use it for executables.
+          # For shared libraries, we enable/disable runtime linking
+          # depending on the kind of the shared library created -
+          # when "with_aix_soname,aix_use_runtimelinking" is:
+          # "aix,no"   lib.a(lib.so.V) shared, rtl:no,  for executables
+          # "aix,yes"  lib.so          shared, rtl:yes, for executables
+          #            lib.a           static archive
+          # "both,no"  lib.so.V(shr.o) shared, rtl:yes
+          #            lib.a(lib.so.V) shared, rtl:no,  for executables
+          # "both,yes" lib.so.V(shr.o) shared, rtl:yes, for executables
+          #            lib.a(lib.so.V) shared, rtl:no
+          # "svr4,*"   lib.so.V(shr.o) shared, rtl:yes, for executables
+          #            lib.a           static archive
           case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
 	    for ld_flag in $LDFLAGS; do
 	      case $ld_flag in
@@ -6008,6 +6488,13 @@ if test "$_lt_caught_CXX_error" != yes; then
 	        ;;
 	      esac
 	    done
+	    if test svr4,no = "$with_aix_soname,$aix_use_runtimelinking"; then
+	      # With aix-soname=svr4, we create the lib.so.V shared archives only,
+	      # so we don't have lib.a shared libs to link our executables.
+	      # We have to force runtime linking in this case.
+	      aix_use_runtimelinking=yes
+	      LDFLAGS="$LDFLAGS -Wl,-brtl"
+	    fi
 	    ;;
           esac
 
@@ -6026,13 +6513,21 @@ if test "$_lt_caught_CXX_error" != yes; then
         _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
         _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
         _LT_TAGVAR(link_all_deplibs, $1)=yes
-        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+        _LT_TAGVAR(file_list_spec, $1)='$wl-f,'
+        case $with_aix_soname,$aix_use_runtimelinking in
+        aix,*) ;;	# no import file
+        svr4,* | *,yes) # use import file
+          # The Import File defines what to hardcode.
+          _LT_TAGVAR(hardcode_direct, $1)=no
+          _LT_TAGVAR(hardcode_direct_absolute, $1)=no
+          ;;
+        esac
 
-        if test "$GXX" = yes; then
+        if test yes = "$GXX"; then
           case $host_os in aix4.[[012]]|aix4.[[012]].*)
           # We only want to do this on AIX 4.2 and lower, the check
           # below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
+	  collect2name=`$CC -print-prog-name=collect2`
 	  if test -f "$collect2name" &&
 	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
 	  then
@@ -6050,64 +6545,84 @@ if test "$_lt_caught_CXX_error" != yes; then
 	  fi
           esac
           shared_flag='-shared'
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag="$shared_flag "'${wl}-G'
+	  if test yes = "$aix_use_runtimelinking"; then
+	    shared_flag=$shared_flag' $wl-G'
 	  fi
+	  # Need to ensure runtime linking is disabled for the traditional
+	  # shared library, or the linker may eventually find shared libraries
+	  # /with/ Import File - we do not want to mix them.
+	  shared_flag_aix='-shared'
+	  shared_flag_svr4='-shared $wl-G'
         else
           # not using gcc
-          if test "$host_cpu" = ia64; then
+          if test ia64 = "$host_cpu"; then
 	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
 	  # chokes on -Wl,-G. The following line is correct:
 	  shared_flag='-G'
           else
-	    if test "$aix_use_runtimelinking" = yes; then
-	      shared_flag='${wl}-G'
+	    if test yes = "$aix_use_runtimelinking"; then
+	      shared_flag='$wl-G'
 	    else
-	      shared_flag='${wl}-bM:SRE'
+	      shared_flag='$wl-bM:SRE'
 	    fi
+	    shared_flag_aix='$wl-bM:SRE'
+	    shared_flag_svr4='$wl-G'
           fi
         fi
 
-        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'
         # It seems that -bexpall does not export symbols beginning with
         # underscore (_), so it is better to generate a list of symbols to
 	# export.
         _LT_TAGVAR(always_export_symbols, $1)=yes
-        if test "$aix_use_runtimelinking" = yes; then
+	if test aix,yes = "$with_aix_soname,$aix_use_runtimelinking"; then
           # Warning - without using the other runtime loading flags (-brtl),
           # -berok will link without error, but may produce a broken library.
-          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+          # The "-G" linker flag allows undefined symbols.
+          _LT_TAGVAR(no_undefined_flag, $1)='-bernotok'
           # Determine the default libpath from the value encoded in an empty
           # executable.
           _LT_SYS_MODULE_PATH_AIX([$1])
-          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'"$aix_libpath"
 
-          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n "$allow_undefined_flag"; then func_echo_all "$wl$allow_undefined_flag"; else :; fi` $wl'$exp_sym_flag:\$export_symbols' '$shared_flag
         else
-          if test "$host_cpu" = ia64; then
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+          if test ia64 = "$host_cpu"; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'
 	    _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
-	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\$wl$no_entry_flag"' $compiler_flags $wl$allow_undefined_flag '"\$wl$exp_sym_flag:\$export_symbols"
           else
 	    # Determine the default libpath from the value encoded in an
 	    # empty executable.
 	    _LT_SYS_MODULE_PATH_AIX([$1])
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'"$aix_libpath"
 	    # Warning - without using the other run time loading flags,
 	    # -berok will link without error, but may produce a broken library.
-	    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
-	    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
-	    if test "$with_gnu_ld" = yes; then
+	    _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'
+	    _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'
+	    if test yes = "$with_gnu_ld"; then
 	      # We only use this code for GNU lds that support --whole-archive.
-	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'
 	    else
 	      # Exported symbols can be pulled into shared objects from archives
 	      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
 	    fi
 	    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
-	    # This is similar to how AIX traditionally builds its shared
-	    # libraries.
-	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'
+	    # -brtl affects multiple linker settings, -berok does not and is overridden later
+	    compiler_flags_filtered='`func_echo_all "$compiler_flags " | $SED -e "s%-brtl\\([[, ]]\\)%-berok\\1%g"`'
+	    if test svr4 != "$with_aix_soname"; then
+	      # This is similar to how AIX traditionally builds its shared
+	      # libraries. Need -bnortl late, we may have -brtl in LDFLAGS.
+	      _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'
+	    fi
+	    if test aix != "$with_aix_soname"; then
+	      _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all "#! $soname($shared_archive_member_spec.o)"; if test shr_64 = "$shared_archive_member_spec"; then func_echo_all "# 64"; else func_echo_all "# 32"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'
+	    else
+	      # used by -dlpreopen to get the symbols
+	      _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'
+	    fi
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="$_LT_TAGVAR(archive_expsym_cmds, $1)"'~$RM -r $output_objdir/$realname.d'
           fi
         fi
         ;;
@@ -6117,7 +6632,7 @@ if test "$_lt_caught_CXX_error" != yes; then
 	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
 	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
 	  # support --undefined.  This deserves some investigation.  FIXME
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
 	else
 	  _LT_TAGVAR(ld_shlibs, $1)=no
 	fi
@@ -6145,57 +6660,58 @@ if test "$_lt_caught_CXX_error" != yes; then
 	  # Tell ltmain to make .lib files, not .a files.
 	  libext=lib
 	  # Tell ltmain to make .dll files, not .so files.
-	  shrext_cmds=".dll"
+	  shrext_cmds=.dll
 	  # FIXME: Setting linknames here is a bad hack.
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
-	  _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	      $SED -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
-	    else
-	      $SED -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
-	    fi~
-	    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
-	    linknames='
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~linknames='
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then
+              cp "$export_symbols" "$output_objdir/$soname.def";
+              echo "$tool_output_objdir$soname.def" > "$output_objdir/$soname.exp";
+            else
+              $SED -e '\''s/^/-link -EXPORT:/'\'' < $export_symbols > $output_objdir/$soname.exp;
+            fi~
+            $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+            linknames='
 	  # The linker will not automatically build a static lib if we build a DLL.
 	  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
 	  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
 	  # Don't use ranlib
 	  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'
 	  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile="@OUTPUT@"~
-	    lt_tool_outputfile="@TOOL_OUTPUT@"~
-	    case $lt_outputfile in
-	      *.exe|*.EXE) ;;
-	      *)
-		lt_outputfile="$lt_outputfile.exe"
-		lt_tool_outputfile="$lt_tool_outputfile.exe"
-		;;
-	    esac~
-	    func_to_tool_file "$lt_outputfile"~
-	    if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
-	      $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
-	      $RM "$lt_outputfile.manifest";
-	    fi'
+            lt_tool_outputfile="@TOOL_OUTPUT@"~
+            case $lt_outputfile in
+              *.exe|*.EXE) ;;
+              *)
+                lt_outputfile=$lt_outputfile.exe
+                lt_tool_outputfile=$lt_tool_outputfile.exe
+                ;;
+            esac~
+            func_to_tool_file "$lt_outputfile"~
+            if test : != "$MANIFEST_TOOL" && test -f "$lt_outputfile.manifest"; then
+              $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+              $RM "$lt_outputfile.manifest";
+            fi'
 	  ;;
 	*)
 	  # g++
 	  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
 	  # as there is no search path for DLLs.
 	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
-	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'
 	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
 	  _LT_TAGVAR(always_export_symbols, $1)=no
 	  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
 
 	  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	    # If the export-symbols file already is a .def file (1st line
-	    # is EXPORTS), use it as is; otherwise, prepend...
-	    _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	      cp $export_symbols $output_objdir/$soname.def;
-	    else
-	      echo EXPORTS > $output_objdir/$soname.def;
-	      cat $export_symbols >> $output_objdir/$soname.def;
-	    fi~
-	    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	    # If the export-symbols file already is a .def file, use it as
+	    # is; otherwise, prepend EXPORTS...
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then
+              cp $export_symbols $output_objdir/$soname.def;
+            else
+              echo EXPORTS > $output_objdir/$soname.def;
+              cat $export_symbols >> $output_objdir/$soname.def;
+            fi~
+            $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
 	  else
 	    _LT_TAGVAR(ld_shlibs, $1)=no
 	  fi
@@ -6206,6 +6722,34 @@ if test "$_lt_caught_CXX_error" != yes; then
         _LT_DARWIN_LINKER_FEATURES($1)
 	;;
 
+      os2*)
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	_LT_TAGVAR(hardcode_minus_L, $1)=yes
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	shrext_cmds=.dll
+	_LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	  $ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	  $ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	  $ECHO EXPORTS >> $output_objdir/$libname.def~
+	  emxexp $libobjs | $SED /"_DLL_InitTerm"/d >> $output_objdir/$libname.def~
+	  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	  emximp -o $lib $output_objdir/$libname.def'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO "LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE" > $output_objdir/$libname.def~
+	  $ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~
+	  $ECHO "DATA MULTIPLE NONSHARED" >> $output_objdir/$libname.def~
+	  $ECHO EXPORTS >> $output_objdir/$libname.def~
+	  prefix_cmds="$SED"~
+	  if test EXPORTS = "`$SED 1q $export_symbols`"; then
+	    prefix_cmds="$prefix_cmds -e 1d";
+	  fi~
+	  prefix_cmds="$prefix_cmds -e \"s/^\(.*\)$/_\1/g\""~
+	  cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~
+	  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~
+	  emximp -o $lib $output_objdir/$libname.def'
+	_LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'
+	_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+	;;
+
       dgux*)
         case $cc_basename in
           ec++*)
@@ -6241,14 +6785,14 @@ if test "$_lt_caught_CXX_error" != yes; then
         ;;
 
       haiku*)
-        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
         _LT_TAGVAR(link_all_deplibs, $1)=yes
         ;;
 
       hpux9*)
-        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'
         _LT_TAGVAR(hardcode_libdir_separator, $1)=:
-        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
         _LT_TAGVAR(hardcode_direct, $1)=yes
         _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
 				             # but as the default
@@ -6260,7 +6804,7 @@ if test "$_lt_caught_CXX_error" != yes; then
             _LT_TAGVAR(ld_shlibs, $1)=no
             ;;
           aCC*)
-            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
             # Commands to make compiler produce verbose output that lists
             # what "hidden" libraries, object files and flags are used when
             # linking a shared library.
@@ -6269,11 +6813,11 @@ if test "$_lt_caught_CXX_error" != yes; then
             # explicitly linking system object files so we need to strip them
             # from the output so that they don't get included in the library
             # dependencies.
-            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
             ;;
           *)
-            if test "$GXX" = yes; then
-              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            if test yes = "$GXX"; then
+              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test "x$output_objdir/$soname" = "x$lib" || mv $output_objdir/$soname $lib'
             else
               # FIXME: insert proper C++ library support
               _LT_TAGVAR(ld_shlibs, $1)=no
@@ -6283,15 +6827,15 @@ if test "$_lt_caught_CXX_error" != yes; then
         ;;
 
       hpux10*|hpux11*)
-        if test $with_gnu_ld = no; then
-	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+        if test no = "$with_gnu_ld"; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'
 	  _LT_TAGVAR(hardcode_libdir_separator, $1)=:
 
           case $host_cpu in
             hppa*64*|ia64*)
               ;;
             *)
-	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
               ;;
           esac
         fi
@@ -6317,13 +6861,13 @@ if test "$_lt_caught_CXX_error" != yes; then
           aCC*)
 	    case $host_cpu in
 	      hppa*64*)
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	        ;;
 	      ia64*)
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	        ;;
 	      *)
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	        ;;
 	    esac
 	    # Commands to make compiler produce verbose output that lists
@@ -6334,20 +6878,20 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
 	    ;;
           *)
-	    if test "$GXX" = yes; then
-	      if test $with_gnu_ld = no; then
+	    if test yes = "$GXX"; then
+	      if test no = "$with_gnu_ld"; then
 	        case $host_cpu in
 	          hppa*64*)
-	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	            ;;
 	          ia64*)
-	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	            ;;
 	          *)
-	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	            ;;
 	        esac
 	      fi
@@ -6362,22 +6906,22 @@ if test "$_lt_caught_CXX_error" != yes; then
       interix[[3-9]]*)
 	_LT_TAGVAR(hardcode_direct, $1)=no
 	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
-	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
-	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
 	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
 	# Instead, shared libraries are loaded at an image base (0x10000000 by
 	# default) and relocated if they conflict, which is a slow very memory
 	# consuming and fragmenting process.  To avoid this, we pick a random,
 	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
 	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s|^|_|" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
 	;;
       irix5* | irix6*)
         case $cc_basename in
           CC*)
 	    # SGI C++
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
 
 	    # Archives containing C++ object files must be created using
 	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
@@ -6386,17 +6930,17 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'
 	    ;;
           *)
-	    if test "$GXX" = yes; then
-	      if test "$with_gnu_ld" = no; then
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	    if test yes = "$GXX"; then
+	      if test no = "$with_gnu_ld"; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 	      else
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` -o $lib'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` -o $lib'
 	      fi
 	    fi
 	    _LT_TAGVAR(link_all_deplibs, $1)=yes
 	    ;;
         esac
-        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
         _LT_TAGVAR(hardcode_libdir_separator, $1)=:
         _LT_TAGVAR(inherit_rpath, $1)=yes
         ;;
@@ -6409,8 +6953,8 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # KCC will only create a shared library if the output file
 	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
 	    # to its proper name (with version) after linking.
-	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
-	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\$tempext\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\$tempext\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib $wl-retain-symbols-file,$export_symbols; mv \$templib $lib'
 	    # Commands to make compiler produce verbose output that lists
 	    # what "hidden" libraries, object files and flags are used when
 	    # linking a shared library.
@@ -6419,10 +6963,10 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
 
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
-	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'
 
 	    # Archives containing C++ object files must be created using
 	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
@@ -6436,59 +6980,59 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # earlier do not add the objects themselves.
 	    case `$CC -V 2>&1` in
 	      *"Version 7."*)
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 		;;
 	      *)  # Version 8.0 or newer
 	        tmp_idyn=
 	        case $host_cpu in
 		  ia64*) tmp_idyn=' -i_dynamic';;
 		esac
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 		;;
 	    esac
 	    _LT_TAGVAR(archive_cmds_need_lc, $1)=no
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
-	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
-	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'
 	    ;;
           pgCC* | pgcpp*)
             # Portland Group C++ compiler
 	    case `$CC -V` in
 	    *pgCC\ [[1-5]].* | *pgcpp\ [[1-5]].*)
 	      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
-		compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
+               rm -rf $tpldir~
+               $CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+               compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
 	      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
-		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
-		$RANLIB $oldlib'
+                rm -rf $tpldir~
+                $CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+                $AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
+                $RANLIB $oldlib'
 	      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+                rm -rf $tpldir~
+                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
 	      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+                rm -rf $tpldir~
+                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 	      ;;
 	    *) # Version 6 and above use weak symbols
-	      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
-	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'
 	      ;;
 	    esac
 
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'
-	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
-	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl--rpath $wl$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
             ;;
 	  cxx*)
 	    # Compaq C++
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname  -o $lib $wl-retain-symbols-file $wl$export_symbols'
 
 	    runpath_var=LD_RUN_PATH
 	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
@@ -6502,18 +7046,18 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
 	    ;;
 	  xl* | mpixl* | bgxl*)
 	    # IBM XL 8.0 on PPC, with GNU ld
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
-	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    if test "x$supports_anon_versioning" = xyes; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'
+	    if test yes = "$supports_anon_versioning"; then
 	      _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
-		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-		echo "local: *; };" >> $output_objdir/$libname.ver~
-		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+                cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+                echo "local: *; };" >> $output_objdir/$libname.ver~
+                $CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'
 	    fi
 	    ;;
 	  *)
@@ -6521,10 +7065,10 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    *Sun\ C*)
 	      # Sun C++ 5.9
 	      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
-	      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file $wl$export_symbols'
 	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
-	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` $wl--no-whole-archive'
 	      _LT_TAGVAR(compiler_needs_object, $1)=yes
 
 	      # Not sure whether something based on
@@ -6582,22 +7126,17 @@ if test "$_lt_caught_CXX_error" != yes; then
         _LT_TAGVAR(ld_shlibs, $1)=yes
 	;;
 
-      openbsd2*)
-        # C++ shared libraries are fairly broken
-	_LT_TAGVAR(ld_shlibs, $1)=no
-	;;
-
-      openbsd*)
+      openbsd* | bitrig*)
 	if test -f /usr/libexec/ld.so; then
 	  _LT_TAGVAR(hardcode_direct, $1)=yes
 	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
 	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
 	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
-	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
-	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
-	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
-	    _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`"; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file,$export_symbols -o $lib'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'
 	  fi
 	  output_verbose_link_cmd=func_echo_all
 	else
@@ -6613,9 +7152,9 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # KCC will only create a shared library if the output file
 	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
 	    # to its proper name (with version) after linking.
-	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\$tempext\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
 
-	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'
 	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
 
 	    # Archives containing C++ object files must be created using
@@ -6633,17 +7172,17 @@ if test "$_lt_caught_CXX_error" != yes; then
           cxx*)
 	    case $host in
 	      osf3*)
-	        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && func_echo_all "${wl}-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $soname `test -n "$verstring" && func_echo_all "$wl-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
 		;;
 	      *)
 	        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib'
 	        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
-	          echo "-hidden">> $lib.exp~
-	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
-	          $RM $lib.exp'
+                  echo "-hidden">> $lib.exp~
+                  $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname $wl-input $wl$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry $output_objdir/so_locations -o $lib~
+                  $RM $lib.exp'
 	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
 		;;
 	    esac
@@ -6658,21 +7197,21 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # explicitly linking system object files so we need to strip them
 	    # from the output so that they don't get included in the library
 	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list= ; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
 	    ;;
 	  *)
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	    if test yes,no = "$GXX,$with_gnu_ld"; then
+	      _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\*'
 	      case $host in
 	        osf3*)
-	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 		  ;;
 	        *)
-	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-msym $wl-soname $wl$soname `test -n "$verstring" && func_echo_all "$wl-set_version $wl$verstring"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'
 		  ;;
 	      esac
 
-	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'
 	      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
 
 	      # Commands to make compiler produce verbose output that lists
@@ -6718,9 +7257,9 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    # Sun C++ 4.2, 5.x and Centerline C++
             _LT_TAGVAR(archive_cmds_need_lc,$1)=yes
 	    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
 	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+              $CC -G$allow_undefined_flag $wl-M $wl$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
 
 	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
 	    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
@@ -6728,7 +7267,7 @@ if test "$_lt_caught_CXX_error" != yes; then
 	      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
 	      *)
 		# The compiler driver will combine and reorder linker options,
-		# but understands `-z linker_flag'.
+		# but understands '-z linker_flag'.
 	        # Supported since Solaris 2.6 (maybe 2.5.1?)
 		_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
 	        ;;
@@ -6745,30 +7284,30 @@ if test "$_lt_caught_CXX_error" != yes; then
 	    ;;
           gcx*)
 	    # Green Hills C++ Compiler
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'
 
 	    # The C++ compiler must be used to create the archive.
 	    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
 	    ;;
           *)
 	    # GNU C++ compiler with Solaris linker
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'
+	    if test yes,no = "$GXX,$with_gnu_ld"; then
+	      _LT_TAGVAR(no_undefined_flag, $1)=' $wl-z ${wl}defs'
 	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'
 	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+                  $CC -shared $pic_flag -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
 
 	        # Commands to make compiler produce verbose output that lists
 	        # what "hidden" libraries, object files and flags are used when
 	        # linking a shared library.
 	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
 	      else
-	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # g++ 2.7 appears to require '-G' NOT '-shared' on this
 	        # platform.
-	        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'
 	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+                  $CC -G -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
 
 	        # Commands to make compiler produce verbose output that lists
 	        # what "hidden" libraries, object files and flags are used when
@@ -6776,11 +7315,11 @@ if test "$_lt_caught_CXX_error" != yes; then
 	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
 	      fi
 
-	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $wl$libdir'
 	      case $host_os in
 		solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
 		*)
-		  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'
 		  ;;
 	      esac
 	    fi
@@ -6789,52 +7328,52 @@ if test "$_lt_caught_CXX_error" != yes; then
         ;;
 
     sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
-      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'
       _LT_TAGVAR(archive_cmds_need_lc, $1)=no
       _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
       runpath_var='LD_RUN_PATH'
 
       case $cc_basename in
         CC*)
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
 	*)
-	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	  ;;
       esac
       ;;
 
       sysv5* | sco3.2v5* | sco5v6*)
-	# Note: We can NOT use -z defs as we might desire, because we do not
+	# Note: We CANNOT use -z defs as we might desire, because we do not
 	# link with -lc, and that would cause any symbols used from libc to
 	# always be unresolved, which means just about no library would
 	# ever link correctly.  If we're not using GNU ld we use -z text
 	# though, which does catch some bad symbols but isn't as heavy-handed
 	# as -z defs.
-	_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
-	_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+	_LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'
+	_LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'
 	_LT_TAGVAR(archive_cmds_need_lc, $1)=no
 	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
-	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'
 	_LT_TAGVAR(hardcode_libdir_separator, $1)=':'
 	_LT_TAGVAR(link_all_deplibs, $1)=yes
-	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'
 	runpath_var='LD_RUN_PATH'
 
 	case $cc_basename in
           CC*)
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~
-	      '"$_LT_TAGVAR(old_archive_cmds, $1)"
+              '"$_LT_TAGVAR(old_archive_cmds, $1)"
 	    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~
-	      '"$_LT_TAGVAR(reload_cmds, $1)"
+              '"$_LT_TAGVAR(reload_cmds, $1)"
 	    ;;
 	  *)
-	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
 	    ;;
 	esac
       ;;
@@ -6865,10 +7404,10 @@ if test "$_lt_caught_CXX_error" != yes; then
     esac
 
     AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
-    test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+    test no = "$_LT_TAGVAR(ld_shlibs, $1)" && can_build_shared=no
 
-    _LT_TAGVAR(GCC, $1)="$GXX"
-    _LT_TAGVAR(LD, $1)="$LD"
+    _LT_TAGVAR(GCC, $1)=$GXX
+    _LT_TAGVAR(LD, $1)=$LD
 
     ## CAVEAT EMPTOR:
     ## There is no encapsulation within the following macros, do not change
@@ -6895,7 +7434,7 @@ if test "$_lt_caught_CXX_error" != yes; then
   lt_cv_path_LD=$lt_save_path_LD
   lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
   lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
-fi # test "$_lt_caught_CXX_error" != yes
+fi # test yes != "$_lt_caught_CXX_error"
 
 AC_LANG_POP
 ])# _LT_LANG_CXX_CONFIG
@@ -6917,13 +7456,14 @@ AC_REQUIRE([_LT_DECL_SED])
 AC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])
 func_stripname_cnf ()
 {
-  case ${2} in
-  .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
-  *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+  case @S|@2 in
+  .*) func_stripname_result=`$ECHO "@S|@3" | $SED "s%^@S|@1%%; s%\\\\@S|@2\$%%"`;;
+  *)  func_stripname_result=`$ECHO "@S|@3" | $SED "s%^@S|@1%%; s%@S|@2\$%%"`;;
   esac
 } # func_stripname_cnf
 ])# _LT_FUNC_STRIPNAME_CNF
 
+
 # _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])
 # ---------------------------------
 # Figure out "hidden" library dependencies from verbose
@@ -7007,13 +7547,13 @@ if AC_TRY_EVAL(ac_compile); then
   pre_test_object_deps_done=no
 
   for p in `eval "$output_verbose_link_cmd"`; do
-    case ${prev}${p} in
+    case $prev$p in
 
     -L* | -R* | -l*)
        # Some compilers place space between "-{L,R}" and the path.
        # Remove the space.
-       if test $p = "-L" ||
-          test $p = "-R"; then
+       if test x-L = "$p" ||
+          test x-R = "$p"; then
 	 prev=$p
 	 continue
        fi
@@ -7029,16 +7569,16 @@ if AC_TRY_EVAL(ac_compile); then
        case $p in
        =*) func_stripname_cnf '=' '' "$p"; p=$lt_sysroot$func_stripname_result ;;
        esac
-       if test "$pre_test_object_deps_done" = no; then
-	 case ${prev} in
+       if test no = "$pre_test_object_deps_done"; then
+	 case $prev in
 	 -L | -R)
 	   # Internal compiler library paths should come after those
 	   # provided the user.  The postdeps already come after the
 	   # user supplied libs so there is no need to process them.
 	   if test -z "$_LT_TAGVAR(compiler_lib_search_path, $1)"; then
-	     _LT_TAGVAR(compiler_lib_search_path, $1)="${prev}${p}"
+	     _LT_TAGVAR(compiler_lib_search_path, $1)=$prev$p
 	   else
-	     _LT_TAGVAR(compiler_lib_search_path, $1)="${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}"
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${_LT_TAGVAR(compiler_lib_search_path, $1)} $prev$p"
 	   fi
 	   ;;
 	 # The "-l" case would never come before the object being
@@ -7046,9 +7586,9 @@ if AC_TRY_EVAL(ac_compile); then
 	 esac
        else
 	 if test -z "$_LT_TAGVAR(postdeps, $1)"; then
-	   _LT_TAGVAR(postdeps, $1)="${prev}${p}"
+	   _LT_TAGVAR(postdeps, $1)=$prev$p
 	 else
-	   _LT_TAGVAR(postdeps, $1)="${_LT_TAGVAR(postdeps, $1)} ${prev}${p}"
+	   _LT_TAGVAR(postdeps, $1)="${_LT_TAGVAR(postdeps, $1)} $prev$p"
 	 fi
        fi
        prev=
@@ -7063,15 +7603,15 @@ if AC_TRY_EVAL(ac_compile); then
 	 continue
        fi
 
-       if test "$pre_test_object_deps_done" = no; then
+       if test no = "$pre_test_object_deps_done"; then
 	 if test -z "$_LT_TAGVAR(predep_objects, $1)"; then
-	   _LT_TAGVAR(predep_objects, $1)="$p"
+	   _LT_TAGVAR(predep_objects, $1)=$p
 	 else
 	   _LT_TAGVAR(predep_objects, $1)="$_LT_TAGVAR(predep_objects, $1) $p"
 	 fi
        else
 	 if test -z "$_LT_TAGVAR(postdep_objects, $1)"; then
-	   _LT_TAGVAR(postdep_objects, $1)="$p"
+	   _LT_TAGVAR(postdep_objects, $1)=$p
 	 else
 	   _LT_TAGVAR(postdep_objects, $1)="$_LT_TAGVAR(postdep_objects, $1) $p"
 	 fi
@@ -7102,51 +7642,6 @@ interix[[3-9]]*)
   _LT_TAGVAR(postdep_objects,$1)=
   _LT_TAGVAR(postdeps,$1)=
   ;;
-
-linux*)
-  case `$CC -V 2>&1 | sed 5q` in
-  *Sun\ C*)
-    # Sun C++ 5.9
-
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
-      ;;
-    esac
-
-    if test "$solaris_use_stlport4" != yes; then
-      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
-
-solaris*)
-  case $cc_basename in
-  CC* | sunCC*)
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
-      ;;
-    esac
-
-    # Adding this requires a known-good setup of shared libraries for
-    # Sun compiler versions before 5.6, else PIC objects from an old
-    # archive will be linked into the output, leading to subtle bugs.
-    if test "$solaris_use_stlport4" != yes; then
-      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
 esac
 ])
 
@@ -7155,7 +7650,7 @@ case " $_LT_TAGVAR(postdeps, $1) " in
 esac
  _LT_TAGVAR(compiler_lib_search_dirs, $1)=
 if test -n "${_LT_TAGVAR(compiler_lib_search_path, $1)}"; then
- _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_TAGVAR(compiler_lib_search_path, $1)}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_TAGVAR(compiler_lib_search_path, $1)}" | $SED -e 's! -L! !g' -e 's!^ !!'`
 fi
 _LT_TAGDECL([], [compiler_lib_search_dirs], [1],
     [The directories searched by this compiler when creating a shared library])
@@ -7175,10 +7670,10 @@ _LT_TAGDECL([], [compiler_lib_search_path], [1],
 # --------------------------
 # Ensure that the configuration variables for a Fortran 77 compiler are
 # suitably defined.  These variables are subsequently used by _LT_CONFIG
-# to write the compiler configuration to `libtool'.
+# to write the compiler configuration to 'libtool'.
 m4_defun([_LT_LANG_F77_CONFIG],
 [AC_LANG_PUSH(Fortran 77)
-if test -z "$F77" || test "X$F77" = "Xno"; then
+if test -z "$F77" || test no = "$F77"; then
   _lt_disable_F77=yes
 fi
 
@@ -7215,7 +7710,7 @@ _LT_TAGVAR(objext, $1)=$objext
 # the F77 compiler isn't working.  Some variables (like enable_shared)
 # are currently assumed to apply to all compilers on this platform,
 # and will be corrupted by setting them based on a non-working compiler.
-if test "$_lt_disable_F77" != yes; then
+if test yes != "$_lt_disable_F77"; then
   # Code to be used in simple compile tests
   lt_simple_compile_test_code="\
       subroutine t
@@ -7237,7 +7732,7 @@ if test "$_lt_disable_F77" != yes; then
   _LT_LINKER_BOILERPLATE
 
   # Allow CC to be a program name with arguments.
-  lt_save_CC="$CC"
+  lt_save_CC=$CC
   lt_save_GCC=$GCC
   lt_save_CFLAGS=$CFLAGS
   CC=${F77-"f77"}
@@ -7251,21 +7746,25 @@ if test "$_lt_disable_F77" != yes; then
     AC_MSG_RESULT([$can_build_shared])
 
     AC_MSG_CHECKING([whether to build shared libraries])
-    test "$can_build_shared" = "no" && enable_shared=no
+    test no = "$can_build_shared" && enable_shared=no
 
     # On AIX, shared libraries and static libraries use the same namespace, and
     # are all built from PIC.
     case $host_os in
       aix3*)
-        test "$enable_shared" = yes && enable_static=no
+        test yes = "$enable_shared" && enable_static=no
         if test -n "$RANLIB"; then
           archive_cmds="$archive_cmds~\$RANLIB \$lib"
           postinstall_cmds='$RANLIB $lib'
         fi
         ;;
       aix[[4-9]]*)
-	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-	  test "$enable_shared" = yes && enable_static=no
+	if test ia64 != "$host_cpu"; then
+	  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in
+	  yes,aix,yes) ;;		# shared object as lib.so file only
+	  yes,svr4,*) ;;		# shared object as lib.so archive member only
+	  yes,*) enable_static=no ;;	# shared object in lib.a archive as well
+	  esac
 	fi
         ;;
     esac
@@ -7273,11 +7772,11 @@ if test "$_lt_disable_F77" != yes; then
 
     AC_MSG_CHECKING([whether to build static libraries])
     # Make sure either enable_shared or enable_static is yes.
-    test "$enable_shared" = yes || enable_static=yes
+    test yes = "$enable_shared" || enable_static=yes
     AC_MSG_RESULT([$enable_static])
 
-    _LT_TAGVAR(GCC, $1)="$G77"
-    _LT_TAGVAR(LD, $1)="$LD"
+    _LT_TAGVAR(GCC, $1)=$G77
+    _LT_TAGVAR(LD, $1)=$LD
 
     ## CAVEAT EMPTOR:
     ## There is no encapsulation within the following macros, do not change
@@ -7294,9 +7793,9 @@ if test "$_lt_disable_F77" != yes; then
   fi # test -n "$compiler"
 
   GCC=$lt_save_GCC
-  CC="$lt_save_CC"
-  CFLAGS="$lt_save_CFLAGS"
-fi # test "$_lt_disable_F77" != yes
+  CC=$lt_save_CC
+  CFLAGS=$lt_save_CFLAGS
+fi # test yes != "$_lt_disable_F77"
 
 AC_LANG_POP
 ])# _LT_LANG_F77_CONFIG
@@ -7306,11 +7805,11 @@ AC_LANG_POP
 # -------------------------
 # Ensure that the configuration variables for a Fortran compiler are
 # suitably defined.  These variables are subsequently used by _LT_CONFIG
-# to write the compiler configuration to `libtool'.
+# to write the compiler configuration to 'libtool'.
 m4_defun([_LT_LANG_FC_CONFIG],
 [AC_LANG_PUSH(Fortran)
 
-if test -z "$FC" || test "X$FC" = "Xno"; then
+if test -z "$FC" || test no = "$FC"; then
   _lt_disable_FC=yes
 fi
 
@@ -7347,7 +7846,7 @@ _LT_TAGVAR(objext, $1)=$objext
 # the FC compiler isn't working.  Some variables (like enable_shared)
 # are currently assumed to apply to all compilers on this platform,
 # and will be corrupted by setting them based on a non-working compiler.
-if test "$_lt_disable_FC" != yes; then
+if test yes != "$_lt_disable_FC"; then
   # Code to be used in simple compile tests
   lt_simple_compile_test_code="\
       subroutine t
@@ -7369,7 +7868,7 @@ if test "$_lt_disable_FC" != yes; then
   _LT_LINKER_BOILERPLATE
 
   # Allow CC to be a program name with arguments.
-  lt_save_CC="$CC"
+  lt_save_CC=$CC
   lt_save_GCC=$GCC
   lt_save_CFLAGS=$CFLAGS
   CC=${FC-"f95"}
@@ -7385,21 +7884,25 @@ if test "$_lt_disable_FC" != yes; then
     AC_MSG_RESULT([$can_build_shared])
 
     AC_MSG_CHECKING([whether to build shared libraries])
-    test "$can_build_shared" = "no" && enable_shared=no
+    test no = "$can_build_shared" && enable_shared=no
 
     # On AIX, shared libraries and static libraries use the same namespace, and
     # are all built from PIC.
     case $host_os in
       aix3*)
-        test "$enable_shared" = yes && enable_static=no
+        test yes = "$enable_shared" && enable_static=no
         if test -n "$RANLIB"; then
           archive_cmds="$archive_cmds~\$RANLIB \$lib"
           postinstall_cmds='$RANLIB $lib'
         fi
         ;;
       aix[[4-9]]*)
-	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-	  test "$enable_shared" = yes && enable_static=no
+	if test ia64 != "$host_cpu"; then
+	  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in
+	  yes,aix,yes) ;;		# shared object as lib.so file only
+	  yes,svr4,*) ;;		# shared object as lib.so archive member only
+	  yes,*) enable_static=no ;;	# shared object in lib.a archive as well
+	  esac
 	fi
         ;;
     esac
@@ -7407,11 +7910,11 @@ if test "$_lt_disable_FC" != yes; then
 
     AC_MSG_CHECKING([whether to build static libraries])
     # Make sure either enable_shared or enable_static is yes.
-    test "$enable_shared" = yes || enable_static=yes
+    test yes = "$enable_shared" || enable_static=yes
     AC_MSG_RESULT([$enable_static])
 
-    _LT_TAGVAR(GCC, $1)="$ac_cv_fc_compiler_gnu"
-    _LT_TAGVAR(LD, $1)="$LD"
+    _LT_TAGVAR(GCC, $1)=$ac_cv_fc_compiler_gnu
+    _LT_TAGVAR(LD, $1)=$LD
 
     ## CAVEAT EMPTOR:
     ## There is no encapsulation within the following macros, do not change
@@ -7431,7 +7934,7 @@ if test "$_lt_disable_FC" != yes; then
   GCC=$lt_save_GCC
   CC=$lt_save_CC
   CFLAGS=$lt_save_CFLAGS
-fi # test "$_lt_disable_FC" != yes
+fi # test yes != "$_lt_disable_FC"
 
 AC_LANG_POP
 ])# _LT_LANG_FC_CONFIG
@@ -7441,7 +7944,7 @@ AC_LANG_POP
 # --------------------------
 # Ensure that the configuration variables for the GNU Java Compiler compiler
 # are suitably defined.  These variables are subsequently used by _LT_CONFIG
-# to write the compiler configuration to `libtool'.
+# to write the compiler configuration to 'libtool'.
 m4_defun([_LT_LANG_GCJ_CONFIG],
 [AC_REQUIRE([LT_PROG_GCJ])dnl
 AC_LANG_SAVE
@@ -7475,7 +7978,7 @@ CC=${GCJ-"gcj"}
 CFLAGS=$GCJFLAGS
 compiler=$CC
 _LT_TAGVAR(compiler, $1)=$CC
-_LT_TAGVAR(LD, $1)="$LD"
+_LT_TAGVAR(LD, $1)=$LD
 _LT_CC_BASENAME([$compiler])
 
 # GCJ did not exist at the time GCC didn't implicitly link libc in.
@@ -7512,7 +8015,7 @@ CFLAGS=$lt_save_CFLAGS
 # --------------------------
 # Ensure that the configuration variables for the GNU Go compiler
 # are suitably defined.  These variables are subsequently used by _LT_CONFIG
-# to write the compiler configuration to `libtool'.
+# to write the compiler configuration to 'libtool'.
 m4_defun([_LT_LANG_GO_CONFIG],
 [AC_REQUIRE([LT_PROG_GO])dnl
 AC_LANG_SAVE
@@ -7546,7 +8049,7 @@ CC=${GOC-"gccgo"}
 CFLAGS=$GOFLAGS
 compiler=$CC
 _LT_TAGVAR(compiler, $1)=$CC
-_LT_TAGVAR(LD, $1)="$LD"
+_LT_TAGVAR(LD, $1)=$LD
 _LT_CC_BASENAME([$compiler])
 
 # Go did not exist at the time GCC didn't implicitly link libc in.
@@ -7583,7 +8086,7 @@ CFLAGS=$lt_save_CFLAGS
 # -------------------------
 # Ensure that the configuration variables for the Windows resource compiler
 # are suitably defined.  These variables are subsequently used by _LT_CONFIG
-# to write the compiler configuration to `libtool'.
+# to write the compiler configuration to 'libtool'.
 m4_defun([_LT_LANG_RC_CONFIG],
 [AC_REQUIRE([LT_PROG_RC])dnl
 AC_LANG_SAVE
@@ -7599,7 +8102,7 @@ _LT_TAGVAR(objext, $1)=$objext
 lt_simple_compile_test_code='sample MENU { MENUITEM "&Soup", 100, CHECKED }'
 
 # Code to be used in simple link tests
-lt_simple_link_test_code="$lt_simple_compile_test_code"
+lt_simple_link_test_code=$lt_simple_compile_test_code
 
 # ltmain only uses $CC for tagged configurations so make sure $CC is set.
 _LT_TAG_COMPILER
@@ -7609,7 +8112,7 @@ _LT_COMPILER_BOILERPLATE
 _LT_LINKER_BOILERPLATE
 
 # Allow CC to be a program name with arguments.
-lt_save_CC="$CC"
+lt_save_CC=$CC
 lt_save_CFLAGS=$CFLAGS
 lt_save_GCC=$GCC
 GCC=
@@ -7638,7 +8141,7 @@ AC_DEFUN([LT_PROG_GCJ],
 [m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],
   [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],
     [AC_CHECK_TOOL(GCJ, gcj,)
-      test "x${GCJFLAGS+set}" = xset || GCJFLAGS="-g -O2"
+      test set = "${GCJFLAGS+set}" || GCJFLAGS="-g -O2"
       AC_SUBST(GCJFLAGS)])])[]dnl
 ])
 
@@ -7749,7 +8252,7 @@ lt_ac_count=0
 # Add /usr/xpg4/bin/sed as it is typically found on Solaris
 # along with /bin/sed that truncates output.
 for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
-  test ! -f $lt_ac_sed && continue
+  test ! -f "$lt_ac_sed" && continue
   cat /dev/null > conftest.in
   lt_ac_count=0
   echo $ECHO_N "0123456789$ECHO_C" >conftest.in
@@ -7766,9 +8269,9 @@ for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
     $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break
     cmp -s conftest.out conftest.nl || break
     # 10000 chars as input seems more than enough
-    test $lt_ac_count -gt 10 && break
+    test 10 -lt "$lt_ac_count" && break
     lt_ac_count=`expr $lt_ac_count + 1`
-    if test $lt_ac_count -gt $lt_ac_max; then
+    if test "$lt_ac_count" -gt "$lt_ac_max"; then
       lt_ac_max=$lt_ac_count
       lt_cv_path_SED=$lt_ac_sed
     fi
@@ -7792,27 +8295,7 @@ dnl AC_DEFUN([LT_AC_PROG_SED], [])
 # Find out whether the shell is Bourne or XSI compatible,
 # or has some other useful features.
 m4_defun([_LT_CHECK_SHELL_FEATURES],
-[AC_MSG_CHECKING([whether the shell understands some XSI constructs])
-# Try some XSI features
-xsi_shell=no
-( _lt_dummy="a/b/c"
-  test "${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}"${_lt_dummy%"$_lt_dummy"}, \
-      = c,a/b,b/c, \
-    && eval 'test $(( 1 + 1 )) -eq 2 \
-    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
-  && xsi_shell=yes
-AC_MSG_RESULT([$xsi_shell])
-_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])
-
-AC_MSG_CHECKING([whether the shell understands "+="])
-lt_shell_append=no
-( foo=bar; set foo baz; eval "$[1]+=\$[2]" && test "$foo" = barbaz ) \
-    >/dev/null 2>&1 \
-  && lt_shell_append=yes
-AC_MSG_RESULT([$lt_shell_append])
-_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])
-
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+[if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   lt_unset=unset
 else
   lt_unset=false
@@ -7836,102 +8319,9 @@ _LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl
 ])# _LT_CHECK_SHELL_FEATURES
 
 
-# _LT_PROG_FUNCTION_REPLACE (FUNCNAME, REPLACEMENT-BODY)
-# ------------------------------------------------------
-# In `$cfgfile', look for function FUNCNAME delimited by `^FUNCNAME ()$' and
-# '^} FUNCNAME ', and replace its body with REPLACEMENT-BODY.
-m4_defun([_LT_PROG_FUNCTION_REPLACE],
-[dnl {
-sed -e '/^$1 ()$/,/^} # $1 /c\
-$1 ()\
-{\
-m4_bpatsubsts([$2], [$], [\\], [^\([	 ]\)], [\\\1])
-} # Extended-shell $1 implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-])
-
-
-# _LT_PROG_REPLACE_SHELLFNS
-# -------------------------
-# Replace existing portable implementations of several shell functions with
-# equivalent extended shell implementations where those features are available..
-m4_defun([_LT_PROG_REPLACE_SHELLFNS],
-[if test x"$xsi_shell" = xyes; then
-  _LT_PROG_FUNCTION_REPLACE([func_dirname], [dnl
-    case ${1} in
-      */*) func_dirname_result="${1%/*}${2}" ;;
-      *  ) func_dirname_result="${3}" ;;
-    esac])
-
-  _LT_PROG_FUNCTION_REPLACE([func_basename], [dnl
-    func_basename_result="${1##*/}"])
-
-  _LT_PROG_FUNCTION_REPLACE([func_dirname_and_basename], [dnl
-    case ${1} in
-      */*) func_dirname_result="${1%/*}${2}" ;;
-      *  ) func_dirname_result="${3}" ;;
-    esac
-    func_basename_result="${1##*/}"])
-
-  _LT_PROG_FUNCTION_REPLACE([func_stripname], [dnl
-    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
-    # positional parameters, so assign one to ordinary parameter first.
-    func_stripname_result=${3}
-    func_stripname_result=${func_stripname_result#"${1}"}
-    func_stripname_result=${func_stripname_result%"${2}"}])
-
-  _LT_PROG_FUNCTION_REPLACE([func_split_long_opt], [dnl
-    func_split_long_opt_name=${1%%=*}
-    func_split_long_opt_arg=${1#*=}])
-
-  _LT_PROG_FUNCTION_REPLACE([func_split_short_opt], [dnl
-    func_split_short_opt_arg=${1#??}
-    func_split_short_opt_name=${1%"$func_split_short_opt_arg"}])
-
-  _LT_PROG_FUNCTION_REPLACE([func_lo2o], [dnl
-    case ${1} in
-      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
-      *)    func_lo2o_result=${1} ;;
-    esac])
-
-  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])
-
-  _LT_PROG_FUNCTION_REPLACE([func_arith], [    func_arith_result=$(( $[*] ))])
-
-  _LT_PROG_FUNCTION_REPLACE([func_len], [    func_len_result=${#1}])
-fi
-
-if test x"$lt_shell_append" = xyes; then
-  _LT_PROG_FUNCTION_REPLACE([func_append], [    eval "${1}+=\\${2}"])
-
-  _LT_PROG_FUNCTION_REPLACE([func_append_quoted], [dnl
-    func_quote_for_eval "${2}"
-dnl m4 expansion turns \\\\ into \\, and then the shell eval turns that into \
-    eval "${1}+=\\\\ \\$func_quote_for_eval_result"])
-
-  # Save a `func_append' function call where possible by direct use of '+='
-  sed -e 's%func_append \([[a-zA-Z_]]\{1,\}\) "%\1+="%g' $cfgfile > $cfgfile.tmp \
-    && mv -f "$cfgfile.tmp" "$cfgfile" \
-      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-  test 0 -eq $? || _lt_function_replace_fail=:
-else
-  # Save a `func_append' function call even when '+=' is not available
-  sed -e 's%func_append \([[a-zA-Z_]]\{1,\}\) "%\1="$\1%g' $cfgfile > $cfgfile.tmp \
-    && mv -f "$cfgfile.tmp" "$cfgfile" \
-      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-  test 0 -eq $? || _lt_function_replace_fail=:
-fi
-
-if test x"$_lt_function_replace_fail" = x":"; then
-  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])
-fi
-])
-
 # _LT_PATH_CONVERSION_FUNCTIONS
 # -----------------------------
-# Determine which file name conversion functions should be used by
+# Determine what file name conversion functions should be used by
 # func_to_host_file (and, implicitly, by func_to_host_path).  These are needed
 # for certain cross-compile configurations and native mingw.
 m4_defun([_LT_PATH_CONVERSION_FUNCTIONS],
diff --git a/lib/Analysis/isl/m4/ltoptions.m4 b/lib/Analysis/isl/m4/ltoptions.m4
index 5d9acd8..94b0829 100644
--- a/lib/Analysis/isl/m4/ltoptions.m4
+++ b/lib/Analysis/isl/m4/ltoptions.m4
@@ -1,14 +1,14 @@
 # Helper functions for option handling.                    -*- Autoconf -*-
 #
-#   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation,
-#   Inc.
+#   Copyright (C) 2004-2005, 2007-2009, 2011-2015 Free Software
+#   Foundation, Inc.
 #   Written by Gary V. Vaughan, 2004
 #
 # This file is free software; the Free Software Foundation gives
 # unlimited permission to copy and/or distribute it, with or without
 # modifications, as long as this notice is preserved.
 
-# serial 7 ltoptions.m4
+# serial 8 ltoptions.m4
 
 # This is to help aclocal find these macros, as it can't see m4_define.
 AC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])
@@ -29,7 +29,7 @@ m4_define([_LT_SET_OPTION],
 [m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl
 m4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),
         _LT_MANGLE_DEFUN([$1], [$2]),
-    [m4_warning([Unknown $1 option `$2'])])[]dnl
+    [m4_warning([Unknown $1 option '$2'])])[]dnl
 ])
 
 
@@ -75,13 +75,15 @@ m4_if([$1],[LT_INIT],[
   dnl
   dnl If no reference was made to various pairs of opposing options, then
   dnl we run the default mode handler for the pair.  For example, if neither
-  dnl `shared' nor `disable-shared' was passed, we enable building of shared
+  dnl 'shared' nor 'disable-shared' was passed, we enable building of shared
   dnl archives by default:
   _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])
   _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])
   _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])
   _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],
-  		   [_LT_ENABLE_FAST_INSTALL])
+		   [_LT_ENABLE_FAST_INSTALL])
+  _LT_UNLESS_OPTIONS([LT_INIT], [aix-soname=aix aix-soname=both aix-soname=svr4],
+		   [_LT_WITH_AIX_SONAME([aix])])
   ])
 ])# _LT_SET_OPTIONS
 
@@ -112,7 +114,7 @@ AU_DEFUN([AC_LIBTOOL_DLOPEN],
 [_LT_SET_OPTION([LT_INIT], [dlopen])
 AC_DIAGNOSE([obsolete],
 [$0: Remove this warning and the call to _LT_SET_OPTION when you
-put the `dlopen' option into LT_INIT's first parameter.])
+put the 'dlopen' option into LT_INIT's first parameter.])
 ])
 
 dnl aclocal-1.4 backwards compatibility:
@@ -148,7 +150,7 @@ AU_DEFUN([AC_LIBTOOL_WIN32_DLL],
 _LT_SET_OPTION([LT_INIT], [win32-dll])
 AC_DIAGNOSE([obsolete],
 [$0: Remove this warning and the call to _LT_SET_OPTION when you
-put the `win32-dll' option into LT_INIT's first parameter.])
+put the 'win32-dll' option into LT_INIT's first parameter.])
 ])
 
 dnl aclocal-1.4 backwards compatibility:
@@ -157,9 +159,9 @@ dnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])
 
 # _LT_ENABLE_SHARED([DEFAULT])
 # ----------------------------
-# implement the --enable-shared flag, and supports the `shared' and
-# `disable-shared' LT_INIT options.
-# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+# implement the --enable-shared flag, and supports the 'shared' and
+# 'disable-shared' LT_INIT options.
+# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.
 m4_define([_LT_ENABLE_SHARED],
 [m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl
 AC_ARG_ENABLE([shared],
@@ -172,14 +174,14 @@ AC_ARG_ENABLE([shared],
     *)
       enable_shared=no
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for pkg in $enableval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$pkg" = "X$p"; then
 	  enable_shared=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       ;;
     esac],
     [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)
@@ -211,9 +213,9 @@ dnl AC_DEFUN([AM_DISABLE_SHARED], [])
 
 # _LT_ENABLE_STATIC([DEFAULT])
 # ----------------------------
-# implement the --enable-static flag, and support the `static' and
-# `disable-static' LT_INIT options.
-# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+# implement the --enable-static flag, and support the 'static' and
+# 'disable-static' LT_INIT options.
+# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.
 m4_define([_LT_ENABLE_STATIC],
 [m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl
 AC_ARG_ENABLE([static],
@@ -226,14 +228,14 @@ AC_ARG_ENABLE([static],
     *)
      enable_static=no
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for pkg in $enableval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$pkg" = "X$p"; then
 	  enable_static=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       ;;
     esac],
     [enable_static=]_LT_ENABLE_STATIC_DEFAULT)
@@ -265,9 +267,9 @@ dnl AC_DEFUN([AM_DISABLE_STATIC], [])
 
 # _LT_ENABLE_FAST_INSTALL([DEFAULT])
 # ----------------------------------
-# implement the --enable-fast-install flag, and support the `fast-install'
-# and `disable-fast-install' LT_INIT options.
-# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+# implement the --enable-fast-install flag, and support the 'fast-install'
+# and 'disable-fast-install' LT_INIT options.
+# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.
 m4_define([_LT_ENABLE_FAST_INSTALL],
 [m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl
 AC_ARG_ENABLE([fast-install],
@@ -280,14 +282,14 @@ AC_ARG_ENABLE([fast-install],
     *)
       enable_fast_install=no
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for pkg in $enableval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$pkg" = "X$p"; then
 	  enable_fast_install=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       ;;
     esac],
     [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)
@@ -304,14 +306,14 @@ AU_DEFUN([AC_ENABLE_FAST_INSTALL],
 [_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])
 AC_DIAGNOSE([obsolete],
 [$0: Remove this warning and the call to _LT_SET_OPTION when you put
-the `fast-install' option into LT_INIT's first parameter.])
+the 'fast-install' option into LT_INIT's first parameter.])
 ])
 
 AU_DEFUN([AC_DISABLE_FAST_INSTALL],
 [_LT_SET_OPTION([LT_INIT], [disable-fast-install])
 AC_DIAGNOSE([obsolete],
 [$0: Remove this warning and the call to _LT_SET_OPTION when you put
-the `disable-fast-install' option into LT_INIT's first parameter.])
+the 'disable-fast-install' option into LT_INIT's first parameter.])
 ])
 
 dnl aclocal-1.4 backwards compatibility:
@@ -319,11 +321,64 @@ dnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])
 dnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])
 
 
+# _LT_WITH_AIX_SONAME([DEFAULT])
+# ----------------------------------
+# implement the --with-aix-soname flag, and support the `aix-soname=aix'
+# and `aix-soname=both' and `aix-soname=svr4' LT_INIT options. DEFAULT
+# is either `aix', `both' or `svr4'.  If omitted, it defaults to `aix'.
+m4_define([_LT_WITH_AIX_SONAME],
+[m4_define([_LT_WITH_AIX_SONAME_DEFAULT], [m4_if($1, svr4, svr4, m4_if($1, both, both, aix))])dnl
+shared_archive_member_spec=
+case $host,$enable_shared in
+power*-*-aix[[5-9]]*,yes)
+  AC_MSG_CHECKING([which variant of shared library versioning to provide])
+  AC_ARG_WITH([aix-soname],
+    [AS_HELP_STRING([--with-aix-soname=aix|svr4|both],
+      [shared library versioning (aka "SONAME") variant to provide on AIX, @<:@default=]_LT_WITH_AIX_SONAME_DEFAULT[@:>@.])],
+    [case $withval in
+    aix|svr4|both)
+      ;;
+    *)
+      AC_MSG_ERROR([Unknown argument to --with-aix-soname])
+      ;;
+    esac
+    lt_cv_with_aix_soname=$with_aix_soname],
+    [AC_CACHE_VAL([lt_cv_with_aix_soname],
+      [lt_cv_with_aix_soname=]_LT_WITH_AIX_SONAME_DEFAULT)
+    with_aix_soname=$lt_cv_with_aix_soname])
+  AC_MSG_RESULT([$with_aix_soname])
+  if test aix != "$with_aix_soname"; then
+    # For the AIX way of multilib, we name the shared archive member
+    # based on the bitwidth used, traditionally 'shr.o' or 'shr_64.o',
+    # and 'shr.imp' or 'shr_64.imp', respectively, for the Import File.
+    # Even when GNU compilers ignore OBJECT_MODE but need '-maix64' flag,
+    # the AIX toolchain works better with OBJECT_MODE set (default 32).
+    if test 64 = "${OBJECT_MODE-32}"; then
+      shared_archive_member_spec=shr_64
+    else
+      shared_archive_member_spec=shr
+    fi
+  fi
+  ;;
+*)
+  with_aix_soname=aix
+  ;;
+esac
+
+_LT_DECL([], [shared_archive_member_spec], [0],
+    [Shared archive member basename, for filename based shared library versioning on AIX])dnl
+])# _LT_WITH_AIX_SONAME
+
+LT_OPTION_DEFINE([LT_INIT], [aix-soname=aix], [_LT_WITH_AIX_SONAME([aix])])
+LT_OPTION_DEFINE([LT_INIT], [aix-soname=both], [_LT_WITH_AIX_SONAME([both])])
+LT_OPTION_DEFINE([LT_INIT], [aix-soname=svr4], [_LT_WITH_AIX_SONAME([svr4])])
+
+
 # _LT_WITH_PIC([MODE])
 # --------------------
-# implement the --with-pic flag, and support the `pic-only' and `no-pic'
+# implement the --with-pic flag, and support the 'pic-only' and 'no-pic'
 # LT_INIT options.
-# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.
+# MODE is either 'yes' or 'no'.  If omitted, it defaults to 'both'.
 m4_define([_LT_WITH_PIC],
 [AC_ARG_WITH([pic],
     [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],
@@ -334,19 +389,17 @@ m4_define([_LT_WITH_PIC],
     *)
       pic_mode=default
       # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,
       for lt_pkg in $withval; do
-	IFS="$lt_save_ifs"
+	IFS=$lt_save_ifs
 	if test "X$lt_pkg" = "X$lt_p"; then
 	  pic_mode=yes
 	fi
       done
-      IFS="$lt_save_ifs"
+      IFS=$lt_save_ifs
       ;;
     esac],
-    [pic_mode=default])
-
-test -z "$pic_mode" && pic_mode=m4_default([$1], [default])
+    [pic_mode=m4_default([$1], [default])])
 
 _LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl
 ])# _LT_WITH_PIC
@@ -359,7 +412,7 @@ AU_DEFUN([AC_LIBTOOL_PICMODE],
 [_LT_SET_OPTION([LT_INIT], [pic-only])
 AC_DIAGNOSE([obsolete],
 [$0: Remove this warning and the call to _LT_SET_OPTION when you
-put the `pic-only' option into LT_INIT's first parameter.])
+put the 'pic-only' option into LT_INIT's first parameter.])
 ])
 
 dnl aclocal-1.4 backwards compatibility:
diff --git a/lib/Analysis/isl/m4/ltsugar.m4 b/lib/Analysis/isl/m4/ltsugar.m4
index 9000a05..48bc934 100644
--- a/lib/Analysis/isl/m4/ltsugar.m4
+++ b/lib/Analysis/isl/m4/ltsugar.m4
@@ -1,6 +1,7 @@
 # ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-
 #
-# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+# Copyright (C) 2004-2005, 2007-2008, 2011-2015 Free Software
+# Foundation, Inc.
 # Written by Gary V. Vaughan, 2004
 #
 # This file is free software; the Free Software Foundation gives
@@ -33,7 +34,7 @@ m4_define([_lt_join],
 # ------------
 # Manipulate m4 lists.
 # These macros are necessary as long as will still need to support
-# Autoconf-2.59 which quotes differently.
+# Autoconf-2.59, which quotes differently.
 m4_define([lt_car], [[$1]])
 m4_define([lt_cdr],
 [m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
@@ -44,7 +45,7 @@ m4_define([lt_unquote], $1)
 
 # lt_append(MACRO-NAME, STRING, [SEPARATOR])
 # ------------------------------------------
-# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.
+# Redefine MACRO-NAME to hold its former content plus 'SEPARATOR''STRING'.
 # Note that neither SEPARATOR nor STRING are expanded; they are appended
 # to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).
 # No SEPARATOR is output if MACRO-NAME was previously undefined (different
diff --git a/lib/Analysis/isl/m4/ltversion.m4 b/lib/Analysis/isl/m4/ltversion.m4
index 07a8602..fa04b52 100644
--- a/lib/Analysis/isl/m4/ltversion.m4
+++ b/lib/Analysis/isl/m4/ltversion.m4
@@ -1,6 +1,6 @@
 # ltversion.m4 -- version numbers			-*- Autoconf -*-
 #
-#   Copyright (C) 2004 Free Software Foundation, Inc.
+#   Copyright (C) 2004, 2011-2015 Free Software Foundation, Inc.
 #   Written by Scott James Remnant, 2004
 #
 # This file is free software; the Free Software Foundation gives
@@ -9,15 +9,15 @@
 
 # @configure_input@
 
-# serial 3337 ltversion.m4
+# serial 4179 ltversion.m4
 # This file is part of GNU Libtool
 
-m4_define([LT_PACKAGE_VERSION], [2.4.2])
-m4_define([LT_PACKAGE_REVISION], [1.3337])
+m4_define([LT_PACKAGE_VERSION], [2.4.6])
+m4_define([LT_PACKAGE_REVISION], [2.4.6])
 
 AC_DEFUN([LTVERSION_VERSION],
-[macro_version='2.4.2'
-macro_revision='1.3337'
+[macro_version='2.4.6'
+macro_revision='2.4.6'
 _LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])
 _LT_DECL(, macro_revision, 0)
 ])
diff --git a/lib/Analysis/isl/m4/lt~obsolete.m4 b/lib/Analysis/isl/m4/lt~obsolete.m4
index c573da9..c6b26f8 100644
--- a/lib/Analysis/isl/m4/lt~obsolete.m4
+++ b/lib/Analysis/isl/m4/lt~obsolete.m4
@@ -1,6 +1,7 @@
 # lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-
 #
-#   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.
+#   Copyright (C) 2004-2005, 2007, 2009, 2011-2015 Free Software
+#   Foundation, Inc.
 #   Written by Scott James Remnant, 2004.
 #
 # This file is free software; the Free Software Foundation gives
@@ -11,7 +12,7 @@
 
 # These exist entirely to fool aclocal when bootstrapping libtool.
 #
-# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)
+# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN),
 # which have later been changed to m4_define as they aren't part of the
 # exported API, or moved to Autoconf or Automake where they belong.
 #
@@ -25,7 +26,7 @@
 # included after everything else.  This provides aclocal with the
 # AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything
 # because those macros already exist, or will be overwritten later.
-# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. 
+# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6.
 #
 # Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.
 # Yes, that means every name once taken will need to remain here until
diff --git a/lib/Analysis/isl/pip.c b/lib/Analysis/isl/pip.c
index 72b2bef..002bc70 100644
--- a/lib/Analysis/isl/pip.c
+++ b/lib/Analysis/isl/pip.c
@@ -94,30 +94,43 @@ static struct isl_basic_set *to_parameter_domain(struct isl_basic_set *context)
 	return context;
 }
 
-isl_basic_set *plug_in_parameters(isl_basic_set *bset, struct isl_vec *params)
+/* Plug in the initial values of "params" for the parameters in "bset" and
+ * return the result.  The remaining entries in "params", if any,
+ * correspond to the existentially quantified variables in the description
+ * of the original context and can be ignored.
+ */
+static __isl_give isl_basic_set *plug_in_parameters(
+	__isl_take isl_basic_set *bset, __isl_take isl_vec *params)
 {
-	int i;
+	int i, n;
 
-	for (i = 0; i < params->size - 1; ++i)
+	n = isl_basic_set_dim(bset, isl_dim_param);
+	for (i = 0; i < n; ++i)
 		bset = isl_basic_set_fix(bset,
 					 isl_dim_param, i, params->el[1 + i]);
 
-	bset = isl_basic_set_remove_dims(bset,
-					 isl_dim_param, 0, params->size - 1);
+	bset = isl_basic_set_remove_dims(bset, isl_dim_param, 0, n);
 
 	isl_vec_free(params);
 
 	return bset;
 }
 
-isl_set *set_plug_in_parameters(isl_set *set, struct isl_vec *params)
+/* Plug in the initial values of "params" for the parameters in "set" and
+ * return the result.  The remaining entries in "params", if any,
+ * correspond to the existentially quantified variables in the description
+ * of the original context and can be ignored.
+ */
+static __isl_give isl_set *set_plug_in_parameters(__isl_take isl_set *set,
+	__isl_take isl_vec *params)
 {
-	int i;
+	int i, n;
 
-	for (i = 0; i < params->size - 1; ++i)
+	n = isl_set_dim(set, isl_dim_param);
+	for (i = 0; i < n; ++i)
 		set = isl_set_fix(set, isl_dim_param, i, params->el[1 + i]);
 
-	set = isl_set_remove_dims(set, isl_dim_param, 0, params->size - 1);
+	set = isl_set_remove_dims(set, isl_dim_param, 0, n);
 
 	isl_vec_free(params);
 
@@ -128,10 +141,11 @@ isl_set *set_plug_in_parameters(isl_set *set, struct isl_vec *params)
  * element of bset for the given values of the parameters, by
  * successively solving an ilp problem in each direction.
  */
-struct isl_vec *opt_at(struct isl_basic_set *bset,
-	struct isl_vec *params, int max)
+static __isl_give isl_vec *opt_at(__isl_take isl_basic_set *bset,
+	__isl_take isl_vec *params, int max)
 {
 	unsigned dim;
+	isl_ctx *ctx;
 	struct isl_vec *opt;
 	struct isl_vec *obj;
 	int i;
@@ -140,16 +154,17 @@ struct isl_vec *opt_at(struct isl_basic_set *bset,
 
 	bset = plug_in_parameters(bset, params);
 
+	ctx = isl_basic_set_get_ctx(bset);
 	if (isl_basic_set_plain_is_empty(bset)) {
-		opt = isl_vec_alloc(bset->ctx, 0);
+		opt = isl_vec_alloc(ctx, 0);
 		isl_basic_set_free(bset);
 		return opt;
 	}
 
-	opt = isl_vec_alloc(bset->ctx, 1 + dim);
+	opt = isl_vec_alloc(ctx, 1 + dim);
 	assert(opt);
 
-	obj = isl_vec_alloc(bset->ctx, 1 + dim);
+	obj = isl_vec_alloc(ctx, 1 + dim);
 	assert(obj);
 
 	isl_int_set_si(opt->el[0], 1);
@@ -174,7 +189,7 @@ struct isl_vec *opt_at(struct isl_basic_set *bset,
 	return opt;
 empty:
 	isl_vec_free(opt);
-	opt = isl_vec_alloc(bset->ctx, 0);
+	opt = isl_vec_alloc(ctx, 0);
 	isl_basic_set_free(bset);
 	isl_vec_free(obj);
 
diff --git a/lib/Analysis/isl/pip_test.sh.in b/lib/Analysis/isl/pip_test.sh.in
index 28ad1ef..5f36b77 100755
--- a/lib/Analysis/isl/pip_test.sh.in
+++ b/lib/Analysis/isl/pip_test.sh.in
@@ -1,6 +1,7 @@
 #!/bin/sh
 
 EXEEXT=@EXEEXT@
+srcdir=@srcdir@
 
 PIP_TESTS="\
 	boulet.pip \
@@ -9,6 +10,8 @@ PIP_TESTS="\
 	esced.pip \
 	ex2.pip \
 	ex.pip \
+	exist.pip \
+	exist2.pip \
 	fimmel.pip \
 	max.pip \
 	negative.pip \
diff --git a/lib/Analysis/isl/print.c b/lib/Analysis/isl/print.c
index 4d724e7..bea1ff1 100644
--- a/lib/Analysis/isl/print.c
+++ b/lib/Analysis/isl/print.c
@@ -100,7 +100,7 @@
 #include <print_templ.c>
 #undef BASE
 #define BASE ast_expr
-#include <print_templ.c>
+#include <print_templ_yaml.c>
 #undef BASE
 #define BASE ast_node
-#include <print_templ.c>
+#include <print_templ_yaml.c>
diff --git a/lib/Analysis/isl/print_templ_yaml.c b/lib/Analysis/isl/print_templ_yaml.c
new file mode 100644
index 0000000..50f7f1f
--- /dev/null
+++ b/lib/Analysis/isl/print_templ_yaml.c
@@ -0,0 +1,39 @@
+#define xCAT(A,B) A ## B
+#define CAT(A,B) xCAT(A,B)
+#undef TYPE
+#define TYPE CAT(isl_,BASE)
+#define xFN(TYPE,NAME) TYPE ## _ ## NAME
+#define FN(TYPE,NAME) xFN(TYPE,NAME)
+
+void FN(TYPE,dump)(__isl_keep TYPE *obj)
+{
+	isl_printer *p;
+
+	if (!obj)
+		return;
+
+	p = isl_printer_to_file(FN(TYPE,get_ctx)(obj), stderr);
+	p = isl_printer_set_yaml_style(p, ISL_YAML_STYLE_BLOCK);
+	p = FN(isl_printer_print,BASE)(p, obj);
+	isl_printer_free(p);
+}
+
+/* Return a string representation of "obj".
+ * Print the object in flow format.
+ */
+__isl_give char *FN(TYPE,to_str)(__isl_keep TYPE *obj)
+{
+	isl_printer *p;
+	char *s;
+
+	if (!obj)
+		return NULL;
+
+	p = isl_printer_to_str(FN(TYPE,get_ctx)(obj));
+	p = isl_printer_set_yaml_style(p, ISL_YAML_STYLE_FLOW);
+	p = FN(isl_printer_print,BASE)(p, obj);
+	s = isl_printer_get_str(p);
+	isl_printer_free(p);
+
+	return s;
+}
diff --git a/lib/Analysis/isl/read_in_string_templ.c b/lib/Analysis/isl/read_in_string_templ.c
new file mode 100644
index 0000000..3dc630e
--- /dev/null
+++ b/lib/Analysis/isl/read_in_string_templ.c
@@ -0,0 +1,38 @@
+#include <isl/stream.h>
+
+#define xCAT(A,B) A ## B
+#define CAT(A,B) xCAT(A,B)
+#undef TYPE
+#define TYPE CAT(isl_,BASE)
+#define xFN(TYPE,NAME) TYPE ## _ ## NAME
+#define FN(TYPE,NAME) xFN(TYPE,NAME)
+
+/* Read an object of type TYPE from "s", where the object may
+ * either be specified directly or as a string.
+ *
+ * First check if the next token in "s" is a string.  If so, try and
+ * extract the object from the string.
+ * Otherwise, try and read the object directly from "s".
+ */
+static __isl_give TYPE *FN(read,BASE)(__isl_keep isl_stream *s)
+{
+	struct isl_token *tok;
+	int type;
+
+	tok = isl_stream_next_token(s);
+	type = isl_token_get_type(tok);
+	if (type == ISL_TOKEN_STRING) {
+		char *str;
+		isl_ctx *ctx;
+		TYPE *res;
+
+		ctx = isl_stream_get_ctx(s);
+		str = isl_token_get_str(ctx, tok);
+		res = FN(TYPE,read_from_str)(ctx, str);
+		free(str);
+		isl_token_free(tok);
+		return res;
+	}
+	isl_stream_push_token(s, tok);
+	return FN(isl_stream_read,BASE)(s);
+}
diff --git a/lib/Analysis/isl/schedule.c b/lib/Analysis/isl/schedule.c
new file mode 100644
index 0000000..2373914
--- /dev/null
+++ b/lib/Analysis/isl/schedule.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016      Sven Verdoolaege
+ *
+ * Use of this software is governed by the MIT license
+ *
+ * Written by Sven Verdoolaege.
+ */
+
+/* This program takes an isl_schedule_constraints object as input and
+ * prints a schedule that satisfies those constraints.
+ */
+
+#include <stdlib.h>
+#include <isl/options.h>
+#include <isl/schedule.h>
+
+int main(int argc, char **argv)
+{
+	isl_ctx *ctx;
+	isl_printer *p;
+	isl_schedule_constraints *sc;
+	isl_schedule *schedule;
+	struct isl_options *options;
+
+	options = isl_options_new_with_defaults();
+	argc = isl_options_parse(options, argc, argv, ISL_ARG_ALL);
+	ctx = isl_ctx_alloc_with_options(&isl_options_args, options);
+
+	sc = isl_schedule_constraints_read_from_file(ctx, stdin);
+	schedule = isl_schedule_constraints_compute_schedule(sc);
+
+	p = isl_printer_to_file(ctx, stdout);
+	p = isl_printer_set_yaml_style(p, ISL_YAML_STYLE_BLOCK);
+	p = isl_printer_print_schedule(p, schedule);
+	isl_printer_free(p);
+
+	isl_schedule_free(schedule);
+
+	isl_ctx_free(ctx);
+
+	return p ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/lib/Analysis/isl/schedule_cmp.c b/lib/Analysis/isl/schedule_cmp.c
new file mode 100644
index 0000000..8bf02ea
--- /dev/null
+++ b/lib/Analysis/isl/schedule_cmp.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2017      Sven Verdoolaege
+ *
+ * Use of this software is governed by the MIT license
+ *
+ * Written by Sven Verdoolaege.
+ */
+
+#include <stdlib.h>
+
+#include <isl/arg.h>
+#include <isl/options.h>
+#include <isl/schedule.h>
+
+struct options {
+	struct isl_options *isl;
+	char *schedule1;
+	char *schedule2;
+};
+
+ISL_ARGS_START(struct options, options_args)
+ISL_ARG_CHILD(struct options, isl, "isl", &isl_options_args, "isl options")
+ISL_ARG_ARG(struct options, schedule1, "schedule1", NULL)
+ISL_ARG_ARG(struct options, schedule2, "schedule2", NULL)
+ISL_ARGS_END
+
+ISL_ARG_DEF(options, struct options, options_args)
+
+static void die(const char *msg)
+{
+	fprintf(stderr, "%s\n", msg);
+	exit(EXIT_FAILURE);
+}
+
+static FILE *open_or_die(const char *filename)
+{
+	FILE *file;
+
+	file = fopen(filename, "r");
+	if (!file) {
+		fprintf(stderr, "Unable to open %s\n", filename);
+		exit(EXIT_FAILURE);
+	}
+	return file;
+}
+
+/* Given two YAML descriptions of isl_schedule objects, check whether
+ * they are equivalent.
+ * Return EXIT_SUCCESS if they are and EXIT_FAILURE if they are not
+ * or if anything else went wrong.
+ */
+int main(int argc, char **argv)
+{
+	isl_ctx *ctx;
+	struct options *options;
+	FILE *input1, *input2;
+	isl_bool equal;
+	isl_schedule *s1, *s2;
+
+	options = options_new_with_defaults();
+	if (!options)
+		return EXIT_FAILURE;
+
+	ctx = isl_ctx_alloc_with_options(&options_args, options);
+	argc = options_parse(options, argc, argv, ISL_ARG_ALL);
+
+	input1 = open_or_die(options->schedule1);
+	input2 = open_or_die(options->schedule2);
+	s1 = isl_schedule_read_from_file(ctx, input1);
+	s2 = isl_schedule_read_from_file(ctx, input2);
+
+	equal = isl_schedule_plain_is_equal(s1, s2);
+	if (equal < 0)
+		return EXIT_FAILURE;
+	if (!equal)
+		die("schedules differ");
+
+	isl_schedule_free(s1);
+	isl_schedule_free(s2);
+	fclose(input1);
+	fclose(input2);
+	isl_ctx_free(ctx);
+
+	return EXIT_SUCCESS;
+}
diff --git a/lib/Analysis/isl/schedule_test.sh.in b/lib/Analysis/isl/schedule_test.sh.in
new file mode 100644
index 0000000..afba802
--- /dev/null
+++ b/lib/Analysis/isl/schedule_test.sh.in
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+EXEEXT=@EXEEXT@
+GREP=@GREP@
+SED=@SED@
+srcdir=@srcdir@
+
+failed=0
+
+for i in $srcdir/test_inputs/schedule/*.sc; do
+	echo $i;
+	base=`basename $i .sc`
+	test=test-$base.st
+	dir=`dirname $i`
+	ref=$dir/$base.st
+	options=`$GREP 'OPTIONS:' $i | $SED 's/.*://'`
+	(./isl_schedule$EXEEXT $options < $i > $test &&
+	./isl_schedule_cmp$EXEEXT $ref $test && rm $test) || failed=1
+done
+
+test $failed -eq 0 || exit
diff --git a/lib/Analysis/isl/set_from_map.c b/lib/Analysis/isl/set_from_map.c
new file mode 100644
index 0000000..cf6f814
--- /dev/null
+++ b/lib/Analysis/isl/set_from_map.c
@@ -0,0 +1,8 @@
+#include <isl/map_type.h>
+
+/* Return the set that was treated as the map "map".
+ */
+static __isl_give isl_set *set_from_map(__isl_take isl_map *map)
+{
+	return (isl_set *) map;
+}
diff --git a/lib/Analysis/isl/set_to_map.c b/lib/Analysis/isl/set_to_map.c
new file mode 100644
index 0000000..dc67ed2
--- /dev/null
+++ b/lib/Analysis/isl/set_to_map.c
@@ -0,0 +1,10 @@
+#include <isl/map_type.h>
+
+/* Treat "set" as a map.
+ * Internally, isl_set is defined to isl_map, so in practice,
+ * this function performs a redundant cast.
+ */
+static __isl_give isl_map *set_to_map(__isl_take isl_set *set)
+{
+	return (isl_map *) set;
+}
diff --git a/lib/Analysis/isl/test-driver b/lib/Analysis/isl/test-driver
new file mode 100755
index 0000000..8e575b0
--- /dev/null
+++ b/lib/Analysis/isl/test-driver
@@ -0,0 +1,148 @@
+#! /bin/sh
+# test-driver - basic testsuite driver script.
+
+scriptversion=2013-07-13.22; # UTC
+
+# Copyright (C) 2011-2014 Free Software Foundation, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# This file is maintained in Automake, please report
+# bugs to <bug-automake@gnu.org> or send patches to
+# <automake-patches@gnu.org>.
+
+# Make unconditional expansion of undefined variables an error.  This
+# helps a lot in preventing typo-related bugs.
+set -u
+
+usage_error ()
+{
+  echo "$0: $*" >&2
+  print_usage >&2
+  exit 2
+}
+
+print_usage ()
+{
+  cat <<END
+Usage:
+  test-driver --test-name=NAME --log-file=PATH --trs-file=PATH
+              [--expect-failure={yes|no}] [--color-tests={yes|no}]
+              [--enable-hard-errors={yes|no}] [--]
+              TEST-SCRIPT [TEST-SCRIPT-ARGUMENTS]
+The '--test-name', '--log-file' and '--trs-file' options are mandatory.
+END
+}
+
+test_name= # Used for reporting.
+log_file=  # Where to save the output of the test script.
+trs_file=  # Where to save the metadata of the test run.
+expect_failure=no
+color_tests=no
+enable_hard_errors=yes
+while test $# -gt 0; do
+  case $1 in
+  --help) print_usage; exit $?;;
+  --version) echo "test-driver $scriptversion"; exit $?;;
+  --test-name) test_name=$2; shift;;
+  --log-file) log_file=$2; shift;;
+  --trs-file) trs_file=$2; shift;;
+  --color-tests) color_tests=$2; shift;;
+  --expect-failure) expect_failure=$2; shift;;
+  --enable-hard-errors) enable_hard_errors=$2; shift;;
+  --) shift; break;;
+  -*) usage_error "invalid option: '$1'";;
+   *) break;;
+  esac
+  shift
+done
+
+missing_opts=
+test x"$test_name" = x && missing_opts="$missing_opts --test-name"
+test x"$log_file"  = x && missing_opts="$missing_opts --log-file"
+test x"$trs_file"  = x && missing_opts="$missing_opts --trs-file"
+if test x"$missing_opts" != x; then
+  usage_error "the following mandatory options are missing:$missing_opts"
+fi
+
+if test $# -eq 0; then
+  usage_error "missing argument"
+fi
+
+if test $color_tests = yes; then
+  # Keep this in sync with 'lib/am/check.am:$(am__tty_colors)'.
+  red='[0;31m' # Red.
+  grn='[0;32m' # Green.
+  lgn='[1;32m' # Light green.
+  blu='[1;34m' # Blue.
+  mgn='[0;35m' # Magenta.
+  std='[m'     # No color.
+else
+  red= grn= lgn= blu= mgn= std=
+fi
+
+do_exit='rm -f $log_file $trs_file; (exit $st); exit $st'
+trap "st=129; $do_exit" 1
+trap "st=130; $do_exit" 2
+trap "st=141; $do_exit" 13
+trap "st=143; $do_exit" 15
+
+# Test script is run here.
+"$@" >$log_file 2>&1
+estatus=$?
+
+if test $enable_hard_errors = no && test $estatus -eq 99; then
+  tweaked_estatus=1
+else
+  tweaked_estatus=$estatus
+fi
+
+case $tweaked_estatus:$expect_failure in
+  0:yes) col=$red res=XPASS recheck=yes gcopy=yes;;
+  0:*)   col=$grn res=PASS  recheck=no  gcopy=no;;
+  77:*)  col=$blu res=SKIP  recheck=no  gcopy=yes;;
+  99:*)  col=$mgn res=ERROR recheck=yes gcopy=yes;;
+  *:yes) col=$lgn res=XFAIL recheck=no  gcopy=yes;;
+  *:*)   col=$red res=FAIL  recheck=yes gcopy=yes;;
+esac
+
+# Report the test outcome and exit status in the logs, so that one can
+# know whether the test passed or failed simply by looking at the '.log'
+# file, without the need of also peaking into the corresponding '.trs'
+# file (automake bug#11814).
+echo "$res $test_name (exit status: $estatus)" >>$log_file
+
+# Report outcome to console.
+echo "${col}${res}${std}: $test_name"
+
+# Register the test result, and other relevant metadata.
+echo ":test-result: $res" > $trs_file
+echo ":global-test-result: $res" >> $trs_file
+echo ":recheck: $recheck" >> $trs_file
+echo ":copy-in-global-log: $gcopy" >> $trs_file
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/lib/Analysis/isl/test_inputs/affine.polylib b/lib/Analysis/isl/test_inputs/affine.polylib
new file mode 100644
index 0000000..f14720c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/affine.polylib
@@ -0,0 +1,9 @@
+# the affine hull of {[a,b] : a=b && 1 <= a <= 163} ...
+3 4
+0 1 -1 0
+1 1  0 -1
+1 -1 0 163
+
+# ... is {[a,b] : a=b} (and not {[In_1,In_2]}, as Omega 1.2 claims)
+1 4
+0 1 -1 0
diff --git a/lib/Analysis/isl/test_inputs/affine2.polylib b/lib/Analysis/isl/test_inputs/affine2.polylib
new file mode 100644
index 0000000..c67db77
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/affine2.polylib
@@ -0,0 +1,9 @@
+5 5
+1 -2 0 1 0
+1 2 0 -1 1
+1 0 -2 1 0
+1 0 2 -1 1
+1 0 0 1 -1
+
+1 5
+0 1 -1 0 0
diff --git a/lib/Analysis/isl/test_inputs/affine3.polylib b/lib/Analysis/isl/test_inputs/affine3.polylib
new file mode 100644
index 0000000..f2bc9a2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/affine3.polylib
@@ -0,0 +1,7 @@
+3 4
+1 1 0 0
+1 -7 4 2
+1 5 -4 2
+
+1 4
+0 3 -2 0
diff --git a/lib/Analysis/isl/test_inputs/application.omega b/lib/Analysis/isl/test_inputs/application.omega
new file mode 100644
index 0000000..8f4fd1d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/application.omega
@@ -0,0 +1,3 @@
+{[x]}
+{[x] -> [y] : y = 2x}
+{[y]: Exists ( alpha : 2alpha = y)}
diff --git a/lib/Analysis/isl/test_inputs/application2.omega b/lib/Analysis/isl/test_inputs/application2.omega
new file mode 100644
index 0000000..f2af1e8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/application2.omega
@@ -0,0 +1,3 @@
+{[x] : x >= 0 && x <= 20 }
+{[x] -> [y] : y = 2x}
+{[y]: Exists ( alpha : 2alpha = y && 0 <= y && y <= 40)}
diff --git a/lib/Analysis/isl/test_inputs/basicLinear.pwqp b/lib/Analysis/isl/test_inputs/basicLinear.pwqp
new file mode 100644
index 0000000..0af7fab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/basicLinear.pwqp
@@ -0,0 +1 @@
+[P, Q] -> { [n, m] -> n : n >= 1 and m >= n and m <= P and m <= Q }
diff --git a/lib/Analysis/isl/test_inputs/basicLinear2.pwqp b/lib/Analysis/isl/test_inputs/basicLinear2.pwqp
new file mode 100644
index 0000000..d411a36
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/basicLinear2.pwqp
@@ -0,0 +1 @@
+[P, Q] -> { [n, m] -> n : n >= 1 and m >= n and m <= P and n >= -1 + Q }
diff --git a/lib/Analysis/isl/test_inputs/basicTest.pwqp b/lib/Analysis/isl/test_inputs/basicTest.pwqp
new file mode 100644
index 0000000..52e7fc8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/basicTest.pwqp
@@ -0,0 +1 @@
+[p] -> { [n, m] -> (n + n^2) : n >= 1 and m >= n and m <= p }
diff --git a/lib/Analysis/isl/test_inputs/basicTestParameterPosNeg.pwqp b/lib/Analysis/isl/test_inputs/basicTestParameterPosNeg.pwqp
new file mode 100644
index 0000000..6cb4490
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/basicTestParameterPosNeg.pwqp
@@ -0,0 +1 @@
+[p] -> { [n, m] -> (n + n^3) : n >= -1 and m >= n and m <= p }
diff --git a/lib/Analysis/isl/test_inputs/boulet.pip b/lib/Analysis/isl/test_inputs/boulet.pip
new file mode 100644
index 0000000..78e90dd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/boulet.pip
@@ -0,0 +1,13 @@
+0 3
+
+-1
+
+5 6
+1 1 -1  2 0 0
+1 0  1  1 4 20
+1 0 -1 -1 0 0
+1 0  1 -1 2 10
+1 0 -1  1 2 10
+
+Urs_parms
+Urs_unknowns
diff --git a/lib/Analysis/isl/test_inputs/brisebarre.pip b/lib/Analysis/isl/test_inputs/brisebarre.pip
new file mode 100644
index 0000000..f3decad
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/brisebarre.pip
@@ -0,0 +1,34 @@
+# ---------------------- CONTEXT ----------------------
+1 2
+1    0
+
+-1
+
+# ----------------------- DOMAIN ----------------------
+26 6
+1    3    0    0     0    -98300
+1   -3    0    0     0     98308
+1  432   36    6     1 -14757611
+1 -432  -36   -6    -1  14758510
+1   54    9    3     1  -1923190
+1  -54   -9   -3    -1   1923303
+1   48   12    6     3  -1782238
+1  -48  -12   -6    -3   1782339
+1   27    9    6     4  -1045164
+1  -27   -9   -6    -4   1045221
+1  432  180  150   125 -17434139
+1 -432 -180 -150  -125  17435038
+1    6    3    3     3   -252443
+1   -6   -3   -3    -3    252456
+1  432  252  294   343 -18949275
+1 -432 -252 -294  -343  18950174
+1   27   18   24    32  -1234720
+1  -27  -18  -24   -32   1234777
+1   48   36   54    81  -2288453
+1  -48  -36  -54   -81   2288554
+1   54   45   75   125  -2684050
+1  -54  -45  -75  -125   2684163
+1  432  396  726  1331 -22386005
+1 -432 -396 -726 -1331  22386904
+1    3    3    6    12   -162072
+1   -3   -3   -6   -12    162080
diff --git a/lib/Analysis/isl/test_inputs/cg1.pip b/lib/Analysis/isl/test_inputs/cg1.pip
new file mode 100644
index 0000000..78e31f1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/cg1.pip
@@ -0,0 +1,15 @@
+2 4
+  1  1  0 -1
+  1 -1  1  0
+
+-1
+
+8 7
+  1  0  1  0 -1  0  0
+  1  0 -1  0  1  0  0
+  1  1  0  0  0 -1  0
+  1 -1  0  0  0  1  0
+  1  0  1  0  0  0 -1
+  1  0 -1  0  0  1  0
+  1  0 -1  1  0  0 -1
+  1  0  0 -1  0  1  0
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic.c b/lib/Analysis/isl/test_inputs/codegen/atomic.c
new file mode 100644
index 0000000..0b70279
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 <= 10; c0 += 1) {
+  if (c0 <= 9)
+    a(c0);
+  if (c0 >= 1)
+    b(c0 - 1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic.in b/lib/Analysis/isl/test_inputs/codegen/atomic.in
new file mode 100644
index 0000000..6d8f818
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic.in
@@ -0,0 +1,3 @@
+{ a[i] -> [i, 0] : 0 <= i < 10; b[i] -> [i+1, 1] : 0 <= i < 10 }
+{ : }
+{ [i, d] -> atomic[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic.st b/lib/Analysis/isl/test_inputs/codegen/atomic.st
new file mode 100644
index 0000000..7591b05
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic.st
@@ -0,0 +1,8 @@
+domain: "{ a[i] : 0 <= i < 10; b[i] : 0 <= i < 10 }"
+child:
+  schedule: "[{ a[i] -> [i]; b[i] -> [i+1] }]"
+  options: "{ atomic[x] }"
+  child:
+    sequence:
+    - filter: "{ a[i] }"
+    - filter: "{ b[i] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic2.c b/lib/Analysis/isl/test_inputs/codegen/atomic2.c
new file mode 100644
index 0000000..9c4a57e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic2.c
@@ -0,0 +1,2 @@
+for (int c0 = ((b0 + 32767) % 32768) + 1; c0 <= 65534; c0 += 32768)
+  A(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic2.in b/lib/Analysis/isl/test_inputs/codegen/atomic2.in
new file mode 100644
index 0000000..99901d0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic2.in
@@ -0,0 +1,4 @@
+# Check that isl properly handles atomic domains that are unions.
+[nn, b0] -> { A[a] -> [a, 0, b0] : exists (e0 = [(b0 - a)/32768]: 32768e0 = b0 - a and a >= 1 and b0 >= 0 and b0 <= 32767 and a <= 65534) }
+[nn, b0] -> { : b0 >= 0 and b0 <= 32767 }
+[nn, b0] -> { [a, b, c] -> atomic[2] : c >= 1; [a, 0, c] -> atomic[2] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic3.c b/lib/Analysis/isl/test_inputs/codegen/atomic3.c
new file mode 100644
index 0000000..c6deb76
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic3.c
@@ -0,0 +1,9 @@
+for (int c0 = 0; c0 <= 64; c0 += 1) {
+  if (c0 >= 63) {
+    sync();
+  } else if (c0 >= 1) {
+    sync();
+  } else {
+    sync();
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic3.in b/lib/Analysis/isl/test_inputs/codegen/atomic3.in
new file mode 100644
index 0000000..4d0c495
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic3.in
@@ -0,0 +1,5 @@
+# Check that isl is not confused by inconsistent
+# separation_class and atomic options.
+{ sync[] -> [i, 0] : 0 <= i <= 64 }
+{ : }
+{ [i, 0] -> separation_class[[1] -> [0]] : 1 <= i <= 62; [i, 0] -> atomic[1]}
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic4.c b/lib/Analysis/isl/test_inputs/codegen/atomic4.c
new file mode 100644
index 0000000..624c2af
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic4.c
@@ -0,0 +1,2 @@
+for (int c0 = 0; c0 <= 64; c0 += 1)
+  sync();
diff --git a/lib/Analysis/isl/test_inputs/codegen/atomic4.in b/lib/Analysis/isl/test_inputs/codegen/atomic4.in
new file mode 100644
index 0000000..c5dab10
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/atomic4.in
@@ -0,0 +1,4 @@
+# Check that isl is not confused by inconsistent separate and atomic options.
+{ sync[] -> [i, 0] : 0 <= i <= 64 }
+{ : }
+{ [i, 0] -> separate[1] : 1 <= i <= 62; [i, 0] -> atomic[1] : i <= 10 or i >= 20 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cholesky.c b/lib/Analysis/isl/test_inputs/codegen/cholesky.c
new file mode 100644
index 0000000..7e6f215
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cholesky.c
@@ -0,0 +1,4 @@
+for (int c0 = 3993; c0 <= 63893; c0 += 1)
+  if (2 * c0 - 3993 * ((3 * c0 + 5990) / 5990) >= 0)
+    for (int c4 = -c0 + 1997 * ((3 * c0 + 5990) / 5990) + 1; c4 <= 12; c4 += 1)
+      S_3(c4, -c0 + 1997 * ((3 * c0 + 5990) / 5990), 2 * c0 - 3993 * ((3 * c0 + 5990) / 5990));
diff --git a/lib/Analysis/isl/test_inputs/codegen/cholesky.st b/lib/Analysis/isl/test_inputs/codegen/cholesky.st
new file mode 100644
index 0000000..2dd62b9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cholesky.st
@@ -0,0 +1,9 @@
+# Earlier versions of isl would fail to produce an AST for this input
+# due to a simplification bug.
+domain: "{ S_3[i, j, k] : 0 <= i <= 12 and 0 <= j < i and 0 <= k < j }"
+child:
+  schedule: "[{ S_3[i, j, k] -> [(3993j + 1997k)] }]"
+  child:
+    schedule: "[{ S_3[i, j, k] -> [(32*floor((2j + k)/32))] }, { S_3[i, j, k] -> [(32*floor((i)/32))] }]"
+    child:
+      schedule: "[{ S_3[i, j, k] -> [(2j + k - 32*floor((2j + k)/32))] }, { S_3[i, j, k] -> [(i)] }]"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.c
new file mode 100644
index 0000000..7f22e2e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.c
@@ -0,0 +1 @@
+S1();
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.st
new file mode 100644
index 0000000..d718258
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-1.st
@@ -0,0 +1,3 @@
+domain: "{ S1[] }"
+child:
+  context: "{ [] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.c
new file mode 100644
index 0000000..b87b57e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.c
@@ -0,0 +1,2 @@
+if (M >= 0)
+  S1();
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.st
new file mode 100644
index 0000000..3ee60f6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-2.st
@@ -0,0 +1,3 @@
+domain: "[M] -> { S1[] : M >= 0 }"
+child:
+  context: "[M] -> { [] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.c
new file mode 100644
index 0000000..7f22e2e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.c
@@ -0,0 +1 @@
+S1();
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.st
new file mode 100644
index 0000000..97cd37e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/0D-3.st
@@ -0,0 +1,3 @@
+domain: "[M] -> { S1[] : M >= 0 }"
+child:
+  context: "[M] -> { [] : M >= 0 }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.c
new file mode 100644
index 0000000..53dd893
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.c
@@ -0,0 +1 @@
+S1(2 * M, M);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.st
new file mode 100644
index 0000000..6194878
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-1.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[2M, M] }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.c
new file mode 100644
index 0000000..0a8cbe37
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.c
@@ -0,0 +1 @@
+S1(2 * M, N + 2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.st
new file mode 100644
index 0000000..9e7adfa
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/1point-2.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S1[2M, 2 + N] }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/4-param.c b/lib/Analysis/isl/test_inputs/codegen/cloog/4-param.c
new file mode 100644
index 0000000..bd38c70
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/4-param.c
@@ -0,0 +1,14 @@
+{
+  for (int c0 = p; c0 <= min(m - 1, q); c0 += 1)
+    S2(c0);
+  for (int c0 = m; c0 <= min(n, p - 1); c0 += 1)
+    S1(c0);
+  for (int c0 = max(m, p); c0 <= min(n, q); c0 += 1) {
+    S1(c0);
+    S2(c0);
+  }
+  for (int c0 = max(max(m, n + 1), p); c0 <= q; c0 += 1)
+    S2(c0);
+  for (int c0 = max(max(m, p), q + 1); c0 <= n; c0 += 1)
+    S1(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/4-param.st b/lib/Analysis/isl/test_inputs/codegen/cloog/4-param.st
new file mode 100644
index 0000000..2433595
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/4-param.st
@@ -0,0 +1,10 @@
+domain: "[m, n, p, q] -> { S1[i0] : i0 >= m and i0 <= n; S2[i0] : i0 >= p and i0 <= q }"
+child:
+  context: "[m, n, p, q] -> { [] }"
+  child:
+    schedule: "[m, n, p, q] -> [{ S2[i0] -> [(i0)]; S1[i0] -> [(i0)] }]"
+    options: "[m, n, p, q] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[m, n, p, q] -> { S1[i0] }"
+      - filter: "[m, n, p, q] -> { S2[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/README b/lib/Analysis/isl/test_inputs/codegen/cloog/README
new file mode 100644
index 0000000..9250f11
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/README
@@ -0,0 +1,2 @@
+The tests in this directory have been adapted from the corresponding CLooG
+test cases.
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.c b/lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.c
new file mode 100644
index 0000000..df0407a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.c
@@ -0,0 +1 @@
+S1(0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.st b/lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.st
new file mode 100644
index 0000000..23fb152
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/backtrack.st
@@ -0,0 +1,6 @@
+domain: "{ S1[0] }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0] -> [(i0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.c
new file mode 100644
index 0000000..95eb5f7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.c
@@ -0,0 +1,2 @@
+for (int c0 = 0; c0 <= 2; c0 += 1)
+  S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.st
new file mode 100644
index 0000000..7c599e8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-1.st
@@ -0,0 +1,6 @@
+domain: "{ S1[i0] : i0 >= 0 and i0 <= 2 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0] -> [(i0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.c
new file mode 100644
index 0000000..df0407a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.c
@@ -0,0 +1 @@
+S1(0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.st
new file mode 100644
index 0000000..23fb152
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-2.st
@@ -0,0 +1,6 @@
+domain: "{ S1[0] }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0] -> [(i0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.c
new file mode 100644
index 0000000..d0dd54b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.c
@@ -0,0 +1,2 @@
+for (int c0 = 0; c0 <= M; c0 += 1)
+  S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.st
new file mode 100644
index 0000000..437f566
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-3.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0] : i0 >= 0 and i0 <= M }"
+child:
+  context: "[M] -> { [] : M >= 0 }"
+  child:
+    schedule: "[M] -> [{ S1[i0] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.c b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.c
new file mode 100644
index 0000000..0ebb7cc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.c
@@ -0,0 +1,2 @@
+for (int c0 = 0; c0 <= M + 1; c0 += 1)
+  S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.st b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.st
new file mode 100644
index 0000000..a5a0b1a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-4.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0] : i0 >= 0 and i0 <= 1 + M }"
+child:
+  context: "[M] -> { [] : M >= 0 }"
+  child:
+    schedule: "[M] -> [{ S1[i0] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.c b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.c
new file mode 100644
index 0000000..09e8c42
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.c
@@ -0,0 +1 @@
+S1(1, floord(M + 1, 2));
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.st b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.st
new file mode 100644
index 0000000..e0bc58f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-5.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[1, i1] : 2i1 >= M and 2i1 <= 1 + M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.c b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.c
new file mode 100644
index 0000000..da8a3fb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.c
@@ -0,0 +1 @@
+S1(-1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.st b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.st
new file mode 100644
index 0000000..a65f088
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/basic-bounds-6.st
@@ -0,0 +1,6 @@
+domain: "{ S1[-1] }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0] -> [(i0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/block.c b/lib/Analysis/isl/test_inputs/codegen/cloog/block.c
new file mode 100644
index 0000000..e24ef30
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/block.c
@@ -0,0 +1,6 @@
+{
+  S1();
+  S3(0);
+  S2();
+  S3(1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/block.st b/lib/Analysis/isl/test_inputs/codegen/cloog/block.st
new file mode 100644
index 0000000..0ab2d88
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/block.st
@@ -0,0 +1,10 @@
+domain: "{ S1[]; S3[i0] : i0 >= 0 and i0 <= 1; S2[] }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S2[] -> [(1)]; S3[i0] -> [(i0)]; S1[] -> [(0)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[]; S2[] }"
+      - filter: "{ S3[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/block2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/block2.c
new file mode 100644
index 0000000..d3fbbd7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/block2.c
@@ -0,0 +1,5 @@
+for (int c0 = 0; c0 <= 9; c0 += 1) {
+  S1(c0, 1);
+  S3(c0, 1);
+  S2(c0, 1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/block2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/block2.st
new file mode 100644
index 0000000..b18ce92
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/block2.st
@@ -0,0 +1,11 @@
+domain: "{ S2[i0, 1] : i0 >= 0 and i0 <= 9; S1[i0, 1] : i0 >= 0 and i0 <= 9; S3[i0, 1] : i0 >= 0 and i0 <= 9 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S3[i0, i1] -> [(i0)]; S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S3[i0, i1] -> [(i1)]; S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1] }"
+      - filter: "{ S3[i0, i1] }"
+      - filter: "{ S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/block3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/block3.c
new file mode 100644
index 0000000..ff4d553
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/block3.c
@@ -0,0 +1,6 @@
+{
+  S1();
+  for (int c0 = 0; c0 <= 1; c0 += 1)
+    S3(c0);
+  S2();
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/block3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/block3.st
new file mode 100644
index 0000000..85f197f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/block3.st
@@ -0,0 +1,6 @@
+domain: "{ S1[]; S3[i0] : i0 >= 0 and i0 <= 1; S2[] }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S2[] -> [(1)]; S3[i0] -> [(i0)]; S1[] -> [(0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.c
new file mode 100644
index 0000000..fad89a9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.c
@@ -0,0 +1,18 @@
+{
+  for (int c0 = 2; c0 <= 3; c0 += 1)
+    for (int c1 = -c0 + 6; c1 <= 6; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 4; c0 <= 8; c0 += 1) {
+    if (c0 == 4)
+      for (int c1 = 3; c1 <= 4; c1 += 1)
+        S1(4, c1);
+    if (c0 <= 5) {
+      S1(c0, -c0 + 9);
+      S2(c0, -c0 + 9);
+    } else {
+      S2(c0, -c0 + 9);
+    }
+    for (int c1 = max(c0 - 1, -c0 + 10); c1 <= 6; c1 += 1)
+      S1(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.st
new file mode 100644
index 0000000..84d3791
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/byu98-1-2-3.st
@@ -0,0 +1,10 @@
+domain: "{ S2[i0, 9 - i0] : i0 <= 8 and i0 >= 4; S1[i0, i1] : i1 >= 6 - i0 and i0 >= 2 and i1 >= 3 and i1 <= 6 and i1 >= -1 + i0 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1] }"
+      - filter: "{ S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.c b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.c
new file mode 100644
index 0000000..1cf61c2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.c
@@ -0,0 +1,12 @@
+for (int c0 = 1; c0 <= n; c0 += 1) {
+  S1(c0);
+  for (int c1 = 1; c1 < c0; c1 += 1)
+    S2(c0, c1);
+  S3(c0);
+  for (int c1 = c0 + 1; c1 <= n; c1 += 1) {
+    S4(c0, c1);
+    for (int c2 = 1; c2 < c0; c2 += 1)
+      S5(c0, c1, c2);
+    S6(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.st b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.st
new file mode 100644
index 0000000..a6e910a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky.st
@@ -0,0 +1,26 @@
+domain: "[n] -> { S2[i0, i1] : i0 >= 1 and i0 <= n and i1 >= 1 and i1 <= -1 + i0; S1[i0] : i0 >= 1 and i0 <= n; S4[i0, i1] : i0 >= 1 and i0 <= n and i1 >= 1 + i0 and i1 <= n; S5[i0, i1, i2] : i0 >= 1 and i0 <= n and i1 >= 1 + i0 and i1 <= n and i2 >= 1 and i2 <= -1 + i0; S6[i0, i1] : i0 >= 1 and i0 <= n and i1 >= 1 + i0 and i1 <= n; S3[i0] : i0 >= 1 and i0 <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S1[i0] -> [(i0)]; S4[i0, i1] -> [(i0)]; S6[i0, i1] -> [(i0)]; S3[i0] -> [(i0)]; S5[i0, i1, i2] -> [(i0)]; S2[i0, i1] -> [(i0)] }]"
+    options: "[n] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[n] -> { S1[i0] }"
+      - filter: "[n] -> { S2[i0, i1] }"
+        child:
+          schedule: "[n] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[n] -> { separate[i0] }"
+      - filter: "[n] -> { S3[i0] }"
+      - filter: "[n] -> { S4[i0, i1]; S5[i0, i1, i2]; S6[i0, i1] }"
+        child:
+          schedule: "[n] -> [{ S4[i0, i1] -> [(i1)]; S6[i0, i1] -> [(i1)]; S5[i0, i1, i2] -> [(i1)] }]"
+          options: "[n] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[n] -> { S4[i0, i1] }"
+            - filter: "[n] -> { S5[i0, i1, i2] }"
+              child:
+                schedule: "[n] -> [{ S5[i0, i1, i2] -> [(i2)] }]"
+                options: "[n] -> { separate[i0] }"
+            - filter: "[n] -> { S6[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.c
new file mode 100644
index 0000000..7834ff4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.c
@@ -0,0 +1,17 @@
+{
+  for (int c1 = 1; c1 <= M; c1 += 1) {
+    S1(c1);
+    for (int c2 = c1 + 1; c2 <= M; c2 += 1)
+      S4(c1, c2);
+  }
+  for (int c0 = 1; c0 < 3 * M - 1; c0 += 3) {
+    S3((c0 + 2) / 3);
+    for (int c1 = (c0 + 5) / 3; c1 <= M; c1 += 1) {
+      S6((c0 + 2) / 3, c1);
+      for (int c4 = (c0 + 5) / 3; c4 < c1; c4 += 1)
+        S5(c4, c1, (c0 + 2) / 3);
+    }
+    for (int c1 = (c0 + 5) / 3; c1 <= M; c1 += 1)
+      S2(c1, (c0 + 2) / 3);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.st
new file mode 100644
index 0000000..d49ff85
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/cholesky2.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S4[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 + i0 and i1 <= M; S5[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 1 + i0 and i1 <= M and i2 >= 1 and i2 <= -1 + i0; S6[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 + i0 and i1 <= M; S3[i0] : i0 >= 1 and i0 <= M; S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= -1 + i0; S1[i0] : i0 >= 1 and i0 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0] -> [(0)]; S3[i0] -> [(-2 + 3i0)]; S4[i0, i1] -> [(0)]; S5[i0, i1, i2] -> [(-1 + 3i2)]; S2[i0, i1] -> [(3i1)]; S6[i0, i1] -> [(-1 + 3i0)] }, { S1[i0] -> [(i0)]; S3[i0] -> [(0)]; S4[i0, i1] -> [(i0)]; S5[i0, i1, i2] -> [(i1)]; S2[i0, i1] -> [(i0)]; S6[i0, i1] -> [(i1)] }, { S1[i0] -> [(0)]; S3[i0] -> [(0)]; S4[i0, i1] -> [(i1)]; S5[i0, i1, i2] -> [(i2)]; S2[i0, i1] -> [(0)]; S6[i0, i1] -> [(0)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/christian.c b/lib/Analysis/isl/test_inputs/codegen/cloog/christian.c
new file mode 100644
index 0000000..113249a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/christian.c
@@ -0,0 +1,6 @@
+for (int c0 = -N + 1; c0 <= N; c0 += 1) {
+  for (int c1 = max(0, c0); c1 < min(N, N + c0); c1 += 1)
+    S1(c1, -c0 + c1);
+  for (int c1 = max(0, c0 - 1); c1 < min(N, N + c0 - 1); c1 += 1)
+    S2(c1, -c0 + c1 + 1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/christian.st b/lib/Analysis/isl/test_inputs/codegen/cloog/christian.st
new file mode 100644
index 0000000..b451774
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/christian.st
@@ -0,0 +1,6 @@
+domain: "[N] -> { S1[i0, i1] : i0 >= 0 and i0 <= -1 + N and i1 >= 0 and i1 <= -1 + N; S2[i0, i1] : i0 >= 0 and i0 <= -1 + N and i1 >= 0 and i1 <= -1 + N }"
+child:
+  context: "[N] -> { [] }"
+  child:
+    schedule: "[N] -> [{ S1[i0, i1] -> [(i0 - i1)]; S2[i0, i1] -> [(1 + i0 - i1)] }]"
+    options: "[N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/classen.c b/lib/Analysis/isl/test_inputs/codegen/cloog/classen.c
new file mode 100644
index 0000000..3155aa7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/classen.c
@@ -0,0 +1,86 @@
+if (m >= 1) {
+  if (m == 1) {
+    S1(0, 1, 1, 1);
+    S8(0, 1);
+  } else {
+    S1(0, 1, 1, 1);
+    S2(0, 1, 1, 1, 1, 1, 2, 1);
+    S3(0, 1, 1, 2, 1, 1, 1, 2);
+    S4(0, 1, 2, 2, 1, 1, 2, 2);
+    S8(0, 1);
+  }
+  for (int c0 = 1; c0 < 2 * m - 3; c0 += 1) {
+    if (c0 + 1 == m) {
+      S5(m - 2, 1, m - 1, 1, m - 1, 1, m, 1);
+      S1(m - 1, 1, m, 1);
+      S3(m - 1, 1, m, 2, m, 1, m, 2);
+    } else if (m >= c0 + 2) {
+      S5(c0 - 1, 1, c0, 1, c0, 1, c0 + 1, 1);
+      S1(c0, 1, c0 + 1, 1);
+      S2(c0, 1, c0 + 1, 1, c0 + 1, 1, c0 + 2, 1);
+      S4(c0, 1, c0 + 2, 2, c0 + 1, 1, c0 + 2, 2);
+      S3(c0, 1, c0 + 1, 2, c0 + 1, 1, c0 + 1, 2);
+    } else {
+      S5(c0 - 1, -m + c0 + 2, c0, -m + c0 + 2, m - 1, -m + c0 + 2, m, -m + c0 + 2);
+      S6(c0 - 1, -m + c0 + 1, c0, -m + c0 + 2, m, -m + c0 + 1, m, -m + c0 + 2);
+      S1(c0, -m + c0 + 2, m, -m + c0 + 2);
+      S3(c0, -m + c0 + 2, c0 + 1, -m + c0 + 3, m, -m + c0 + 2, m, -m + c0 + 3);
+    }
+    for (int c1 = max(2, -m + c0 + 3); c1 <= min(m - 1, c0); c1 += 1) {
+      S5(c0 - 1, c1, c0, c1, c0 - c1 + 1, c1, c0 - c1 + 2, c1);
+      S7(c0 - 1, c1 - 1, c0 + 1, c1, c0 - c1 + 2, c1 - 1, c0 - c1 + 3, c1);
+      S6(c0 - 1, c1 - 1, c0, c1, c0 - c1 + 2, c1 - 1, c0 - c1 + 2, c1);
+      S1(c0, c1, c0 - c1 + 2, c1);
+      S2(c0, c1, c0 + 1, c1, c0 - c1 + 2, c1, c0 - c1 + 3, c1);
+      S4(c0, c1, c0 + 2, c1 + 1, c0 - c1 + 2, c1, c0 - c1 + 3, c1 + 1);
+      S3(c0, c1, c0 + 1, c1 + 1, c0 - c1 + 2, c1, c0 - c1 + 2, c1 + 1);
+    }
+    if (c0 + 1 == m) {
+      S7(m - 2, m - 1, m, m, 1, m - 1, 2, m);
+      S6(m - 2, m - 1, m - 1, m, 1, m - 1, 1, m);
+      S1(m - 1, m, 1, m);
+      S2(m - 1, m, m, m, 1, m, 2, m);
+    } else if (c0 >= m) {
+      S5(c0 - 1, m, c0, m, -m + c0 + 1, m, -m + c0 + 2, m);
+      S7(c0 - 1, m - 1, c0 + 1, m, -m + c0 + 2, m - 1, -m + c0 + 3, m);
+      S6(c0 - 1, m - 1, c0, m, -m + c0 + 2, m - 1, -m + c0 + 2, m);
+      S1(c0, m, -m + c0 + 2, m);
+      S2(c0, m, c0 + 1, m, -m + c0 + 2, m, -m + c0 + 3, m);
+    } else {
+      S6(c0 - 1, c0, c0, c0 + 1, 1, c0, 1, c0 + 1);
+      S7(c0 - 1, c0, c0 + 1, c0 + 1, 1, c0, 2, c0 + 1);
+      S1(c0, c0 + 1, 1, c0 + 1);
+      S2(c0, c0 + 1, c0 + 1, c0 + 1, 1, c0 + 1, 2, c0 + 1);
+      S4(c0, c0 + 1, c0 + 2, c0 + 2, 1, c0 + 1, 2, c0 + 2);
+      S3(c0, c0 + 1, c0 + 1, c0 + 2, 1, c0 + 1, 1, c0 + 2);
+    }
+    for (int c2 = max(1, -m + c0 + 2); c2 <= min(m, c0 + 1); c2 += 1)
+      S8(c0, c2);
+  }
+  if (m >= 2) {
+    if (m >= 3) {
+      S5(2 * m - 4, m - 1, 2 * m - 3, m - 1, m - 1, m - 1, m, m - 1);
+      S6(2 * m - 4, m - 2, 2 * m - 3, m - 1, m, m - 2, m, m - 1);
+      S1(2 * m - 3, m - 1, m, m - 1);
+      S3(2 * m - 3, m - 1, 2 * m - 2, m, m, m - 1, m, m);
+      S5(2 * m - 4, m, 2 * m - 3, m, m - 2, m, m - 1, m);
+      S7(2 * m - 4, m - 1, 2 * m - 2, m, m - 1, m - 1, m, m);
+      S6(2 * m - 4, m - 1, 2 * m - 3, m, m - 1, m - 1, m - 1, m);
+      S1(2 * m - 3, m, m - 1, m);
+    } else {
+      S5(0, 1, 1, 1, 1, 1, 2, 1);
+      S1(1, 1, 2, 1);
+      S3(1, 1, 2, 2, 2, 1, 2, 2);
+      S7(0, 1, 2, 2, 1, 1, 2, 2);
+      S6(0, 1, 1, 2, 1, 1, 1, 2);
+      S1(1, 2, 1, 2);
+    }
+    S2(2 * m - 3, m, 2 * m - 2, m, m - 1, m, m, m);
+    for (int c2 = m - 1; c2 <= m; c2 += 1)
+      S8(2 * m - 3, c2);
+    S5(2 * m - 3, m, 2 * m - 2, m, m - 1, m, m, m);
+    S6(2 * m - 3, m - 1, 2 * m - 2, m, m, m - 1, m, m);
+    S1(2 * m - 2, m, m, m);
+    S8(2 * m - 2, m);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/classen.st b/lib/Analysis/isl/test_inputs/codegen/cloog/classen.st
new file mode 100644
index 0000000..e9d3baf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/classen.st
@@ -0,0 +1,24 @@
+domain: "[m] -> { S2[coordT1, coordP1, 1 + coordT1, coordP1, 2 + coordT1 - coordP1, coordP1, 3 + coordT1 - coordP1, coordP1] : m >= 1 and coordT1 <= -3 + 2m and coordT1 >= 0 and coordP1 <= 1 + coordT1 and coordP1 <= m and coordP1 >= 3 - m + coordT1 and coordP1 >= 1; S4[coordT1, coordP1, 2 + coordT1, 1 + coordP1, 2 + coordT1 - coordP1, coordP1, 3 + coordT1 - coordP1, 1 + coordP1] : m >= 1 and coordT1 <= -4 + 2m and coordT1 >= 0 and coordP1 <= 1 + coordT1 and coordP1 <= -1 + m and coordP1 >= 3 - m + coordT1 and coordP1 >= 1; S6[coordT1, coordP1, 1 + coordT1, 1 + coordP1, 2 + coordT1 - coordP1, coordP1, 2 + coordT1 - coordP1, 1 + coordP1] : m >= 1 and coordT1 <= -3 + 2m and coordT1 >= 0 and coordP1 <= 1 + coordT1 and coordP1 <= -1 + m and coordP1 >= 2 - m + coordT1 and coordP1 >= 1; S1[coordT1, coordP1, 2 + coordT1 - coordP1, coordP1] : m >= 1 and coordP1 >= 2 - m + coordT1 and coordP1 <= 1 + coordT1 and coordP1 <= m and coordP1 >= 1; S8[coordT1, coordP1] : coordT1 <= -2 + 2m and coordT1 >= 0 and coordP1 <= 1 + coordT1 and coordP1 <= m and coordP1 >= 2 - m + coordT1 and coordP1 >= 1; S5[coordT1, coordP1, 1 + coordT1, coordP1, 2 + coordT1 - coordP1, coordP1, 3 + coordT1 - coordP1, coordP1] : m >= 1 and coordT1 <= -3 + 2m and coordT1 >= 0 and coordP1 <= 1 + coordT1 and coordP1 <= m and coordP1 >= 3 - m + coordT1 and coordP1 >= 1; S7[coordT1, coordP1, 2 + coordT1, 1 + coordP1, 2 + coordT1 - coordP1, coordP1, 3 + coordT1 - coordP1, 1 + coordP1] : m >= 1 and coordT1 <= -4 + 2m and coordT1 >= 0 and coordP1 <= 1 + coordT1 and coordP1 <= -1 + m and coordP1 >= 3 - m + coordT1 and coordP1 >= 1; S3[coordT1, coordP1, 1 + coordT1, 1 + coordP1, 2 + coordT1 - coordP1, coordP1, 2 + coordT1 - coordP1, 1 + coordP1] : m >= 1 and coordT1 <= -3 + 2m and coordT1 >= 0 and coordP1 <= 1 + coordT1 and coordP1 <= -1 + m and coordP1 >= 2 - m + coordT1 and coordP1 >= 1 }"
+child:
+  context: "[m] -> { [] : m >= 0 }"
+  child:
+    schedule: "[m] -> [{ S7[i0, i1, i2, i3, i4, i5, i6, i7] -> [(1 + i0)]; S4[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i0)]; S8[i0, i1] -> [(i0)]; S3[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i0)]; S1[i0, i1, i2, i3] -> [(i0)]; S2[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i0)]; S5[i0, i1, i2, i3, i4, i5, i6, i7] -> [(1 + i0)]; S6[i0, i1, i2, i3, i4, i5, i6, i7] -> [(1 + i0)] }]"
+    options: "[m] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[m] -> { S2[i0, i1, i2, i3, i4, i5, i6, i7]; S6[i0, i1, i2, i3, i4, i5, i6, i7]; S4[i0, i1, i2, i3, i4, i5, i6, i7]; S1[i0, i1, i2, i3]; S7[i0, i1, i2, i3, i4, i5, i6, i7]; S5[i0, i1, i2, i3, i4, i5, i6, i7]; S3[i0, i1, i2, i3, i4, i5, i6, i7] }"
+        child:
+          schedule: "[m] -> [{ S7[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i3)]; S4[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i1)]; S3[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i1)]; S1[i0, i1, i2, i3] -> [(i1)]; S2[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i1)]; S5[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i3)]; S6[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i3)] }]"
+          options: "[m] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[m] -> { S6[i0, i1, i2, i3, i4, i5, i6, i7]; S5[i0, i1, i2, i3, i4, i5, i6, i7]; S7[i0, i1, i2, i3, i4, i5, i6, i7] }"
+              child:
+                schedule: "[m] -> [{ S7[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i4)]; S5[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i4)]; S6[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i4)] }, { S7[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i5)]; S5[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i5)]; S6[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i5)] }]"
+                options: "[m] -> { separate[i0] }"
+            - filter: "[m] -> { S1[i0, i1, i2, i3] }"
+            - filter: "[m] -> { S2[i0, i1, i2, i3, i4, i5, i6, i7]; S4[i0, i1, i2, i3, i4, i5, i6, i7]; S3[i0, i1, i2, i3, i4, i5, i6, i7] }"
+              child:
+                schedule: "[m] -> [{ S4[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i4)]; S3[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i4)]; S2[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i4)] }, { S4[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i5)]; S3[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i5)]; S2[i0, i1, i2, i3, i4, i5, i6, i7] -> [(i5)] }]"
+                options: "[m] -> { separate[i0] }"
+      - filter: "[m] -> { S8[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/classen2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/classen2.c
new file mode 100644
index 0000000..a737d2d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/classen2.c
@@ -0,0 +1,4 @@
+for (int c0 = max(max(max(max(max(max(4, 5 * outerTimeTileScatter), 5 * outerProcTileScatter1), 5 * outerProcTileScatter2 + 1), 5 * outerProcTileScatter1 + 5 * outerProcTileScatter2 - N), 10 * outerProcTileScatter2 - N + 1), 10 * outerProcTileScatter1 - 2 * N + 2); c0 <= min(min(min(min(min(min(5 * outerTimeTileScatter + 4, 10 * outerProcTileScatter1 + 4), 5 * outerProcTileScatter1 + 5 * outerProcTileScatter2 + 5), 5 * outerProcTileScatter1 + M + 2), 2 * M + 2 * N - 6), 5 * outerProcTileScatter2 + M + N), 10 * outerProcTileScatter2 + N + 3); c0 += 1)
+  for (int c1 = max(max(max(max(5 * outerProcTileScatter1, 5 * outerProcTileScatter2 + 1), -5 * outerProcTileScatter2 + c0 - 1), -M + c0 + 2), (c0 + 1) / 2 + 2); c1 <= min(min(min(min(5 * outerProcTileScatter1 + 4, 5 * outerProcTileScatter2 + N + 2), -5 * outerProcTileScatter2 + N + c0), c0), N + c0 / 2 - 1); c1 += 1)
+    for (int c2 = max(max(5 * outerProcTileScatter2, -N + c1 + 2), c0 - c1 + 3); c2 <= min(min(5 * outerProcTileScatter2 + 4, c1 - 1), N + c0 - c1); c2 += 1)
+      S1(c0 - c1 + 1, -c0 + c1 + c2 - 2, c1 - c2, c0, c1, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/classen2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/classen2.st
new file mode 100644
index 0000000..f7115ca
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/classen2.st
@@ -0,0 +1,6 @@
+domain: "[outerTimeTileScatter, outerProcTileScatter1, outerProcTileScatter2, M, N] -> { S1[compIter1, compIter2, compIter3, 2compIter1 + compIter2 + compIter3, 1 + compIter1 + compIter2 + compIter3, 1 + compIter1 + compIter2] : N >= 3 and compIter3 <= 3 + 5outerProcTileScatter1 - compIter1 - compIter2 and compIter2 >= -1 + 5outerProcTileScatter2 - compIter1 and M >= 2 and compIter3 <= 4 + 5outerTimeTileScatter - 2compIter1 - compIter2 and compIter2 <= 3 + 5outerProcTileScatter2 - compIter1 and compIter3 >= 1 and compIter3 <= -2 + N and compIter2 >= 1 and compIter2 <= -2 + N and compIter1 >= 1 and compIter1 <= -1 + M and compIter3 >= 5outerTimeTileScatter - 2compIter1 - compIter2 and compIter3 >= -1 + 5outerProcTileScatter1 - compIter1 - compIter2 }"
+child:
+  context: "[outerTimeTileScatter, outerProcTileScatter1, outerProcTileScatter2, M, N] -> { [] }"
+  child:
+    schedule: "[outerTimeTileScatter, outerProcTileScatter1, outerProcTileScatter2, M, N] -> [{ S1[i0, i1, i2, i3, i4, i5] -> [(i3)] }, { S1[i0, i1, i2, i3, i4, i5] -> [(i4)] }, { S1[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
+    options: "[outerTimeTileScatter, outerProcTileScatter1, outerProcTileScatter2, M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/constant.c b/lib/Analysis/isl/test_inputs/codegen/cloog/constant.c
new file mode 100644
index 0000000..f39a3a2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/constant.c
@@ -0,0 +1,18 @@
+{
+  for (int c1 = 0; c1 <= min(1023, M + 1024); c1 += 1) {
+    S1(c1);
+    S3(c1);
+  }
+  for (int c1 = max(0, M + 1025); c1 <= 1023; c1 += 1) {
+    S2(c1);
+    S3(c1);
+  }
+  for (int c0 = 0; c0 <= min(1023, M + 1024); c0 += 1) {
+    S4(c0);
+    S6(c0);
+  }
+  for (int c0 = max(0, M + 1025); c0 <= 1023; c0 += 1) {
+    S5(c0);
+    S6(c0);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/constant.st b/lib/Analysis/isl/test_inputs/codegen/cloog/constant.st
new file mode 100644
index 0000000..f4f85f7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/constant.st
@@ -0,0 +1,11 @@
+domain: "[M] -> { S4[i0] : i0 >= 0 and i0 <= 1023 and i0 <= 1024 + M; S5[i0] : i0 >= 0 and i0 <= 1023 and i0 >= 1025 + M; S3[i0] : i0 >= 0 and i0 <= 1023; S2[i0] : i0 >= 0 and i0 <= 1023 and i0 >= 1025 + M; S1[i0] : i0 >= 0 and i0 <= 1023 and i0 <= 1024 + M; S6[i0] : i0 >= 0 and i0 <= 1023 }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S2[i0] -> [(-1)]; S4[i0] -> [(i0)]; S1[i0] -> [(-1)]; S3[i0] -> [(-1)]; S6[i0] -> [(i0)]; S5[i0] -> [(i0)] }, { S2[i0] -> [(i0)]; S4[i0] -> [(0)]; S1[i0] -> [(i0)]; S3[i0] -> [(i0)]; S6[i0] -> [(0)]; S5[i0] -> [(0)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S4[i0]; S1[i0] }"
+      - filter: "[M] -> { S5[i0]; S2[i0] }"
+      - filter: "[M] -> { S3[i0]; S6[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/constbound.c b/lib/Analysis/isl/test_inputs/codegen/cloog/constbound.c
new file mode 100644
index 0000000..7fbebe0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/constbound.c
@@ -0,0 +1,8 @@
+for (int c0 = 0; c0 <= 199; c0 += 1) {
+  for (int c1 = 50 * c0; c1 <= 50 * c0 + 24; c1 += 1)
+    for (int c2 = 0; c2 <= c1; c2 += 1)
+      S1(c0, c1, c2);
+  for (int c1 = 50 * c0 + 25; c1 <= 50 * c0 + 49; c1 += 1)
+    for (int c2 = 0; c2 <= c1; c2 += 1)
+      S2(c0, c1, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/constbound.st b/lib/Analysis/isl/test_inputs/codegen/cloog/constbound.st
new file mode 100644
index 0000000..1f6789e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/constbound.st
@@ -0,0 +1,16 @@
+domain: "{ S2[i0, i1, i2] : i1 >= 0 and i1 <= 9999 and i2 >= 0 and i2 <= i1 and i1 >= 25 + 50i0 and i1 <= 49 + 50i0; S1[i0, i1, i2] : i1 >= 0 and i1 <= 9999 and i2 >= 0 and i2 <= i1 and i1 >= 50i0 and i1 <= 24 + 50i0 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1, i2] }"
+        child:
+          schedule: "[{ S1[i0, i1, i2] -> [(i1)] }, { S1[i0, i1, i2] -> [(i2)] }]"
+          options: "{ separate[i0] }"
+      - filter: "{ S2[i0, i1, i2] }"
+        child:
+          schedule: "[{ S2[i0, i1, i2] -> [(i1)] }, { S2[i0, i1, i2] -> [(i2)] }]"
+          options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/darte.c b/lib/Analysis/isl/test_inputs/codegen/cloog/darte.c
new file mode 100644
index 0000000..acb6371
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/darte.c
@@ -0,0 +1,14 @@
+for (int c0 = -n + 1; c0 <= n; c0 += 1) {
+  if (c0 <= 0)
+    for (int c2 = -c0 + 4; c2 <= 2 * n - c0 + 2; c2 += 2)
+      S1(1, -c0 + 1, ((c0 + c2) / 2) - 1);
+  for (int c1 = max(c0 + 2, -c0 + 4); c1 <= min(2 * n - c0, 2 * n + c0); c1 += 2) {
+    for (int c2 = c1 + 2; c2 <= 2 * n + c1; c2 += 2)
+      S1((c0 + c1) / 2, (-c0 + c1) / 2, (-c1 + c2) / 2);
+    for (int c2 = 1; c2 <= n; c2 += 1)
+      S2(((c0 + c1) / 2) - 1, (-c0 + c1) / 2, c2);
+  }
+  if (c0 >= 1)
+    for (int c2 = 1; c2 <= n; c2 += 1)
+      S2(n, n - c0 + 1, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/darte.st b/lib/Analysis/isl/test_inputs/codegen/cloog/darte.st
new file mode 100644
index 0000000..33e9386
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/darte.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i0, i1, i2] : i0 >= 1 and i0 <= n and i1 >= 1 and i1 <= n and i2 >= 1 and i2 <= n; S2[i0, i1, i2] : i0 >= 1 and i0 <= n and i1 >= 1 and i1 <= n and i2 >= 1 and i2 <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S1[i0, i1, i2] -> [(i0 - i1)]; S2[i0, i1, i2] -> [(1 + i0 - i1)] }, { S1[i0, i1, i2] -> [(i0 + i1)]; S2[i0, i1, i2] -> [(2 + i0 + i1)] }, { S1[i0, i1, i2] -> [(i0 + i1 + 2i2)]; S2[i0, i1, i2] -> [(i2)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/dealII.c b/lib/Analysis/isl/test_inputs/codegen/cloog/dealII.c
new file mode 100644
index 0000000..99ac53e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/dealII.c
@@ -0,0 +1,18 @@
+{
+  for (int c0 = 0; c0 <= min(min(T_2 - 1, T_67 - 1), T_66); c0 += 1) {
+    S1(c0);
+    S2(c0);
+  }
+  for (int c0 = max(0, T_66 + 1); c0 < min(T_2, T_67); c0 += 1)
+    S1(c0);
+  for (int c0 = T_67; c0 <= min(T_2 - 1, T_66); c0 += 1) {
+    S1(c0);
+    S2(c0);
+  }
+  for (int c0 = max(T_67, T_66 + 1); c0 < T_2; c0 += 1)
+    S1(c0);
+  for (int c0 = T_2; c0 <= min(T_67 - 1, T_66); c0 += 1)
+    S2(c0);
+  if (T_2 == 0 && T_67 == 0)
+    S1(0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/dealII.st b/lib/Analysis/isl/test_inputs/codegen/cloog/dealII.st
new file mode 100644
index 0000000..586e8fb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/dealII.st
@@ -0,0 +1,10 @@
+domain: "[T_2, T_67, T_66] -> { S1[scat_0] : (scat_0 >= 0 and scat_0 <= -1 + T_2) or (scat_0 <= -T_67 and scat_0 >= 0); S2[scat_0] : (scat_0 >= 0 and scat_0 <= T_66 and scat_0 <= -1 + T_2) or (scat_0 >= 0 and scat_0 <= T_66 and scat_0 <= -1 + T_67) }"
+child:
+  context: "[T_2, T_67, T_66] -> { [] : T_2 <= 4 and T_2 >= 0 and T_67 <= 4 and T_67 >= 0 }"
+  child:
+    schedule: "[T_2, T_67, T_66] -> [{ S2[scat_0] -> [(scat_0)]; S1[scat_0] -> [(scat_0)] }]"
+    options: "[T_2, T_67, T_66] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[T_2, T_67, T_66] -> { S1[scat_0] }"
+      - filter: "[T_2, T_67, T_66] -> { S2[scat_0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.c b/lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.c
new file mode 100644
index 0000000..6e2cfce
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.c
@@ -0,0 +1,6 @@
+for (int c0 = 1; c0 <= 10; c0 += 1) {
+  for (int c1 = 1; c1 <= c0; c1 += 1)
+    S1(c0, c1);
+  for (int c1 = 11; c1 <= M; c1 += 1)
+    S2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.st b/lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.st
new file mode 100644
index 0000000..1dd72f4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/donotsimp.st
@@ -0,0 +1,9 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= 10 and i1 >= 1 and i1 <= i0; S2[i0, i1] : i0 >= 1 and i0 <= 10 and i1 >= 11 and i1 <= M }"
+child:
+  context: "[M] -> { [] : M >= 20 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      schedule: "[M] -> [{ S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+      options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/dot.c b/lib/Analysis/isl/test_inputs/codegen/cloog/dot.c
new file mode 100644
index 0000000..b08de33
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/dot.c
@@ -0,0 +1,7 @@
+{
+  for (int c1 = 1; c1 <= M; c1 += 1)
+    S1(0, c1);
+  for (int c0 = 1; c0 <= N; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/dot.st b/lib/Analysis/isl/test_inputs/codegen/cloog/dot.st
new file mode 100644
index 0000000..a9ca44a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/dot.st
@@ -0,0 +1,10 @@
+domain: "[M, N] -> { S1[0, i1] : i1 <= M and N >= 0 and i1 >= 1; S2[i0, i1] : i0 >= 1 and i1 <= M and i0 <= N and i1 >= 1 }"
+child:
+  context: "[M, N] -> { [] : M >= 1 and N >= 1 }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/dot2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/dot2.c
new file mode 100644
index 0000000..1990d26
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/dot2.c
@@ -0,0 +1,12 @@
+{
+  for (int c0 = 1; c0 <= min(M, N); c0 += 1) {
+    S1(c0);
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0, c1);
+  }
+  for (int c0 = M + 1; c0 <= N; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0, c1);
+  for (int c0 = N + 1; c0 <= M; c0 += 1)
+    S1(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/dot2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/dot2.st
new file mode 100644
index 0000000..192d23c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/dot2.st
@@ -0,0 +1,10 @@
+domain: "[M, N] -> { S1[i0] : i0 >= 1 and i0 <= M; S2[i0, i1] : i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= M }"
+child:
+  context: "[M, N] -> { [] : M >= 1 and N >= 1 }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0, i1] -> [(i0)]; S1[i0] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0] -> [(0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.c b/lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.c
new file mode 100644
index 0000000..2559099
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.c
@@ -0,0 +1,23 @@
+{
+  S4(1, 0, 0);
+  S7(1, 0, 0);
+  S8(1, 0, 3);
+  for (int c0 = 2; c0 <= 9; c0 += 1) {
+    S2(c0, -7, 0);
+    for (int c1 = -7; c1 < c0 - 8; c1 += 1)
+      S3(c0, c1, 1);
+    S6(c0, c0 - 9, 2);
+    S8(c0, 0, 3);
+    for (int c1 = 1; c1 < c0; c1 += 1)
+      S5(c0, c1, 3);
+  }
+  S2(10, -7, 0);
+  for (int c1 = -7; c1 <= 1; c1 += 1)
+    S3(10, c1, 1);
+  S6(10, 1, 2);
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    S5(10, c1, 3);
+    S1(10, c1, 4);
+  }
+  S1(10, 10, 4);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.st b/lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.st
new file mode 100644
index 0000000..8b08767
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/durbin_e_s.st
@@ -0,0 +1,16 @@
+domain: "{ S2[i0, -7, 0] : i0 >= 2 and i0 <= 10; S4[1, 0, 0]; S6[i0, -9 + i0, 2] : i0 >= 2 and i0 <= 10; S1[10, i1, 4] : i1 >= 1 and i1 <= 10; S5[i0, i1, 3] : i1 <= -1 + i0 and i0 <= 10 and i1 >= 1; S7[1, 0, 0]; S8[i0, 0, 3] : i0 >= 1 and i0 <= 9; S3[i0, i1, 1] : i1 >= -7 and i0 <= 10 and i1 <= -9 + i0 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S6[i0, i1, i2] -> [(i0)]; S8[i0, i1, i2] -> [(i0)]; S5[i0, i1, i2] -> [(i0)]; S4[i0, i1, i2] -> [(i0)]; S7[i0, i1, i2] -> [(i0)]; S3[i0, i1, i2] -> [(i0)]; S1[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)] }, { S6[i0, i1, i2] -> [(i1)]; S8[i0, i1, i2] -> [(i1)]; S5[i0, i1, i2] -> [(i1)]; S4[i0, i1, i2] -> [(i1)]; S7[i0, i1, i2] -> [(i1)]; S3[i0, i1, i2] -> [(i1)]; S1[i0, i1, i2] -> [(i1)]; S2[i0, i1, i2] -> [(i1)] }, { S6[i0, i1, i2] -> [(i2)]; S8[i0, i1, i2] -> [(i2)]; S5[i0, i1, i2] -> [(i2)]; S4[i0, i1, i2] -> [(i2)]; S7[i0, i1, i2] -> [(i2)]; S3[i0, i1, i2] -> [(i2)]; S1[i0, i1, i2] -> [(i2)]; S2[i0, i1, i2] -> [(i2)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1, i2] }"
+      - filter: "{ S2[i0, i1, i2] }"
+      - filter: "{ S3[i0, i1, i2] }"
+      - filter: "{ S4[i0, i1, i2] }"
+      - filter: "{ S5[i0, i1, i2] }"
+      - filter: "{ S6[i0, i1, i2] }"
+      - filter: "{ S7[i0, i1, i2] }"
+      - filter: "{ S8[i0, i1, i2] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/emploi.c b/lib/Analysis/isl/test_inputs/codegen/cloog/emploi.c
new file mode 100644
index 0000000..80ee37d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/emploi.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= n; c0 += 1) {
+  S1(c0);
+  for (int c1 = 1; c1 <= m; c1 += 1)
+    S2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/emploi.st b/lib/Analysis/isl/test_inputs/codegen/cloog/emploi.st
new file mode 100644
index 0000000..a7f4c26
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/emploi.st
@@ -0,0 +1,10 @@
+domain: "[m, n] -> { S1[i0] : (i0 >= 1 and i0 <= n and i0 <= 2m) or (i0 >= m and i0 >= 1 and i0 <= n); S2[i0, i1] : i0 >= 1 and i0 <= n and i1 >= 1 and i1 <= m }"
+child:
+  context: "[m, n] -> { [] }"
+  child:
+    schedule: "[m, n] -> [{ S1[i0] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0] -> [(0)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[m, n] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[m, n] -> { S1[i0] }"
+      - filter: "[m, n] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/equality.c b/lib/Analysis/isl/test_inputs/codegen/cloog/equality.c
new file mode 100644
index 0000000..fa6ff75
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/equality.c
@@ -0,0 +1,7 @@
+for (int c0 = 0; c0 <= 5; c0 += 1)
+  for (int c1 = min(4, 2 * c0); c1 <= max(4, 2 * c0); c1 += 1) {
+    if (c1 == 2 * c0)
+      S1(c0, 2 * c0);
+    if (c1 == 4)
+      S2(c0, 4);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/equality.st b/lib/Analysis/isl/test_inputs/codegen/cloog/equality.st
new file mode 100644
index 0000000..084689c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/equality.st
@@ -0,0 +1,10 @@
+domain: "{ S2[i0, 4] : i0 >= 0 and i0 <= 5; S1[i0, 2i0] : i0 >= 0 and i0 <= 5 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "{ atomic[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1] }"
+      - filter: "{ S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/equality2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/equality2.c
new file mode 100644
index 0000000..be22da2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/equality2.c
@@ -0,0 +1,8 @@
+for (int c0 = 1; c0 <= 10000; c0 += 1)
+  for (int c1 = 1000; c1 <= 1016; c1 += 1)
+    for (int c2 = 1; c2 < 2 * c1 - 1998; c2 += 1) {
+      if (c1 <= 1008 && c2 + 1999 == 2 * c1)
+        S2(c0, c1, 2 * c1 - 1999, 1, c0, 2 * c1 - 1000, 1, 2, c0, c1 - 499, 2 * c1 - 1999, c0, 2 * c1 - 1999, c1 - 999, c1 - 999);
+      if (c2 == 1 && c1 % 2 == 0)
+        S1(c0, c1, 1, 2, c0, (c1 / 2) + 1, c1 - 999, c0, c1 - 999, (c1 / 2) - 499, (c1 / 2) - 499);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/equality2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/equality2.st
new file mode 100644
index 0000000..bbcb338
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/equality2.st
@@ -0,0 +1,10 @@
+domain: "{ S1[i0, i1, 1, 2, i0, i5, -999 + i1, i0, -999 + i1, i9, i10] : 2i5 = 2 + i1 and 2i9 = -998 + i1 and 2i10 = -998 + i1 and i0 >= 1 and i0 <= 10000 and i1 >= 1000 and i1 <= 1016; S2[i0, i1, -1999 + 2i1, 1, i0, -1000 + 2i1, 1, 2, i0, -499 + i1, -1999 + 2i1, i0, -1999 + 2i1, -999 + i1, -999 + i1] : i0 >= 1 and i0 <= 10000 and i1 >= 1000 and i1 <= 1008 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i0)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i0)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i1)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i1)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i2)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i2)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i3)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i3)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i4)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i4)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i5)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i5)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i6)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i6)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i7)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i7)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i8)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i8)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i9)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i9)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(i10)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i10)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(0)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i11)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(0)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i12)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(0)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i13)] }, { S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] -> [(0)]; S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] -> [(i14)] }]"
+    options: "{ atomic[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10] }"
+      - filter: "{ S2[i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/esced.c b/lib/Analysis/isl/test_inputs/codegen/cloog/esced.c
new file mode 100644
index 0000000..f7c7ee0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/esced.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= m; c0 += 1) {
+  S1(c0);
+  for (int c1 = 1; c1 <= n; c1 += 1)
+    S2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/esced.st b/lib/Analysis/isl/test_inputs/codegen/cloog/esced.st
new file mode 100644
index 0000000..f48ccf6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/esced.st
@@ -0,0 +1,10 @@
+domain: "[n, m] -> { S1[i0] : i0 >= 1 and i0 <= m; S2[i0, i1] : i0 >= 1 and i0 <= m and i1 >= 1 and i1 <= n }"
+child:
+  context: "[n, m] -> { [] }"
+  child:
+    schedule: "[n, m] -> [{ S2[i0, i1] -> [(i0)]; S1[i0] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0] -> [(0)] }]"
+    options: "[n, m] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[n, m] -> { S1[i0] }"
+      - filter: "[n, m] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/ex1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/ex1.c
new file mode 100644
index 0000000..2627f23
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/ex1.c
@@ -0,0 +1,15 @@
+{
+  for (int c0 = 0; c0 <= 14; c0 += 1)
+    for (int c1 = 0; c1 < n - 14; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 15; c0 <= n; c0 += 1) {
+    for (int c1 = 0; c1 <= 9; c1 += 1)
+      S1(c0, c1);
+    for (int c1 = 10; c1 < n - 14; c1 += 1) {
+      S1(c0, c1);
+      S2(c0, c1);
+    }
+    for (int c1 = n - 14; c1 <= n; c1 += 1)
+      S2(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/ex1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/ex1.st
new file mode 100644
index 0000000..ea02538
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/ex1.st
@@ -0,0 +1,10 @@
+domain: "[n] -> { S1[i0, i1] : i0 >= 0 and i0 <= n and i1 >= 0 and i1 <= -15 + n; S2[i0, i1] : i0 >= 15 and i0 <= n and i1 >= 10 and i1 <= n }"
+child:
+  context: "[n] -> { [] : n >= 25 }"
+  child:
+    schedule: "[n] -> [{ S2[i0, i1] -> [(i0)]; S1[i0, i1] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0, i1] -> [(i1)] }]"
+    options: "[n] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[n] -> { S1[i0, i1] }"
+      - filter: "[n] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/faber.c b/lib/Analysis/isl/test_inputs/codegen/cloog/faber.c
new file mode 100644
index 0000000..4aef0a5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/faber.c
@@ -0,0 +1,149 @@
+{
+  for (int c0 = 0; c0 <= 36; c0 += 1) {
+    for (int c1 = -6; c1 < c0 / 14 - 5; c1 += 1) {
+      for (int c2 = -((-2 * c1 + 3) / 5) + 9; c2 <= c1 + 12; c2 += 1)
+        S6(c0, c1, c2);
+      for (int c2 = c1 + 24; c2 <= -2 * c1 + 24; c2 += 1)
+        S2(c0, c1, c2);
+      for (int c2 = -2 * c1 + 30; c2 <= c1 + 48; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    for (int c1 = c0 / 14 - 5; c1 < 0; c1 += 1) {
+      if (c1 >= -3 && 2 * c0 >= 7 * c1 + 42)
+        S7(c0, c1, 6);
+      for (int c2 = max(c1 - (6 * c0 + 77) / 77 + 13, -((-2 * c1 + 3) / 5) + 9); c2 <= c1 + 12; c2 += 1)
+        S6(c0, c1, c2);
+      for (int c2 = c1 - (3 * c0 + 14) / 14 + 49; c2 <= c1 + 48; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    S3(c0, 0, 0);
+    S10(c0, 0, 0);
+    for (int c2 = 1; c2 <= 5; c2 += 1)
+      S3(c0, 0, c2);
+    for (int c2 = 6; c2 <= 2 * c0 / 21 + 4; c2 += 1) {
+      S3(c0, 0, c2);
+      S7(c0, 0, c2);
+    }
+    for (int c2 = max(6, 2 * c0 / 21 + 5); c2 <= -((6 * c0 + 77) / 77) + 12; c2 += 1)
+      S3(c0, 0, c2);
+    for (int c2 = -((6 * c0 + 77) / 77) + 13; c2 <= 12; c2 += 1) {
+      S3(c0, 0, c2);
+      S6(c0, 0, c2);
+    }
+    for (int c2 = 13; c2 <= 24; c2 += 1)
+      S3(c0, 0, c2);
+    for (int c2 = -((3 * c0 + 14) / 14) + 49; c2 <= 48; c2 += 1)
+      S1(c0, 0, c2);
+    for (int c1 = 1; c1 <= 18; c1 += 1) {
+      for (int c2 = -8 * c1; c2 <= min(6, -8 * c1 + 24); c2 += 1)
+        S3(c0, c1, c2);
+      if (c1 == 2) {
+        S3(c0, 2, 7);
+      } else if (c0 <= 34 && c1 == 1) {
+        S3(c0, 1, 7);
+      } else if (c0 >= 35 && c1 == 1) {
+        S3(c0, 1, 7);
+        S7(c0, 1, 7);
+      }
+      for (int c2 = 8; c2 <= min(-8 * c1 + 24, c1 - (6 * c0 + 77) / 77 + 12); c2 += 1)
+        S3(c0, c1, c2);
+      for (int c2 = max(-8 * c1 + 25, c1 - (6 * c0 + 77) / 77 + 13); c2 <= c1 + 12; c2 += 1)
+        S6(c0, c1, c2);
+      if (c1 == 1) {
+        for (int c2 = -((6 * c0 + 77) / 77) + 14; c2 <= 13; c2 += 1) {
+          S3(c0, 1, c2);
+          S6(c0, 1, c2);
+        }
+        for (int c2 = 14; c2 <= 16; c2 += 1)
+          S3(c0, 1, c2);
+      }
+      for (int c2 = c1 - (3 * c0 + 14) / 14 + 49; c2 <= c1 + 48; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    for (int c1 = 19; c1 <= 24; c1 += 1) {
+      for (int c2 = -8 * c1; c2 <= -8 * c1 + 24; c2 += 1)
+        S3(c0, c1, c2);
+      for (int c2 = c1 - (6 * c0 + 77) / 77 + 13; c2 <= 30; c2 += 1)
+        S6(c0, c1, c2);
+    }
+  }
+  for (int c0 = 37; c0 <= 218; c0 += 1) {
+    for (int c1 = (c0 + 5) / 14 - 8; c1 < min(0, c0 / 14 - 5); c1 += 1) {
+      if (c0 <= 46 && c1 == -3)
+        S7(c0, -3, 6);
+      if (77 * c1 + 77 * ((-2 * c1 - 2) / 5) + 524 >= 6 * c0)
+        S6(c0, c1, -((-2 * c1 + 3) / 5) + 9);
+      for (int c2 = c1 + 24; c2 <= -2 * c1 + 24; c2 += 1)
+        S2(c0, c1, c2);
+      for (int c2 = -2 * c1 + 30; c2 <= c1 - (3 * c0 + 17) / 14 + 56; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    for (int c1 = c0 / 14 - 5; c1 < 0; c1 += 1) {
+      if (7 * c1 + 114 >= 2 * c0)
+        S7(c0, c1, 6);
+      for (int c2 = max(8, c1 - (6 * c0 + 77) / 77 + 13); c2 <= c1 - (6 * c0 + 91) / 77 + 15; c2 += 1)
+        S6(c0, c1, c2);
+      for (int c2 = c1 - (3 * c0 + 14) / 14 + 49; c2 <= c1 - (3 * c0 + 17) / 14 + 56; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    if (c0 <= 148)
+      for (int c1 = max(0, (c0 + 5) / 14 - 8); c1 < c0 / 14 - 5; c1 += 1) {
+        if (c1 == 0)
+          S2(c0, 0, 24);
+        for (int c2 = max(c1 + 24, -2 * c1 + 30); c2 <= c1 - (3 * c0 + 17) / 14 + 56; c2 += 1)
+          S1(c0, c1, c2);
+      }
+    if (c0 >= 70 && c0 % 14 >= 9)
+      for (int c2 = max(c0 / 14 + 19, -((3 * c0 + 14) / 14) + c0 / 14 + 44); c2 <= -((3 * c0 + 17) / 14) + c0 / 14 + 51; c2 += 1)
+        S1(c0, c0 / 14 - 5, c2);
+    for (int c1 = max(0, (c0 + 5) / 14 - 5); c1 < c0 / 14 - 2; c1 += 1) {
+      for (int c2 = max(c1, -2 * c1 + 6); c2 <= min(c1 + 5, -2 * c1 + 24); c2 += 1)
+        S9(c0, c1, c2);
+      for (int c2 = c1 + 6; c2 <= min((2 * c1 + 1) / 5 + 7, (2 * c0 - 7 * c1 - 10) / 21 + 1); c2 += 1)
+        S9(c0, c1, c2);
+      for (int c2 = max(c1 + 6, (2 * c0 - 7 * c1 - 10) / 21 + 2); c2 <= (2 * c1 + 1) / 5 + 7; c2 += 1) {
+        S7(c0, c1, c2);
+        S9(c0, c1, c2);
+      }
+      if (c1 <= 3)
+        S9(c0, c1, (2 * c1 + 1) / 5 + 8);
+      for (int c2 = (2 * c1 + 1) / 5 + 9; c2 <= c1 - (6 * c0 + 91) / 77 + 15; c2 += 1) {
+        S6(c0, c1, c2);
+        S9(c0, c1, c2);
+      }
+      for (int c2 = max(max(c1 + 6, c1 - (6 * c0 + 91) / 77 + 16), (2 * c1 + 1) / 5 + 9); c2 <= -2 * c1 + 24; c2 += 1)
+        S9(c0, c1, c2);
+      for (int c2 = max(c1, -2 * c1 + 30); c2 <= min(c1 + 24, c1 - (3 * c0 + 17) / 14 + 47); c2 += 1)
+        S8(c0, c1, c2);
+      for (int c2 = max(c1 + 24, c1 - (3 * c0 + 14) / 14 + 49); c2 <= c1 - (3 * c0 + 17) / 14 + 56; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    for (int c1 = c0 / 14 - 2; c1 <= 18; c1 += 1) {
+      for (int c2 = max(6, (c0 + 5) / 14 + 1); c2 <= min(min(c1, c0 / 14 + 3), -c1 + c1 / 2 + 18); c2 += 1)
+        S5(c0, c1, c2);
+      for (int c2 = max(c1 + (3 * c0 + 3) / 14 - 40, -c1 + (c1 + 1) / 2 + 21); c2 <= min(c1, c1 + 3 * c0 / 14 - 33); c2 += 1)
+        S4(c0, c1, c2);
+      for (int c2 = c1 + 6; c2 <= min((2 * c1 + 1) / 5 + 7, (2 * c0 - 7 * c1 + 63) / 21 + 1); c2 += 1)
+        S7(c0, c1, c2);
+      for (int c2 = max(max(c1 + 6, c1 - (6 * c0 + 77) / 77 + 13), (2 * c1 + 1) / 5 + 9); c2 <= c1 - (6 * c0 + 91) / 77 + 15; c2 += 1)
+        S6(c0, c1, c2);
+      for (int c2 = max(c1, c1 - (3 * c0 + 14) / 14 + 40); c2 <= min(c1 + 24, c1 - (3 * c0 + 17) / 14 + 47); c2 += 1)
+        S8(c0, c1, c2);
+      for (int c2 = max(c1 + 24, c1 - (3 * c0 + 14) / 14 + 49); c2 <= c1 - (3 * c0 + 17) / 14 + 56; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    for (int c1 = 19; c1 <= 24; c1 += 1) {
+      for (int c2 = max(c1 - 12, (c0 + 5) / 14 + 1); c2 <= min(c0 / 14 + 3, -c1 + c1 / 2 + 18); c2 += 1)
+        S5(c0, c1, c2);
+      for (int c2 = max(max(c1 - 12, c1 + (3 * c0 + 3) / 14 - 40), -c1 + (c1 + 1) / 2 + 21); c2 <= min(c1, c1 + 3 * c0 / 14 - 33); c2 += 1)
+        S4(c0, c1, c2);
+      for (int c2 = max(c1 + 6, c1 - (6 * c0 + 77) / 77 + 13); c2 <= min(30, c1 - (6 * c0 + 91) / 77 + 15); c2 += 1)
+        S6(c0, c1, c2);
+      for (int c2 = max(c1, c1 - (3 * c0 + 14) / 14 + 40); c2 <= min(c1 + 24, c1 - (3 * c0 + 17) / 14 + 47); c2 += 1)
+        S8(c0, c1, c2);
+    }
+    for (int c1 = 25; c1 <= min(42, -((3 * c0 + 17) / 14) + 71); c1 += 1)
+      for (int c2 = max(c1 - 12, c1 + (3 * c0 + 3) / 14 - 40); c2 <= min(min(30, c1), c1 + 3 * c0 / 14 - 33); c2 += 1)
+        S4(c0, c1, c2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/faber.st b/lib/Analysis/isl/test_inputs/codegen/cloog/faber.st
new file mode 100644
index 0000000..f800894
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/faber.st
@@ -0,0 +1,18 @@
+domain: "{ S2[idx4, idx5, idx6] : 14idx5 <= -84 + idx4 and 14idx5 >= -120 + idx4 and idx6 >= 24 + idx5 and idx6 <= 48 + idx5 and idx5 >= -6 and idx5 <= 18 and idx6 <= 24 - 2idx5; S4[idx4, idx5, idx6] : 14idx6 <= -462 + 3idx4 + 14idx5 and 14idx6 >= -570 + 3idx4 + 14idx5 and idx6 <= idx5 and idx6 >= -12 + idx5 and idx6 >= 6 and idx6 <= 30 and 2idx6 >= 42 - idx5; S6[idx4, idx5, idx6] : 77idx6 >= 924 - 6idx4 + 77idx5 and 77idx6 <= 1140 - 6idx4 + 77idx5 and idx6 <= 12 + idx5 and idx6 >= 6 + idx5 and idx6 >= 6 and idx6 <= 30 and 5idx6 >= 42 + 2idx5; S1[idx4, idx5, idx6] : 14idx6 >= 672 - 3idx4 + 14idx5 and 14idx6 <= 780 - 3idx4 + 14idx5 and idx6 >= 24 + idx5 and idx6 <= 48 + idx5 and idx5 >= -6 and idx5 <= 18 and idx6 >= 30 - 2idx5; S5[idx4, idx5, idx6] : 14idx6 <= 42 + idx4 and 14idx6 >= 6 + idx4 and idx6 <= idx5 and idx6 >= -12 + idx5 and idx6 >= 6 and idx6 <= 30 and 2idx6 <= 36 - idx5; S7[idx4, idx5, idx6] : 21idx6 <= 84 + 2idx4 - 7idx5 and 21idx6 >= 12 + 2idx4 - 7idx5 and idx6 <= 12 + idx5 and idx6 >= 6 + idx5 and idx6 >= 6 and idx6 <= 30 and 5idx6 <= 36 + 2idx5; S8[idx4, idx5, idx6] : 14idx6 >= 546 - 3idx4 + 14idx5 and 14idx6 <= 654 - 3idx4 + 14idx5 and idx6 >= idx5 and idx6 <= 24 + idx5 and idx5 >= 0 and idx5 <= 24 and idx6 >= 30 - 2idx5; S3[idx4, idx5, idx6] : idx4 >= 0 and idx4 <= 36 and idx6 >= -8idx5 and idx6 <= 24 - 8idx5 and idx5 >= 0 and idx5 <= 24; S9[idx4, idx5, idx6] : 14idx5 <= -42 + idx4 and 14idx5 >= -78 + idx4 and idx6 >= idx5 and idx6 <= 24 + idx5 and idx5 >= 0 and idx5 <= 24 and idx6 <= 24 - 2idx5 and idx6 >= 6 - 2idx5; S10[idx4, idx5, idx6] : 7idx6 <= idx4 - 28idx5 and 7idx6 >= -36 + idx4 - 28idx5 and idx6 >= idx5 and idx6 <= 24 + idx5 and idx5 >= 0 and idx5 <= 24 and idx6 <= -2idx5 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S6[idx4, idx5, idx6] -> [(idx4)]; S8[idx4, idx5, idx6] -> [(idx4)]; S5[idx4, idx5, idx6] -> [(idx4)]; S9[idx4, idx5, idx6] -> [(idx4)]; S4[idx4, idx5, idx6] -> [(idx4)]; S10[idx4, idx5, idx6] -> [(idx4)]; S7[idx4, idx5, idx6] -> [(idx4)]; S3[idx4, idx5, idx6] -> [(idx4)]; S1[idx4, idx5, idx6] -> [(idx4)]; S2[idx4, idx5, idx6] -> [(idx4)] }, { S6[idx4, idx5, idx6] -> [(idx5)]; S8[idx4, idx5, idx6] -> [(idx5)]; S5[idx4, idx5, idx6] -> [(idx5)]; S9[idx4, idx5, idx6] -> [(idx5)]; S4[idx4, idx5, idx6] -> [(idx5)]; S10[idx4, idx5, idx6] -> [(idx5)]; S7[idx4, idx5, idx6] -> [(idx5)]; S3[idx4, idx5, idx6] -> [(idx5)]; S1[idx4, idx5, idx6] -> [(idx5)]; S2[idx4, idx5, idx6] -> [(idx5)] }, { S6[idx4, idx5, idx6] -> [(idx6)]; S8[idx4, idx5, idx6] -> [(idx6)]; S5[idx4, idx5, idx6] -> [(idx6)]; S9[idx4, idx5, idx6] -> [(idx6)]; S4[idx4, idx5, idx6] -> [(idx6)]; S10[idx4, idx5, idx6] -> [(idx6)]; S7[idx4, idx5, idx6] -> [(idx6)]; S3[idx4, idx5, idx6] -> [(idx6)]; S1[idx4, idx5, idx6] -> [(idx6)]; S2[idx4, idx5, idx6] -> [(idx6)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[idx4, idx5, idx6] }"
+      - filter: "{ S2[idx4, idx5, idx6] }"
+      - filter: "{ S3[idx4, idx5, idx6] }"
+      - filter: "{ S4[idx4, idx5, idx6] }"
+      - filter: "{ S5[idx4, idx5, idx6] }"
+      - filter: "{ S6[idx4, idx5, idx6] }"
+      - filter: "{ S7[idx4, idx5, idx6] }"
+      - filter: "{ S8[idx4, idx5, idx6] }"
+      - filter: "{ S9[idx4, idx5, idx6] }"
+      - filter: "{ S10[idx4, idx5, idx6] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.c
new file mode 100644
index 0000000..45fe75e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.c
@@ -0,0 +1,9 @@
+{
+  S3(1, 1);
+  for (int c0 = 2; c0 <= M; c0 += 1) {
+    S1(c0, 1);
+    for (int c1 = 2; c1 < c0; c1 += 1)
+      S2(c0, c1);
+    S4(c0, c0);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.st
new file mode 100644
index 0000000..152e6b0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-1-1-2.st
@@ -0,0 +1,12 @@
+domain: "[M] -> { S4[i0, i0] : M >= 3 and i0 <= M and i0 >= 2; S1[i0, 1] : M >= 3 and i0 <= M and i0 >= 2; S3[1, 1] : M >= 3; S2[i0, i1] : i1 <= -1 + i0 and i1 >= 2 and i0 <= M }"
+child:
+  context: "[M] -> { [] : M >= 3 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S4[i0, i1] -> [(i0)]; S3[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S4[i0, i1] -> [(i1)]; S3[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1] }"
+      - filter: "[M] -> { S2[i0, i1] }"
+      - filter: "[M] -> { S3[i0, i1] }"
+      - filter: "[M] -> { S4[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.c
new file mode 100644
index 0000000..cfc3e7d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.c
@@ -0,0 +1,10 @@
+{
+  S3(1, 0);
+  for (int c2 = 2; c2 <= M; c2 += 1)
+    S1(1, 1, c2);
+  for (int c0 = 2; c0 <= M; c0 += 1) {
+    S4(c0, 0);
+    for (int c2 = c0 + 1; c2 <= M; c2 += 1)
+      S2(c0, 1, c2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.st
new file mode 100644
index 0000000..76f0831
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-2-1-2-3.st
@@ -0,0 +1,12 @@
+domain: "[M] -> { S4[i0, 0] : i0 >= 2 and M >= 3 and i0 <= M; S3[1, 0] : M >= 3; S2[i0, 1, i2] : i2 >= 1 + i0 and i0 >= 2 and i2 <= M; S1[1, 1, i2] : M >= 3 and i2 <= M and i2 >= 2 }"
+child:
+  context: "[M] -> { [] : M >= 3 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i0)]; S4[i0, i1] -> [(i0)]; S3[i0, i1] -> [(i0)]; S2[i0, i1, i2] -> [(i0)] }, { S1[i0, i1, i2] -> [(i1)]; S4[i0, i1] -> [(i1)]; S3[i0, i1] -> [(i1)]; S2[i0, i1, i2] -> [(i1)] }, { S1[i0, i1, i2] -> [(i2)]; S4[i0, i1] -> [(0)]; S3[i0, i1] -> [(0)]; S2[i0, i1, i2] -> [(i2)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1, i2] }"
+      - filter: "[M] -> { S2[i0, i1, i2] }"
+      - filter: "[M] -> { S3[i0, i1] }"
+      - filter: "[M] -> { S4[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.c
new file mode 100644
index 0000000..9300d18
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.c
@@ -0,0 +1,17 @@
+{
+  S3(2, 1);
+  S1(3, 1);
+  for (int c0 = 4; c0 <= M + 1; c0 += 1) {
+    S1(c0, 1);
+    for (int c1 = 2; c1 < (c0 + 1) / 2; c1 += 1)
+      S2(c0, c1);
+    if (c0 % 2 == 0)
+      S4(c0, c0 / 2);
+  }
+  for (int c0 = M + 2; c0 <= 2 * M; c0 += 1) {
+    for (int c1 = -M + c0; c1 < (c0 + 1) / 2; c1 += 1)
+      S2(c0, c1);
+    if (c0 % 2 == 0)
+      S4(c0, c0 / 2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.st
new file mode 100644
index 0000000..35677b4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/forwardsub-3-1-2.st
@@ -0,0 +1,12 @@
+domain: "[M] -> { S4[i0, i1] : 2i1 = i0 and M >= 3 and i0 <= 2M and i0 >= 4; S1[i0, 1] : M >= 3 and i0 <= 1 + M and i0 >= 3; S3[2, 1] : M >= 3; S2[i0, i1] : 2i1 <= -1 + i0 and i1 >= 2 and i1 >= -M + i0 }"
+child:
+  context: "[M] -> { [] : M >= 3 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S4[i0, i1] -> [(i0)]; S3[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S4[i0, i1] -> [(i1)]; S3[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1] }"
+      - filter: "[M] -> { S2[i0, i1] }"
+      - filter: "[M] -> { S3[i0, i1] }"
+      - filter: "[M] -> { S4[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gauss.c b/lib/Analysis/isl/test_inputs/codegen/cloog/gauss.c
new file mode 100644
index 0000000..4bbe42c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gauss.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 < M; c0 += 1)
+  for (int c1 = c0 + 1; c1 <= M; c1 += 1) {
+    for (int c3 = 1; c3 < c0; c3 += 1)
+      S1(c0, c3, c1);
+    for (int c3 = c0 + 1; c3 <= M; c3 += 1)
+      S2(c0, c3, c1);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gauss.st b/lib/Analysis/isl/test_inputs/codegen/cloog/gauss.st
new file mode 100644
index 0000000..7173a4c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gauss.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S2[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 1 + i0 and i1 <= M and i2 >= 1 + i0 and i2 <= M; S1[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= -1 + i0 and i2 >= 1 + i0 and i2 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)] }, { S1[i0, i1, i2] -> [(i2)]; S2[i0, i1, i2] -> [(i2)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gesced.c b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced.c
new file mode 100644
index 0000000..40cdad9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced.c
@@ -0,0 +1,16 @@
+{
+  for (int c0 = 1; c0 <= N; c0 += 1)
+    S1(c0);
+  for (int c0 = N + 1; c0 <= 2 * N; c0 += 1)
+    for (int c1 = 1; c1 <= N; c1 += 1)
+      S2(c1, -N + c0);
+  for (int c0 = 2 * N + 1; c0 <= M + N; c0 += 1) {
+    for (int c1 = 1; c1 <= N; c1 += 1)
+      S2(c1, -N + c0);
+    for (int c1 = 1; c1 <= N; c1 += 1)
+      S3(c1, -2 * N + c0);
+  }
+  for (int c0 = M + N + 1; c0 <= M + 2 * N; c0 += 1)
+    for (int c1 = 1; c1 <= N; c1 += 1)
+      S3(c1, -2 * N + c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gesced.st b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced.st
new file mode 100644
index 0000000..3534f75
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S3[i0, i1] : i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= M; S1[i0] : i0 >= 1 and i0 <= N; S2[i0, i1] : i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= M }"
+child:
+  context: "[M, N] -> { [] : N <= M and M >= 2 and N >= 2 }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0, i1] -> [(N + i1)]; S3[i0, i1] -> [(2N + i1)]; S1[i0] -> [(i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.c
new file mode 100644
index 0000000..eeba38e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.c
@@ -0,0 +1,20 @@
+{
+  for (int c0 = 1; c0 <= 4; c0 += 1)
+    for (int c1 = 5; c1 < M - 9; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 5; c0 < M - 9; c0 += 1) {
+    for (int c1 = -c0 + 1; c1 <= 4; c1 += 1)
+      S2(c0 + c1, c0);
+    for (int c1 = 5; c1 <= min(M - 10, M - c0); c1 += 1) {
+      S2(c0 + c1, c0);
+      S1(c0, c1);
+    }
+    for (int c1 = M - c0 + 1; c1 < M - 9; c1 += 1)
+      S1(c0, c1);
+    for (int c1 = M - 9; c1 <= M - c0; c1 += 1)
+      S2(c0 + c1, c0);
+  }
+  for (int c0 = M - 9; c0 <= M; c0 += 1)
+    for (int c1 = 5; c1 < M - 9; c1 += 1)
+      S1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.st
new file mode 100644
index 0000000..c5f41bf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced2.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 5 and i1 <= -10 + M; S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 5 and i1 <= -10 + M }"
+child:
+  context: "[M] -> { [] : M >= 16 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i1)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i0 - i1)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.c
new file mode 100644
index 0000000..c163ed0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.c
@@ -0,0 +1,10 @@
+{
+  for (int c0 = M + 1; c0 <= 2 * M; c0 += 1)
+    S1(-M + c0);
+  for (int c0 = 2 * M + 1; c0 <= M + N; c0 += 1) {
+    S2(-2 * M + c0);
+    S1(-M + c0);
+  }
+  for (int c0 = M + N + 1; c0 <= 2 * M + N; c0 += 1)
+    S2(-2 * M + c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.st
new file mode 100644
index 0000000..cb0a285
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/gesced3.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S1[i0] : i0 >= 1 and i0 <= N; S2[i0] : i0 >= 1 and i0 <= N }"
+child:
+  context: "[M, N] -> { [] : N >= M and M >= 2 }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0] -> [(2M + i0)]; S1[i0] -> [(M + i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/guide.c b/lib/Analysis/isl/test_inputs/codegen/cloog/guide.c
new file mode 100644
index 0000000..bc48f1e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/guide.c
@@ -0,0 +1,6 @@
+{
+  for (int c0 = 1; c0 <= N; c0 += 1)
+    S1(c0);
+  for (int c0 = N + 1; c0 <= 2 * N; c0 += 1)
+    S2(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/guide.st b/lib/Analysis/isl/test_inputs/codegen/cloog/guide.st
new file mode 100644
index 0000000..3ca5c6e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/guide.st
@@ -0,0 +1,10 @@
+domain: "[M, N] -> { S1[i0] : (i0 >= 1 and i0 <= N and i0 <= 2M) or (i0 >= M and i0 >= 1 and i0 <= N); S2[i0] : i0 >= 1 + N and i0 <= 2N }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0] -> [(i0)]; S1[i0] -> [(i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0] }"
+      - filter: "[M, N] -> { S2[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/iftest.c b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest.c
new file mode 100644
index 0000000..0f41fb7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest.c
@@ -0,0 +1,2 @@
+for (int c0 = 1; c0 <= n; c0 += 1)
+  S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/iftest.st b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest.st
new file mode 100644
index 0000000..cd26fab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest.st
@@ -0,0 +1,6 @@
+domain: "[m, n] -> { S1[i0] : (i0 >= m and i0 >= 1 and i0 <= n) or (i0 >= 1 and i0 <= n and i0 <= 2m) }"
+child:
+  context: "[m, n] -> { [] }"
+  child:
+    schedule: "[m, n] -> [{ S1[i0] -> [(i0)] }]"
+    options: "[m, n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.c
new file mode 100644
index 0000000..8e3e4c1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= N; c0 += 1)
+  for (int c1 = 1; c1 <= M; c1 += 1)
+    S1(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.st
new file mode 100644
index 0000000..f073f5c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/iftest2.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S1[i0, i1] : (i0 >= M and i0 <= N and i1 >= 1 and i1 <= M) or (i0 >= 1 and i0 <= N and i0 <= 2M and i1 >= 1 and i1 <= M) }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.c
new file mode 100644
index 0000000..bbb6d6e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.c
@@ -0,0 +1,9 @@
+{
+  for (int c0 = 1; c0 <= N; c0 += 1) {
+    S1(c0);
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0, c1);
+  }
+  for (int c0 = N + 1; 1; c0 += 1)
+    S1(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.st
new file mode 100644
index 0000000..7bd85d3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/infinite2.st
@@ -0,0 +1,10 @@
+domain: "[M, N] -> { S1[i0] : i0 >= 1; S2[i0, i1] : i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= M }"
+child:
+  context: "[M, N] -> { [] : M >= 1 and N >= 1 }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0, i1] -> [(i0)]; S1[i0] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0] -> [(0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.c b/lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.c
new file mode 100644
index 0000000..bf70932
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.c
@@ -0,0 +1,3 @@
+if (((t1 + 31) % 32) + g2 >= 2 && N >= ((t1 + 31) % 32) + g2 + 2 && (h0 + 1) % 2 == 0)
+  for (int c0 = max(((t0 + 15) % 16) + 1, ((g1 + t0 + 13) % 16) - g1 + 3); c0 <= min(32, N - g1 - 1); c0 += 16)
+    S1(g1 + c0 - 1, -((g2 - t1 + 32) % 32) + g2 + 31);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.st b/lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.st
new file mode 100644
index 0000000..73f5dd8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/jacobi-shared.st
@@ -0,0 +1,6 @@
+domain: "[T, N, h0, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> { S1[i0, i1] : exists (e0 = floor((-1 + h0)/2), e1 = floor((-32b0 + g1)/2048), e2 = floor((-32b1 + g2)/1024), e3 = floor((-15 - t0 + i0)/16), e4 = floor((-31 - t1 + i1)/32): g0 = h0 and 2e0 = -1 + h0 and 2048e1 = -32b0 + g1 and 1024e2 = -32b1 + g2 and 16e3 = -15 - t0 + i0 and 32e4 = -31 - t1 + i1 and h0 >= 1 and h0 <= -1 + 2T and i0 >= 2 and i0 <= -2 + N and i1 >= 2 and i1 <= -2 + N and b1 <= 31 and b1 >= 0 and b0 <= 63 and b0 >= 0 and i1 <= 31 + g2 and i1 >= g2 and N >= 4 and i0 >= g1 and i0 <= 31 + g1 and g2 <= -2 + N and g2 >= -29 and g1 <= -2 + N and g1 >= -29 and g1 >= 32b0 and g2 >= 32b1 and 32b0 <= -2 + N and 32b1 <= -2 + N and t0 >= 0 and t0 <= 15 and t1 >= 0 and t1 <= 31) }"
+child:
+  context: "[T, N, h0, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> { [] : exists (e0 = floor((-32b0 + g1)/2048), e1 = floor((-32b1 + g2)/1024): g0 = h0 and 2048e0 = -32b0 + g1 and 1024e1 = -32b1 + g2 and g2 <= -2 + N and g2 >= -29 and g1 <= -2 + N and g1 >= -29 and b1 >= 0 and b1 <= 31 and b0 <= 63 and 32b1 <= -2 + N and 32b0 <= -2 + N and b0 >= 0 and N >= 4 and h0 >= 0 and h0 <= -1 + 2T and g2 >= 32b1 and g1 >= 32b0 and t0 >= 0 and t0 <= 15 and t1 >= 0 and t1 <= 31) }"
+  child:
+    schedule: "[T, N, h0, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> [{ S1[i0, i1] -> [(1 - g1 + i0)] }, { S1[i0, i1] -> [(1 - g2 + i1)] }, { S1[i0, i1] -> [(t0)] }, { S1[i0, i1] -> [(t1)] }]"
+    options: "[T, N, h0, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> { separate[x] : x >= 3 }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/largeur.c b/lib/Analysis/isl/test_inputs/codegen/cloog/largeur.c
new file mode 100644
index 0000000..faced0a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/largeur.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= M; c0 += 1)
+  for (int c1 = 1; c1 <= c0; c1 += 1)
+    S1(c1, c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/largeur.st b/lib/Analysis/isl/test_inputs/codegen/cloog/largeur.st
new file mode 100644
index 0000000..bb29f21
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/largeur.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= i0 and i1 <= M }"
+child:
+  context: "[M] -> { [] : M >= 0 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i1)] }, { S1[i0, i1] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.c
new file mode 100644
index 0000000..70d1ea5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.c
@@ -0,0 +1,32 @@
+{
+  S1(0, 0);
+  for (int c0 = 1; c0 <= N; c0 += 1) {
+    S2(c0, 0);
+    for (int c1 = 1; c1 < c0; c1 += 1)
+      S6(c0, c1);
+    S3(c0, c0);
+  }
+  S7(N + 1, 0);
+  for (int c1 = 1; c1 <= N; c1 += 1) {
+    S6(N + 1, c1);
+    S8(N + 1, c1);
+  }
+  for (int c0 = N + 2; c0 < 2 * M - N - 1; c0 += 1) {
+    S7(c0, -N + (N + c0 + 1) / 2 - 1);
+    if ((N + c0) % 2 == 0) {
+      S5(c0, (-N + c0) / 2);
+      S8(c0, (-N + c0) / 2);
+    }
+    for (int c1 = -N + (N + c0) / 2 + 1; c1 < (N + c0 + 1) / 2; c1 += 1) {
+      S6(c0, c1);
+      S8(c0, c1);
+    }
+    if ((N + c0) % 2 == 0) {
+      S4(c0, (N + c0) / 2);
+      S8(c0, (N + c0) / 2);
+    }
+  }
+  for (int c0 = 2 * M - N - 1; c0 < 2 * M - 1; c0 += 1)
+    for (int c1 = -M + c0 + 1; c1 < M; c1 += 1)
+      S6(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.st
new file mode 100644
index 0000000..9b1d7cb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/levenshtein-1-2-3.st
@@ -0,0 +1,16 @@
+domain: "[M, N] -> { S5[i0, i1] : 2i1 = -N + i0 and i0 >= 2 + N and i0 <= -2 + 2M - N and N >= 1; S3[i0, i0] : i0 >= 1 and i0 <= N and N <= -2 + M; S7[i0, i1] : i0 >= 1 + N and 2i1 <= -1 - N + i0 and i0 <= -2 + 2M - N and 2i1 >= -2 - N + i0 and N <= -2 + M and N >= 1; S6[i0, i1] : 2i1 <= -1 + N + i0 and i1 <= -1 + i0 and i1 >= 1 - M + i0 and 2i1 >= 1 - N + i0 and i1 >= 1 and i1 <= -1 + M and N <= -2 + M; S1[0, 0] : N <= -2 + M and N >= 1; S2[i0, 0] : i0 >= 1 and i0 <= N and N <= -2 + M; S4[i0, i1] : 2i1 = N + i0 and i0 >= 2 + N and i0 <= -2 + 2M - N and N >= 1; S8[i0, i1] : i0 >= 1 + N and 2i1 <= N + i0 and 2i1 >= -N + i0 and i0 <= -2 + 2M - N and N <= -2 + M and N >= 1 }"
+child:
+  context: "[M, N] -> { [] : N <= -2 + M and N >= 1 }"
+  child:
+    schedule: "[M, N] -> [{ S7[i0, i1] -> [(i0)]; S5[i0, i1] -> [(i0)]; S1[i0, i1] -> [(i0)]; S3[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)]; S4[i0, i1] -> [(i0)]; S8[i0, i1] -> [(i0)]; S6[i0, i1] -> [(i0)] }, { S7[i0, i1] -> [(i1)]; S5[i0, i1] -> [(i1)]; S1[i0, i1] -> [(i1)]; S3[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)]; S4[i0, i1] -> [(i1)]; S8[i0, i1] -> [(i1)]; S6[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
+      - filter: "[M, N] -> { S3[i0, i1] }"
+      - filter: "[M, N] -> { S4[i0, i1] }"
+      - filter: "[M, N] -> { S5[i0, i1] }"
+      - filter: "[M, N] -> { S6[i0, i1] }"
+      - filter: "[M, N] -> { S7[i0, i1] }"
+      - filter: "[M, N] -> { S8[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lex.c b/lib/Analysis/isl/test_inputs/codegen/cloog/lex.c
new file mode 100644
index 0000000..e81e97e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lex.c
@@ -0,0 +1,4 @@
+for (int c0 = 0; c0 <= 10; c0 += 1) {
+  S2(c0);
+  S1(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lex.st b/lib/Analysis/isl/test_inputs/codegen/cloog/lex.st
new file mode 100644
index 0000000..2d4d58d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lex.st
@@ -0,0 +1,10 @@
+domain: "{ S1[i0] : i0 >= 0 and i0 <= 10; S2[i0] : i0 >= 0 and i0 <= 10 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S2[i0] -> [(i0)]; S1[i0] -> [(i0)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S2[i0] }"
+      - filter: "{ S1[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.c
new file mode 100644
index 0000000..bb1e071
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.c
@@ -0,0 +1,8 @@
+for (int c0 = 1; c0 <= M; c0 += 1) {
+  for (int c1 = 1; c1 < c0; c1 += 1)
+    S1(c0, c1);
+  S1(c0, c0);
+  S2(c0, c0);
+  for (int c1 = c0 + 1; c1 <= M; c1 += 1)
+    S1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.st
new file mode 100644
index 0000000..0d079b5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-1-2.st
@@ -0,0 +1,10 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i1 >= 1 and i0 <= M and i1 <= M; S2[i0, i0] : i0 >= 1 and i0 <= M }"
+child:
+  context: "[M] -> { [] : M >= 2 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1] }"
+      - filter: "[M] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.c
new file mode 100644
index 0000000..97a4b04
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.c
@@ -0,0 +1,12 @@
+for (int c0 = 1; c0 <= M; c0 += 1) {
+  for (int c1 = 1; c1 <= min(M, c0 + 1); c1 += 1)
+    S1(c0, c1);
+  if (M >= c0 + 2) {
+    S1(c0, c0 + 2);
+    S2(c0, c0 + 2);
+  }
+  for (int c1 = c0 + 3; c1 <= M; c1 += 1)
+    S1(c0, c1);
+  if (c0 + 1 >= M)
+    S2(c0, c0 + 2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.st
new file mode 100644
index 0000000..dbadca7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lineality-2-1-2.st
@@ -0,0 +1,10 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i1 >= 1 and i0 <= M and i1 <= M; S2[i0, 2 + i0] : i0 >= 1 and i0 <= M }"
+child:
+  context: "[M] -> { [] : M >= 2 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1] }"
+      - filter: "[M] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/logo.c b/lib/Analysis/isl/test_inputs/codegen/cloog/logo.c
new file mode 100644
index 0000000..abe35b5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/logo.c
@@ -0,0 +1,17 @@
+{
+  for (int c1 = 0; c1 <= 7; c1 += 1)
+    S1(1, c1);
+  for (int c0 = 2; c0 <= 6; c0 += 1) {
+    for (int c1 = 0; c1 < c0 - 1; c1 += 1)
+      S2(c0, c1);
+    for (int c1 = c0 - 1; c1 <= 4; c1 += 1) {
+      S1(c0, c1);
+      S2(c0, c1);
+    }
+    for (int c1 = 5; c1 <= 7; c1 += 1)
+      S1(c0, c1);
+  }
+  for (int c0 = 7; c0 <= 8; c0 += 1)
+    for (int c1 = c0 - 1; c1 <= 7; c1 += 1)
+      S1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/logo.st b/lib/Analysis/isl/test_inputs/codegen/cloog/logo.st
new file mode 100644
index 0000000..89fe649
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/logo.st
@@ -0,0 +1,10 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i1 <= 7 and i1 >= -1 + i0; S2[i0, i1] : i0 >= 2 and i0 <= 6 and i1 >= 0 and i1 <= 4 }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1] }"
+      - filter: "[M] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/logopar.c b/lib/Analysis/isl/test_inputs/codegen/cloog/logopar.c
new file mode 100644
index 0000000..70f98e8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/logopar.c
@@ -0,0 +1,17 @@
+{
+  for (int c1 = 0; c1 <= m; c1 += 1)
+    S1(1, c1);
+  for (int c0 = 2; c0 <= n; c0 += 1) {
+    for (int c1 = 0; c1 < c0 - 1; c1 += 1)
+      S2(c0, c1);
+    for (int c1 = c0 - 1; c1 <= n; c1 += 1) {
+      S1(c0, c1);
+      S2(c0, c1);
+    }
+    for (int c1 = n + 1; c1 <= m; c1 += 1)
+      S1(c0, c1);
+  }
+  for (int c0 = n + 1; c0 <= m + 1; c0 += 1)
+    for (int c1 = c0 - 1; c1 <= m; c1 += 1)
+      S1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/logopar.st b/lib/Analysis/isl/test_inputs/codegen/cloog/logopar.st
new file mode 100644
index 0000000..8ed609b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/logopar.st
@@ -0,0 +1,10 @@
+domain: "[m, n] -> { S1[i0, i1] : i0 >= 1 and i1 <= m and i1 >= -1 + i0; S2[i0, i1] : i0 >= 2 and i0 <= n and i1 >= 0 and i1 <= n }"
+child:
+  context: "[m, n] -> { [] : n <= m and m >= 0 and n >= 2 }"
+  child:
+    schedule: "[m, n] -> [{ S2[i0, i1] -> [(i0)]; S1[i0, i1] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0, i1] -> [(i1)] }]"
+    options: "[m, n] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[m, n] -> { S1[i0, i1] }"
+      - filter: "[m, n] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lu.c b/lib/Analysis/isl/test_inputs/codegen/cloog/lu.c
new file mode 100644
index 0000000..a7fe2b3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lu.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= n; c0 += 1) {
+  for (int c1 = 2; c1 <= n; c1 += 1)
+    for (int c2 = 1; c2 < min(c0, c1); c2 += 1)
+      S2(c2, c1, c0);
+  for (int c3 = c0 + 1; c3 <= n; c3 += 1)
+    S1(c0, c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lu.st b/lib/Analysis/isl/test_inputs/codegen/cloog/lu.st
new file mode 100644
index 0000000..6f9320c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lu.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i0, i1] : i0 >= 1 and i0 <= n and i1 >= 1 + i0 and i1 <= n; S2[i0, i1, i2] : i0 >= 1 and i0 <= n and i1 >= 1 + i0 and i1 <= n and i2 >= 1 + i0 and i2 <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S2[i0, i1, i2] -> [(i2)]; S1[i0, i1] -> [(i0)] }, { S2[i0, i1, i2] -> [(i1)]; S1[i0, i1] -> [(n)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lu2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/lu2.c
new file mode 100644
index 0000000..d5cc912
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lu2.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= n; c0 += 1) {
+  for (int c1 = 2; c1 <= n; c1 += 1)
+    for (int c2 = 1; c2 < min(c0, c1); c2 += 1)
+      S2(c0, c1, c2, c1, c0);
+  for (int c3 = c0 + 1; c3 <= n; c3 += 1)
+    S1(c0, n, c0, c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lu2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/lu2.st
new file mode 100644
index 0000000..eb0ab21
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lu2.st
@@ -0,0 +1,10 @@
+domain: "[n] -> { S2[i0, i1, i2, i1, i0] : i2 >= 1 and i2 <= n and i2 <= -1 + i1 and i1 <= n and i2 <= -1 + i0 and i0 <= n; S1[i0, n, i0, i3] : i0 >= 1 and i0 <= n and i3 >= 1 + i0 and i3 <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S2[i0, i1, i2, i3, i4] -> [(i0)]; S1[i0, i1, i2, i3] -> [(i0)] }, { S2[i0, i1, i2, i3, i4] -> [(i1)]; S1[i0, i1, i2, i3] -> [(i1)] }, { S2[i0, i1, i2, i3, i4] -> [(i2)]; S1[i0, i1, i2, i3] -> [(i2)] }, { S2[i0, i1, i2, i3, i4] -> [(i3)]; S1[i0, i1, i2, i3] -> [(i3)] }, { S2[i0, i1, i2, i3, i4] -> [(i4)]; S1[i0, i1, i2, i3] -> [(0)] }]"
+    options: "[n] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[n] -> { S1[i0, i1, i2, i3] }"
+      - filter: "[n] -> { S2[i0, i1, i2, i3, i4] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lux.c b/lib/Analysis/isl/test_inputs/codegen/cloog/lux.c
new file mode 100644
index 0000000..3b33025
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lux.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= M; c0 += 1) {
+  for (int c1 = 1; c1 < c0; c1 += 1)
+    for (int c2 = c1 + 1; c2 <= M; c2 += 1)
+      S2(c0, c1, c2, c2, c0);
+  for (int c3 = c0 + 1; c3 <= M; c3 += 1)
+    S1(c0, c0, M, c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/lux.st b/lib/Analysis/isl/test_inputs/codegen/cloog/lux.st
new file mode 100644
index 0000000..8c5bdb6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/lux.st
@@ -0,0 +1,10 @@
+domain: "[M] -> { S1[i0, i0, M, i3] : i0 >= 1 and i0 <= M and i3 >= 1 + i0 and i3 <= M; S2[i0, i1, i2, i2, i0] : i1 >= 1 and i1 <= M and i2 >= 1 + i1 and i2 <= M and i1 <= -1 + i0 and i0 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i0)]; S2[i0, i1, i2, i3, i4] -> [(i0)] }, { S1[i0, i1, i2, i3] -> [(i1)]; S2[i0, i1, i2, i3, i4] -> [(i1)] }, { S1[i0, i1, i2, i3] -> [(i2)]; S2[i0, i1, i2, i3, i4] -> [(i2)] }, { S1[i0, i1, i2, i3] -> [(i3)]; S2[i0, i1, i2, i3, i4] -> [(i3)] }, { S1[i0, i1, i2, i3] -> [(0)]; S2[i0, i1, i2, i3, i4] -> [(i4)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1, i2, i3] }"
+      - filter: "[M] -> { S2[i0, i1, i2, i3, i4] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/merge.c b/lib/Analysis/isl/test_inputs/codegen/cloog/merge.c
new file mode 100644
index 0000000..64564ad
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/merge.c
@@ -0,0 +1,8 @@
+{
+  S1(0);
+  for (int c0 = 0; c0 <= 10; c0 += 1) {
+    if (c0 >= 2)
+      S2(c0);
+    S3(c0);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/merge.st b/lib/Analysis/isl/test_inputs/codegen/cloog/merge.st
new file mode 100644
index 0000000..d451317
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/merge.st
@@ -0,0 +1,11 @@
+domain: "{ S3[i0] : i0 >= 0 and i0 <= 10; S1[0]; S2[i0] : i0 >= 2 and i0 <= 10 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S2[i0] -> [(i0)]; S3[i0] -> [(i0)]; S1[i0] -> [(i0)] }]"
+    options: "{ atomic[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0] }"
+      - filter: "{ S2[i0] }"
+      - filter: "{ S3[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.c
new file mode 100644
index 0000000..b869e1b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= N; c0 += 1)
+  for (int c1 = 0; c1 <= min(min(M, c0), N - c0); c1 += 1)
+    S1(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.st
new file mode 100644
index 0000000..cf3dc12
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-1-1.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S1[i0, i1] : i0 >= 1 and i1 >= 0 and i1 <= M and i1 <= i0 and i1 <= N - i0 }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.c
new file mode 100644
index 0000000..8e6fabf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.c
@@ -0,0 +1,4 @@
+for (int c0 = 1; c0 <= N; c0 += 1)
+  for (int c1 = 0; c1 <= min(min(M, c0), N - c0); c1 += 1)
+    for (int c2 = 0; c2 <= min(min(M, c0), N - c0); c2 += 1)
+      S1(c0, c1, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.st
new file mode 100644
index 0000000..c2a4852
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-2-1.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S1[i0, i1, i2] : i0 >= 1 and i1 >= 0 and i1 <= M and i1 <= i0 and i1 <= N - i0 and i2 >= 0 and i2 <= M and i2 <= i0 and i2 <= N - i0 }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(i0)] }, { S1[i0, i1, i2] -> [(i1)] }, { S1[i0, i1, i2] -> [(i2)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.c
new file mode 100644
index 0000000..8d11d76
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= min(10, M); c0 += 1)
+  for (int c1 = 0; c1 <= min(10, M); c1 += 1)
+    S1(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.st
new file mode 100644
index 0000000..30dec04
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-3-1.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 0 and i0 <= M and i0 <= 10 and i1 >= 0 and i1 <= M and i1 <= 10 }"
+child:
+  context: "[M] -> { [] : M >= 0 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.c
new file mode 100644
index 0000000..da272fc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.c
@@ -0,0 +1,2 @@
+for (int c0 = max(-M, -N); c0 <= min(N, O); c0 += 1)
+  S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.st
new file mode 100644
index 0000000..8c0fd86
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/min-4-1.st
@@ -0,0 +1,6 @@
+domain: "[M, N, O] -> { S1[i0] : i0 >= -M and i0 >= -N and i0 <= N and i0 <= O }"
+child:
+  context: "[M, N, O] -> { [] }"
+  child:
+    schedule: "[M, N, O] -> [{ S1[i0] -> [(i0)] }]"
+    options: "[M, N, O] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod.c b/lib/Analysis/isl/test_inputs/codegen/cloog/mod.c
new file mode 100644
index 0000000..cafe0b8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= 3; c0 += 1)
+  if ((c0 + 1) % 3 >= 1)
+    S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod.st b/lib/Analysis/isl/test_inputs/codegen/cloog/mod.st
new file mode 100644
index 0000000..cecdef1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod.st
@@ -0,0 +1,6 @@
+domain: "{ S1[i0] : exists (e0 = floor((1 + i0)/3): 3e0 <= i0 and 3e0 >= -1 + i0 and i0 >= 0 and i0 <= 3) }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0] -> [(i0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/mod2.c
new file mode 100644
index 0000000..cafe0b8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod2.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= 3; c0 += 1)
+  if ((c0 + 1) % 3 >= 1)
+    S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/mod2.st
new file mode 100644
index 0000000..3097bb7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod2.st
@@ -0,0 +1,6 @@
+domain: "{ S1[i] : exists (e0 = floor((1 + i)/3): 3e0 <= i and 3e0 >= -1 + i and i >= 0 and i <= 3) }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i] -> [(i)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/mod3.c
new file mode 100644
index 0000000..f8d879c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod3.c
@@ -0,0 +1,4 @@
+for (int c0 = max(0, 32 * h0 - 1991); c0 <= min(999, 32 * h0 + 31); c0 += 1)
+  if ((32 * h0 - c0 + 32) % 64 >= 1)
+    for (int c1 = 0; c1 <= 999; c1 += 1)
+      S1(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/mod3.st
new file mode 100644
index 0000000..eaad170
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod3.st
@@ -0,0 +1,6 @@
+domain: "[h0] -> { S1[i0, i1] : exists (e0 = floor((32 + 32h0 - i0)/64): 64e0 <= 31 + 32h0 - i0 and 64e0 >= -31 + 32h0 - i0 and i0 >= 0 and i0 <= 999 and i0 >= -2015 + 32h0 and 32e0 >= -999 + 32h0 - i0 and i1 >= 0 and i1 <= 999 and i0 <= 32 + 32h0) }"
+child:
+  context: "[h0] -> { [] : h0 <= 93 and h0 >= 0 }"
+  child:
+    schedule: "[h0] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[h0] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod4.c b/lib/Analysis/isl/test_inputs/codegen/cloog/mod4.c
new file mode 100644
index 0000000..a5dca24
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod4.c
@@ -0,0 +1,5 @@
+for (int c0 = 2; c0 <= 10; c0 += 3) {
+  S1(c0, (c0 + 1) / 3, (c0 + 1) / 3, 2, (c0 - 2) / 3);
+  S2(c0, (c0 + 1) / 3, (c0 + 1) / 3, 2, (c0 - 2) / 3);
+  S3(c0, (c0 + 1) / 3, (c0 + 1) / 3, 2, (c0 - 2) / 3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mod4.st b/lib/Analysis/isl/test_inputs/codegen/cloog/mod4.st
new file mode 100644
index 0000000..99501a8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mod4.st
@@ -0,0 +1,11 @@
+domain: "{ S1[j, div41, div42, 2, mod6_a] : 3mod6_a = -2 + j and j >= 1 and j <= 10 and 3div41 >= j and 3div42 >= -1 + j and 3div42 <= 1 + j and 3div41 <= 2 + j; S2[j, div41, div42, 2, mod6_a] : 3div42 = 1 + j and 3mod6_a = -2 + j and 3div41 >= 1 + j and 3div41 <= 2 + j and j >= 1 and j <= 10; S3[j, div41, div42, 2, mod6_a] : 3mod6_a = -2 + j and j >= 1 and j <= 10 and 3div41 >= j and 3div42 >= -1 + j and 3div42 <= 1 + j and 3div41 <= 2 + j }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[j, div41, div42, mod6, mod6_a] -> [(j)]; S3[j, div41, div42, mod6, mod6_a] -> [(j)]; S2[j, div41, div42, mod6, mod6_a] -> [(j)] }, { S1[j, div41, div42, mod6, mod6_a] -> [(div41)]; S3[j, div41, div42, mod6, mod6_a] -> [(div41)]; S2[j, div41, div42, mod6, mod6_a] -> [(div41)] }, { S1[j, div41, div42, mod6, mod6_a] -> [(div42)]; S3[j, div41, div42, mod6, mod6_a] -> [(div42)]; S2[j, div41, div42, mod6, mod6_a] -> [(div42)] }, { S1[j, div41, div42, mod6, mod6_a] -> [(mod6)]; S3[j, div41, div42, mod6, mod6_a] -> [(mod6)]; S2[j, div41, div42, mod6, mod6_a] -> [(mod6)] }, { S1[j, div41, div42, mod6, mod6_a] -> [(mod6_a)]; S3[j, div41, div42, mod6, mod6_a] -> [(mod6_a)]; S2[j, div41, div42, mod6, mod6_a] -> [(mod6_a)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[j, div41, div42, mod6, mod6_a] }"
+      - filter: "{ S2[j, div41, div42, mod6, mod6_a] }"
+      - filter: "{ S3[j, div41, div42, mod6, mod6_a] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mode.c b/lib/Analysis/isl/test_inputs/codegen/cloog/mode.c
new file mode 100644
index 0000000..5596b26
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mode.c
@@ -0,0 +1,10 @@
+for (int c0 = 0; c0 <= M; c0 += 1) {
+  for (int c1 = 0; c1 <= min(N, c0); c1 += 1) {
+    S1(c0, c1);
+    S2(c0, c1);
+  }
+  for (int c1 = c0 + 1; c1 <= N; c1 += 1)
+    S2(c0, c1);
+  for (int c1 = max(0, N + 1); c1 <= c0; c1 += 1)
+    S1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mode.st b/lib/Analysis/isl/test_inputs/codegen/cloog/mode.st
new file mode 100644
index 0000000..68ece14
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mode.st
@@ -0,0 +1,10 @@
+domain: "[M, N] -> { S1[i0, i1] : i0 >= 0 and i0 <= M and i1 >= 0 and i1 <= i0; S2[i0, i1] : i0 >= 0 and i0 <= M and i1 >= 0 and i1 <= N }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.c
new file mode 100644
index 0000000..271d863
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.c
@@ -0,0 +1,8 @@
+for (int c0 = 0; c0 <= M; c0 += 1) {
+  for (int c1 = 0; c1 <= min(N, c0); c1 += 1) {
+    S1(c0, c1);
+    S2(c0, c1);
+  }
+  for (int c1 = N + 1; c1 <= c0; c1 += 1)
+    S1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.st
new file mode 100644
index 0000000..de96851
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-mm-1.st
@@ -0,0 +1,10 @@
+domain: "[M, N] -> { S1[i0, i1] : i1 >= 0 and i1 <= i0 and i0 <= M; S2[i0, i1] : i1 >= 0 and i1 <= i0 and i0 <= M and i1 <= N }"
+child:
+  context: "[M, N] -> { [] : N <= M and N >= 1 }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.c b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.c
new file mode 100644
index 0000000..2c63c08
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.c
@@ -0,0 +1,2 @@
+{
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.st b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.st
new file mode 100644
index 0000000..2c7788b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride.st
@@ -0,0 +1,6 @@
+domain: "{ S1[i0, i1, i2] : 2i1 = -1 + i0 and 6i2 = -2 + i0 and i0 >= 0 and i0 <= 100 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1, i2] -> [(i0)] }, { S1[i0, i1, i2] -> [(i1)] }, { S1[i0, i1, i2] -> [(i2)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.c
new file mode 100644
index 0000000..14f8050
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.c
@@ -0,0 +1,2 @@
+for (int c0 = 5; c0 <= 100; c0 += 6)
+  S1(c0, (c0 - 1) / 2, (c0 - 2) / 3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.st
new file mode 100644
index 0000000..e3fc0bc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/multi-stride2.st
@@ -0,0 +1,6 @@
+domain: "{ S1[i0, i1, i2] : 2i1 = -1 + i0 and 3i2 = -2 + i0 and i0 >= 0 and i0 <= 100 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1, i2] -> [(i0)] }, { S1[i0, i1, i2] -> [(i1)] }, { S1[i0, i1, i2] -> [(i2)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.c b/lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.c
new file mode 100644
index 0000000..4308a9c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.c
@@ -0,0 +1,3 @@
+if (N >= g0 + t1 + 1 && t1 <= 7 && g4 % 4 == 0)
+  for (int c0 = t0; c0 <= min(127, N - g1 - 1); c0 += 16)
+    S1(g0 + t1, g1 + c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.st b/lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.st
new file mode 100644
index 0000000..c86ed9c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/mxm-shared.st
@@ -0,0 +1,6 @@
+domain: "[N, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> { S1[g0 + t1, i1] : (exists (e0 = floor((g1)/128), e1 = floor((128b1 - g1)/4096), e2 = floor((-8b0 + g0)/128), e3 = floor((-t0 + i1)/16): g3 = 128b1 and g4 = 0 and g2 = 8b0 and 128e0 = g1 and 4096e1 = 128b1 - g1 and 128e2 = -8b0 + g0 and 16e3 = -t0 + i1 and b0 <= 15 and b0 >= 0 and b1 <= 31 and b1 >= 0 and g0 >= 8b0 and g1 >= 128b1 and t0 <= 15 and t0 >= 0 and t1 <= 7 and t1 >= 0 and t1 <= -1 + N - g0 and i1 >= g1 and i1 <= 127 + g1 and i1 <= -1 + N)) or (exists (e0 = floor((g1)/128), e1 = floor((128b1 - g1)/4096), e2 = floor((g4)/4), e3 = floor((-8b0 + g0)/128), e4 = floor((-t0 + i1)/16): g3 = 128b1 and g2 = 8b0 and 128e0 = g1 and 4096e1 = 128b1 - g1 and 4e2 = g4 and 128e3 = -8b0 + g0 and 16e4 = -t0 + i1 and b0 <= 15 and b0 >= 0 and b1 <= 31 and b1 >= 0 and g0 >= 8b0 and g1 >= 128b1 and g4 >= 0 and g4 <= -1 + N and t0 <= 15 and t0 >= 0 and t1 <= 7 and t1 >= 0 and t1 <= -1 + N - g0 and i1 >= g1 and i1 <= 127 + g1 and i1 <= -1 + N)) }"
+child:
+  context: "[N, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> { [] : exists (e0 = floor((g0)/8), e1 = floor((-128b1 + g1)/4096), e2 = floor((8b0 - g0)/128): g2 = 8b0 and g3 = 128b1 and 8e0 = g0 and 4096e1 = -128b1 + g1 and 128e2 = 8b0 - g0 and b0 >= 0 and g4 <= -1 + N and b0 <= 15 and g1 <= -1 + N and g4 >= 0 and b1 <= 31 and g0 <= -1 + N and g1 >= 128b1 and b1 >= 0 and g0 >= 8b0 and t0 >= 0 and t0 <= 15 and t1 >= 0 and t1 <= 15) }"
+  child:
+    schedule: "[N, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> [{ S1[i0, i1] -> [(-g1 + i1)] }, { S1[i0, i1] -> [(t1)] }, { S1[i0, i1] -> [(t0)] }, { S1[i0, i1] -> [(t1)] }]"
+    options: "[N, b0, b1, g0, g1, g2, g3, g4, t0, t1] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.c b/lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.c
new file mode 100644
index 0000000..1432b5e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.c
@@ -0,0 +1 @@
+S1(N + 2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.st b/lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.st
new file mode 100644
index 0000000..da06c8d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/no_lindep.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S1[2 + N] }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0] -> [(1 + M)] }, { S1[i0] -> [(N)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.c
new file mode 100644
index 0000000..9293aef
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.c
@@ -0,0 +1,2 @@
+for (int c0 = 0; c0 <= M; c0 += 2)
+  S1(c0, c0 / 2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.st
new file mode 100644
index 0000000..d8a3201
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic1.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0, i1] : 2i1 = i0 and i0 >= 0 and i0 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.c
new file mode 100644
index 0000000..2b7bb4d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.c
@@ -0,0 +1,5 @@
+for (int c0 = 2; c0 <= n; c0 += 2) {
+  if (c0 % 4 == 0)
+    S2(c0, c0 / 4);
+  S1(c0, c0 / 2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.st
new file mode 100644
index 0000000..3258c67
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_basic2.st
@@ -0,0 +1,10 @@
+domain: "[n] -> { S1[i0, i1] : 2i1 = i0 and i0 >= 1 and i0 <= n; S2[i0, i1] : 4i1 = i0 and i0 >= 1 and i0 <= n }"
+child:
+  context: "[n] -> { [] : n >= 2 }"
+  child:
+    schedule: "[n] -> [{ S2[i0, i1] -> [(i0)]; S1[i0, i1] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0, i1] -> [(i1)] }]"
+    options: "[n] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[n] -> { S1[i0, i1] }"
+      - filter: "[n] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.c
new file mode 100644
index 0000000..067e751
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= 5 * n; c0 += 1)
+  for (int c1 = max(-((5 * n - c0 + 1) % 2) - n + c0 + 1, 2 * ((c0 + 2) / 3)); c1 <= min(c0, n + c0 - (n + c0 + 2) / 3); c1 += 2)
+    S1((3 * c1 / 2) - c0, c0 - c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.st
new file mode 100644
index 0000000..93e3329
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_complex1.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i0, i1] : i0 >= 0 and i0 <= n and i1 >= 0 and i1 <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S1[i0, i1] -> [(2i0 + 3i1)] }, { S1[i0, i1] -> [(2i0 + 2i1)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.c b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.c
new file mode 100644
index 0000000..e6f3968
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.c
@@ -0,0 +1,13 @@
+{
+  for (int c0 = 1; c0 <= 6; c0 += 2) {
+    for (int c2 = 1; c2 <= c0; c2 += 1) {
+      S1(c0, (c0 - 1) / 2, c2);
+      S2(c0, (c0 - 1) / 2, c2);
+    }
+    for (int c2 = c0 + 1; c2 <= p; c2 += 1)
+      S1(c0, (c0 - 1) / 2, c2);
+  }
+  for (int c0 = 7; c0 <= m; c0 += 2)
+    for (int c2 = 1; c2 <= p; c2 += 1)
+      S1(c0, (c0 - 1) / 2, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.st b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.st
new file mode 100644
index 0000000..4571d78
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/nul_lcpc.st
@@ -0,0 +1,10 @@
+domain: "[m, n, p] -> { S1[i, k, j] : 2k = -1 + i and i >= 1 and i <= m and j >= 1 and j <= p; S2[i, k, j] : 2k = -1 + i and i >= 1 and i <= n and j >= 1 and j <= i }"
+child:
+  context: "[m, n, p] -> { [] : n = 6 and m >= 7 and p >= 7 }"
+  child:
+    schedule: "[m, n, p] -> [{ S1[i, k, j] -> [(i)]; S2[i, k, j] -> [(i)] }, { S1[i, k, j] -> [(k)]; S2[i, k, j] -> [(k)] }, { S1[i, k, j] -> [(j)]; S2[i, k, j] -> [(j)] }]"
+    options: "[m, n, p] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[m, n, p] -> { S1[i, k, j] }"
+      - filter: "[m, n, p] -> { S2[i, k, j] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/orc.c b/lib/Analysis/isl/test_inputs/codegen/cloog/orc.c
new file mode 100644
index 0000000..4099944
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/orc.c
@@ -0,0 +1,16 @@
+{
+  for (int c0 = 0; c0 <= 2; c0 += 1) {
+    S1(c0);
+    for (int c1 = 0; c1 <= -c0 + 11; c1 += 1) {
+      S2(c0, c1);
+      S3(c0, c1);
+    }
+    S4(c0);
+  }
+  for (int c0 = 0; c0 <= 14; c0 += 1) {
+    S5(c0);
+    for (int c1 = 0; c1 <= 9; c1 += 1)
+      S6(c0, c1);
+    S7(c0);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/orc.st b/lib/Analysis/isl/test_inputs/codegen/cloog/orc.st
new file mode 100644
index 0000000..a67a880
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/orc.st
@@ -0,0 +1,13 @@
+domain: "{ S5[i] : i >= 0 and i <= 14; S6[i, j] : i >= 0 and i <= 14 and j >= 0 and j <= 9; S7[i] : i >= 0 and i <= 14; S4[i] : i >= 0 and i <= 2; S2[i, j] : i >= 0 and i <= 2 and j >= 0 and j <= 11 - i; S1[i] : i >= 0 and i <= 2; S3[i, j] : i >= 0 and i <= 2 and j >= 0 and j <= 11 - i }"
+child:
+  context: "{ [] }"
+  child:
+    sequence:
+    - filter: "{ S4[i0]; S2[i0, i1]; S1[i0]; S3[i0, i1] }"
+      child:
+        schedule: "[{ S3[i0, i1] -> [(1 + 3i0)]; S2[i0, i1] -> [(1 + 3i0)]; S1[i0] -> [(3i0)]; S4[i0] -> [(2 + 3i0)] }, { S3[i0, i1] -> [(1 + 2i1)]; S2[i0, i1] -> [(2i1)]; S1[i0] -> [(0)]; S4[i0] -> [(0)] }]"
+        options: "{ separate[i0] }"
+    - filter: "{ S5[i0]; S6[i0, i1]; S7[i0] }"
+      child:
+        schedule: "[{ S6[i0, i1] -> [(1 + 3i0)]; S7[i0] -> [(2 + 3i0)]; S5[i0] -> [(3i0)] }, { S6[i0, i1] -> [(i1)]; S7[i0] -> [(0)]; S5[i0] -> [(0)] }]"
+        options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/otl.c b/lib/Analysis/isl/test_inputs/codegen/cloog/otl.c
new file mode 100644
index 0000000..7937334
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/otl.c
@@ -0,0 +1,7 @@
+if (M >= 3 && N >= 4)
+  for (int c0 = 1; c0 < (2 * M + 2 * N - 2) / 5; c0 += 1)
+    for (int c1 = max(c0 - (M + 2) / 5, (c0 + 1) / 2); c1 <= min(min(c0, (M + 2 * N) / 5 - 1), (2 * N + 5 * c0 + 1) / 10); c1 += 1)
+      for (int c2 = max(max(max(max(0, c0 - c1 - 1), c1 - (N + 6) / 5 + 1), c0 - (M + N + 4) / 5 + 1), floord(-N + 5 * c0 - 3, 10) + 1); c2 <= min(min(min(c1, (M + N - 2) / 5), c0 - c1 + (N - 1) / 5 + 1), (N + 5 * c0 + 3) / 10); c2 += 1)
+        for (int c3 = max(max(max(c0, 2 * c1 - (2 * N + 5) / 5 + 1), c1 + c2 - (N + 3) / 5), 2 * c2 - (N + 2) / 5); c3 <= min(min(min(min(min(c0 + 1, c1 + c2 + 1), c1 + (M - 2) / 5 + 1), 2 * c2 + (N - 2) / 5 + 1), (2 * M + 2 * N - 1) / 5 - 1), c2 + (M + N) / 5); c3 += 1)
+          for (int c4 = max(max(max(max(c1, c0 - c2), c0 - (M + 6) / 5 + 1), c3 - (M + 2) / 5), (c3 + 1) / 2); c4 <= min(min(min(min(min(min(min(c0, c1 + 1), -c2 + c3 + (N - 1) / 5 + 1), c0 - c2 + N / 5 + 1), (M + 2 * N + 1) / 5 - 1), c2 + (N + 2) / 5), (2 * N + 5 * c0 + 3) / 10), (2 * N + 5 * c3 + 2) / 10); c4 += 1)
+            S1(c0, c1, c2, c3, c4, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/otl.st b/lib/Analysis/isl/test_inputs/codegen/cloog/otl.st
new file mode 100644
index 0000000..da70683
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/otl.st
@@ -0,0 +1,6 @@
+domain: "[M, N] -> { S1[outerTimeTileIter, outerProcTileIter1, outerProcTileIter2, innerTimeTileIter, innerProcTileIter1, outerProcTileIter2] : 5outerTimeTileIter <= -7 + 2M + 2N and innerProcTileIter1 >= outerTimeTileIter - outerProcTileIter2 and 10outerProcTileIter2 >= -2 - N + 5outerTimeTileIter and outerProcTileIter2 >= -1 + outerTimeTileIter - outerProcTileIter1 and 2innerProcTileIter1 >= outerTimeTileIter and outerTimeTileIter >= 1 and outerProcTileIter1 >= 1 and 2outerProcTileIter1 >= outerTimeTileIter and outerProcTileIter2 >= 0 and 5outerProcTileIter2 >= 1 - M - N + 5outerTimeTileIter and 5innerProcTileIter1 >= -1 - M + 5outerTimeTileIter and innerTimeTileIter >= outerTimeTileIter and 5outerProcTileIter1 >= -2 - M + 5outerTimeTileIter and innerTimeTileIter >= 1 and 5innerTimeTileIter >= -3 - N + 5outerProcTileIter1 + 5outerProcTileIter2 and 5outerProcTileIter2 <= 4 + N + 5outerTimeTileIter - 5outerProcTileIter1 and innerProcTileIter1 >= 1 and outerProcTileIter2 <= outerTimeTileIter and 5innerTimeTileIter >= -2N + 10outerProcTileIter1 and 5outerProcTileIter1 <= -5 + M + 2N and 10outerProcTileIter1 <= 1 + 2N + 5outerTimeTileIter and 5outerProcTileIter2 >= -1 - N + 5outerProcTileIter1 and innerProcTileIter1 >= outerProcTileIter1 and innerTimeTileIter >= outerProcTileIter1 and outerProcTileIter2 <= outerProcTileIter1 and outerProcTileIter1 <= outerTimeTileIter and 5innerProcTileIter1 <= 4 + N - 5outerProcTileIter2 + 5innerTimeTileIter and 5innerProcTileIter1 <= 5 + N + 5outerTimeTileIter - 5outerProcTileIter2 and 5innerTimeTileIter >= -2 - N + 10outerProcTileIter2 and 5outerProcTileIter2 <= -2 + M + N and 10outerProcTileIter2 <= 3 + N + 5outerTimeTileIter and N >= 4 and innerProcTileIter1 >= outerProcTileIter2 and innerTimeTileIter >= outerProcTileIter2 and M >= 3 and innerProcTileIter1 <= outerTimeTileIter and 5innerTimeTileIter <= -6 + 2M + 2N and innerProcTileIter1 >= -1 - outerProcTileIter2 + innerTimeTileIter and 5innerTimeTileIter <= 3 + N + 10outerProcTileIter2 and innerTimeTileIter <= 1 + outerProcTileIter1 + outerProcTileIter2 and innerProcTileIter1 <= 1 + outerProcTileIter1 and 2innerProcTileIter1 >= innerTimeTileIter and 5innerProcTileIter1 <= 2 + N + 5outerProcTileIter2 and innerTimeTileIter <= 1 + 2outerProcTileIter1 and innerProcTileIter1 <= innerTimeTileIter and 5innerTimeTileIter <= M + N + 5outerProcTileIter2 and 5innerProcTileIter1 >= -2 - M + 5innerTimeTileIter and 10innerProcTileIter1 <= 3 + 2N + 5outerTimeTileIter and innerTimeTileIter <= 1 + outerTimeTileIter and 5innerTimeTileIter <= 3 + M + 5outerProcTileIter1 and 5innerProcTileIter1 <= -4 + M + 2N and 10innerProcTileIter1 <= 2 + 2N + 5innerTimeTileIter }"
+child:
+  context: "[M, N] -> { [] : M >= 1 and N >= 1 }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1, i2, i3, i4, i5] -> [(i0)] }, { S1[i0, i1, i2, i3, i4, i5] -> [(i1)] }, { S1[i0, i1, i2, i3, i4, i5] -> [(i2)] }, { S1[i0, i1, i2, i3, i4, i5] -> [(i3)] }, { S1[i0, i1, i2, i3, i4, i5] -> [(i4)] }, { S1[i0, i1, i2, i3, i4, i5] -> [(i5)] }]"
+    options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/param-split.c b/lib/Analysis/isl/test_inputs/codegen/cloog/param-split.c
new file mode 100644
index 0000000..a9d9712
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/param-split.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 <= max(0, M); c0 += 1) {
+  if (M >= c0)
+    S1(c0);
+  if (c0 == 0)
+    S2(0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/param-split.st b/lib/Analysis/isl/test_inputs/codegen/cloog/param-split.st
new file mode 100644
index 0000000..371372f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/param-split.st
@@ -0,0 +1,10 @@
+domain: "[M] -> { S2[0]; S1[i0] : i0 >= 0 and i0 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S2[i0] -> [(i0)]; S1[i0] -> [(i0)] }]"
+    options: "[M] -> { atomic[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0] }"
+      - filter: "[M] -> { S2[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.c b/lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.c
new file mode 100644
index 0000000..97974bb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.c
@@ -0,0 +1,12 @@
+for (int c0 = 1; c0 <= floord(Ny, 2) + 2; c0 += 1)
+  for (int c1 = max(c0 - 1, c0 / 2 + 1); c1 <= min(c0, (Ny + 2 * c0) / 4); c1 += 1) {
+    if (Ny + 2 * c0 >= 4 * c1 + 1) {
+      for (int c2 = 1; c2 <= 2; c2 += 1) {
+        S1(c0 - c1, c1, 2 * c0 - 2 * c1, -2 * c0 + 4 * c1, c2);
+        S2(c0 - c1, c1, 2 * c0 - 2 * c1, -2 * c0 + 4 * c1 - 1, c2);
+      }
+    } else {
+      for (int c2 = 1; c2 <= 2; c2 += 1)
+        S2((-Ny + 2 * c0) / 4, (Ny + 2 * c0) / 4, (-Ny / 2) + c0, Ny - 1, c2);
+    }
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.st b/lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.st
new file mode 100644
index 0000000..8ba0928
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/pouchet.st
@@ -0,0 +1,6 @@
+domain: "[Ny] -> { S1[i0, i1, 2i0, -2i0 + 2i1, i4] : i0 >= 0 and i0 <= 1 and i1 >= 1 + i0 and 2i1 <= -1 + Ny + 2i0 and i4 >= 1 and i4 <= 2; S2[i0, i1, 2i0, -1 - 2i0 + 2i1, i4] : i0 >= 0 and i0 <= 1 and i1 >= 1 + i0 and 2i1 <= Ny + 2i0 and i4 >= 1 and i4 <= 2 }"
+child:
+  context: "[Ny] -> { [] }"
+  child:
+    schedule: "[Ny] -> [{ S1[i0, i1, i2, i3, i4] -> [(i0 + i1)]; S2[i0, i1, i2, i3, i4] -> [(i0 + i1)] }, { S1[i0, i1, i2, i3, i4] -> [(i1)]; S2[i0, i1, i2, i3, i4] -> [(i1)] }, { S1[i0, i1, i2, i3, i4] -> [(i4)]; S2[i0, i1, i2, i3, i4] -> [(i4)] }, { S1[i0, i1, i2, i3, i4] -> [(i2)]; S2[i0, i1, i2, i3, i4] -> [(i2)] }, { S1[i0, i1, i2, i3, i4] -> [(i3)]; S2[i0, i1, i2, i3, i4] -> [(1 + i3)] }, { S1[i0, i1, i2, i3, i4] -> [(i4)]; S2[i0, i1, i2, i3, i4] -> [(1 + i4)] }]"
+    options: "[Ny] -> { separate[x] : x >= 2 }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.c b/lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.c
new file mode 100644
index 0000000..10d1f76
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= 2 * n; c0 += 1)
+  for (int c1 = max(0, -n + c0); c1 <= min(n, c0); c1 += 1)
+    S1(c1, c0 - c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.st b/lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.st
new file mode 100644
index 0000000..a4a9e51
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/rectangle.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i0, i1] : i0 >= 0 and i0 <= n and i1 >= 0 and i1 <= n }"
+child:
+  context: "[n] -> { [] : n >= 0 }"
+  child:
+    schedule: "[n] -> [{ S1[i0, i1] -> [(i0 + i1)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.c
new file mode 100644
index 0000000..fee61aa
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.c
@@ -0,0 +1,54 @@
+if (N >= 1) {
+  S1(0);
+  if (N == 1) {
+    for (int c1 = 0; c1 < M; c1 += 1)
+      S2(0, c1);
+    S3(0);
+    for (int c1 = 0; c1 < M; c1 += 1)
+      S4(0, c1);
+    S10(0);
+    S5(0);
+  } else {
+    for (int c1 = 0; c1 < M; c1 += 1)
+      S2(0, c1);
+    S3(0);
+    for (int c1 = 0; c1 < M; c1 += 1)
+      S4(0, c1);
+    S10(0);
+    S1(1);
+    S5(0);
+  }
+  for (int c0 = 2; c0 < N; c0 += 1) {
+    for (int c1 = c0 - 1; c1 < N; c1 += 1) {
+      S6(c0 - 2, c1);
+      for (int c2 = c0 - 2; c2 < M; c2 += 1)
+        S7(c0 - 2, c1, c2);
+      S8(c0 - 2, c1);
+      for (int c2 = c0 - 2; c2 < M; c2 += 1)
+        S9(c0 - 2, c1, c2);
+    }
+    for (int c1 = c0 - 1; c1 < M; c1 += 1)
+      S2(c0 - 1, c1);
+    S3(c0 - 1);
+    for (int c1 = c0 - 1; c1 < M; c1 += 1)
+      S4(c0 - 1, c1);
+    S10(c0 - 1);
+    S1(c0);
+    S5(c0 - 1);
+  }
+  if (N >= 2) {
+    S6(N - 2, N - 1);
+    for (int c2 = N - 2; c2 < M; c2 += 1)
+      S7(N - 2, N - 1, c2);
+    S8(N - 2, N - 1);
+    for (int c2 = N - 2; c2 < M; c2 += 1)
+      S9(N - 2, N - 1, c2);
+    for (int c1 = N - 1; c1 < M; c1 += 1)
+      S2(N - 1, c1);
+    S3(N - 1);
+    for (int c1 = N - 1; c1 < M; c1 += 1)
+      S4(N - 1, c1);
+    S10(N - 1);
+    S5(N - 1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.st
new file mode 100644
index 0000000..8be6a03
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-QR.st
@@ -0,0 +1,36 @@
+domain: "[M, N] -> { S5[i0] : i0 >= 0 and i0 <= -1 + N; S1[i0] : i0 >= 0 and i0 <= -1 + N; S3[i0] : i0 >= 0 and i0 <= -1 + N; S2[i0, i1] : i0 >= 0 and i0 <= -1 + N and i1 >= i0 and i1 <= -1 + M; S6[i0, i1] : i0 >= 0 and i1 >= 1 + i0 and i1 <= -1 + N; S9[i0, i1, i2] : i0 >= 0 and i1 >= 1 + i0 and i1 <= -1 + N and i2 >= i0 and i2 <= -1 + M; S4[i0, i1] : i0 >= 0 and i0 <= -1 + N and i1 >= i0 and i1 <= -1 + M; S8[i0, i1] : i0 >= 0 and i1 >= 1 + i0 and i1 <= -1 + N; S10[i0] : i0 >= 0 and i0 <= -1 + N; S7[i0, i1, i2] : i0 >= 0 and i1 >= 1 + i0 and i1 <= -1 + N and i2 >= i0 and i2 <= -1 + M }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S3[i0] -> [(1 + i0)]; S10[i0] -> [(1 + i0)]; S5[i0] -> [(1 + i0)]; S7[i0, i1, i2] -> [(2 + i0)]; S9[i0, i1, i2] -> [(2 + i0)]; S2[i0, i1] -> [(1 + i0)]; S4[i0, i1] -> [(1 + i0)]; S8[i0, i1] -> [(2 + i0)]; S1[i0] -> [(i0)]; S6[i0, i1] -> [(2 + i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S6[i0, i1]; S9[i0, i1, i2]; S8[i0, i1]; S7[i0, i1, i2] }"
+        child:
+          schedule: "[M, N] -> [{ S7[i0, i1, i2] -> [(i1)]; S9[i0, i1, i2] -> [(i1)]; S8[i0, i1] -> [(i1)]; S6[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[M, N] -> { S6[i0, i1] }"
+            - filter: "[M, N] -> { S7[i0, i1, i2] }"
+              child:
+                schedule: "[M, N] -> [{ S7[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N] -> { separate[i0] }"
+            - filter: "[M, N] -> { S8[i0, i1] }"
+            - filter: "[M, N] -> { S9[i0, i1, i2] }"
+              child:
+                schedule: "[M, N] -> [{ S9[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N] -> { separate[i0] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
+        child:
+          schedule: "[M, N] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+      - filter: "[M, N] -> { S3[i0] }"
+      - filter: "[M, N] -> { S4[i0, i1] }"
+        child:
+          schedule: "[M, N] -> [{ S4[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+      - filter: "[M, N] -> { S10[i0] }"
+      - filter: "[M, N] -> { S1[i0] }"
+      - filter: "[M, N] -> { S5[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.c
new file mode 100644
index 0000000..6d82ce4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.c
@@ -0,0 +1,3 @@
+for (int c0 = 3; c0 <= 9; c0 += 1)
+  for (int c1 = max(c0 - 6, -(c0 % 2) + 2); c1 <= min(3, c0 - 2); c1 += 2)
+    S1(c0, c1, (c0 - c1) / 2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.st
new file mode 100644
index 0000000..66fe7a3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-bastoul3.st
@@ -0,0 +1,6 @@
+domain: "{ S1[i0, i1, i2] : 2i2 = i0 - i1 and i1 >= 1 and i1 <= 3 and i1 <= -2 + i0 and i1 >= -6 + i0 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1, i2] -> [(i0)] }, { S1[i0, i1, i2] -> [(i1)] }, { S1[i0, i1, i2] -> [(i2)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.c
new file mode 100644
index 0000000..73f7790
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.c
@@ -0,0 +1,9 @@
+for (int c0 = 2; c0 < 3 * M; c0 += 1) {
+  if ((c0 + 1) % 3 == 0)
+    S1((c0 + 1) / 3);
+  for (int c1 = (c0 + 1) / 3 + 1; c1 <= min(M, c0 - 2); c1 += 1)
+    for (int c2 = -c1 + (c0 + c1 + 1) / 2 + 1; c2 <= min(c1, c0 - c1); c2 += 1)
+      S3(c0 - c1 - c2 + 1, c1, c2);
+  for (int c1 = -c0 + 2 * ((2 * c0 + 1) / 3) + 2; c1 <= min(M, c0); c1 += 2)
+    S2(((c0 - c1) / 2) + 1, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.st
new file mode 100644
index 0000000..4ae03d7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-cholesky2.st
@@ -0,0 +1,20 @@
+domain: "[M] -> { S3[i0, i1, i2] : i0 >= 1 and i1 <= M and i2 >= 1 + i0 and i2 <= i1; S2[i0, i1] : i0 >= 1 and i1 >= 1 + i0 and i1 <= M; S1[i0] : i0 >= 1 and i0 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0] -> [(-1 + 3i0)]; S3[i0, i1, i2] -> [(-1 + i0 + i1 + i2)]; S2[i0, i1] -> [(-2 + 2i0 + i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0] }"
+      - filter: "[M] -> { S3[i0, i1, i2] }"
+        child:
+          schedule: "[M] -> [{ S3[i0, i1, i2] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+          child:
+            schedule: "[M] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+            options: "[M] -> { separate[i0] }"
+      - filter: "[M] -> { S2[i0, i1] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.c
new file mode 100644
index 0000000..d586eba
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 0; c0 <= M; c0 += 1)
+    S1(c0);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    S2(c0);
+  for (int c0 = 0; c0 <= M; c0 += 1)
+    S3(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.st
new file mode 100644
index 0000000..25c0cfd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion1.st
@@ -0,0 +1,17 @@
+domain: "[M] -> { S3[i0] : i0 >= 0 and i0 <= M; S2[i0] : i0 >= 1 and i0 <= M; S1[i0] : i0 >= 0 and i0 <= M }"
+child:
+  context: "[M] -> { [] : M >= 1 }"
+  child:
+    sequence:
+    - filter: "[M] -> { S1[i0] }"
+      child:
+        schedule: "[M] -> [{ S1[i0] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S2[i0] }"
+      child:
+        schedule: "[M] -> [{ S2[i0] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S3[i0] }"
+      child:
+        schedule: "[M] -> [{ S3[i0] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.c
new file mode 100644
index 0000000..e31aaec
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.c
@@ -0,0 +1,12 @@
+if (N >= 1) {
+  for (int c1 = 1; c1 <= M; c1 += 1)
+    S1(1, c1);
+  for (int c0 = 2; c0 <= N; c0 += 1) {
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0 - 1, c1);
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  }
+  for (int c1 = 1; c1 <= M; c1 += 1)
+    S2(N, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.st
new file mode 100644
index 0000000..ee65424
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-fusion2.st
@@ -0,0 +1,16 @@
+domain: "[M, N] -> { S1[i0, i1] : i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= M; S2[i0, i1] : i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= M }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(1 + i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S2[i0, i1] }"
+        child:
+          schedule: "[M, N] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+      - filter: "[M, N] -> { S1[i0, i1] }"
+        child:
+          schedule: "[M, N] -> [{ S1[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.c
new file mode 100644
index 0000000..6a04045
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 < M; c0 += 1)
+  for (int c1 = 0; c1 < M; c1 += 1)
+    S1(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.st
new file mode 100644
index 0000000..fe1230d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi2.st
@@ -0,0 +1,9 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 0 and i0 <= -1 + M and i1 >= 0 and i1 <= -1 + M }"
+child:
+  context: "[M] -> { [] : M >= 1 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      schedule: "[M] -> [{ S1[i0, i1] -> [(i1)] }]"
+      options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.c
new file mode 100644
index 0000000..7253575
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.c
@@ -0,0 +1,8 @@
+for (int c0 = 1; c0 <= M; c0 += 1) {
+  for (int c2 = 2; c2 < N; c2 += 1)
+    for (int c3 = 2; c3 < N; c3 += 1)
+      S1(c0, c2, c3);
+  for (int c2 = 2; c2 < N; c2 += 1)
+    for (int c3 = 2; c3 < N; c3 += 1)
+      S2(c0, c2, c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.st
new file mode 100644
index 0000000..815ffe2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-jacobi3.st
@@ -0,0 +1,22 @@
+domain: "[M, N] -> { S2[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + N; S1[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + N }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(2i0)]; S2[i0, i1, i2] -> [(1 + 2i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1, i2] }"
+        child:
+          schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+          child:
+            schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N] -> { separate[i0] }"
+      - filter: "[M, N] -> { S2[i0, i1, i2] }"
+        child:
+          schedule: "[M, N] -> [{ S2[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+          child:
+            schedule: "[M, N] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.c
new file mode 100644
index 0000000..e326941
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.c
@@ -0,0 +1,10 @@
+for (int c0 = -99; c0 <= 100; c0 += 1) {
+  if (c0 <= 0)
+    S1(1, -c0 + 1);
+  for (int c1 = max(1, -2 * c0 + 3); c1 <= min(199, -2 * c0 + 199); c1 += 2) {
+    S2(((c1 - 1) / 2) + c0, (c1 + 1) / 2);
+    S1(((c1 + 1) / 2) + c0, (c1 + 1) / 2);
+  }
+  if (c0 >= 1)
+    S2(100, -c0 + 101);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.st
new file mode 100644
index 0000000..cf7efee
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam1.st
@@ -0,0 +1,13 @@
+domain: "{ S2[i0, i1] : i0 >= 1 and i0 <= 100 and i1 >= 1 and i1 <= 100; S1[i0, i1] : i0 >= 1 and i0 <= 100 and i1 >= 1 and i1 <= 100 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1] -> [(i0 - i1)]; S2[i0, i1] -> [(1 + i0 - i1)] }]"
+    options: "{ separate[i0] }"
+    child:
+      schedule: "[{ S1[i0, i1] -> [(2i1)]; S2[i0, i1] -> [(-1 + 2i1)] }]"
+      options: "{ separate[i0] }"
+      child:
+        sequence:
+        - filter: "{ S1[i0, i1] }"
+        - filter: "{ S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.c
new file mode 100644
index 0000000..483fe52
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.c
@@ -0,0 +1,10 @@
+{
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    S1(c0);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 2; c1 <= N; c1 += 1)
+      S2(c0, c1);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1)
+      S3(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.st
new file mode 100644
index 0000000..b53558f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam2.st
@@ -0,0 +1,23 @@
+domain: "[M, N] -> { S3[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= -1 + N; S1[i0] : i0 >= 1 and i0 <= M; S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 2 and i1 <= N }"
+child:
+  context: "[M, N] -> { [] : M >= 1 and N >= 1 }"
+  child:
+    sequence:
+    - filter: "[M, N] -> { S1[i0] }"
+      child:
+        schedule: "[M, N] -> [{ S1[i0] -> [(i0)] }]"
+        options: "[M, N] -> { separate[i0] }"
+    - filter: "[M, N] -> { S2[i0, i1] }"
+      child:
+        schedule: "[M, N] -> [{ S2[i0, i1] -> [(i0)] }]"
+        options: "[M, N] -> { separate[i0] }"
+        child:
+          schedule: "[M, N] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+    - filter: "[M, N] -> { S3[i0, i1] }"
+      child:
+        schedule: "[M, N] -> [{ S3[i0, i1] -> [(i0)] }]"
+        options: "[M, N] -> { separate[i0] }"
+        child:
+          schedule: "[M, N] -> [{ S3[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.c
new file mode 100644
index 0000000..9d290b5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.c
@@ -0,0 +1,11 @@
+for (int c0 = 5; c0 <= 5 * M; c0 += 1) {
+  for (int c1 = max(2, floord(-M + c0, 4)); c1 < min(-((5 * M - c0 + 1) % 2) + M, (c0 + 1) / 3 - 2); c1 += 1)
+    for (int c2 = max(1, -M - c1 + (M + c0) / 2 - 2); c2 < min(c1, -2 * c1 + (c0 + c1) / 2 - 2); c2 += 1)
+      S1(c0 - 2 * c1 - 2 * c2 - 5, c1, c2);
+  for (int c1 = max(1, floord(-M + c0, 4)); c1 < (c0 + 1) / 5; c1 += 1)
+    S2(c0 - 4 * c1 - 3, c1);
+  if (c0 % 5 == 0)
+    S4(c0 / 5);
+  for (int c1 = max(-3 * M - c0 + 3 * ((M + c0) / 2) + 1, -((c0 - 1) % 3) + 3); c1 < (c0 + 1) / 5; c1 += 3)
+    S3((c0 - 2 * c1 - 1) / 3, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.st
new file mode 100644
index 0000000..cedd5e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam3.st
@@ -0,0 +1,23 @@
+domain: "[M] -> { S4[i0] : i0 >= 1 and i0 <= M; S3[i0, i1] : i0 <= M and i1 >= 1 and i1 <= -1 + i0; S2[i0, i1] : i0 <= M and i1 >= 1 and i1 <= -1 + i0; S1[i0, i1, i2] : i0 <= M and i1 <= -1 + i0 and i2 >= 1 and i2 <= -1 + i1 }"
+child:
+  context: "[M] -> { [] : M >= 1 }"
+  child:
+    schedule: "[M] -> [{ S4[i0] -> [(5i0)]; S1[i0, i1, i2] -> [(5 + i0 + 2i1 + 2i2)]; S3[i0, i1] -> [(1 + 3i0 + 2i1)]; S2[i0, i1] -> [(3 + i0 + 4i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1, i2] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+          child:
+            schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M] -> { separate[i0] }"
+      - filter: "[M] -> { S2[i0, i1] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+      - filter: "[M] -> { S4[i0]; S3[i0, i1] }"
+        child:
+          schedule: "[M] -> [{ S4[i0] -> [(0)]; S3[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.c
new file mode 100644
index 0000000..ed00e99
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.c
@@ -0,0 +1,10 @@
+for (int c0 = 1; c0 < 2 * M - 1; c0 += 1) {
+  for (int c1 = max(-M + 1, -c0 + 1); c1 < 0; c1 += 1) {
+    for (int c3 = max(1, -M + c0 + 1); c3 <= min(M - 1, c0 + c1); c3 += 1)
+      S1(c3, c0 + c1 - c3, -c1);
+    for (int c2 = max(-M + c0 + 1, -c1); c2 < min(M, c0); c2 += 1)
+      S2(c0 - c2, c1 + c2, c2);
+  }
+  for (int c3 = max(1, -M + c0 + 1); c3 <= min(M - 1, c0); c3 += 1)
+    S1(c3, c0 - c3, 0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.st
new file mode 100644
index 0000000..14b0052
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam4.st
@@ -0,0 +1,19 @@
+domain: "[M] -> { S2[i0, i1, i2] : i0 >= 1 and i0 <= -1 + M and i1 >= 0 and i2 >= 1 + i1 and i2 <= -1 + M; S1[i0, i1, i2] : i0 >= 1 and i0 <= -1 + M and i1 >= 0 and i2 >= 0 and i2 <= -1 + M - i1 }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i0 + i1 + i2)]; S2[i0, i1, i2] -> [(i0 + i2)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      schedule: "[M] -> [{ S1[i0, i1, i2] -> [(-i2)]; S2[i0, i1, i2] -> [(i1 - i2)] }]"
+      options: "[M] -> { separate[i0] }"
+      child:
+        sequence:
+        - filter: "[M] -> { S1[i0, i1, i2] }"
+          child:
+            schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M] -> { separate[i0] }"
+        - filter: "[M] -> { S2[i0, i1, i2] }"
+          child:
+            schedule: "[M] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+            options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.c
new file mode 100644
index 0000000..05cbb74
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.c
@@ -0,0 +1,11 @@
+{
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0, c1);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S3(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.st
new file mode 100644
index 0000000..5684455
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam5.st
@@ -0,0 +1,26 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M; S3[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M; S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    sequence:
+    - filter: "[M] -> { S1[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S2[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S2[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S3[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S3[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S3[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.c
new file mode 100644
index 0000000..39e4538
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 0; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 0; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c1, c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.st
new file mode 100644
index 0000000..3119ef1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-lim-lam6.st
@@ -0,0 +1,19 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 0 and i0 <= M and i1 >= 1 and i1 <= M; S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 0 and i1 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    sequence:
+    - filter: "[M] -> { S1[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S2[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S2[i0, i1] -> [(i1)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1] -> [(i0)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.c
new file mode 100644
index 0000000..84f6a25
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.c
@@ -0,0 +1,19 @@
+if (M >= 0 && N >= 0)
+  for (int c0 = -4; c0 <= 3 * M + N; c0 += 1) {
+    if (c0 >= 3 * M) {
+      S2(M, -3 * M + c0);
+    } else if (3 * M >= c0 + 4 && (c0 + 1) % 3 == 0) {
+      S1((c0 + 4) / 3, 0);
+    }
+    for (int c1 = max(-3 * M + c0 + 3, (c0 + 6) % 3); c1 <= min(N - 1, c0); c1 += 3) {
+      S2((c0 - c1) / 3, c1);
+      S1(((c0 - c1) / 3) + 1, c1 + 1);
+    }
+    if (3 * M + N >= c0 + 3 && c0 >= N && (N - c0) % 3 == 0) {
+      S2((-N + c0) / 3, N);
+    } else if (N >= c0 + 4 && c0 >= -3) {
+      S1(0, c0 + 4);
+    }
+    for (int c1 = max(-3 * M + c0, (c0 + 6) % 3); c1 <= min(N, c0); c1 += 3)
+      S3((c0 - c1) / 3, c1);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.st
new file mode 100644
index 0000000..e915285
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-liu-zhuge1.st
@@ -0,0 +1,16 @@
+domain: "[M, N] -> { S3[i0, i1] : i0 >= 0 and i0 <= M and i1 >= 0 and i1 <= N; S1[i0, i1] : i0 >= 0 and i0 <= M and i1 >= 0 and i1 <= N; S2[i0, i1] : i0 >= 0 and i0 <= M and i1 >= 0 and i1 <= N }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(-4 + 3i0 + i1)]; S2[i0, i1] -> [(3i0 + i1)]; S3[i0, i1] -> [(3i0 + i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1]; S2[i0, i1] }"
+        child:
+          schedule: "[M, N] -> [{ S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+      - filter: "[M, N] -> { S3[i0, i1] }"
+        child:
+          schedule: "[M, N] -> [{ S3[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.c
new file mode 100644
index 0000000..a164372
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.c
@@ -0,0 +1,4 @@
+for (int c0 = 1; c0 <= M; c0 += 1)
+  for (int c1 = 2; c1 <= M + c0; c1 += 1)
+    for (int c2 = max(1, -c0 + c1); c2 <= min(M, c1 - 1); c2 += 1)
+      S1(c0, c2, c1 - c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.st
new file mode 100644
index 0000000..90b561a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner3.st
@@ -0,0 +1,12 @@
+domain: "[M] -> { S1[i0, i1, i2] : i0 <= M and i1 >= 1 and i1 <= M and i2 >= 1 and i2 <= i0 }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i1 + i2)] }]"
+      options: "[M] -> { separate[i0] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i1)] }]"
+        options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.c
new file mode 100644
index 0000000..cf9c764
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.c
@@ -0,0 +1,5 @@
+for (int c0 = 2; c0 <= 2 * M; c0 += 1)
+  for (int c1 = 1; c1 <= M; c1 += 1)
+    for (int c2 = 1; c2 <= M; c2 += 1)
+      for (int c3 = max(1, -M + c0); c3 <= min(M, c0 - 1); c3 += 1)
+        S1(c2, c1, c3, c0 - c3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.st
new file mode 100644
index 0000000..516da7e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner4.st
@@ -0,0 +1,15 @@
+domain: "[M] -> { S1[i0, i1, i2, i3] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M and i2 >= 1 and i2 <= M and i3 >= 1 and i3 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i2 + i3)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i1)] }]"
+      options: "[M] -> { separate[i0] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i2)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.c
new file mode 100644
index 0000000..6193503
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= M; c0 += 1)
+  for (int c1 = 1; c1 <= M; c1 += 1)
+    for (int c2 = 1; c2 <= M; c2 += 1)
+      for (int c3 = 1; c3 <= M; c3 += 1)
+        S1(c1, c2, c0, c3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.st
new file mode 100644
index 0000000..691d924
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-loechner5.st
@@ -0,0 +1,15 @@
+domain: "[M] -> { S1[i0, i1, i2, i3] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M and i2 >= 1 and i2 <= M and i3 >= 1 and i3 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i2)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i0)] }]"
+      options: "[M] -> { separate[i0] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i1)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1, i2, i3] -> [(i3)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.c
new file mode 100644
index 0000000..e929c56
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.c
@@ -0,0 +1,14 @@
+for (int c0 = 1; c0 < O; c0 += 1) {
+  for (int c1 = Q; c1 < N; c1 += 1) {
+    for (int c2 = P; c2 < M; c2 += 1)
+      S1(c0, c1, c2);
+    for (int c2 = 1; c2 < M; c2 += 1)
+      S2(c0, c1, c2);
+  }
+  for (int c1 = 1; c1 < N; c1 += 1) {
+    for (int c2 = P; c2 < M; c2 += 1)
+      S3(c0, c1, c2);
+    for (int c2 = 1; c2 < M; c2 += 1)
+      S4(c0, c1, c2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.st
new file mode 100644
index 0000000..5a292ab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-long.st
@@ -0,0 +1,36 @@
+domain: "[M, N, O, P, Q, R, S, T, U] -> { S1[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= Q and i1 <= -1 + N and i2 >= P and i2 <= -1 + M; S3[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= P and i2 <= -1 + M; S4[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S2[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= Q and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M }"
+child:
+  context: "[M, N, O, P, Q, R, S, T, U] -> { [] : M >= 10 and N >= 10 and O >= 10 and P >= 1 and P <= 2 and Q >= 1 and Q <= 2 and R >= 1 and R <= 2 and S >= 0 and S <= 1 and T >= 0 and T <= 1 and U >= 0 and U <= 1 }"
+  child:
+    schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)]; S1[i0, i1, i2] -> [(i0)]; S3[i0, i1, i2] -> [(i0)] }]"
+    options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N, O, P, Q, R, S, T, U] -> { S1[i0, i1, i2]; S2[i0, i1, i2] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(i1)]; S1[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S1[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S2[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+      - filter: "[M, N, O, P, Q, R, S, T, U] -> { S3[i0, i1, i2]; S4[i0, i1, i2] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i1)]; S3[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S3[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S4[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.c
new file mode 100644
index 0000000..c5d7774
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.c
@@ -0,0 +1,85 @@
+{
+  if (N >= 2)
+    for (int c0 = 1; c0 < O; c0 += 1) {
+      for (int c3 = 1; c3 <= M; c3 += 1)
+        S1(c0, 1, c3);
+      for (int c3 = 1; c3 < M; c3 += 1) {
+        S6(c0, 1, c3);
+        S7(c0, 1, c3);
+      }
+      if (N >= 3) {
+        for (int c3 = 1; c3 <= M; c3 += 1)
+          S3(c0, 1, c3);
+        for (int c3 = 1; c3 <= M; c3 += 1)
+          S1(c0, 2, c3);
+        for (int c3 = 1; c3 < M; c3 += 1) {
+          S6(c0, 2, c3);
+          S7(c0, 2, c3);
+        }
+        for (int c3 = 1; c3 < M; c3 += 1)
+          S11(c0, 1, c3);
+      } else {
+        for (int c3 = 1; c3 <= M; c3 += 1)
+          S3(c0, 1, c3);
+        for (int c3 = 1; c3 < M; c3 += 1)
+          S11(c0, 1, c3);
+      }
+      for (int c1 = 3; c1 < 2 * N - 4; c1 += 2) {
+        for (int c3 = 1; c3 < M; c3 += 1)
+          S10(c0, (c1 - 1) / 2, c3);
+        for (int c3 = 1; c3 <= M; c3 += 1)
+          S3(c0, (c1 + 1) / 2, c3);
+        for (int c3 = 1; c3 <= M; c3 += 1)
+          S1(c0, (c1 + 3) / 2, c3);
+        for (int c3 = 1; c3 < M; c3 += 1) {
+          S6(c0, (c1 + 3) / 2, c3);
+          S7(c0, (c1 + 3) / 2, c3);
+        }
+        for (int c3 = 1; c3 < M; c3 += 1)
+          S11(c0, (c1 + 1) / 2, c3);
+      }
+      if (N >= 3) {
+        for (int c3 = 1; c3 < M; c3 += 1)
+          S10(c0, N - 2, c3);
+        for (int c3 = 1; c3 <= M; c3 += 1)
+          S3(c0, N - 1, c3);
+        for (int c3 = 1; c3 < M; c3 += 1)
+          S11(c0, N - 1, c3);
+      }
+      for (int c3 = 1; c3 < M; c3 += 1)
+        S10(c0, N - 1, c3);
+    }
+  for (int c0 = 1; c0 < O; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1) {
+      for (int c3 = 1; c3 <= M; c3 += 1)
+        S2(c0, c1, c3);
+      for (int c3 = 1; c3 < M; c3 += 1)
+        S8(c0, c1, c3);
+      for (int c3 = 1; c3 < M; c3 += 1)
+        S9(c0, c1, c3);
+    }
+  for (int c0 = 1; c0 < O; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1)
+      for (int c2 = 1; c2 < M; c2 += 1)
+        S4(c0, c1, c2);
+  for (int c0 = 1; c0 < O; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1)
+      for (int c2 = 1; c2 < M; c2 += 1)
+        S5(c0, c1, c2);
+  for (int c0 = R; c0 < O; c0 += 1)
+    for (int c1 = Q; c1 < N; c1 += 1)
+      for (int c2 = P; c2 < M; c2 += 1)
+        S12(c0, c1, c2);
+  for (int c0 = R; c0 < O; c0 += 1)
+    for (int c1 = Q; c1 < N; c1 += 1)
+      for (int c2 = 1; c2 < M; c2 += 1)
+        S13(c0, c1, c2);
+  for (int c0 = R; c0 < O; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1)
+      for (int c2 = P; c2 < M; c2 += 1)
+        S14(c0, c1, c2);
+  for (int c0 = R; c0 < O; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1)
+      for (int c2 = 1; c2 < M; c2 += 1)
+        S15(c0, c1, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.st
new file mode 100644
index 0000000..2d63015
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp.st
@@ -0,0 +1,115 @@
+domain: "[M, N, O, P, Q, R, S, T, U] -> { S8[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S12[i0, i1, i2] : i0 >= R and i0 <= -1 + O and i1 >= Q and i1 <= -1 + N and i2 >= P and i2 <= -1 + M; S5[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S10[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S6[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S1[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= M; S3[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= M; S4[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S15[i0, i1, i2] : i0 >= R and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S11[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S2[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= M; S7[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S9[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S14[i0, i1, i2] : i0 >= R and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= P and i2 <= -1 + M; S13[i0, i1, i2] : i0 >= R and i0 <= -1 + O and i1 >= Q and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M }"
+child:
+  context: "[M, N, O, P, Q, R, S, T, U] -> { [] }"
+  child:
+    sequence:
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S10[i0, i1, i2]; S6[i0, i1, i2]; S3[i0, i1, i2]; S1[i0, i1, i2]; S11[i0, i1, i2]; S7[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S11[i0, i1, i2] -> [(i0)]; S1[i0, i1, i2] -> [(i0)]; S6[i0, i1, i2] -> [(i0)]; S10[i0, i1, i2] -> [(i0)]; S3[i0, i1, i2] -> [(i0)]; S7[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S11[i0, i1, i2] -> [(2i1)]; S1[i0, i1, i2] -> [(-3 + 2i1)]; S6[i0, i1, i2] -> [(-2 + 2i1)]; S10[i0, i1, i2] -> [(1 + 2i1)]; S3[i0, i1, i2] -> [(-1 + 2i1)]; S7[i0, i1, i2] -> [(-2 + 2i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S10[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S10[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S3[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S6[i0, i1, i2]; S1[i0, i1, i2]; S7[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S1[i0, i1, i2] -> [(i2)]; S6[i0, i1, i2] -> [(i2)]; S7[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+                child:
+                  sequence:
+                  - filter: "[M, N, O, P, Q, R, S, T, U] -> { S6[i0, i1, i2]; S1[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R, S, T, U] -> { S7[i0, i1, i2] }"
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S11[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S11[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S2[i0, i1, i2]; S9[i0, i1, i2]; S8[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(i0)]; S8[i0, i1, i2] -> [(i0)]; S9[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(2i1)]; S8[i0, i1, i2] -> [(2i1)]; S9[i0, i1, i2] -> [(1 + 2i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S2[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S8[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S8[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+            - filter: "[M, N, O, P, Q, R, S, T, U] -> { S9[i0, i1, i2] }"
+              child:
+                schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S9[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S4[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S5[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S5[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S5[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S5[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S12[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S12[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S12[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S12[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S13[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S13[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S13[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S13[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S14[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S14[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S14[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S14[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S15[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S15[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S15[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S15[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.c
new file mode 100644
index 0000000..48c5dfd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.c
@@ -0,0 +1,18 @@
+{
+  for (int c0 = 1; c0 < O; c0 += 1)
+    for (int c1 = Q; c1 < N; c1 += 1)
+      for (int c2 = P; c2 < M; c2 += 1)
+        S1(c0, c1, c2);
+  for (int c0 = 1; c0 < O; c0 += 1)
+    for (int c1 = Q; c1 < N; c1 += 1)
+      for (int c2 = 1; c2 < M; c2 += 1)
+        S2(c0, c1, c2);
+  for (int c0 = 1; c0 < O; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1)
+      for (int c2 = P; c2 < M; c2 += 1)
+        S3(c0, c1, c2);
+  for (int c0 = 1; c0 < O; c0 += 1)
+    for (int c1 = 1; c1 < N; c1 += 1)
+      for (int c2 = 1; c2 < M; c2 += 1)
+        S4(c0, c1, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.st
new file mode 100644
index 0000000..a2ea2b3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-interp2.st
@@ -0,0 +1,45 @@
+domain: "[M, N, O, P, Q, R, S, T, U] -> { S1[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= Q and i1 <= -1 + N and i2 >= P and i2 <= -1 + M; S3[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= P and i2 <= -1 + M; S4[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= 1 and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M; S2[i0, i1, i2] : i0 >= 1 and i0 <= -1 + O and i1 >= Q and i1 <= -1 + N and i2 >= 1 and i2 <= -1 + M }"
+child:
+  context: "[M, N, O, P, Q, R, S, T, U] -> { [] }"
+  child:
+    sequence:
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S1[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S1[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S1[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S2[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S3[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S3[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S3[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+    - filter: "[M, N, O, P, Q, R, S, T, U] -> { S4[i0, i1, i2] }"
+      child:
+        schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+        child:
+          schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
+          child:
+            schedule: "[M, N, O, P, Q, R, S, T, U] -> [{ S4[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R, S, T, U] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.c
new file mode 100644
index 0000000..cfb4045
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.c
@@ -0,0 +1,9 @@
+for (int c0 = 2; c0 < O; c0 += 1)
+  for (int c1 = 3; c1 < 2 * N - 2; c1 += 2) {
+    for (int c3 = 1; c3 <= M; c3 += 1) {
+      S1(c0, (c1 + 1) / 2, c3);
+      S2(c0, (c1 + 1) / 2, c3);
+    }
+    for (int c3 = 2; c3 < M; c3 += 1)
+      S3(c0, (c1 + 1) / 2, c3);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.st
new file mode 100644
index 0000000..c64638b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-psinv.st
@@ -0,0 +1,23 @@
+domain: "[M, N, O] -> { S3[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + M; S2[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 1 and i2 <= M; S1[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 1 and i2 <= M }"
+child:
+  context: "[M, N, O] -> { [] }"
+  child:
+    schedule: "[M, N, O] -> [{ S3[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)]; S1[i0, i1, i2] -> [(i0)] }]"
+    options: "[M, N, O] -> { separate[i0] }"
+    child:
+      schedule: "[M, N, O] -> [{ S3[i0, i1, i2] -> [(2i1)]; S2[i0, i1, i2] -> [(-1 + 2i1)]; S1[i0, i1, i2] -> [(-1 + 2i1)] }]"
+      options: "[M, N, O] -> { separate[i0] }"
+      child:
+        sequence:
+        - filter: "[M, N, O] -> { S2[i0, i1, i2]; S1[i0, i1, i2] }"
+          child:
+            schedule: "[M, N, O] -> [{ S2[i0, i1, i2] -> [(i2)]; S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O] -> { separate[i0] }"
+            child:
+              sequence:
+              - filter: "[M, N, O] -> { S1[i0, i1, i2] }"
+              - filter: "[M, N, O] -> { S2[i0, i1, i2] }"
+        - filter: "[M, N, O] -> { S3[i0, i1, i2] }"
+          child:
+            schedule: "[M, N, O] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.c
new file mode 100644
index 0000000..cfb4045
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.c
@@ -0,0 +1,9 @@
+for (int c0 = 2; c0 < O; c0 += 1)
+  for (int c1 = 3; c1 < 2 * N - 2; c1 += 2) {
+    for (int c3 = 1; c3 <= M; c3 += 1) {
+      S1(c0, (c1 + 1) / 2, c3);
+      S2(c0, (c1 + 1) / 2, c3);
+    }
+    for (int c3 = 2; c3 < M; c3 += 1)
+      S3(c0, (c1 + 1) / 2, c3);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.st
new file mode 100644
index 0000000..c64638b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-resid.st
@@ -0,0 +1,23 @@
+domain: "[M, N, O] -> { S3[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + M; S2[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 1 and i2 <= M; S1[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 1 and i2 <= M }"
+child:
+  context: "[M, N, O] -> { [] }"
+  child:
+    schedule: "[M, N, O] -> [{ S3[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)]; S1[i0, i1, i2] -> [(i0)] }]"
+    options: "[M, N, O] -> { separate[i0] }"
+    child:
+      schedule: "[M, N, O] -> [{ S3[i0, i1, i2] -> [(2i1)]; S2[i0, i1, i2] -> [(-1 + 2i1)]; S1[i0, i1, i2] -> [(-1 + 2i1)] }]"
+      options: "[M, N, O] -> { separate[i0] }"
+      child:
+        sequence:
+        - filter: "[M, N, O] -> { S2[i0, i1, i2]; S1[i0, i1, i2] }"
+          child:
+            schedule: "[M, N, O] -> [{ S2[i0, i1, i2] -> [(i2)]; S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O] -> { separate[i0] }"
+            child:
+              sequence:
+              - filter: "[M, N, O] -> { S1[i0, i1, i2] }"
+              - filter: "[M, N, O] -> { S2[i0, i1, i2] }"
+        - filter: "[M, N, O] -> { S3[i0, i1, i2] }"
+          child:
+            schedule: "[M, N, O] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.c
new file mode 100644
index 0000000..e73ba5d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.c
@@ -0,0 +1,35 @@
+if (M >= 2 && N >= 3)
+  for (int c0 = 2; c0 < O; c0 += 1) {
+    for (int c2 = 2; c2 <= M; c2 += 1)
+      S1(c0, 2, c2);
+    for (int c1 = 3; c1 < N; c1 += 1) {
+      for (int c2 = 2; c2 <= M; c2 += 1)
+        S2(c0, c1 - 1, c2);
+      if (M >= 3)
+        S4(c0, c1 - 1, 2);
+      for (int c2 = 2; c2 < M - 1; c2 += 1) {
+        S3(c0, c1 - 1, c2);
+        S5(c0, c1 - 1, c2);
+        S4(c0, c1 - 1, c2 + 1);
+      }
+      if (M >= 3) {
+        S3(c0, c1 - 1, M - 1);
+        S5(c0, c1 - 1, M - 1);
+      }
+      for (int c2 = 2; c2 <= M; c2 += 1)
+        S1(c0, c1, c2);
+    }
+    for (int c2 = 2; c2 <= M; c2 += 1)
+      S2(c0, N - 1, c2);
+    if (M >= 3)
+      S4(c0, N - 1, 2);
+    for (int c2 = 2; c2 < M - 1; c2 += 1) {
+      S3(c0, N - 1, c2);
+      S5(c0, N - 1, c2);
+      S4(c0, N - 1, c2 + 1);
+    }
+    if (M >= 3) {
+      S3(c0, N - 1, M - 1);
+      S5(c0, N - 1, M - 1);
+    }
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.st
new file mode 100644
index 0000000..d330a83
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-mg-rprj3.st
@@ -0,0 +1,28 @@
+domain: "[M, N, O, P, Q, R] -> { S2[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= M; S4[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + M; S1[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= M; S5[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + M; S3[i0, i1, i2] : i0 >= 2 and i0 <= -1 + O and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + M }"
+child:
+  context: "[M, N, O, P, Q, R] -> { [] }"
+  child:
+    schedule: "[M, N, O, P, Q, R] -> [{ S5[i0, i1, i2] -> [(i0)]; S3[i0, i1, i2] -> [(i0)]; S4[i0, i1, i2] -> [(i0)]; S1[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)] }]"
+    options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+    child:
+      schedule: "[M, N, O, P, Q, R] -> [{ S5[i0, i1, i2] -> [(1 + i1)]; S3[i0, i1, i2] -> [(1 + i1)]; S4[i0, i1, i2] -> [(1 + i1)]; S1[i0, i1, i2] -> [(i1)]; S2[i0, i1, i2] -> [(1 + i1)] }]"
+      options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+      child:
+        sequence:
+        - filter: "[M, N, O, P, Q, R] -> { S2[i0, i1, i2] }"
+          child:
+            schedule: "[M, N, O, P, Q, R] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+        - filter: "[M, N, O, P, Q, R] -> { S4[i0, i1, i2]; S5[i0, i1, i2]; S3[i0, i1, i2] }"
+          child:
+            schedule: "[M, N, O, P, Q, R] -> [{ S5[i0, i1, i2] -> [(i2)]; S3[i0, i1, i2] -> [(i2)]; S4[i0, i1, i2] -> [(-1 + i2)] }]"
+            options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+            child:
+              sequence:
+              - filter: "[M, N, O, P, Q, R] -> { S3[i0, i1, i2] }"
+              - filter: "[M, N, O, P, Q, R] -> { S5[i0, i1, i2] }"
+              - filter: "[M, N, O, P, Q, R] -> { S4[i0, i1, i2] }"
+        - filter: "[M, N, O, P, Q, R] -> { S1[i0, i1, i2] }"
+          child:
+            schedule: "[M, N, O, P, Q, R] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N, O, P, Q, R] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.c
new file mode 100644
index 0000000..43c6ef0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= M; c0 += 1)
+  for (int c1 = 1; c1 < 2 * N; c1 += 1) {
+    for (int c2 = max(1, -N + c1); c2 < (c1 + 1) / 2; c2 += 1)
+      S1(c0, c1 - c2, c2);
+    if ((c1 + 1) % 2 == 0)
+      S2(c0, (c1 + 1) / 2);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.st
new file mode 100644
index 0000000..4ab2a65
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali1.st
@@ -0,0 +1,16 @@
+domain: "[M, N] -> { S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= N; S1[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 <= N and i2 >= 1 and i2 <= -1 + i1 }"
+child:
+  context: "[M, N] -> { [] }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0, i1] -> [(i0)]; S1[i0, i1, i2] -> [(i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      schedule: "[M, N] -> [{ S2[i0, i1] -> [(-1 + 2i1)]; S1[i0, i1, i2] -> [(i1 + i2)] }]"
+      options: "[M, N] -> { separate[i0] }"
+      child:
+        sequence:
+        - filter: "[M, N] -> { S1[i0, i1, i2] }"
+          child:
+            schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N] -> { separate[i0] }"
+        - filter: "[M, N] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.c
new file mode 100644
index 0000000..195f15b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.st
new file mode 100644
index 0000000..ff76034
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali2.st
@@ -0,0 +1,19 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M; S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    sequence:
+    - filter: "[M] -> { S1[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S2[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S2[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.c
new file mode 100644
index 0000000..eede142
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.c
@@ -0,0 +1,9 @@
+{
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      for (int c2 = 1; c2 <= M; c2 += 1)
+        S2(c0, c1, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.st
new file mode 100644
index 0000000..c3065a1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali3.st
@@ -0,0 +1,22 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M; S2[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M and i2 >= 1 and i2 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    sequence:
+    - filter: "[M] -> { S1[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S2[i0, i1, i2] }"
+      child:
+        schedule: "[M] -> [{ S2[i0, i1, i2] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1, i2] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+          child:
+            schedule: "[M] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+            options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.c
new file mode 100644
index 0000000..195f15b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 1; c0 <= M; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.st
new file mode 100644
index 0000000..0d724e9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali4.st
@@ -0,0 +1,19 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M; S2[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M }"
+child:
+  context: "[M] -> { [] : M >= 2 }"
+  child:
+    sequence:
+    - filter: "[M] -> { S1[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+    - filter: "[M] -> { S2[i0, i1] }"
+      child:
+        schedule: "[M] -> [{ S2[i0, i1] -> [(i0)] }]"
+        options: "[M] -> { separate[i0] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.c
new file mode 100644
index 0000000..0e9bcf4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.c
@@ -0,0 +1,10 @@
+for (int c0 = 3; c0 < 2 * M; c0 += 1) {
+  for (int c1 = c0 / 2 + 2; c1 <= M; c1 += 1)
+    for (int c3 = c0 / 2 + 1; c3 < min(c0, c1); c3 += 1)
+      S1(c3, c0 - c3, c1);
+  for (int c1 = max(1, -M + c0); c1 < (c0 + 1) / 2; c1 += 1)
+    S2(c0 - c1, c1);
+  for (int c1 = c0 / 2 + 2; c1 <= M; c1 += 1)
+    for (int c3 = c0 / 2 + 1; c3 < min(c0, c1); c3 += 1)
+      S3(c3, c0 - c3, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.st
new file mode 100644
index 0000000..d83eb55
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali5.st
@@ -0,0 +1,26 @@
+domain: "[M] -> { S3[i0, i1, i2] : i1 >= 1 and i1 <= -1 + i0 and i2 >= 1 + i0 and i2 <= M; S2[i0, i1] : i0 <= M and i1 >= 1 and i1 <= -1 + i0; S1[i0, i1, i2] : i1 >= 1 and i1 <= -1 + i0 and i2 >= 1 + i0 and i2 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i0 + i1)]; S3[i0, i1, i2] -> [(i0 + i1)]; S2[i0, i1] -> [(i0 + i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1, i2] }"
+        child:
+          schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+          options: "[M] -> { separate[i0] }"
+          child:
+            schedule: "[M] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M] -> { separate[i0] }"
+      - filter: "[M] -> { S2[i0, i1] }"
+        child:
+          schedule: "[M] -> [{ S2[i0, i1] -> [(i1)] }]"
+          options: "[M] -> { separate[i0] }"
+      - filter: "[M] -> { S3[i0, i1, i2] }"
+        child:
+          schedule: "[M] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+          options: "[M] -> { separate[i0] }"
+          child:
+            schedule: "[M] -> [{ S3[i0, i1, i2] -> [(i2)] }]"
+            options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.c
new file mode 100644
index 0000000..7253575
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.c
@@ -0,0 +1,8 @@
+for (int c0 = 1; c0 <= M; c0 += 1) {
+  for (int c2 = 2; c2 < N; c2 += 1)
+    for (int c3 = 2; c3 < N; c3 += 1)
+      S1(c0, c2, c3);
+  for (int c2 = 2; c2 < N; c2 += 1)
+    for (int c3 = 2; c3 < N; c3 += 1)
+      S2(c0, c2, c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.st
new file mode 100644
index 0000000..3cf78bf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-pingali6.st
@@ -0,0 +1,22 @@
+domain: "[M, N] -> { S2[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + N; S1[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 2 and i1 <= -1 + N and i2 >= 2 and i2 <= -1 + N }"
+child:
+  context: "[M, N] -> { [] : M >= 1 and N >= 1 }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(2i0)]; S2[i0, i1, i2] -> [(1 + 2i0)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1, i2] }"
+        child:
+          schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+          child:
+            schedule: "[M, N] -> [{ S1[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N] -> { separate[i0] }"
+      - filter: "[M, N] -> { S2[i0, i1, i2] }"
+        child:
+          schedule: "[M, N] -> [{ S2[i0, i1, i2] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+          child:
+            schedule: "[M, N] -> [{ S2[i0, i1, i2] -> [(i2)] }]"
+            options: "[M, N] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.c
new file mode 100644
index 0000000..6a970d4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.c
@@ -0,0 +1,2 @@
+for (int c0 = 2; c0 <= M; c0 += 7)
+  S1(c0, (c0 - 2) / 7);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.st
new file mode 100644
index 0000000..135c90c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0, i1] : 7i1 = -2 + i0 and i0 >= 2 and i0 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.c
new file mode 100644
index 0000000..6a970d4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.c
@@ -0,0 +1,2 @@
+for (int c0 = 2; c0 <= M; c0 += 7)
+  S1(c0, (c0 - 2) / 7);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.st
new file mode 100644
index 0000000..0600029
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-stride2.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0, i1] : 7i1 = -2 + i0 and i0 >= 0 and i0 <= M }"
+child:
+  context: "[M] -> { [] }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.c
new file mode 100644
index 0000000..2a0f875
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.c
@@ -0,0 +1,5 @@
+for (int c0 = 0; c0 <= 9; c0 += 2)
+  for (int c1 = 0; c1 <= min(4, c0 + 3); c1 += 2)
+    for (int c2 = max(1, c0); c2 <= min(c0 + 1, c0 - c1 + 4); c2 += 1)
+      for (int c3 = max(1, -c0 + c1 + c2); c3 <= min(4, -c0 + c1 + c2 + 1); c3 += 1)
+        S1(c0 / 2, (-c0 + c1) / 2, -c0 + c2, -c1 + c3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.st
new file mode 100644
index 0000000..89d8b72
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-tang-xue1.st
@@ -0,0 +1,15 @@
+domain: "{ S1[i0, i1, i2, i3] : i3 <= 4 - 2i0 - 2i1 and i3 >= i2 and i2 <= 9 - 2i0 and i2 >= 0 and i2 >= 1 - 2i0 and i3 <= 1 + i2 and i2 <= 1 and i3 >= 1 - 2i0 - 2i1 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1, i2, i3] -> [(2i0)] }]"
+    options: "{ separate[i0] }"
+    child:
+      schedule: "[{ S1[i0, i1, i2, i3] -> [(2i0 + 2i1)] }]"
+      options: "{ separate[i0] }"
+      child:
+        schedule: "[{ S1[i0, i1, i2, i3] -> [(2i0 + i2)] }]"
+        options: "{ separate[i0] }"
+        child:
+          schedule: "[{ S1[i0, i1, i2, i3] -> [(2i0 + 2i1 + i3)] }]"
+          options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.c b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.c
new file mode 100644
index 0000000..3946c42
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.c
@@ -0,0 +1 @@
+S1(1, 1, 5);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.st b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.st
new file mode 100644
index 0000000..c780ca2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/reservoir-two.st
@@ -0,0 +1,6 @@
+domain: "{ S1[i0, i1, i2] : 2i1 = 3 - i0 and 2i2 = 9 + i0 and i0 >= 0 and i0 <= 1 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i0, i1, i2] -> [(i0)] }, { S1[i0, i1, i2] -> [(i1)] }, { S1[i0, i1, i2] -> [(i2)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/singleton.c b/lib/Analysis/isl/test_inputs/codegen/cloog/singleton.c
new file mode 100644
index 0000000..0023bc6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/singleton.c
@@ -0,0 +1,4 @@
+{
+  S2();
+  S1();
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/singleton.st b/lib/Analysis/isl/test_inputs/codegen/cloog/singleton.st
new file mode 100644
index 0000000..a38487b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/singleton.st
@@ -0,0 +1,7 @@
+domain: "{ S1[]; S2[] }"
+child:
+  context: "{ [] }"
+  child:
+    sequence:
+    - filter: "{ S2[] }"
+    - filter: "{ S1[] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.c b/lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.c
new file mode 100644
index 0000000..92c6b33
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.c
@@ -0,0 +1,13 @@
+if (M >= 1 && N >= 3)
+  for (int c0 = -1; c0 <= (3 * M + N - 5) / 100; c0 += 1) {
+    for (int c1 = max(max(0, c0 - (2 * M + N + 95) / 100 + 1), floord(-N + 100 * c0 + 106, 300)); c1 <= min(min(c0, M / 100), (c0 + 1) / 3); c1 += 1)
+      for (int c2 = max(200 * c1 - 3, 100 * c0 - 100 * c1); c2 <= min(min(2 * M + N - 5, 100 * c0 - 100 * c1 + 99), N + 200 * c1 + 193); c2 += 1) {
+        if (c1 >= 1 && N + 200 * c1 >= c2 + 7)
+          S3(c0 - c1, c1 - 1, c1, 100 * c1 - 1, -200 * c1 + c2 + 6);
+        for (int c3 = max(max(1, 100 * c1), -N + (N + c2) / 2 + 3); c3 <= min(min(M, 100 * c1 + 99), c2 / 2 + 1); c3 += 1)
+          S1(c0 - c1, c1, c3, c2 - 2 * c3 + 4);
+        if (M >= 100 * c1 + 100 && c2 >= 200 * c1 + 197)
+          S2(c0 - c1, c1, c1 + 1, 100 * c1 + 99, -200 * c1 + c2 - 194);
+      }
+    S4(c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.st b/lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.st
new file mode 100644
index 0000000..bdde2e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/sor1d.st
@@ -0,0 +1,24 @@
+domain: "[M, N] -> { S2[i0, i1, 1 + i1, 99 + 100i1, i4] : i4 >= 3 and i4 >= -193 - 200i1 and i4 >= -194 + 100i0 - 200i1 and 100i0 >= -284 - 3N and i4 <= -1 + N and i4 <= -201 + 2M + N - 200i1 and i4 <= -95 + 100i0 - 200i1 and 100i0 >= -94 - N and 50i0 >= -45 - N and 3N >= -134 - M and i1 >= 0 and N >= 4 and 200i1 >= -192 - N and 200i1 >= -193 - N + 100i0 and 100i0 <= -7 + 2M + N and 7N >= -463 - 2M and 100i1 <= -100 + M and i0 >= 0 and 200i1 <= -204 + 2M + N and 2i1 <= -1 + i0 and 5N >= -75 - 2M and N >= 8 - 2M and 50i0 <= -6 + M + N and 50i0 <= 89 + M + 2N and 100i0 <= -15 + 2M + 3N and M >= 2 and 100i1 <= -5 + M + N and 2N >= -39 - M and 200i1 <= 96 + N + 100i0 and 3N >= 16 - 2M and 100i1 >= -94 - N + 50i0 and N >= 6 - M and 100i1 >= -94 - N; S3[i0, i1, 1 + i1, 99 + 100i1, i4] : i4 >= 3 and i4 >= -193 - 200i1 and i4 >= -194 + 100i0 - 200i1 and 100i0 >= -284 - 3N and i4 <= -1 + N and i4 <= -201 + 2M + N - 200i1 and i4 <= -95 + 100i0 - 200i1 and 100i0 >= -94 - N and 50i0 >= -45 - N and 3N >= -134 - M and i1 >= 0 and N >= 4 and 200i1 >= -192 - N and 200i1 >= -193 - N + 100i0 and 100i0 <= -7 + 2M + N and 7N >= -463 - 2M and 100i1 <= -100 + M and i0 >= 0 and 200i1 <= -204 + 2M + N and 2i1 <= -1 + i0 and 5N >= -75 - 2M and N >= 8 - 2M and 50i0 <= -6 + M + N and 50i0 <= 89 + M + 2N and 100i0 <= -15 + 2M + 3N and M >= 2 and 100i1 <= -5 + M + N and 2N >= -39 - M and 200i1 <= 96 + N + 100i0 and 3N >= 16 - 2M and 100i1 >= -94 - N + 50i0 and N >= 6 - M and 100i1 >= -94 - N; S4[i0] : 200i0 >= -781 - 3N and 200i0 >= -391 - N and 50i0 >= -268 - N and 100i0 >= -392 - N and i0 >= -1 and 200i0 <= 377 + 6M + 5N and 100i0 <= 335 + 3M + 3N and 100i0 <= 190 + 3M + 2N and 200i0 <= -13 + 6M + 3N and 100i0 <= -5 + 3M + N and 3N >= -484 - 2M and N >= -95 - M and N >= -192 - 3M and 5N >= -873 - 3M and 2N >= -189 - 3M and 7N >= -1062 - 6M and 5N >= -771 - 6M and 4N >= -579 - 3M and N >= 3 and N >= 5 - 2M and M >= 1; S1[i0, i1, i2, i3] : i3 >= 4 + 100i0 - 2i2 and i3 >= 2 and i3 <= 103 + 100i0 - 2i2 and i3 <= -1 + N and i2 >= 1 and i2 >= 100i1 and 2i2 >= 5 - N + 100i0 and i2 <= M and i2 <= 99 + 100i1 and i2 <= 50 + 50i0 and i1 >= 0 and 200i1 >= -193 - N + 100i0 and 100i1 <= M and 2i1 <= 1 + i0 and i0 >= 0 and 100i0 <= -5 + 2M + N and N >= 3 and N >= -94 - 2M and M >= 1 }"
+child:
+  context: "[M, N] -> { [] : M >= 0 and N >= 0 }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0, i1, i2, i3, i4] -> [(i0 + i1)]; S1[i0, i1, i2, i3] -> [(i0 + i1)]; S3[i0, i1, i2, i3, i4] -> [(1 + i0 + i1)]; S4[i0] -> [(i0)] }]"
+    options: "[M, N] -> { atomic[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S2[i0, i1, i2, i3, i4]; S3[i0, i1, i2, i3, i4]; S1[i0, i1, i2, i3] }"
+        child:
+          schedule: "[M, N] -> [{ S2[i0, i1, i2, i3, i4] -> [(i1)]; S1[i0, i1, i2, i3] -> [(i1)]; S3[i0, i1, i2, i3, i4] -> [(i2)] }, { S2[i0, i1, i2, i3, i4] -> [(-4 + 2i3 + i4)]; S1[i0, i1, i2, i3] -> [(-4 + 2i2 + i3)]; S3[i0, i1, i2, i3, i4] -> [(-4 + 2i3 + i4)] }, { S2[i0, i1, i2, i3, i4] -> [(i3)]; S1[i0, i1, i2, i3] -> [(i2)]; S3[i0, i1, i2, i3, i4] -> [(i3)] }]"
+          options: "[M, N] -> { atomic[i0] }"
+          child:
+            sequence:
+            - filter: "[M, N] -> { S3[i0, i1, i2, i3, i4] }"
+              child:
+                schedule: "[M, N] -> [{ S3[i0, i1, i2, i3, i4] -> [(i1)] }, { S3[i0, i1, i2, i3, i4] -> [(i4)] }]"
+                options: "[M, N] -> { atomic[i0] }"
+            - filter: "[M, N] -> { S1[i0, i1, i2, i3] }"
+            - filter: "[M, N] -> { S2[i0, i1, i2, i3, i4] }"
+              child:
+                schedule: "[M, N] -> [{ S2[i0, i1, i2, i3, i4] -> [(i2)] }, { S2[i0, i1, i2, i3, i4] -> [(i4)] }]"
+                options: "[M, N] -> { atomic[i0] }"
+      - filter: "[M, N] -> { S4[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.c
new file mode 100644
index 0000000..316213f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.c
@@ -0,0 +1,9 @@
+for (int c0 = 1; c0 <= M; c0 += 1) {
+  S1(c0, 1);
+  for (int c1 = 2; c1 <= c0; c1 += 1) {
+    S1(c0, c1);
+    S2(c0, c1);
+  }
+  for (int c1 = c0 + 1; c1 <= M; c1 += 1)
+    S1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.st
new file mode 100644
index 0000000..bff294d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/square+triangle-1-1-2-3.st
@@ -0,0 +1,10 @@
+domain: "[M] -> { S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= M; S2[i0, i1] : i1 >= 2 and i1 <= i0 and i0 <= M }"
+child:
+  context: "[M] -> { [] : M >= 1 }"
+  child:
+    schedule: "[M] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M] -> { S1[i0, i1] }"
+      - filter: "[M] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride.c b/lib/Analysis/isl/test_inputs/codegen/cloog/stride.c
new file mode 100644
index 0000000..9bd4ddf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride.c
@@ -0,0 +1,7 @@
+{
+  for (int c0 = 3; c0 <= 24; c0 += 3)
+    S2(c0, c0 / 3);
+  S1(25);
+  for (int c0 = 27; c0 <= 100; c0 += 3)
+    S2(c0, c0 / 3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride.st b/lib/Analysis/isl/test_inputs/codegen/cloog/stride.st
new file mode 100644
index 0000000..d83f979
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride.st
@@ -0,0 +1,6 @@
+domain: "{ S2[i0, i1] : 3i1 = i0 and i0 >= 3 and i0 <= 100; S1[25] }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S2[i0, i1] -> [(i0)]; S1[i0] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0] -> [(0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/stride2.c
new file mode 100644
index 0000000..c56af8e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride2.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 3; c0 <= 26; c0 += 3)
+    S2(c0, c0 / 3);
+  S1(27);
+  S2(27, 9);
+  for (int c0 = 30; c0 <= 100; c0 += 3)
+    S2(c0, c0 / 3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/stride2.st
new file mode 100644
index 0000000..d2e3420
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride2.st
@@ -0,0 +1,6 @@
+domain: "{ S2[i0, i1] : 3i1 = i0 and i0 >= 3 and i0 <= 100; S1[27] }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S2[i0, i1] -> [(i0)]; S1[i0] -> [(i0)] }, { S2[i0, i1] -> [(i1)]; S1[i0] -> [(0)] }]"
+    options: "{ separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/stride3.c
new file mode 100644
index 0000000..d145938
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride3.c
@@ -0,0 +1,2 @@
+for (int c0 = max(1, m); c0 <= n; c0 += 1)
+  S1(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/stride3.st
new file mode 100644
index 0000000..f970d2c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride3.st
@@ -0,0 +1,6 @@
+domain: "[m, n] -> { S1[i] : i >= 1 and i <= n and i >= m }"
+child:
+  context: "[m, n] -> { [] }"
+  child:
+    schedule: "[m, n] -> [{ S1[i0] -> [(50i0)] }]"
+    options: "[m, n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride4.c b/lib/Analysis/isl/test_inputs/codegen/cloog/stride4.c
new file mode 100644
index 0000000..03908e6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride4.c
@@ -0,0 +1,3 @@
+if (t >= 0 && t <= 15)
+  for (int c0 = t; c0 <= 99; c0 += 16)
+    S1(c0, t);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/stride4.st b/lib/Analysis/isl/test_inputs/codegen/cloog/stride4.st
new file mode 100644
index 0000000..9ffa62a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/stride4.st
@@ -0,0 +1,6 @@
+domain: "[t] -> { S1[i0, t] : exists (e0 = floor((t - i0)/16): 16e0 = t - i0 and i0 >= 0 and i0 <= 99 and t >= 0 and t <= 15) }"
+child:
+  context: "[t] -> { [] }"
+  child:
+    schedule: "[t] -> [{ S1[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)] }]"
+    options: "[t] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/swim.c b/lib/Analysis/isl/test_inputs/codegen/cloog/swim.c
new file mode 100644
index 0000000..14f6514
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/swim.c
@@ -0,0 +1,159 @@
+if (M == 1) {
+  S1();
+  S2();
+  S3();
+  S4();
+  S5();
+  S6();
+  S7();
+  S8();
+  S9();
+  S10();
+  S11();
+  S12();
+  S13();
+  S14();
+  S15();
+  S16();
+  S17();
+  S18();
+  S19();
+  S20();
+  S21();
+  S22();
+  S23();
+  S24();
+  S25();
+  S26();
+  S27();
+  for (int c0 = 1; c0 <= N; c0 += 1) {
+    for (int c1 = 1; c1 <= N; c1 += 1) {
+      S28(c0, c1);
+      S29(c0, c1);
+      S30(c0, c1);
+    }
+    S31(c0);
+  }
+  S32();
+  S33();
+  S34();
+  if (O <= 1)
+    S35();
+  S36();
+  S37();
+  for (int c0 = 2; c0 <= P; c0 += 1) {
+    S38(c0);
+    S39(c0);
+    for (int c1 = 1; c1 <= Q; c1 += 1)
+      for (int c2 = 1; c2 <= R; c2 += 1) {
+        S40(c0, c1, c2);
+        S41(c0, c1, c2);
+        S42(c0, c1, c2);
+        S43(c0, c1, c2);
+      }
+    for (int c1 = 1; c1 <= Q; c1 += 1) {
+      S44(c0, c1);
+      S45(c0, c1);
+      S46(c0, c1);
+      S47(c0, c1);
+    }
+    for (int c1 = 1; c1 <= R; c1 += 1) {
+      S48(c0, c1);
+      S49(c0, c1);
+      S50(c0, c1);
+      S51(c0, c1);
+    }
+    S52(c0);
+    S53(c0);
+    S54(c0);
+    S55(c0);
+    S56(c0);
+    S57(c0);
+    S58(c0);
+    for (int c1 = 1; c1 <= Q; c1 += 1)
+      for (int c2 = 1; c2 <= R; c2 += 1) {
+        S59(c0, c1, c2);
+        S60(c0, c1, c2);
+        S61(c0, c1, c2);
+      }
+    for (int c1 = 1; c1 <= Q; c1 += 1) {
+      S62(c0, c1);
+      S63(c0, c1);
+      S64(c0, c1);
+    }
+    for (int c1 = 1; c1 <= R; c1 += 1) {
+      S65(c0, c1);
+      S66(c0, c1);
+      S67(c0, c1);
+    }
+    S68(c0);
+    S69(c0);
+    S70(c0);
+    S71(c0);
+    S72(c0);
+    S73(c0);
+    S74(c0);
+    S75(c0);
+    S76(c0);
+    S77(c0);
+    S78(c0);
+    S79(c0);
+    S80(c0);
+    S81(c0);
+    S82(c0);
+    S83(c0);
+    S84(c0);
+    S85(c0);
+    S86(c0);
+    S87(c0);
+    S88(c0);
+    S89(c0);
+    S90(c0);
+    S91(c0);
+    S92(c0);
+    S93(c0);
+    S94(c0);
+    for (int c1 = 1; c1 <= N; c1 += 1) {
+      for (int c2 = 1; c2 <= N; c2 += 1) {
+        S95(c0, c1, c2);
+        S96(c0, c1, c2);
+        S97(c0, c1, c2);
+      }
+      S98(c0, c1);
+    }
+    S99(c0);
+    S100(c0);
+    S101(c0);
+    for (int c1 = 1; c1 <= Q; c1 += 1)
+      for (int c2 = 1; c2 <= R; c2 += 1) {
+        S102(c0, c1, c2);
+        S103(c0, c1, c2);
+        S104(c0, c1, c2);
+        S105(c0, c1, c2);
+        S106(c0, c1, c2);
+        S107(c0, c1, c2);
+      }
+    for (int c1 = 1; c1 <= Q; c1 += 1) {
+      S108(c0, c1);
+      S109(c0, c1);
+      S110(c0, c1);
+      S111(c0, c1);
+      S112(c0, c1);
+      S113(c0, c1);
+    }
+    for (int c1 = 1; c1 <= R; c1 += 1) {
+      S114(c0, c1);
+      S115(c0, c1);
+      S116(c0, c1);
+      S117(c0, c1);
+      S118(c0, c1);
+      S119(c0, c1);
+    }
+    S120(c0);
+    S121(c0);
+    S122(c0);
+    S123(c0);
+    S124(c0);
+    S125(c0);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/swim.st b/lib/Analysis/isl/test_inputs/codegen/cloog/swim.st
new file mode 100644
index 0000000..ff08bb1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/swim.st
@@ -0,0 +1,223 @@
+domain: "[M, N, O, P, Q, R] -> { S40[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S106[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S99[i0] : M = 1 and i0 >= 2 and i0 <= P; S83[i0] : M = 1 and i0 >= 2 and i0 <= P; S86[i0] : M = 1 and i0 >= 2 and i0 <= P; S56[i0] : M = 1 and i0 >= 2 and i0 <= P; S124[i0] : M = 1 and i0 >= 2 and i0 <= P; S66[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S46[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S64[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S22[] : M = 1; S15[] : M = 1; S30[i0, i1] : M = 1 and i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= N; S14[] : M = 1; S12[] : M = 1; S87[i0] : M = 1 and i0 >= 2 and i0 <= P; S110[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S73[i0] : M = 1 and i0 >= 2 and i0 <= P; S44[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S31[i0] : M = 1 and i0 >= 1 and i0 <= N; S118[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S8[] : M = 1; S125[i0] : M = 1 and i0 >= 2 and i0 <= P; S63[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S25[] : M = 1; S51[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S91[i0] : M = 1 and i0 >= 2 and i0 <= P; S84[i0] : M = 1 and i0 >= 2 and i0 <= P; S35[] : M = 1 and O <= 1; S97[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= N and i2 >= 1 and i2 <= N; S75[i0] : M = 1 and i0 >= 2 and i0 <= P; S19[] : M = 1; S50[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S114[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S13[] : M = 1; S72[i0] : M = 1 and i0 >= 2 and i0 <= P; S78[i0] : M = 1 and i0 >= 2 and i0 <= P; S39[i0] : M = 1 and i0 >= 2 and i0 <= P; S102[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S107[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S68[i0] : M = 1 and i0 >= 2 and i0 <= P; S32[] : M = 1; S41[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S69[i0] : M = 1 and i0 >= 2 and i0 <= P; S3[] : M = 1; S100[i0] : M = 1 and i0 >= 2 and i0 <= P; S11[] : M = 1; S76[i0] : M = 1 and i0 >= 2 and i0 <= P; S88[i0] : M = 1 and i0 >= 2 and i0 <= P; S49[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S45[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S10[] : M = 1; S80[i0] : M = 1 and i0 >= 2 and i0 <= P; S61[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S67[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S70[i0] : M = 1 and i0 >= 2 and i0 <= P; S29[i0, i1] : M = 1 and i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= N; S60[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S21[] : M = 1; S92[i0] : M = 1 and i0 >= 2 and i0 <= P; S47[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S24[] : M = 1; S16[] : M = 1; S105[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S18[] : M = 1; S48[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S5[] : M = 1; S113[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S7[] : M = 1; S38[i0] : M = 1 and i0 >= 2 and i0 <= P; S54[i0] : M = 1 and i0 >= 2 and i0 <= P; S109[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S23[] : M = 1; S82[i0] : M = 1 and i0 >= 2 and i0 <= P; S59[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S77[i0] : M = 1 and i0 >= 2 and i0 <= P; S101[i0] : M = 1 and i0 >= 2 and i0 <= P; S37[] : M = 1; S71[i0] : M = 1 and i0 >= 2 and i0 <= P; S121[i0] : M = 1 and i0 >= 2 and i0 <= P; S115[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S104[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S94[i0] : M = 1 and i0 >= 2 and i0 <= P; S6[] : M = 1; S43[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S1[] : M = 1; S98[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= N; S55[i0] : M = 1 and i0 >= 2 and i0 <= P; S58[i0] : M = 1 and i0 >= 2 and i0 <= P; S42[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S89[i0] : M = 1 and i0 >= 2 and i0 <= P; S53[i0] : M = 1 and i0 >= 2 and i0 <= P; S111[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S52[i0] : M = 1 and i0 >= 2 and i0 <= P; S85[i0] : M = 1 and i0 >= 2 and i0 <= P; S26[] : M = 1; S79[i0] : M = 1 and i0 >= 2 and i0 <= P; S81[i0] : M = 1 and i0 >= 2 and i0 <= P; S57[i0] : M = 1 and i0 >= 2 and i0 <= P; S4[] : M = 1; S123[i0] : M = 1 and i0 >= 2 and i0 <= P; S36[] : M = 1; S65[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S34[] : M = 1; S119[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S9[] : M = 1; S28[i0, i1] : M = 1 and i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= N; S20[] : M = 1; S117[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S112[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S103[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q and i2 >= 1 and i2 <= R; S17[] : M = 1; S96[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= N and i2 >= 1 and i2 <= N; S95[i0, i1, i2] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= N and i2 >= 1 and i2 <= N; S62[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S90[i0] : M = 1 and i0 >= 2 and i0 <= P; S120[i0] : M = 1 and i0 >= 2 and i0 <= P; S116[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= R; S108[i0, i1] : M = 1 and i0 >= 2 and i0 <= P and i1 >= 1 and i1 <= Q; S74[i0] : M = 1 and i0 >= 2 and i0 <= P; S93[i0] : M = 1 and i0 >= 2 and i0 <= P; S2[] : M = 1; S27[] : M = 1; S122[i0] : M = 1 and i0 >= 2 and i0 <= P; S33[] : M = 1 }"
+child:
+  context: "[M, N, O, P, Q, R] -> { [] }"
+  child:
+    sequence:
+    - filter: "[M, N, O, P, Q, R] -> { S1[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S2[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S3[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S4[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S5[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S6[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S7[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S8[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S9[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S10[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S11[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S12[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S13[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S14[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S15[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S16[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S17[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S18[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S19[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S20[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S21[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S22[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S23[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S24[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S25[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S26[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S27[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S30[i0, i1]; S28[i0, i1]; S31[i0]; S29[i0, i1] }"
+      child:
+        schedule: "[M, N, O, P, Q, R] -> [{ S31[i0] -> [(i0)]; S29[i0, i1] -> [(i0)]; S30[i0, i1] -> [(i0)]; S28[i0, i1] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+        child:
+          sequence:
+          - filter: "[M, N, O, P, Q, R] -> { S30[i0, i1]; S28[i0, i1]; S29[i0, i1] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S29[i0, i1] -> [(i1)]; S30[i0, i1] -> [(i1)]; S28[i0, i1] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S28[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S29[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S30[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S31[i0] }"
+    - filter: "[M, N, O, P, Q, R] -> { S32[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S33[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S34[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S35[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S36[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S37[] }"
+    - filter: "[M, N, O, P, Q, R] -> { S58[i0]; S116[i0, i1]; S120[i0]; S106[i0, i1, i2]; S102[i0, i1, i2]; S114[i0, i1]; S113[i0, i1]; S122[i0]; S83[i0]; S103[i0, i1, i2]; S71[i0]; S50[i0, i1]; S98[i0, i1]; S65[i0, i1]; S82[i0]; S109[i0, i1]; S51[i0, i1]; S60[i0, i1, i2]; S91[i0]; S78[i0]; S101[i0]; S123[i0]; S111[i0, i1]; S97[i0, i1, i2]; S67[i0, i1]; S117[i0, i1]; S88[i0]; S79[i0]; S46[i0, i1]; S56[i0]; S45[i0, i1]; S74[i0]; S49[i0, i1]; S75[i0]; S115[i0, i1]; S119[i0, i1]; S42[i0, i1, i2]; S57[i0]; S62[i0, i1]; S99[i0]; S107[i0, i1, i2]; S100[i0]; S104[i0, i1, i2]; S70[i0]; S89[i0]; S125[i0]; S44[i0, i1]; S93[i0]; S90[i0]; S84[i0]; S105[i0, i1, i2]; S95[i0, i1, i2]; S66[i0, i1]; S77[i0]; S38[i0]; S41[i0, i1, i2]; S92[i0]; S87[i0]; S47[i0, i1]; S108[i0, i1]; S54[i0]; S76[i0]; S112[i0, i1]; S80[i0]; S55[i0]; S39[i0]; S59[i0, i1, i2]; S121[i0]; S86[i0]; S110[i0, i1]; S48[i0, i1]; S68[i0]; S53[i0]; S72[i0]; S85[i0]; S52[i0]; S69[i0]; S61[i0, i1, i2]; S43[i0, i1, i2]; S124[i0]; S73[i0]; S81[i0]; S63[i0, i1]; S118[i0, i1]; S96[i0, i1, i2]; S40[i0, i1, i2]; S94[i0]; S64[i0, i1] }"
+      child:
+        schedule: "[M, N, O, P, Q, R] -> [{ S99[i0] -> [(i0)]; S97[i0, i1, i2] -> [(i0)]; S53[i0] -> [(i0)]; S101[i0] -> [(i0)]; S60[i0, i1, i2] -> [(i0)]; S40[i0, i1, i2] -> [(i0)]; S103[i0, i1, i2] -> [(i0)]; S55[i0] -> [(i0)]; S89[i0] -> [(i0)]; S56[i0] -> [(i0)]; S87[i0] -> [(i0)]; S115[i0, i1] -> [(i0)]; S123[i0] -> [(i0)]; S88[i0] -> [(i0)]; S70[i0] -> [(i0)]; S59[i0, i1, i2] -> [(i0)]; S52[i0] -> [(i0)]; S54[i0] -> [(i0)]; S63[i0, i1] -> [(i0)]; S92[i0] -> [(i0)]; S93[i0] -> [(i0)]; S119[i0, i1] -> [(i0)]; S76[i0] -> [(i0)]; S57[i0] -> [(i0)]; S44[i0, i1] -> [(i0)]; S79[i0] -> [(i0)]; S61[i0, i1, i2] -> [(i0)]; S69[i0] -> [(i0)]; S117[i0, i1] -> [(i0)]; S121[i0] -> [(i0)]; S84[i0] -> [(i0)]; S83[i0] -> [(i0)]; S43[i0, i1, i2] -> [(i0)]; S98[i0, i1] -> [(i0)]; S78[i0] -> [(i0)]; S114[i0, i1] -> [(i0)]; S66[i0, i1] -> [(i0)]; S77[i0] -> [(i0)]; S109[i0, i1] -> [(i0)]; S42[i0, i1, i2] -> [(i0)]; S58[i0] -> [(i0)]; S71[i0] -> [(i0)]; S68[i0] -> [(i0)]; S116[i0, i1] -> [(i0)]; S81[i0] -> [(i0)]; S125[i0] -> [(i0)]; S80[i0] -> [(i0)]; S73[i0] -> [(i0)]; S110[i0, i1] -> [(i0)]; S72[i0] -> [(i0)]; S51[i0, i1] -> [(i0)]; S122[i0] -> [(i0)]; S38[i0] -> [(i0)]; S39[i0] -> [(i0)]; S90[i0] -> [(i0)]; S113[i0, i1] -> [(i0)]; S46[i0, i1] -> [(i0)]; S47[i0, i1] -> [(i0)]; S96[i0, i1, i2] -> [(i0)]; S45[i0, i1] -> [(i0)]; S49[i0, i1] -> [(i0)]; S118[i0, i1] -> [(i0)]; S50[i0, i1] -> [(i0)]; S102[i0, i1, i2] -> [(i0)]; S112[i0, i1] -> [(i0)]; S86[i0] -> [(i0)]; S124[i0] -> [(i0)]; S41[i0, i1, i2] -> [(i0)]; S100[i0] -> [(i0)]; S104[i0, i1, i2] -> [(i0)]; S75[i0] -> [(i0)]; S62[i0, i1] -> [(i0)]; S85[i0] -> [(i0)]; S105[i0, i1, i2] -> [(i0)]; S82[i0] -> [(i0)]; S111[i0, i1] -> [(i0)]; S48[i0, i1] -> [(i0)]; S65[i0, i1] -> [(i0)]; S120[i0] -> [(i0)]; S107[i0, i1, i2] -> [(i0)]; S106[i0, i1, i2] -> [(i0)]; S95[i0, i1, i2] -> [(i0)]; S108[i0, i1] -> [(i0)]; S91[i0] -> [(i0)]; S67[i0, i1] -> [(i0)]; S74[i0] -> [(i0)]; S64[i0, i1] -> [(i0)]; S94[i0] -> [(i0)] }]"
+        options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+        child:
+          sequence:
+          - filter: "[M, N, O, P, Q, R] -> { S38[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S39[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S40[i0, i1, i2]; S41[i0, i1, i2]; S43[i0, i1, i2]; S42[i0, i1, i2] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S43[i0, i1, i2] -> [(i1)]; S41[i0, i1, i2] -> [(i1)]; S40[i0, i1, i2] -> [(i1)]; S42[i0, i1, i2] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                schedule: "[M, N, O, P, Q, R] -> [{ S43[i0, i1, i2] -> [(i2)]; S41[i0, i1, i2] -> [(i2)]; S40[i0, i1, i2] -> [(i2)]; S42[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+                child:
+                  sequence:
+                  - filter: "[M, N, O, P, Q, R] -> { S40[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S41[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S42[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S43[i0, i1, i2] }"
+          - filter: "[M, N, O, P, Q, R] -> { S46[i0, i1]; S45[i0, i1]; S44[i0, i1]; S47[i0, i1] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S47[i0, i1] -> [(i1)]; S46[i0, i1] -> [(i1)]; S44[i0, i1] -> [(i1)]; S45[i0, i1] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S44[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S45[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S46[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S47[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S51[i0, i1]; S49[i0, i1]; S50[i0, i1]; S48[i0, i1] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S51[i0, i1] -> [(i1)]; S49[i0, i1] -> [(i1)]; S48[i0, i1] -> [(i1)]; S50[i0, i1] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S48[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S49[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S50[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S51[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S52[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S53[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S54[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S55[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S56[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S57[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S58[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S60[i0, i1, i2]; S59[i0, i1, i2]; S61[i0, i1, i2] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S61[i0, i1, i2] -> [(i1)]; S59[i0, i1, i2] -> [(i1)]; S60[i0, i1, i2] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                schedule: "[M, N, O, P, Q, R] -> [{ S61[i0, i1, i2] -> [(i2)]; S59[i0, i1, i2] -> [(i2)]; S60[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+                child:
+                  sequence:
+                  - filter: "[M, N, O, P, Q, R] -> { S59[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S60[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S61[i0, i1, i2] }"
+          - filter: "[M, N, O, P, Q, R] -> { S62[i0, i1]; S63[i0, i1]; S64[i0, i1] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S64[i0, i1] -> [(i1)]; S62[i0, i1] -> [(i1)]; S63[i0, i1] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S62[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S63[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S64[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S65[i0, i1]; S66[i0, i1]; S67[i0, i1] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S66[i0, i1] -> [(i1)]; S65[i0, i1] -> [(i1)]; S67[i0, i1] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S65[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S66[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S67[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S68[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S69[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S70[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S71[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S72[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S73[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S74[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S75[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S76[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S77[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S78[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S79[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S80[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S81[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S82[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S83[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S84[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S85[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S86[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S87[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S88[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S89[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S90[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S91[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S92[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S93[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S94[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S96[i0, i1, i2]; S98[i0, i1]; S97[i0, i1, i2]; S95[i0, i1, i2] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S98[i0, i1] -> [(i1)]; S95[i0, i1, i2] -> [(i1)]; S96[i0, i1, i2] -> [(i1)]; S97[i0, i1, i2] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S96[i0, i1, i2]; S97[i0, i1, i2]; S95[i0, i1, i2] }"
+                  child:
+                    schedule: "[M, N, O, P, Q, R] -> [{ S95[i0, i1, i2] -> [(i2)]; S96[i0, i1, i2] -> [(i2)]; S97[i0, i1, i2] -> [(i2)] }]"
+                    options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+                    child:
+                      sequence:
+                      - filter: "[M, N, O, P, Q, R] -> { S95[i0, i1, i2] }"
+                      - filter: "[M, N, O, P, Q, R] -> { S96[i0, i1, i2] }"
+                      - filter: "[M, N, O, P, Q, R] -> { S97[i0, i1, i2] }"
+                - filter: "[M, N, O, P, Q, R] -> { S98[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S99[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S100[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S101[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S107[i0, i1, i2]; S105[i0, i1, i2]; S102[i0, i1, i2]; S104[i0, i1, i2]; S106[i0, i1, i2]; S103[i0, i1, i2] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S102[i0, i1, i2] -> [(i1)]; S103[i0, i1, i2] -> [(i1)]; S104[i0, i1, i2] -> [(i1)]; S107[i0, i1, i2] -> [(i1)]; S106[i0, i1, i2] -> [(i1)]; S105[i0, i1, i2] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                schedule: "[M, N, O, P, Q, R] -> [{ S102[i0, i1, i2] -> [(i2)]; S103[i0, i1, i2] -> [(i2)]; S104[i0, i1, i2] -> [(i2)]; S107[i0, i1, i2] -> [(i2)]; S106[i0, i1, i2] -> [(i2)]; S105[i0, i1, i2] -> [(i2)] }]"
+                options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+                child:
+                  sequence:
+                  - filter: "[M, N, O, P, Q, R] -> { S102[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S103[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S104[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S105[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S106[i0, i1, i2] }"
+                  - filter: "[M, N, O, P, Q, R] -> { S107[i0, i1, i2] }"
+          - filter: "[M, N, O, P, Q, R] -> { S113[i0, i1]; S112[i0, i1]; S108[i0, i1]; S111[i0, i1]; S110[i0, i1]; S109[i0, i1] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S110[i0, i1] -> [(i1)]; S112[i0, i1] -> [(i1)]; S111[i0, i1] -> [(i1)]; S113[i0, i1] -> [(i1)]; S109[i0, i1] -> [(i1)]; S108[i0, i1] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S108[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S109[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S110[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S111[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S112[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S113[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S119[i0, i1]; S114[i0, i1]; S117[i0, i1]; S115[i0, i1]; S118[i0, i1]; S116[i0, i1] }"
+            child:
+              schedule: "[M, N, O, P, Q, R] -> [{ S115[i0, i1] -> [(i1)]; S116[i0, i1] -> [(i1)]; S118[i0, i1] -> [(i1)]; S117[i0, i1] -> [(i1)]; S119[i0, i1] -> [(i1)]; S114[i0, i1] -> [(i1)] }]"
+              options: "[M, N, O, P, Q, R] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N, O, P, Q, R] -> { S114[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S115[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S116[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S117[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S118[i0, i1] }"
+                - filter: "[M, N, O, P, Q, R] -> { S119[i0, i1] }"
+          - filter: "[M, N, O, P, Q, R] -> { S120[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S121[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S122[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S123[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S124[i0] }"
+          - filter: "[M, N, O, P, Q, R] -> { S125[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/test.c b/lib/Analysis/isl/test_inputs/codegen/cloog/test.c
new file mode 100644
index 0000000..f0544ab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/test.c
@@ -0,0 +1,17 @@
+{
+  for (int c0 = 1; c0 <= 2; c0 += 1)
+    for (int c1 = 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  for (int c0 = 3; c0 <= N; c0 += 1) {
+    for (int c1 = 1; c1 <= min(M, c0 - 1); c1 += 1)
+      S1(c0, c1);
+    if (c0 >= M + 1) {
+      S2(c0, c0);
+    } else {
+      S1(c0, c0);
+      S2(c0, c0);
+    }
+    for (int c1 = c0 + 1; c1 <= M; c1 += 1)
+      S1(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/test.st b/lib/Analysis/isl/test_inputs/codegen/cloog/test.st
new file mode 100644
index 0000000..97a290e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/test.st
@@ -0,0 +1,10 @@
+domain: "[M, N] -> { S1[i0, i1] : i0 >= 1 and i0 <= N and i1 >= 1 and i1 <= M; S2[i0, i0] : i0 >= 3 and i0 <= N }"
+child:
+  context: "[M, N] -> { [] : N >= M and M >= 4 }"
+  child:
+    schedule: "[M, N] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[M, N] -> { S1[i0, i1] }"
+      - filter: "[M, N] -> { S2[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.c b/lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.c
new file mode 100644
index 0000000..8d6709e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.c
@@ -0,0 +1,9 @@
+{
+  for (int c0 = 0; c0 <= floord(n - 1, 3); c0 += 1)
+    for (int c2 = 3 * c0 + 1; c2 <= min(n, 3 * c0 + 3); c2 += 1)
+      S1(c2, c0);
+  for (int c0 = floord(n, 3); c0 <= 2 * floord(n, 3); c0 += 1)
+    for (int c1 = 0; c1 < n; c1 += 1)
+      for (int c3 = max(1, (n % 3) - n + 3 * c0); c3 <= min(n, (n % 3) - n + 3 * c0 + 2); c3 += 1)
+        S2(c1 + 1, c3, 0, n / 3, c0 - n / 3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.st b/lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.st
new file mode 100644
index 0000000..612b650
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/thomasset.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i, j] : i <= n and i >= 1 and 3j <= -1 + i and 3j >= -3 + i; S2[i, j, 0, p, q] : i <= n and j <= n and j >= 1 and i >= 1 and 3q <= j and 3q >= -2 + j and 3p <= n and 3p >= -2 + n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S2[i0, i1, i2, i3, i4] -> [(i2 + i3 + i4)]; S1[i0, i1] -> [(i1)] }, { S2[i0, i1, i2, i3, i4] -> [(-1 + i0)]; S1[i0, i1] -> [(0)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/tiling.c b/lib/Analysis/isl/test_inputs/codegen/cloog/tiling.c
new file mode 100644
index 0000000..971b988
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/tiling.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= n / 10; c0 += 1)
+  for (int c1 = 10 * c0; c1 <= min(n, 10 * c0 + 9); c1 += 1)
+    S1(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/tiling.st b/lib/Analysis/isl/test_inputs/codegen/cloog/tiling.st
new file mode 100644
index 0000000..5e8f0af
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/tiling.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[ii, i] : i >= 0 and i <= n and i <= 9 + 10ii and i >= 10ii }"
+child:
+  context: "[n] -> { [] : n >= 0 }"
+  child:
+    schedule: "[n] -> [{ S1[ii, i] -> [(ii)] }, { S1[ii, i] -> [(i)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.c b/lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.c
new file mode 100644
index 0000000..7d870a5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.c
@@ -0,0 +1,6 @@
+{
+  for (int c0 = 0; c0 <= n; c0 += 1)
+    S1(c0, 0, 0);
+  for (int c0 = 0; c0 <= n; c0 += 1)
+    S2(0, c0, 0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.st b/lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.st
new file mode 100644
index 0000000..1501e83
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/uday_scalars.st
@@ -0,0 +1,13 @@
+domain: "[n] -> { S1[j, 0, 0] : j >= 0 and j <= n; S2[0, l, 0] : l >= 0 and l <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    sequence:
+    - filter: "[n] -> { S1[i0, i1, i2] }"
+      child:
+        schedule: "[n] -> [{ S1[i0, i1, i2] -> [(i0)] }]"
+        options: "[n] -> { separate[i0] }"
+    - filter: "[n] -> { S2[i0, i1, i2] }"
+      child:
+        schedule: "[n] -> [{ S2[i0, i1, i2] -> [(i1)] }]"
+        options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/union.c b/lib/Analysis/isl/test_inputs/codegen/cloog/union.c
new file mode 100644
index 0000000..b9daaf9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/union.c
@@ -0,0 +1,7 @@
+if (M >= 11) {
+  for (int c0 = -100; c0 <= 0; c0 += 1)
+    S1(-c0);
+} else {
+  for (int c0 = 0; c0 <= 100; c0 += 1)
+    S1(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/union.st b/lib/Analysis/isl/test_inputs/codegen/cloog/union.st
new file mode 100644
index 0000000..c2622dc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/union.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S1[i0] : i0 >= 0 and i0 <= 100 }"
+child:
+  context: "[M] -> { [] : M >= 1 or M <= -1 }"
+  child:
+    schedule: "[M] -> [{ S1[i0] -> [(i0)] : M <= 10; S1[i0] -> [(-i0)] : M >= 11 }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/unroll.c b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll.c
new file mode 100644
index 0000000..83c4577
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll.c
@@ -0,0 +1,13 @@
+{
+  S1(0);
+  S1(1);
+  S1(2);
+  S1(3);
+  S1(4);
+  S1(5);
+  S1(6);
+  S1(7);
+  S1(8);
+  S1(9);
+  S1(10);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/unroll.st b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll.st
new file mode 100644
index 0000000..8780a63
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i] : i >= 0 and i <= 10 }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S1[i] -> [(i)] }]"
+    options: "[n] -> { unroll[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.c
new file mode 100644
index 0000000..58f2705
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.c
@@ -0,0 +1,5 @@
+if (n >= -1 && n <= 9) {
+  if (n >= 0)
+    S1(n);
+  S1(n + 1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.st
new file mode 100644
index 0000000..32cbb8c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/unroll2.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i] : i >= n and i <= 1 + n and n <= 9 and i >= 0 }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S1[i] -> [(i)] }]"
+    options: "[n] -> { unroll[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.c b/lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.c
new file mode 100644
index 0000000..af8c9fe
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.c
@@ -0,0 +1,348 @@
+{
+  for (int c0 = 0; c0 <= 2; c0 += 1) {
+    S1(c0, 0, 0);
+    for (int c1 = 0; c1 <= 4; c1 += 1)
+      S2(c0, c1, 0);
+  }
+  S1(3, 0, 0);
+  for (int c1 = 0; c1 <= 4; c1 += 1)
+    S2(3, c1, 0);
+  for (int c1 = 7; c1 <= 11; c1 += 1)
+    S8(3, c1, 0);
+  S1(4, 0, 0);
+  S2(4, 0, 0);
+  S3(4, 0, 0);
+  S5(4, 0, 0);
+  for (int c1 = 1; c1 <= 4; c1 += 1) {
+    S2(4, c1, 0);
+    S5(4, c1, 0);
+  }
+  for (int c1 = 7; c1 <= 11; c1 += 1)
+    S8(4, c1, 0);
+  for (int c0 = 5; c0 <= 6; c0 += 1) {
+    for (int c1 = -4; c1 < c0 - 8; c1 += 1)
+      S6(c0, c1, 0);
+    for (int c1 = c0 - 9; c1 < 0; c1 += 1)
+      S7(c0, c1, 0);
+    S3(c0, 0, 0);
+    S7(c0, 0, 0);
+    for (int c1 = 1; c1 < c0 - 3; c1 += 1)
+      S4(c0, c1, -1);
+    for (int c1 = c0 - 4; c1 <= 4; c1 += 1)
+      S5(c0, c1, 0);
+    for (int c1 = 7; c1 <= 11; c1 += 1)
+      S8(c0, c1, 0);
+  }
+  for (int c1 = -4; c1 < -1; c1 += 1)
+    S6(7, c1, 0);
+  for (int c1 = -2; c1 < 0; c1 += 1)
+    S7(7, c1, 0);
+  S3(7, 0, 0);
+  S7(7, 0, 0);
+  for (int c1 = 1; c1 <= 3; c1 += 1)
+    S4(7, c1, -1);
+  for (int c1 = 3; c1 <= 4; c1 += 1)
+    S5(7, c1, 0);
+  S9(7, 4, 0);
+  S10(7, 4, 0);
+  S11(7, 4, 0);
+  S21(7, 4, 0);
+  S23(7, 4, 0);
+  S11(7, 4, 1);
+  S16(7, 4, 1);
+  S17(7, 4, 1);
+  for (int c2 = 2; c2 <= 4; c2 += 1)
+    S11(7, 4, c2);
+  S12(7, 5, 0);
+  S21(7, 5, 0);
+  S22(7, 5, 0);
+  S23(7, 5, 0);
+  S12(7, 5, 1);
+  S16(7, 5, 1);
+  S17(7, 5, 1);
+  for (int c2 = 2; c2 <= 4; c2 += 1)
+    S12(7, 5, c2);
+  S21(7, 6, 0);
+  S22(7, 6, 0);
+  S23(7, 6, 0);
+  for (int c1 = 7; c1 <= 8; c1 += 1) {
+    S8(7, c1, 0);
+    S21(7, c1, 0);
+    S22(7, c1, 0);
+    S23(7, c1, 0);
+  }
+  S8(7, 9, 0);
+  S22(7, 9, 0);
+  for (int c1 = 10; c1 <= 11; c1 += 1)
+    S8(7, c1, 0);
+  for (int c1 = -4; c1 < 0; c1 += 1)
+    S6(8, c1, 0);
+  S7(8, -1, 0);
+  S3(8, 0, 0);
+  S7(8, 0, 0);
+  S19(8, 1, -2);
+  S4(8, 1, -1);
+  S19(8, 1, -1);
+  S19(8, 1, 0);
+  S15(8, 1, 4);
+  S18(8, 1, 4);
+  for (int c2 = -4; c2 < -2; c2 += 1) {
+    S14(8, 2, c2);
+    S20(8, 2, c2);
+  }
+  S14(8, 2, -2);
+  S19(8, 2, -2);
+  S20(8, 2, -2);
+  S4(8, 2, -1);
+  S14(8, 2, -1);
+  S19(8, 2, -1);
+  S20(8, 2, -1);
+  S14(8, 2, 0);
+  S19(8, 2, 0);
+  S20(8, 2, 0);
+  S15(8, 2, 4);
+  S18(8, 2, 4);
+  for (int c2 = -4; c2 < -1; c2 += 1) {
+    S14(8, 3, c2);
+    S20(8, 3, c2);
+  }
+  S4(8, 3, -1);
+  S14(8, 3, -1);
+  S20(8, 3, -1);
+  S14(8, 3, 0);
+  S20(8, 3, 0);
+  S15(8, 3, 4);
+  S18(8, 3, 4);
+  for (int c2 = -4; c2 < -1; c2 += 1) {
+    S14(8, 4, c2);
+    S20(8, 4, c2);
+  }
+  S4(8, 4, -1);
+  S14(8, 4, -1);
+  S20(8, 4, -1);
+  S5(8, 4, 0);
+  S9(8, 4, 0);
+  S10(8, 4, 0);
+  S14(8, 4, 0);
+  S20(8, 4, 0);
+  S23(8, 4, 0);
+  S13(8, 4, 1);
+  S21(8, 4, 1);
+  S23(8, 4, 1);
+  S24(8, 4, 1);
+  S13(8, 4, 2);
+  S16(8, 4, 2);
+  S17(8, 4, 2);
+  S24(8, 4, 2);
+  S13(8, 4, 3);
+  S24(8, 4, 3);
+  S13(8, 4, 4);
+  S15(8, 4, 4);
+  S23(8, 5, 0);
+  S11(8, 5, 1);
+  S21(8, 5, 1);
+  S22(8, 5, 1);
+  S23(8, 5, 1);
+  S24(8, 5, 1);
+  S11(8, 5, 2);
+  S16(8, 5, 2);
+  S17(8, 5, 2);
+  S24(8, 5, 2);
+  S11(8, 5, 3);
+  S24(8, 5, 3);
+  S11(8, 5, 4);
+  S15(8, 5, 4);
+  S23(8, 6, 0);
+  S12(8, 6, 1);
+  S21(8, 6, 1);
+  S22(8, 6, 1);
+  S23(8, 6, 1);
+  S24(8, 6, 1);
+  S12(8, 6, 2);
+  S16(8, 6, 2);
+  S17(8, 6, 2);
+  S24(8, 6, 2);
+  S12(8, 6, 3);
+  S24(8, 6, 3);
+  S12(8, 6, 4);
+  for (int c1 = 7; c1 <= 8; c1 += 1) {
+    S23(8, c1, 0);
+    S21(8, c1, 1);
+    S22(8, c1, 1);
+    S23(8, c1, 1);
+    for (int c2 = 1; c2 <= 3; c2 += 1)
+      S24(8, c1, c2);
+  }
+  S22(8, 9, 1);
+  S7(9, 0, 0);
+  for (int c1 = 1; c1 <= 2; c1 += 1) {
+    for (int c2 = -1; c2 <= 0; c2 += 1)
+      S19(9, c1, c2);
+    for (int c2 = 4; c2 <= 5; c2 += 1) {
+      S15(9, c1, c2);
+      S18(9, c1, c2);
+    }
+  }
+  S20(9, 3, -4);
+  for (int c2 = -3; c2 < -1; c2 += 1) {
+    S14(9, 3, c2);
+    S20(9, 3, c2);
+  }
+  for (int c2 = -1; c2 <= 0; c2 += 1) {
+    S14(9, 3, c2);
+    S19(9, 3, c2);
+    S20(9, 3, c2);
+  }
+  for (int c2 = 4; c2 <= 5; c2 += 1) {
+    S15(9, 3, c2);
+    S18(9, 3, c2);
+  }
+  S20(9, 4, -4);
+  for (int c2 = -3; c2 < 0; c2 += 1) {
+    S14(9, 4, c2);
+    S20(9, 4, c2);
+  }
+  S9(9, 4, 0);
+  S10(9, 4, 0);
+  S14(9, 4, 0);
+  S20(9, 4, 0);
+  for (int c2 = 0; c2 <= 1; c2 += 1)
+    S23(9, 4, c2);
+  S13(9, 4, 2);
+  S21(9, 4, 2);
+  S23(9, 4, 2);
+  S24(9, 4, 2);
+  S13(9, 4, 3);
+  S16(9, 4, 3);
+  S17(9, 4, 3);
+  S24(9, 4, 3);
+  S13(9, 4, 4);
+  for (int c2 = 4; c2 <= 5; c2 += 1) {
+    S15(9, 4, c2);
+    S18(9, 4, c2);
+  }
+  for (int c2 = 0; c2 <= 1; c2 += 1)
+    S23(9, 5, c2);
+  S13(9, 5, 2);
+  S21(9, 5, 2);
+  S22(9, 5, 2);
+  S23(9, 5, 2);
+  S24(9, 5, 2);
+  S13(9, 5, 3);
+  S16(9, 5, 3);
+  S17(9, 5, 3);
+  S24(9, 5, 3);
+  S13(9, 5, 4);
+  for (int c2 = 4; c2 <= 5; c2 += 1)
+    S15(9, 5, c2);
+  for (int c2 = 0; c2 <= 1; c2 += 1)
+    S23(9, 6, c2);
+  S11(9, 6, 2);
+  S21(9, 6, 2);
+  S22(9, 6, 2);
+  S23(9, 6, 2);
+  S24(9, 6, 2);
+  S11(9, 6, 3);
+  S16(9, 6, 3);
+  S17(9, 6, 3);
+  S24(9, 6, 3);
+  S11(9, 6, 4);
+  for (int c2 = 0; c2 <= 1; c2 += 1)
+    S23(9, 7, c2);
+  S12(9, 7, 2);
+  S21(9, 7, 2);
+  S22(9, 7, 2);
+  S23(9, 7, 2);
+  S24(9, 7, 2);
+  S12(9, 7, 3);
+  S16(9, 7, 3);
+  S17(9, 7, 3);
+  S24(9, 7, 3);
+  S12(9, 7, 4);
+  for (int c2 = 0; c2 <= 1; c2 += 1)
+    S23(9, 8, c2);
+  S21(9, 8, 2);
+  S22(9, 8, 2);
+  S23(9, 8, 2);
+  for (int c2 = 2; c2 <= 3; c2 += 1)
+    S24(9, 8, c2);
+  S22(9, 9, 2);
+  for (int c1 = 1; c1 <= 3; c1 += 1) {
+    S19(10, c1, 0);
+    S26(10, c1, 3);
+    S15(10, c1, 4);
+    S18(10, c1, 4);
+    S25(10, c1, 4);
+    for (int c2 = 5; c2 <= 6; c2 += 1) {
+      S15(10, c1, c2);
+      S18(10, c1, c2);
+    }
+  }
+  for (int c2 = -4; c2 < -2; c2 += 1)
+    S20(10, 4, c2);
+  for (int c2 = -2; c2 < 0; c2 += 1) {
+    S14(10, 4, c2);
+    S20(10, 4, c2);
+  }
+  S9(10, 4, 0);
+  S10(10, 4, 0);
+  S14(10, 4, 0);
+  S19(10, 4, 0);
+  S20(10, 4, 0);
+  S13(10, 4, 3);
+  S21(10, 4, 3);
+  S24(10, 4, 3);
+  S26(10, 4, 3);
+  S13(10, 4, 4);
+  S15(10, 4, 4);
+  S16(10, 4, 4);
+  S17(10, 4, 4);
+  S18(10, 4, 4);
+  S25(10, 4, 4);
+  for (int c2 = 5; c2 <= 6; c2 += 1) {
+    S15(10, 4, c2);
+    S18(10, 4, c2);
+  }
+  S13(10, 5, 3);
+  S21(10, 5, 3);
+  S22(10, 5, 3);
+  S24(10, 5, 3);
+  S26(10, 5, 3);
+  S13(10, 5, 4);
+  S15(10, 5, 4);
+  S16(10, 5, 4);
+  S17(10, 5, 4);
+  S18(10, 5, 4);
+  S25(10, 5, 4);
+  for (int c2 = 5; c2 <= 6; c2 += 1) {
+    S15(10, 5, c2);
+    S18(10, 5, c2);
+  }
+  S13(10, 6, 3);
+  S21(10, 6, 3);
+  S22(10, 6, 3);
+  S24(10, 6, 3);
+  S13(10, 6, 4);
+  S16(10, 6, 4);
+  S17(10, 6, 4);
+  S11(10, 7, 3);
+  S21(10, 7, 3);
+  S22(10, 7, 3);
+  S24(10, 7, 3);
+  S11(10, 7, 4);
+  S16(10, 7, 4);
+  S17(10, 7, 4);
+  S12(10, 8, 3);
+  S21(10, 8, 3);
+  S22(10, 8, 3);
+  S24(10, 8, 3);
+  S12(10, 8, 4);
+  S16(10, 8, 4);
+  S17(10, 8, 4);
+  S22(10, 9, 3);
+  for (int c0 = 11; c0 <= 14; c0 += 1)
+    for (int c1 = 1; c1 <= 5; c1 += 1) {
+      S26(c0, c1, 3);
+      S25(c0, c1, 4);
+    }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.st b/lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.st
new file mode 100644
index 0000000..6494165
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/usvd_e_t.st
@@ -0,0 +1,34 @@
+domain: "{ S22[i0, i1, -7 + i0] : i0 >= 7 and i1 >= 5 and i1 <= 9 and i0 <= 10; S21[i0, i1, -7 + i0] : i0 <= 10 and i1 >= 4 and i1 <= 8 and i0 >= 7; S4[i0, i1, -1] : i0 <= 8 and i1 >= 1 and i1 <= -4 + i0; S8[i0, i1, 0] : i0 >= 3 and i0 <= 7 and i1 >= 7 and i1 <= 11; S25[i0, i1, 4] : i0 >= 10 and i0 <= 14 and i1 >= 1 and i1 <= 5; S15[i0, i1, i2] : i0 <= 10 and i1 >= 1 and i1 <= 5 and i2 >= 4 and i2 <= -4 + i0; S6[i0, i1, 0] : i0 <= 8 and i1 >= -4 and i1 <= -9 + i0; S16[i0, i1, -6 + i0] : i0 <= 10 and i1 >= 4 and i0 >= 7 and i1 <= -2 + i0; S7[i0, i1, 0] : i0 >= 5 and i1 <= 0 and i1 >= -9 + i0; S1[i0, 0, 0] : i0 >= 0 and i0 <= 4; S2[i0, i1, 0] : i0 >= 0 and i0 <= 4 and i1 >= 0 and i1 <= 4; S26[i0, i1, 3] : i0 >= 10 and i0 <= 14 and i1 >= 1 and i1 <= 5; S10[i0, 4, 0] : i0 >= 7 and i0 <= 10; S12[i0, -2 + i0, i2] : i0 >= 7 and i0 <= 10 and i2 <= 4 and i2 >= -7 + i0; S23[i0, i1, i2] : i0 <= 9 and i1 >= 4 and i1 <= 8 and i2 >= 0 and i2 <= -7 + i0; S13[i0, i1, i2] : i0 <= 10 and i1 >= 4 and i2 <= 4 and i2 >= -7 + i0 and i1 <= -4 + i0; S20[i0, i1, i2] : i0 >= 8 and i1 <= 4 and i2 >= -4 and i2 <= 0 and i1 >= -6 + i0; S24[i0, i1, i2] : i0 >= 8 and i1 >= 4 and i1 <= 8 and i2 <= 3 and i2 >= -7 + i0; S19[i0, i1, i2] : i0 >= 8 and i1 >= 1 and i2 <= 0 and i2 >= -10 + i0 and i1 <= -6 + i0; S11[i0, -3 + i0, i2] : i0 <= 10 and i0 >= 7 and i2 <= 4 and i2 >= -7 + i0; S14[i0, i1, i2] : i0 >= 8 and i1 <= 4 and i2 <= 0 and i2 >= -12 + i0 and i1 >= -6 + i0; S3[i0, 0, 0] : i0 >= 4 and i0 <= 8; S9[i0, 4, 0] : i0 >= 7 and i0 <= 10; S18[i0, i1, i2] : i0 <= 10 and i1 >= 1 and i2 >= 4 and i2 <= -4 + i0 and i1 <= -5 + i0; S5[i0, i1, 0] : i0 >= 4 and i1 <= 4 and i1 >= -4 + i0; S17[i0, i1, -6 + i0] : i0 >= 7 and i1 >= 4 and i0 <= 10 and i1 <= -2 + i0 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S8[i0, i1, i2] -> [(i0)]; S21[i0, i1, i2] -> [(i0)]; S9[i0, i1, i2] -> [(i0)]; S10[i0, i1, i2] -> [(i0)]; S24[i0, i1, i2] -> [(i0)]; S15[i0, i1, i2] -> [(i0)]; S12[i0, i1, i2] -> [(i0)]; S7[i0, i1, i2] -> [(i0)]; S6[i0, i1, i2] -> [(i0)]; S23[i0, i1, i2] -> [(i0)]; S22[i0, i1, i2] -> [(i0)]; S16[i0, i1, i2] -> [(i0)]; S17[i0, i1, i2] -> [(i0)]; S25[i0, i1, i2] -> [(i0)]; S18[i0, i1, i2] -> [(i0)]; S26[i0, i1, i2] -> [(i0)]; S5[i0, i1, i2] -> [(i0)]; S2[i0, i1, i2] -> [(i0)]; S4[i0, i1, i2] -> [(i0)]; S13[i0, i1, i2] -> [(i0)]; S3[i0, i1, i2] -> [(i0)]; S14[i0, i1, i2] -> [(i0)]; S19[i0, i1, i2] -> [(i0)]; S20[i0, i1, i2] -> [(i0)]; S11[i0, i1, i2] -> [(i0)]; S1[i0, i1, i2] -> [(i0)] }, { S8[i0, i1, i2] -> [(i1)]; S21[i0, i1, i2] -> [(i1)]; S9[i0, i1, i2] -> [(i1)]; S10[i0, i1, i2] -> [(i1)]; S24[i0, i1, i2] -> [(i1)]; S15[i0, i1, i2] -> [(i1)]; S12[i0, i1, i2] -> [(i1)]; S7[i0, i1, i2] -> [(i1)]; S6[i0, i1, i2] -> [(i1)]; S23[i0, i1, i2] -> [(i1)]; S22[i0, i1, i2] -> [(i1)]; S16[i0, i1, i2] -> [(i1)]; S17[i0, i1, i2] -> [(i1)]; S25[i0, i1, i2] -> [(i1)]; S18[i0, i1, i2] -> [(i1)]; S26[i0, i1, i2] -> [(i1)]; S5[i0, i1, i2] -> [(i1)]; S2[i0, i1, i2] -> [(i1)]; S4[i0, i1, i2] -> [(i1)]; S13[i0, i1, i2] -> [(i1)]; S3[i0, i1, i2] -> [(i1)]; S14[i0, i1, i2] -> [(i1)]; S19[i0, i1, i2] -> [(i1)]; S20[i0, i1, i2] -> [(i1)]; S11[i0, i1, i2] -> [(i1)]; S1[i0, i1, i2] -> [(i1)] }, { S8[i0, i1, i2] -> [(i2)]; S21[i0, i1, i2] -> [(i2)]; S9[i0, i1, i2] -> [(i2)]; S10[i0, i1, i2] -> [(i2)]; S24[i0, i1, i2] -> [(i2)]; S15[i0, i1, i2] -> [(i2)]; S12[i0, i1, i2] -> [(i2)]; S7[i0, i1, i2] -> [(i2)]; S6[i0, i1, i2] -> [(i2)]; S23[i0, i1, i2] -> [(i2)]; S22[i0, i1, i2] -> [(i2)]; S16[i0, i1, i2] -> [(i2)]; S17[i0, i1, i2] -> [(i2)]; S25[i0, i1, i2] -> [(i2)]; S18[i0, i1, i2] -> [(i2)]; S26[i0, i1, i2] -> [(i2)]; S5[i0, i1, i2] -> [(i2)]; S2[i0, i1, i2] -> [(i2)]; S4[i0, i1, i2] -> [(i2)]; S13[i0, i1, i2] -> [(i2)]; S3[i0, i1, i2] -> [(i2)]; S14[i0, i1, i2] -> [(i2)]; S19[i0, i1, i2] -> [(i2)]; S20[i0, i1, i2] -> [(i2)]; S11[i0, i1, i2] -> [(i2)]; S1[i0, i1, i2] -> [(i2)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1, i2] }"
+      - filter: "{ S2[i0, i1, i2] }"
+      - filter: "{ S3[i0, i1, i2] }"
+      - filter: "{ S4[i0, i1, i2] }"
+      - filter: "{ S5[i0, i1, i2] }"
+      - filter: "{ S6[i0, i1, i2] }"
+      - filter: "{ S7[i0, i1, i2] }"
+      - filter: "{ S8[i0, i1, i2] }"
+      - filter: "{ S9[i0, i1, i2] }"
+      - filter: "{ S10[i0, i1, i2] }"
+      - filter: "{ S11[i0, i1, i2] }"
+      - filter: "{ S12[i0, i1, i2] }"
+      - filter: "{ S13[i0, i1, i2] }"
+      - filter: "{ S14[i0, i1, i2] }"
+      - filter: "{ S15[i0, i1, i2] }"
+      - filter: "{ S16[i0, i1, i2] }"
+      - filter: "{ S17[i0, i1, i2] }"
+      - filter: "{ S18[i0, i1, i2] }"
+      - filter: "{ S19[i0, i1, i2] }"
+      - filter: "{ S20[i0, i1, i2] }"
+      - filter: "{ S21[i0, i1, i2] }"
+      - filter: "{ S22[i0, i1, i2] }"
+      - filter: "{ S23[i0, i1, i2] }"
+      - filter: "{ S24[i0, i1, i2] }"
+      - filter: "{ S25[i0, i1, i2] }"
+      - filter: "{ S26[i0, i1, i2] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.c b/lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.c
new file mode 100644
index 0000000..0df7889
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.c
@@ -0,0 +1,24 @@
+{
+  S1();
+  S2();
+  for (int c0 = 0; c0 < N; c0 += 1)
+    for (int c1 = 0; c1 < N; c1 += 1) {
+      S4(c0, c1);
+      S5(c0, c1);
+    }
+  for (int c0 = 0; c0 < N; c0 += 1)
+    for (int c1 = 0; c1 < N; c1 += 1)
+      for (int c2 = 0; c2 <= (N - 1) / 32; c2 += 1) {
+        S7(c0, c1, c2, 32 * c2);
+        for (int c3 = 32 * c2 + 1; c3 <= min(N - 1, 32 * c2 + 31); c3 += 1) {
+          S6(c0, c1, c2, c3 - 1);
+          S7(c0, c1, c2, c3);
+        }
+        if (32 * c2 + 31 >= N) {
+          S6(c0, c1, c2, N - 1);
+        } else {
+          S6(c0, c1, c2, 32 * c2 + 31);
+        }
+      }
+  S8();
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.st b/lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.st
new file mode 100644
index 0000000..f0cd320
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/vasilache.st
@@ -0,0 +1,37 @@
+domain: "[M, N] -> { S5[i0, i1] : i0 >= 0 and i0 <= -1 + N and i1 >= 0 and i1 <= -1 + N; S8[]; S2[]; S7[i0, i1, i2, i3] : i0 >= 0 and i0 <= -1 + N and i1 >= 0 and i1 <= -1 + N and i3 >= 0 and i3 <= -1 + N and i3 >= 32i2 and i3 <= 31 + 32i2; S4[i0, i1] : i0 >= 0 and i0 <= -1 + N and i1 >= 0 and i1 <= -1 + N; S1[]; S3[] : M >= 79; S6[i0, i1, i2, i3] : i0 >= 0 and i0 <= -1 + N and i1 >= 0 and i1 <= -1 + N and i3 >= 0 and i3 <= -1 + N and i3 >= 32i2 and i3 <= 31 + 32i2 }"
+child:
+  context: "[M, N] -> { [] : M <= 3 and N >= 100 }"
+  child:
+    sequence:
+    - filter: "[M, N] -> { S1[] }"
+    - filter: "[M, N] -> { S2[] }"
+    - filter: "[M, N] -> { S3[] }"
+    - filter: "[M, N] -> { S5[i0, i1]; S4[i0, i1] }"
+      child:
+        schedule: "[M, N] -> [{ S5[i0, i1] -> [(i0)]; S4[i0, i1] -> [(i0)] }]"
+        options: "[M, N] -> { separate[i0] }"
+        child:
+          schedule: "[M, N] -> [{ S5[i0, i1] -> [(i1)]; S4[i0, i1] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+          child:
+            sequence:
+            - filter: "[M, N] -> { S4[i0, i1] }"
+            - filter: "[M, N] -> { S5[i0, i1] }"
+    - filter: "[M, N] -> { S7[i0, i1, i2, i3]; S6[i0, i1, i2, i3] }"
+      child:
+        schedule: "[M, N] -> [{ S7[i0, i1, i2, i3] -> [(i0)]; S6[i0, i1, i2, i3] -> [(i0)] }]"
+        options: "[M, N] -> { separate[i0] }"
+        child:
+          schedule: "[M, N] -> [{ S7[i0, i1, i2, i3] -> [(i1)]; S6[i0, i1, i2, i3] -> [(i1)] }]"
+          options: "[M, N] -> { separate[i0] }"
+          child:
+            schedule: "[M, N] -> [{ S7[i0, i1, i2, i3] -> [(i2)]; S6[i0, i1, i2, i3] -> [(i2)] }]"
+            options: "[M, N] -> { separate[i0] }"
+            child:
+              schedule: "[M, N] -> [{ S7[i0, i1, i2, i3] -> [(i3)]; S6[i0, i1, i2, i3] -> [(1 + i3)] }]"
+              options: "[M, N] -> { separate[i0] }"
+              child:
+                sequence:
+                - filter: "[M, N] -> { S6[i0, i1, i2, i3] }"
+                - filter: "[M, N] -> { S7[i0, i1, i2, i3] }"
+    - filter: "[M, N] -> { S8[] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/vivien.c b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien.c
new file mode 100644
index 0000000..3976bab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien.c
@@ -0,0 +1,88 @@
+{
+  for (int c0 = -27 * n + 2; c0 <= 1; c0 += 1)
+    S1(c0 - 1);
+  for (int c0 = 2; c0 <= min(2 * n, n + 29); c0 += 1) {
+    if (c0 >= 3) {
+      if (2 * n >= c0 + 1) {
+        S4(c0 - c0 / 2 - 1, c0 / 2 + 1);
+        if (c0 + 2 >= 2 * n) {
+          for (int c2 = 1; c2 < -n + c0; c2 += 1)
+            S5(-n + c0, n, c2);
+        } else if (c0 >= 5) {
+          S4(c0 - c0 / 2 - 2, c0 / 2 + 2);
+          for (int c2 = 1; c2 < c0 - c0 / 2 - 1; c2 += 1)
+            S5(c0 - c0 / 2 - 1, c0 / 2 + 1, c2);
+        }
+      }
+      for (int c1 = -c0 + c0 / 2 + 3; c1 <= min(-1, n - c0); c1 += 1) {
+        S6(-c1 + 2, c0 + c1 - 2);
+        S4(-c1, c0 + c1);
+        for (int c2 = 1; c2 <= -c1; c2 += 1)
+          S5(-c1 + 1, c0 + c1 - 1, c2);
+      }
+      if (2 * n >= c0 + 3 && c0 >= n + 2) {
+        S6(-n + c0 + 1, n - 1);
+        for (int c2 = 1; c2 < -n + c0; c2 += 1)
+          S5(-n + c0, n, c2);
+      }
+      if (n >= 3 && c0 == n + 2) {
+        S1(n + 1);
+        S6(2, n);
+      } else {
+        if (c0 >= n + 3 && 2 * n >= c0 + 1)
+          S6(-n + c0, n);
+        if (c0 >= n + 3) {
+          S1(c0 - 1);
+        } else {
+          if (n + 1 >= c0 && c0 <= 4) {
+            S1(c0 - 1);
+          } else if (c0 >= 5 && n + 1 >= c0) {
+            S1(c0 - 1);
+            S6(2, c0 - 2);
+          }
+          if (n + 1 >= c0)
+            S6(1, c0 - 1);
+        }
+      }
+      if (n == 2 && c0 == 4)
+        S1(3);
+    } else {
+      S1(1);
+    }
+    if (c0 % 2 == 0)
+      S3(c0 / 2);
+    for (int c1 = max(1, -n + c0); c1 < (c0 + 1) / 2; c1 += 1)
+      S2(c0 - c1, c1);
+  }
+  for (int c0 = max(2 * n + 1, -27 * n + 2); c0 <= n + 29; c0 += 1)
+    S1(c0 - 1);
+  for (int c0 = n + 30; c0 <= 2 * n; c0 += 1) {
+    if (2 * n >= c0 + 1) {
+      S4(c0 - c0 / 2 - 1, c0 / 2 + 1);
+      if (c0 + 2 >= 2 * n) {
+        for (int c2 = 1; c2 < -n + c0; c2 += 1)
+          S5(-n + c0, n, c2);
+      } else {
+        S4(c0 - c0 / 2 - 2, c0 / 2 + 2);
+        for (int c2 = 1; c2 < c0 - c0 / 2 - 1; c2 += 1)
+          S5(c0 - c0 / 2 - 1, c0 / 2 + 1, c2);
+      }
+      for (int c1 = -c0 + c0 / 2 + 3; c1 <= n - c0; c1 += 1) {
+        S6(-c1 + 2, c0 + c1 - 2);
+        S4(-c1, c0 + c1);
+        for (int c2 = 1; c2 <= -c1; c2 += 1)
+          S5(-c1 + 1, c0 + c1 - 1, c2);
+      }
+      if (2 * n >= c0 + 3) {
+        S6(-n + c0 + 1, n - 1);
+        for (int c2 = 1; c2 < -n + c0; c2 += 1)
+          S5(-n + c0, n, c2);
+      }
+      S6(-n + c0, n);
+    }
+    if (c0 % 2 == 0)
+      S3(c0 / 2);
+    for (int c1 = -n + c0; c1 < (c0 + 1) / 2; c1 += 1)
+      S2(c0 - c1, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/vivien.st b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien.st
new file mode 100644
index 0000000..681b170
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S2[i, j] : 29j >= 1 - i and i <= n and j >= 1 and j <= -1 + i; S1[i] : i >= 1 - 27n and i <= 28 + n; S4[i, j] : i >= 1 and i <= n and j >= 1 + i and j <= n; S5[i, j, k] : i >= 1 and i <= n and j >= 1 + i and j <= n and k >= 1 and k <= -1 + i; S6[i, j] : i >= 1 and i <= n and j >= 1 + i and j <= n; S3[i] : i >= 1 and i <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S1[i0] -> [(2 + 2i0)]; S4[i0, i1] -> [(2i0 + 2i1)]; S6[i0, i1] -> [(2i0 + 2i1)]; S3[i0] -> [(1 + 4i0)]; S5[i0, i1, i2] -> [(2i0 + 2i1)]; S2[i0, i1] -> [(1 + 2i0 + 2i1)] }, { S1[i0] -> [(0)]; S4[i0, i1] -> [(-i0)]; S6[i0, i1] -> [(2 - i0)]; S3[i0] -> [(0)]; S5[i0, i1, i2] -> [(1 - i0)]; S2[i0, i1] -> [(i1)] }, { S1[i0] -> [(0)]; S4[i0, i1] -> [(0)]; S6[i0, i1] -> [(0)]; S3[i0] -> [(0)]; S5[i0, i1, i2] -> [(i2)]; S2[i0, i1] -> [(0)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.c
new file mode 100644
index 0000000..f13c6d7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.c
@@ -0,0 +1,80 @@
+{
+  for (int c0 = -27 * n + 2; c0 <= 1; c0 += 1)
+    S1(c0 - 1);
+  for (int c0 = 2; c0 <= n + 29; c0 += 1) {
+    if (c0 >= 3) {
+      S4(c0 - c0 / 2 - 1, c0 / 2 + 1);
+      if (c0 >= 5 && 2 * n >= c0 + 3) {
+        S4(c0 - c0 / 2 - 2, c0 / 2 + 2);
+        for (int c2 = 1; c2 < c0 - c0 / 2 - 1; c2 += 1)
+          S5(c0 - c0 / 2 - 1, c0 / 2 + 1, c2);
+      }
+      for (int c1 = -c0 + c0 / 2 + 3; c1 <= min(-1, n - c0); c1 += 1) {
+        S6(-c1 + 2, c0 + c1 - 2);
+        S4(-c1, c0 + c1);
+        for (int c2 = 1; c2 <= -c1; c2 += 1)
+          S5(-c1 + 1, c0 + c1 - 1, c2);
+      }
+      if (2 * n >= c0 + 3 && c0 >= n + 2) {
+        S6(-n + c0 + 1, n - 1);
+        for (int c2 = 1; c2 < -n + c0; c2 += 1)
+          S5(-n + c0, n, c2);
+        if (c0 == n + 2) {
+          S1(n + 1);
+          S6(2, n);
+        }
+      } else if (c0 + 2 >= 2 * n) {
+        for (int c2 = 1; c2 < -n + c0; c2 += 1)
+          S5(-n + c0, n, c2);
+      }
+      if (c0 >= n + 3) {
+        S6(-n + c0, n);
+        S1(c0 - 1);
+      } else {
+        if (c0 >= 5 && n + 1 >= c0) {
+          S1(c0 - 1);
+          S6(2, c0 - 2);
+        } else if (c0 <= 4) {
+          S1(c0 - 1);
+        }
+        if (n + 1 >= c0)
+          S6(1, c0 - 1);
+      }
+    } else {
+      S1(1);
+    }
+    if (c0 % 2 == 0)
+      S3(c0 / 2);
+    for (int c1 = max(1, -n + c0); c1 < (c0 + 1) / 2; c1 += 1)
+      S2(c0 - c1, c1);
+  }
+  for (int c0 = n + 30; c0 <= 2 * n; c0 += 1) {
+    if (2 * n >= c0 + 1) {
+      S4(c0 - c0 / 2 - 1, c0 / 2 + 1);
+      if (c0 + 2 >= 2 * n) {
+        for (int c2 = 1; c2 < -n + c0; c2 += 1)
+          S5(-n + c0, n, c2);
+      } else {
+        S4(c0 - c0 / 2 - 2, c0 / 2 + 2);
+        for (int c2 = 1; c2 < c0 - c0 / 2 - 1; c2 += 1)
+          S5(c0 - c0 / 2 - 1, c0 / 2 + 1, c2);
+      }
+      for (int c1 = -c0 + c0 / 2 + 3; c1 <= n - c0; c1 += 1) {
+        S6(-c1 + 2, c0 + c1 - 2);
+        S4(-c1, c0 + c1);
+        for (int c2 = 1; c2 <= -c1; c2 += 1)
+          S5(-c1 + 1, c0 + c1 - 1, c2);
+      }
+      if (2 * n >= c0 + 3) {
+        S6(-n + c0 + 1, n - 1);
+        for (int c2 = 1; c2 < -n + c0; c2 += 1)
+          S5(-n + c0, n, c2);
+      }
+      S6(-n + c0, n);
+    }
+    if (c0 % 2 == 0)
+      S3(c0 / 2);
+    for (int c1 = -n + c0; c1 < (c0 + 1) / 2; c1 += 1)
+      S2(c0 - c1, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.st
new file mode 100644
index 0000000..932fbc2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/vivien2.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S2[i, j] : 29j >= 1 - i and i <= n and j >= 1 and j <= -1 + i; S1[i] : i >= 1 - 27n and i <= 28 + n; S4[i, j] : i >= 1 and i <= n and j >= 1 + i and j <= n; S5[i, j, k] : i >= 1 and i <= n and j >= 1 + i and j <= n and k >= 1 and k <= -1 + i; S6[i, j] : i >= 1 and i <= n and j >= 1 + i and j <= n; S3[i] : i >= 1 and i <= n }"
+child:
+  context: "[n] -> { [] : n >= 30 }"
+  child:
+    schedule: "[n] -> [{ S1[i0] -> [(2 + 2i0)]; S4[i0, i1] -> [(2i0 + 2i1)]; S6[i0, i1] -> [(2i0 + 2i1)]; S3[i0] -> [(1 + 4i0)]; S5[i0, i1, i2] -> [(2i0 + 2i1)]; S2[i0, i1] -> [(1 + 2i0 + 2i1)] }, { S1[i0] -> [(0)]; S4[i0, i1] -> [(-i0)]; S6[i0, i1] -> [(2 - i0)]; S3[i0] -> [(0)]; S5[i0, i1, i2] -> [(1 - i0)]; S2[i0, i1] -> [(i1)] }, { S1[i0] -> [(0)]; S4[i0, i1] -> [(0)]; S6[i0, i1] -> [(0)]; S3[i0] -> [(0)]; S5[i0, i1, i2] -> [(i2)]; S2[i0, i1] -> [(0)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/walters.c b/lib/Analysis/isl/test_inputs/codegen/cloog/walters.c
new file mode 100644
index 0000000..3854892
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/walters.c
@@ -0,0 +1,16 @@
+{
+  S2(1, 0, 1, 0);
+  S4(1, 0, 1, 0);
+  S3(2, 0, 1, 1);
+  S4(2, 0, 1, 1);
+  for (int c0 = 3; c0 <= 10; c0 += 1) {
+    if ((c0 + 1) % 3 == 0) {
+      S3(c0, (c0 - 2) / 3, (c0 + 1) / 3, (c0 + 1) / 3);
+    } else if (c0 % 3 == 0) {
+      S1(c0, c0 / 3, c0 / 3, c0 / 3);
+    } else {
+      S2(c0, (c0 - 1) / 3, (c0 + 2) / 3, (c0 - 1) / 3);
+    }
+    S4(c0, c0 / 3, (c0 - 1) / 3 + 1, c0 - (c0 - 1) / 3 - c0 / 3 - 1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/walters.st b/lib/Analysis/isl/test_inputs/codegen/cloog/walters.st
new file mode 100644
index 0000000..f168c99
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/walters.st
@@ -0,0 +1,12 @@
+domain: "{ S2[i, div36, div37, div38] : 3div37 = 2 + i and i >= 1 and i <= 10 and 3div36 >= -2 + i and 3div38 <= 1 + i and 3div38 >= -1 + i and 3div36 <= i; S4[i, div36, div37, div38] : i >= 1 and i <= 10 and 3div36 <= i and 3div36 >= -2 + i and 3div37 <= 2 + i and 3div37 >= i and 3div38 <= 1 + i and 3div38 >= -1 + i; S1[i, div36, div37, div38] : 3div36 = i and i >= 3 and i <= 10 and 3div37 >= i and 3div38 <= 1 + i and 3div37 <= 2 + i and 3div38 >= -1 + i; S3[i, div36, div37, div38] : 3div38 = 1 + i and i <= 10 and i >= 2 and 3div36 >= -2 + i and 3div37 <= 2 + i and 3div36 <= i and 3div37 >= i }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[i, div36, div37, div38] -> [(i)]; S4[i, div36, div37, div38] -> [(i)]; S3[i, div36, div37, div38] -> [(i)]; S2[i, div36, div37, div38] -> [(i)] }, { S1[i, div36, div37, div38] -> [(div36)]; S4[i, div36, div37, div38] -> [(div36)]; S3[i, div36, div37, div38] -> [(div36)]; S2[i, div36, div37, div38] -> [(div36)] }, { S1[i, div36, div37, div38] -> [(div37)]; S4[i, div36, div37, div38] -> [(div37)]; S3[i, div36, div37, div38] -> [(div37)]; S2[i, div36, div37, div38] -> [(div37)] }, { S1[i, div36, div37, div38] -> [(div38)]; S4[i, div36, div37, div38] -> [(div38)]; S3[i, div36, div37, div38] -> [(div38)]; S2[i, div36, div37, div38] -> [(div38)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i, div36, div37, div38] }"
+      - filter: "{ S2[i, div36, div37, div38] }"
+      - filter: "{ S3[i, div36, div37, div38] }"
+      - filter: "{ S4[i, div36, div37, div38] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/walters2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/walters2.c
new file mode 100644
index 0000000..27565fb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/walters2.c
@@ -0,0 +1,12 @@
+{
+  for (int c1 = 0; c1 <= 51; c1 += 1)
+    S2(0, c1);
+  for (int c0 = 1; c0 <= 24; c0 += 1) {
+    S2(c0, 0);
+    for (int c1 = 1; c1 <= 50; c1 += 1)
+      S1(c0, c1);
+    S2(c0, 51);
+  }
+  for (int c1 = 0; c1 <= 51; c1 += 1)
+    S2(25, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/walters2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/walters2.st
new file mode 100644
index 0000000..5caba80
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/walters2.st
@@ -0,0 +1,10 @@
+domain: "{ S2[j, 51] : j <= 24 and j >= 1; S2[25, i] : i <= 51 and i >= 1; S2[j, 0] : j <= 25 and j >= 1; S2[0, i] : i <= 51 and i >= 0; S1[j, i] : j >= 1 and j <= 24 and i >= 1 and i <= 50 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[j, i] -> [(j)]; S2[j, i] -> [(j)] }, { S1[j, i] -> [(i)]; S2[j, i] -> [(i)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[j, i] }"
+      - filter: "{ S2[j, i] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/walters3.c b/lib/Analysis/isl/test_inputs/codegen/cloog/walters3.c
new file mode 100644
index 0000000..bafb9ac
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/walters3.c
@@ -0,0 +1,7 @@
+{
+  for (int c0 = 2; c0 <= 8; c0 += 2) {
+    S1(c0, c0 / 2, c0 / 2);
+    S2(c0, c0 / 2, c0 / 2);
+  }
+  S2(10, 5, 5);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/walters3.st b/lib/Analysis/isl/test_inputs/codegen/cloog/walters3.st
new file mode 100644
index 0000000..1a14273
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/walters3.st
@@ -0,0 +1,10 @@
+domain: "{ S2[j, a, b] : 2a = j and j >= 1 and j <= 10 and 2b <= j and 2b >= -1 + j; S1[j, a, b] : 2a = j and 2b = j and j <= 8 and j >= 2 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S1[j, a, b] -> [(j)]; S2[j, a, b] -> [(j)] }, { S1[j, a, b] -> [(a)]; S2[j, a, b] -> [(a)] }, { S1[j, a, b] -> [(b)]; S2[j, a, b] -> [(b)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[j, a, b] }"
+      - filter: "{ S2[j, a, b] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.c b/lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.c
new file mode 100644
index 0000000..7db0788
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.c
@@ -0,0 +1,3 @@
+for (int c0 = 2; c0 <= n + m; c0 += 1)
+  for (int c1 = max(1, -m + c0); c1 <= min(n, c0 - 1); c1 += 1)
+    S1(c1, c0 - c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.st b/lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.st
new file mode 100644
index 0000000..b31e0de
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/wavefront.st
@@ -0,0 +1,6 @@
+domain: "[n, m] -> { S1[i0, i1] : i0 >= 1 and i0 <= n and i1 >= 1 and i1 <= m }"
+child:
+  context: "[n, m] -> { [] }"
+  child:
+    schedule: "[n, m] -> [{ S1[i0, i1] -> [(i0 + i1)] }, { S1[i0, i1] -> [(i0)] }]"
+    options: "[n, m] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/yosr.c b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr.c
new file mode 100644
index 0000000..1c20057
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr.c
@@ -0,0 +1,12 @@
+{
+  for (int c0 = 1; c0 < n; c0 += 1) {
+    for (int c2 = c0 + 1; c2 <= n; c2 += 1)
+      S1(c0, c2);
+    for (int c1 = 1; c1 < c0; c1 += 1)
+      for (int c2 = c1 + 1; c2 <= n; c2 += 1)
+        S2(c1, c2, c0);
+  }
+  for (int c1 = 1; c1 < n; c1 += 1)
+    for (int c2 = c1 + 1; c2 <= n; c2 += 1)
+      S2(c1, c2, n);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/yosr.st b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr.st
new file mode 100644
index 0000000..3ad4297
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr.st
@@ -0,0 +1,6 @@
+domain: "[n] -> { S1[i0, i1] : i0 >= 1 and i0 <= -1 + n and i1 >= 1 + i0 and i1 <= n; S2[i0, i1, i2] : i0 >= 1 and i0 <= -1 + n and i1 >= 1 + i0 and i1 <= n and i2 >= 1 + i0 and i2 <= n }"
+child:
+  context: "[n] -> { [] }"
+  child:
+    schedule: "[n] -> [{ S2[i0, i1, i2] -> [(i2)]; S1[i0, i1] -> [(i0)] }]"
+    options: "[n] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.c b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.c
new file mode 100644
index 0000000..1a3e992
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.c
@@ -0,0 +1,13 @@
+{
+  for (int c1 = 1; c1 <= M; c1 += 1)
+    S2(c1);
+  for (int c0 = 2; c0 <= M; c0 += 1) {
+    for (int c2 = 1; c2 < c0; c2 += 1)
+      S1(c0, c2);
+    for (int c1 = 1; c1 < c0; c1 += 1)
+      S4(c1, c0);
+    for (int c2 = c0 + 1; c2 <= M; c2 += 1)
+      for (int c3 = 1; c3 < c0; c3 += 1)
+        S3(c0, c2, c3);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.st b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.st
new file mode 100644
index 0000000..eb1ab41
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/yosr2.st
@@ -0,0 +1,6 @@
+domain: "[M] -> { S4[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 + i0 and i1 <= M; S3[i0, i1, i2] : i0 >= 1 and i0 <= M and i1 >= 1 + i0 and i1 <= M and i2 >= 1 and i2 <= -1 + i0; S1[i0, i1] : i0 >= 1 and i0 <= M and i1 >= 1 and i1 <= -1 + i0; S2[i0] : i0 >= 1 and i0 <= M }"
+child:
+  context: "[M] -> { [] : M >= 2 }"
+  child:
+    schedule: "[M] -> [{ S2[i0] -> [(0)]; S1[i0, i1] -> [(i0)]; S4[i0, i1] -> [(i1)]; S3[i0, i1, i2] -> [(i0)] }]"
+    options: "[M] -> { separate[i0] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/youcef.c b/lib/Analysis/isl/test_inputs/codegen/cloog/youcef.c
new file mode 100644
index 0000000..1bc7ffd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/youcef.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 <= 5; c0 += 1) {
+  S1(c0, c0);
+  for (int c1 = c0; c1 <= 5; c1 += 1)
+    S2(c0, c1);
+  S3(c0, 5);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/youcef.st b/lib/Analysis/isl/test_inputs/codegen/cloog/youcef.st
new file mode 100644
index 0000000..fa7cbda
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/youcef.st
@@ -0,0 +1,11 @@
+domain: "{ S2[i0, i1] : i0 >= 0 and i0 <= 5 and i1 >= i0 and i1 <= 5; S1[i0, i0] : i0 >= 0 and i0 <= 5; S3[i0, 5] : i0 >= 0 and i0 <= 5 }"
+child:
+  context: "{ [] }"
+  child:
+    schedule: "[{ S3[i0, i1] -> [(i0)]; S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)] }, { S3[i0, i1] -> [(i1)]; S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)] }]"
+    options: "{ separate[i0] }"
+    child:
+      sequence:
+      - filter: "{ S1[i0, i1] }"
+      - filter: "{ S2[i0, i1] }"
+      - filter: "{ S3[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.c b/lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.c
new file mode 100644
index 0000000..1107790
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.c
@@ -0,0 +1,10 @@
+{
+  for (int c0 = 1; c0 <= n; c0 += 1) {
+    S1(c0, c0);
+    for (int c1 = c0; c1 <= n; c1 += 1)
+      S2(c0, c1);
+    S3(c0, n);
+  }
+  for (int c0 = n + 1; c0 <= m; c0 += 1)
+    S3(c0, n);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.st b/lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.st
new file mode 100644
index 0000000..9405c65
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/cloog/youcefn.st
@@ -0,0 +1,11 @@
+domain: "[n, m] -> { S1[i0, i0] : i0 >= 1 and i0 <= n; S3[i0, n] : i0 >= 1 and i0 <= m; S2[i0, i1] : i0 >= 1 and i0 <= n and i1 >= i0 and i1 <= n }"
+child:
+  context: "[n, m] -> { [] : n >= 2 and m >= n }"
+  child:
+    schedule: "[n, m] -> [{ S1[i0, i1] -> [(i0)]; S2[i0, i1] -> [(i0)]; S3[i0, i1] -> [(i0)] }, { S1[i0, i1] -> [(i1)]; S2[i0, i1] -> [(i1)]; S3[i0, i1] -> [(i1)] }]"
+    options: "[n, m] -> { separate[i0] }"
+    child:
+      sequence:
+      - filter: "[n, m] -> { S1[i0, i1] }"
+      - filter: "[n, m] -> { S2[i0, i1] }"
+      - filter: "[n, m] -> { S3[i0, i1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/component0.c b/lib/Analysis/isl/test_inputs/codegen/component0.c
new file mode 100644
index 0000000..9b1c685
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component0.c
@@ -0,0 +1,5 @@
+{
+  A();
+  for (int c0 = 0; c0 <= 9; c0 += 1)
+    B(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/component0.st b/lib/Analysis/isl/test_inputs/codegen/component0.st
new file mode 100644
index 0000000..3483af0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component0.st
@@ -0,0 +1,3 @@
+domain: "{ A[]; B[i] : 0 <= i < 10 }"
+child:
+  schedule: "[{ A[] -> [0]; B[i] -> [i] }]"
diff --git a/lib/Analysis/isl/test_inputs/codegen/component1.c b/lib/Analysis/isl/test_inputs/codegen/component1.c
new file mode 100644
index 0000000..9b1c685
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component1.c
@@ -0,0 +1,5 @@
+{
+  A();
+  for (int c0 = 0; c0 <= 9; c0 += 1)
+    B(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/component1.st b/lib/Analysis/isl/test_inputs/codegen/component1.st
new file mode 100644
index 0000000..87c5eeb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component1.st
@@ -0,0 +1,7 @@
+domain: "{ A[]; B[i] : 0 <= i < 10 }"
+child:
+  schedule: "[{ A[] -> [0]; B[i] -> [i] }]"
+  child:
+    sequence:
+    - filter: "{ A[] }"
+    - filter: "{ B[i] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/component2.c b/lib/Analysis/isl/test_inputs/codegen/component2.c
new file mode 100644
index 0000000..c963c7a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component2.c
@@ -0,0 +1,5 @@
+for (int c0 = 0; c0 <= 9; c0 += 1) {
+  B(c0);
+  if (c0 == 0)
+    A();
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/component2.st b/lib/Analysis/isl/test_inputs/codegen/component2.st
new file mode 100644
index 0000000..70acba4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component2.st
@@ -0,0 +1,7 @@
+domain: "{ A[]; B[i] : 0 <= i < 10 }"
+child:
+  schedule: "[{ A[] -> [0]; B[i] -> [i] }]"
+  child:
+    sequence:
+    - filter: "{ B[i] }"
+    - filter: "{ A[] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/component3.c b/lib/Analysis/isl/test_inputs/codegen/component3.c
new file mode 100644
index 0000000..9b1c685
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component3.c
@@ -0,0 +1,5 @@
+{
+  A();
+  for (int c0 = 0; c0 <= 9; c0 += 1)
+    B(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/component3.st b/lib/Analysis/isl/test_inputs/codegen/component3.st
new file mode 100644
index 0000000..c0bb65b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component3.st
@@ -0,0 +1,7 @@
+domain: "{ A[]; B[i] : 0 <= i < 10 }"
+child:
+  schedule: "[{ A[] -> [0]; B[i] -> [i] }]"
+  child:
+    set:
+    - filter: "{ B[i] }"
+    - filter: "{ A[] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/component4.c b/lib/Analysis/isl/test_inputs/codegen/component4.c
new file mode 100644
index 0000000..1f188dd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component4.c
@@ -0,0 +1,7 @@
+{
+  for (int c1 = 0; c1 <= 9; c1 += 1)
+    A(c1);
+  for (int c0 = 0; c0 <= 9; c0 += 1)
+    for (int c2 = 0; c2 <= 9; c2 += 1)
+      B(c0, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/component4.st b/lib/Analysis/isl/test_inputs/codegen/component4.st
new file mode 100644
index 0000000..c9e400b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component4.st
@@ -0,0 +1,7 @@
+domain: "{ A[i] : 0 <= i < 10; B[i,j] : 0 <= i,j < 10 }"
+child:
+  schedule: "[{ A[i] -> [0]; B[i,j] -> [i] }]"
+  child:
+    sequence:
+    - filter: "{ A[i] }"
+    - filter: "{ B[i,j] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/component5.c b/lib/Analysis/isl/test_inputs/codegen/component5.c
new file mode 100644
index 0000000..072f2ea
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component5.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 <= 9; c0 += 1)
+  for (int c1 = 0; c1 <= 9; c1 += 1) {
+    if (c0 == 0)
+      A(c1);
+    B(c0, c1);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/component5.st b/lib/Analysis/isl/test_inputs/codegen/component5.st
new file mode 100644
index 0000000..1d22898
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component5.st
@@ -0,0 +1,9 @@
+domain: "{ A[i] : 0 <= i < 10; B[i,j] : 0 <= i,j < 10 }"
+child:
+  schedule: "[{ A[i] -> [0]; B[i,j] -> [i] }]"
+  child:
+    schedule: "[{ A[i] -> [i]; B[i,j] -> [j] }]"
+    child:
+      sequence:
+      - filter: "{ A[i] }"
+      - filter: "{ B[i,j] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/component6.c b/lib/Analysis/isl/test_inputs/codegen/component6.c
new file mode 100644
index 0000000..9b1c685
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component6.c
@@ -0,0 +1,5 @@
+{
+  A();
+  for (int c0 = 0; c0 <= 9; c0 += 1)
+    B(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/component6.st b/lib/Analysis/isl/test_inputs/codegen/component6.st
new file mode 100644
index 0000000..d13e8bf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/component6.st
@@ -0,0 +1,10 @@
+# Check that components are still detected in presence of nested context node
+domain: "{ A[]; B[i] : 0 <= i < 10 }"
+child:
+  schedule: "[{ A[] -> [0]; B[i] -> [i] }]"
+  child:
+    context: "[n] -> { [i] : 0 <= n <= i }"
+    child:
+      sequence:
+      - filter: "{ A[] }"
+      - filter: "{ B[i] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/correlation.c b/lib/Analysis/isl/test_inputs/codegen/correlation.c
new file mode 100644
index 0000000..e771b43
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/correlation.c
@@ -0,0 +1,45 @@
+for (int c0 = 0; c0 < m; c0 += 32)
+  for (int c1 = (n >= 32 && m >= c0 + 2) || (m == 1 && c0 == 0) ? 0 : 32 * n - 32 * floord(31 * n + 31, 32); c1 <= ((n <= -1 && c0 == 0) || (m == 1 && n >= 0 && c0 == 0) ? max(0, n - 1) : n); c1 += 32)
+    for (int c2 = c0; c2 <= (m >= 2 && c0 + 31 >= m && n >= c1 && c1 + 31 >= n ? 2 * m - 3 : (m >= 2 * c0 + 63 && c1 <= -32 && n >= c1 && c1 + 31 >= n) || (m >= c0 + 32 && 2 * c0 + 62 >= m && n >= c1 && c1 + 31 >= n) || (n >= 0 && c0 >= 32 && m >= 2 * c0 + 63 && c1 == n) || (m >= 63 && n >= 32 && c0 == 0 && c1 == n) ? 2 * c0 + 61 : m - 1); c2 += 32) {
+      if (n >= c1 + 32 && c1 >= 0 && 2 * c0 >= c2 + 32) {
+        for (int c4 = 0; c4 <= 31; c4 += 1)
+          for (int c5 = max(0, c0 - c2 + 1); c5 <= min(31, m - c2 - 1); c5 += 1)
+            S_27(c0, c2 + c5, c1 + c4);
+      } else if (c0 >= 32 && c1 >= 0 && c2 >= 2 * c0) {
+        for (int c4 = 0; c4 <= min(31, n - c1 - 1); c4 += 1)
+          for (int c5 = 0; c5 <= min(31, m - c2 - 1); c5 += 1)
+            S_27(c0, c2 + c5, c1 + c4);
+      } else if (c0 == 0 && c1 >= 0) {
+        for (int c4 = 0; c4 <= min(31, n - c1 - 1); c4 += 1)
+          for (int c5 = 0; c5 <= min(31, m - c2 - 1); c5 += 1) {
+            if (c1 == 0 && c4 == 0)
+              S_14(c2 + c5);
+            S_19(c1 + c4, c2 + c5);
+            if (c2 + c5 >= 1)
+              S_27(0, c2 + c5, c1 + c4);
+          }
+      }
+      if (c1 >= 0) {
+        for (int c3 = 1; c3 <= min(31, (c2 / 2) - c0); c3 += 1)
+          for (int c4 = 0; c4 <= min(31, n - c1 - 1); c4 += 1)
+            for (int c5 = 0; c5 <= min(31, m - c2 - 1); c5 += 1)
+              S_27(c0 + c3, c2 + c5, c1 + c4);
+        if (n >= c1 + 32) {
+          for (int c3 = max(1, (c2 / 2) - c0 + 1); c3 <= min(min(31, m - c0 - 2), -c0 + c2 + 30); c3 += 1)
+            for (int c4 = 0; c4 <= 31; c4 += 1)
+              for (int c5 = max(0, c0 - c2 + c3 + 1); c5 <= min(31, m - c2 - 1); c5 += 1)
+                S_27(c0 + c3, c2 + c5, c1 + c4);
+        } else if (n <= 0 && c0 == 0 && c1 == 0) {
+          for (int c5 = 0; c5 <= min(31, m - c2 - 1); c5 += 1)
+            S_14(c2 + c5);
+        }
+      }
+      if (n >= c1 && c1 + 31 >= n)
+        for (int c3 = max(0, (c2 / 2) - c0 + 1); c3 <= min(31, m - c0 - 1); c3 += 1) {
+          for (int c4 = max(0, -c1); c4 < n - c1; c4 += 1)
+            for (int c5 = max(0, c0 - c2 + c3 + 1); c5 <= min(31, m - c2 - 1); c5 += 1)
+              S_27(c0 + c3, c2 + c5, c1 + c4);
+          for (int c5 = max(0, c0 - c2 + c3); c5 <= min(31, 2 * c0 - c2 + 2 * c3 - 1); c5 += 1)
+            S_29(-c0 + c2 - c3 + c5, c0 + c3);
+        }
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/correlation.st b/lib/Analysis/isl/test_inputs/codegen/correlation.st
new file mode 100644
index 0000000..bba5a09
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/correlation.st
@@ -0,0 +1,18 @@
+domain: "[m, n] -> { S_14[j] : 0 <= j < m; S_19[i, j] : 0 <= i < n and 0 <= j < m; S_27[i, j, k] : i >= 0 and i < j < m and 0 <= k < n; S_29[i, j] : i >= 0 and i < j < m }"
+child:
+  context: "[m, n] -> { [] : 0 < m <= 2147483647 and -2147483648 <= n <= 2147483647 }"
+  child:
+            schedule: "[m, n] -> [{ S_19[i, j] -> [(0)]; S_29[i, j] -> [(32*floor((j)/32))]; S_27[i, j, k] -> [(32*floor((i)/32))]; S_14[j] -> [(0)] }, { S_19[i, j] -> [(32*floor((i)/32))]; S_29[i, j] -> [(32*floor((n)/32))]; S_27[i, j, k] -> [(32*floor((k)/32))]; S_14[j] -> [(0)] }, { S_19[i, j] -> [(32*floor((j)/32))]; S_29[i, j] -> [(32*floor((i + j)/32))]; S_27[i, j, k] -> [(32*floor((j)/32))]; S_14[j] -> [(32*floor((j)/32))] }]"
+            permutable: 1
+            coincident: [ 1, 1, 1 ]
+            options: "{ atomic[i0] : 0 <= i0 <= 2 }"
+            child:
+              schedule: "[m, n] -> [{ S_19[i, j] -> [(0)]; S_29[i, j] -> [(j - 32*floor((j)/32))]; S_27[i, j, k] -> [(i - 32*floor((i)/32))]; S_14[j] -> [(0)] }, { S_19[i, j] -> [(i - 32*floor((i)/32))]; S_29[i, j] -> [(n - 32*floor((n)/32))]; S_27[i, j, k] -> [(k - 32*floor((k)/32))]; S_14[j] -> [(0)] }, { S_19[i, j] -> [(j - 32*floor((j)/32))]; S_29[i, j] -> [(i + j - 32*floor((i + j)/32))]; S_27[i, j, k] -> [(j - 32*floor((j)/32))]; S_14[j] -> [(j - 32*floor((j)/32))] }]"
+              permutable: 1
+              coincident: [ 1, 1, 1 ]
+              child:
+                sequence:
+                - filter: "[m, n] -> { S_29[i, j] }"
+                - filter: "[m, n] -> { S_14[j] }"
+                - filter: "[m, n] -> { S_19[i, j] }"
+                - filter: "[m, n] -> { S_27[i, j, k] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/disjuncts.c b/lib/Analysis/isl/test_inputs/codegen/disjuncts.c
new file mode 100644
index 0000000..207e337
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/disjuncts.c
@@ -0,0 +1,10 @@
+for (int c0 = 0; c0 <= n; c0 += 1)
+  for (int c1 = 0; c1 <= n; c1 += 1)
+    if (c1 == n || c0 == n || c1 == 0 || c0 == 0) {
+      for (int c3 = 0; c3 <= n; c3 += 1)
+        for (int c4 = 0; c4 <= n; c4 += 1)
+          a(c0, c1, c3, c4);
+      for (int c3 = 0; c3 <= n; c3 += 1)
+        for (int c4 = 0; c4 <= n; c4 += 1)
+          b(c0, c1, c3, c4);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/disjuncts.in b/lib/Analysis/isl/test_inputs/codegen/disjuncts.in
new file mode 100644
index 0000000..0138670
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/disjuncts.in
@@ -0,0 +1,7 @@
+# Check that conditions are hoisted up from the innermost loop
+[n] -> { a[i,j,k,l] -> [i,j,0,k,l] :
+	    0 <= i,j,k,l <= n and (i = 0 or j = 0 or i = n or j = n);
+	 b[i,j,k,l] -> [i,j,1,k,l] :
+	    0 <= i,j,k,l <= n and (i = 0 or j = 0 or i = n or j = n) }
+{ : }
+{ [i,j,t,k,l] -> atomic[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/disjuncts2.c b/lib/Analysis/isl/test_inputs/codegen/disjuncts2.c
new file mode 100644
index 0000000..6011a3b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/disjuncts2.c
@@ -0,0 +1,3 @@
+if (P >= Q + 1 || Q >= P + 1)
+  for (int c0 = 0; c0 < N; c0 += 1)
+    S(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/disjuncts2.st b/lib/Analysis/isl/test_inputs/codegen/disjuncts2.st
new file mode 100644
index 0000000..d0170a6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/disjuncts2.st
@@ -0,0 +1,4 @@
+# Check that the loop is generated only once with an outer disjunctive condition
+domain: "[N, Q, P] -> { S[i0] : 0 <= i0 < N and (P > Q or P < Q) }"
+child:
+  schedule: "[N, Q, P] -> [{ S[i0] -> [(i0)] }]"
diff --git a/lib/Analysis/isl/test_inputs/codegen/dwt.c b/lib/Analysis/isl/test_inputs/codegen/dwt.c
new file mode 100644
index 0000000..a4de671
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/dwt.c
@@ -0,0 +1,9 @@
+for (int c0 = 0; c0 < Ncl; c0 += 1) {
+  if (Ncl >= c0 + 2 && c0 >= 1) {
+    S(c0, 28);
+  } else if (c0 == 0) {
+    S(0, 26);
+  } else {
+    S(Ncl - 1, 27);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/dwt.in b/lib/Analysis/isl/test_inputs/codegen/dwt.in
new file mode 100644
index 0000000..424b0f3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/dwt.in
@@ -0,0 +1,3 @@
+[Ncl] -> { S[j, 28] -> [j] : j <= -2 + Ncl and Ncl <= 256 and Ncl >= 40 and j >= 1; S[0, 26] -> [0] : Ncl <= 256 and Ncl >= 40; S[-1 + Ncl, 27] -> [-1 + Ncl] : Ncl <= 256 and Ncl >= 40 }
+[Ncl] -> {  :  Ncl >= 40 and Ncl <= 256 }
+{  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/empty.c b/lib/Analysis/isl/test_inputs/codegen/empty.c
new file mode 100644
index 0000000..0205735
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/empty.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 <= 10; c0 += 1) {
+  S0(c0);
+  S1(c0);
+  if (c0 == 5)
+    S2();
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/empty.in b/lib/Analysis/isl/test_inputs/codegen/empty.in
new file mode 100644
index 0000000..17febea
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/empty.in
@@ -0,0 +1,5 @@
+# Earlier versions of isl would end up with an empty partial
+# executed relation and fail to detect this emptiness.
+[M] -> { S0[i] -> [i, -M] : 0 <= i <= 10; S1[i] -> [i, 0] : 0 <= i <= 10; S2[] -> [5, 0] }
+[M] -> {  : M >= 1 }
+{ }
diff --git a/lib/Analysis/isl/test_inputs/codegen/filter.c b/lib/Analysis/isl/test_inputs/codegen/filter.c
new file mode 100644
index 0000000..c326fa8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/filter.c
@@ -0,0 +1,9 @@
+if (n >= m + 1) {
+  for (int c0 = 0; c0 < n; c0 += 1)
+    for (int c2 = 0; c2 < n; c2 += 1)
+      A(c0, c2);
+} else {
+  for (int c0 = 0; c0 < n; c0 += 1)
+    for (int c2 = 0; c2 < n; c2 += 1)
+      A(c0, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/filter.st b/lib/Analysis/isl/test_inputs/codegen/filter.st
new file mode 100644
index 0000000..719fb7e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/filter.st
@@ -0,0 +1,18 @@
+# Check proper handling of filters that turn out to be empty on their paths
+domain: "[n,m] -> { A[i,j] : 0 <= i,j < n }"
+child:
+  set:
+  - filter: "[n,m] -> { A[i,j] : m < n }"
+    child:
+      schedule: "[{ A[i,j] -> [i] }]"
+      child:
+        set:
+        - filter: "[n,m] -> { A[i,j] : m < n }"
+        - filter: "[n,m] -> { A[i,j] : m >= n }"
+  - filter: "[n,m] -> { A[i,j] : m >= n }"
+    child:
+      schedule: "[{ A[i,j] -> [i] }]"
+      child:
+        set:
+        - filter: "[n,m] -> { A[i,j] : m < n }"
+        - filter: "[n,m] -> { A[i,j] : m >= n }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/gemm.c b/lib/Analysis/isl/test_inputs/codegen/gemm.c
new file mode 100644
index 0000000..d309b23
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/gemm.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 < ni; c0 += 1)
+  for (int c1 = 0; c1 < nj; c1 += 1) {
+    S_2(c0, c1);
+    for (int c2 = 0; c2 < nk; c2 += 1)
+      S_4(c0, c1, c2);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/gemm.st b/lib/Analysis/isl/test_inputs/codegen/gemm.st
new file mode 100644
index 0000000..31df19d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/gemm.st
@@ -0,0 +1,12 @@
+domain: "[ni, nj, nk] -> { S_4[i, j, k] : k <= -1 + nk and k >= 0 and j <= -1 + nj and j >= 0 and i <= -1 + ni and i >= 0; S_2[i, j] : j <= -1 + nj and j >= 0 and i <= -1 + ni and i >= 0 }"
+child:
+  set:
+  - filter: "[ni, nj, nk] -> { S_4[i, j, k]; S_2[i, j] }"
+    child:
+      schedule: "[ni, nj, nk] -> [{ S_4[i, j, k] -> [(i)]; S_2[i, j] -> [(i)] }, { S_4[i, j, k] -> [(j)]; S_2[i, j] -> [(j)] }, { S_4[i, j, k] -> [(k)]; S_2[i, j] -> [(0)] }]"
+      permutable: 1
+      coincident: [ 1, 1, 0 ]
+      child:
+        sequence:
+        - filter: "[ni, nj, nk] -> { S_2[i, j] }"
+        - filter: "[ni, nj, nk] -> { S_4[i, j, k] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/hoist.c b/lib/Analysis/isl/test_inputs/codegen/hoist.c
new file mode 100644
index 0000000..7ba854f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/hoist.c
@@ -0,0 +1,45 @@
+if (ni >= t0 + 1 && nj >= t1 + 1)
+  for (int c2 = 0; c2 <= min(15, nk - 1); c2 += 1) {
+    S_1(t0, t1, c2);
+    if (nj >= t1 + 17) {
+      S_1(t0, t1 + 16, c2);
+      if (nj >= t1 + 33) {
+        S_1(t0, t1 + 32, c2);
+        if (nj >= t1 + 49)
+          S_1(t0, t1 + 48, c2);
+      }
+    }
+    if (ni >= t0 + 17) {
+      S_1(t0 + 16, t1, c2);
+      if (nj >= t1 + 17) {
+        S_1(t0 + 16, t1 + 16, c2);
+        if (nj >= t1 + 33) {
+          S_1(t0 + 16, t1 + 32, c2);
+          if (nj >= t1 + 49)
+            S_1(t0 + 16, t1 + 48, c2);
+        }
+      }
+      if (ni >= t0 + 33) {
+        S_1(t0 + 32, t1, c2);
+        if (nj >= t1 + 17) {
+          S_1(t0 + 32, t1 + 16, c2);
+          if (nj >= t1 + 33) {
+            S_1(t0 + 32, t1 + 32, c2);
+            if (nj >= t1 + 49)
+              S_1(t0 + 32, t1 + 48, c2);
+          }
+        }
+        if (ni >= t0 + 49) {
+          S_1(t0 + 48, t1, c2);
+          if (nj >= t1 + 17) {
+            S_1(t0 + 48, t1 + 16, c2);
+            if (nj >= t1 + 33) {
+              S_1(t0 + 48, t1 + 32, c2);
+              if (nj >= t1 + 49)
+                S_1(t0 + 48, t1 + 48, c2);
+            }
+          }
+        }
+      }
+    }
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/hoist.in b/lib/Analysis/isl/test_inputs/codegen/hoist.in
new file mode 100644
index 0000000..80a9052
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/hoist.in
@@ -0,0 +1,10 @@
+# check that the shared conditions ni >= t0 + 1 and nj >= t1 + 1
+# are hoisted out of the loop
+[ni, nj, nk, t0, t1] -> { S_1[i, j, k] -> [t0, t1, k, i, j] :
+	exists (e0 = [(-t0 + i)/16], e1 = [(-t1 + j)/16]:
+	16e0 = -t0 + i and 16e1 = -t1 + j and k >= 0 and j >= 0 and
+	j <= -1 + nj and i >= 0 and i <= -1 + ni and k <= -1 + nk and
+	ni >= 1 and nj >= 1 and nk >= 1 and j <= 63 and t1 >= 0 and
+	i <= 63 and k <= 15 and t0 >= 0 and t1 <= 15 and t0 <= 15) }
+[t0, t1] -> { : 0 <= t0, t1 <= 15 }
+{ [t0, t1, i5, i6, i7] -> unroll[x] : x >= 3}
diff --git a/lib/Analysis/isl/test_inputs/codegen/hoist2.c b/lib/Analysis/isl/test_inputs/codegen/hoist2.c
new file mode 100644
index 0000000..907652f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/hoist2.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= 5; c0 += 1)
+  if (c0 <= 3 || (b == 1 && t1 + c0 >= 10) || (t1 == 5 && b == 1 && c0 == 4))
+    for (int c1 = t1 - 64 * b + 64; c1 <= min(70, -c0 + 73); c1 += 64)
+      if (c0 <= 3 || (t1 + c0 >= 10 && c1 == t1) || c1 == 5)
+        A(c0, 64 * b + c1 - 8);
diff --git a/lib/Analysis/isl/test_inputs/codegen/hoist2.in b/lib/Analysis/isl/test_inputs/codegen/hoist2.in
new file mode 100644
index 0000000..6a29a026
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/hoist2.in
@@ -0,0 +1,5 @@
+# Check that the constraints hoisted from the inner loop
+# do not end up involving the inner loop iterator.
+[t1, b] -> { A[i1, i2] -> [i1, 8 - 64b + i2] : exists (e0, e1 = [(-8 + t1 - i2)/64]: 64e1 = -8 + t1 - i2 and i2 >= 1 and i2 <= 127 and 2e0 >= -3 + i1 and 2e0 >= -1 - i1 and 2e0 <= 8 - i1 and 2e0 <= 6 + i1 and 2e0 >= -65 - 64b + i2 and 2e0 >= -1 + 64b - i2 and e0 <= 1 and e0 >= 0 and 2e0 <= 62 + 64b - i2 and b <= 1 and b >= 0 and i1 >= 1 and i1 <= 2046 and t1 >= 5 and t1 <= 8) }
+[t1, b] -> { : b >= 0 and b <= 1 and t1 >= 5 and t1 <= 8 }
+[t1] -> { [i0, i1, i5, a] -> atomic[x]}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate1.c b/lib/Analysis/isl/test_inputs/codegen/isolate1.c
new file mode 100644
index 0000000..db6edf8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate1.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 0; c0 <= 3; c0 += 1)
+    A(c0);
+  for (int c0 = 4; c0 <= 6; c0 += 1)
+    A(c0);
+  for (int c0 = 7; c0 <= 99; c0 += 1)
+    A(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate1.st b/lib/Analysis/isl/test_inputs/codegen/isolate1.st
new file mode 100644
index 0000000..037dda1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate1.st
@@ -0,0 +1,5 @@
+# Check that the isolate option is adjusted by schedule space scaling
+domain: "{ A[i] : 0 <= i < 100 }"
+child:
+  schedule: "[{ A[i] -> [3i] }]"
+  options: "{ isolate[[] -> [x]] : 10 <= x <= 20 }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate2.c b/lib/Analysis/isl/test_inputs/codegen/isolate2.c
new file mode 100644
index 0000000..28a78bc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate2.c
@@ -0,0 +1,9 @@
+for (int c0 = 0; c0 <= 99; c0 += 1) {
+  if (c0 >= 4 && c0 <= 6) {
+    for (int c1 = 0; c1 <= 99; c1 += 1)
+      A(c0, c1);
+  } else {
+    for (int c1 = 0; c1 <= 99; c1 += 1)
+      A(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate2.st b/lib/Analysis/isl/test_inputs/codegen/isolate2.st
new file mode 100644
index 0000000..a9478f3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate2.st
@@ -0,0 +1,7 @@
+# Check that the isolate option is adjusted by schedule space scaling
+domain: "{ A[i,j] : 0 <= i,j < 100 }"
+child:
+  schedule: "[{ A[i,j] -> [3i] }]"
+  child:
+    schedule: "[{ A[i,j] -> [3j] }]"
+    options: "{ isolate[[x] -> [y]] : 10 <= x <= 20 }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate3.c b/lib/Analysis/isl/test_inputs/codegen/isolate3.c
new file mode 100644
index 0000000..921ea49
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate3.c
@@ -0,0 +1,17 @@
+{
+  for (int c0 = 0; c0 <= 9; c0 += 1)
+    A(c0);
+  A(10);
+  A(11);
+  A(12);
+  A(13);
+  A(14);
+  A(15);
+  A(16);
+  A(17);
+  A(18);
+  A(19);
+  A(20);
+  for (int c0 = 21; c0 <= 99; c0 += 1)
+    A(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate3.st b/lib/Analysis/isl/test_inputs/codegen/isolate3.st
new file mode 100644
index 0000000..bce38a8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate3.st
@@ -0,0 +1,5 @@
+# Check use of options specific to isolated part
+domain: "{ A[i] : 0 <= i < 100 }"
+child:
+  schedule: "[{ A[i] -> [i] }]"
+  options: "{ isolate[[] -> [x]] : 10 <= x <= 20; [isolate[] -> unroll[x]] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate4.c b/lib/Analysis/isl/test_inputs/codegen/isolate4.c
new file mode 100644
index 0000000..71484e1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate4.c
@@ -0,0 +1,13 @@
+{
+  A(0);
+  A(1);
+  A(2);
+  A(3);
+  A(4);
+  for (int c0 = 5; c0 <= 15; c0 += 1)
+    A(c0);
+  A(16);
+  A(17);
+  A(18);
+  A(19);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate4.st b/lib/Analysis/isl/test_inputs/codegen/isolate4.st
new file mode 100644
index 0000000..58b5168
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate4.st
@@ -0,0 +1,5 @@
+# Check that generic options are not applied to isolated part
+domain: "{ A[i] : 0 <= i < 20 }"
+child:
+  schedule: "[{ A[i] -> [i] }]"
+  options: "{ isolate[[] -> [x]] : 5 <= x <= 15; unroll[x] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate5.c b/lib/Analysis/isl/test_inputs/codegen/isolate5.c
new file mode 100644
index 0000000..0f1588d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate5.c
@@ -0,0 +1,29 @@
+{
+  for (int c0 = 0; c0 <= 9; c0 += 1) {
+    if ((c0 + 1) % 2 == 0) {
+      for (int c1 = 0; c1 <= 1; c1 += 1)
+        B((c0 - 1) / 2, c1);
+    } else {
+      for (int c1 = 0; c1 <= 1; c1 += 1)
+        A(c0 / 2, c1);
+    }
+  }
+  for (int c0 = 10; c0 <= 89; c0 += 1) {
+    if ((c0 + 1) % 2 == 0) {
+      for (int c1 = 0; c1 <= 1; c1 += 1)
+        B((c0 - 1) / 2, c1);
+    } else {
+      for (int c1 = 0; c1 <= 1; c1 += 1)
+        A(c0 / 2, c1);
+    }
+  }
+  for (int c0 = 90; c0 <= 199; c0 += 1) {
+    if ((c0 + 1) % 2 == 0) {
+      for (int c1 = 0; c1 <= 1; c1 += 1)
+        B((c0 - 1) / 2, c1);
+    } else {
+      for (int c1 = 0; c1 <= 1; c1 += 1)
+        A(c0 / 2, c1);
+    }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate5.st b/lib/Analysis/isl/test_inputs/codegen/isolate5.st
new file mode 100644
index 0000000..86b0dd1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate5.st
@@ -0,0 +1,5 @@
+# Check that use of isolate option prevents shifted stride detection
+domain: "{ A[i,j] : 0 <= i < 100 and 0 <= j < 2; B[i,j] : 0 <= i < 100 and 0 <= j < 2 }"
+child:
+  schedule: "[{ A[i,j] -> [2i]; B[i,j] -> [2i+1] }, { A[i,j] -> [j]; B[i,j] -> [j]}]"
+  options: "{ isolate[[] -> [x, y]] : 10 <= x < 90 }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate6.c b/lib/Analysis/isl/test_inputs/codegen/isolate6.c
new file mode 100644
index 0000000..e92a2b8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate6.c
@@ -0,0 +1,26 @@
+{
+  for (int c0 = 0; c0 <= 8; c0 += 1) {
+    for (int c1 = 0; c1 <= -c0 + 8; c1 += 1)
+      for (int c2 = 10 * c0; c2 <= 10 * c0 + 9; c2 += 1) {
+        A(c2, 10 * c1);
+        A(c2, 10 * c1 + 1);
+        A(c2, 10 * c1 + 2);
+        A(c2, 10 * c1 + 3);
+        A(c2, 10 * c1 + 4);
+        A(c2, 10 * c1 + 5);
+        A(c2, 10 * c1 + 6);
+        A(c2, 10 * c1 + 7);
+        A(c2, 10 * c1 + 8);
+        A(c2, 10 * c1 + 9);
+      }
+    for (int c1 = -c0 + 9; c1 <= -c0 + 10; c1 += 1)
+      for (int c2 = 10 * c0; c2 <= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
+        for (int c3 = 10 * c1; c3 <= min(10 * c1 + 9, -c2 + 100); c3 += 1)
+          A(c2, c3);
+  }
+  for (int c0 = 9; c0 <= 10; c0 += 1)
+    for (int c1 = 0; c1 <= -c0 + 10; c1 += 1)
+      for (int c2 = 10 * c0; c2 <= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
+        for (int c3 = 10 * c1; c3 <= min(10 * c1 + 9, -c2 + 100); c3 += 1)
+          A(c2, c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate6.st b/lib/Analysis/isl/test_inputs/codegen/isolate6.st
new file mode 100644
index 0000000..1342223
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate6.st
@@ -0,0 +1,8 @@
+# Example from the manual
+domain: "{ A[i,j] : 0 <= i,j and i + j <= 100 }"
+child:
+  schedule: "[{ A[i,j] -> [floor(i/10)] }, \
+	{ A[i,j] -> [floor(j/10)] }, \
+	{ A[i,j] -> [i] }, { A[i,j] -> [j] }]"
+  options: "{ isolate[[] -> [a,b,c,d]] : 0 <= 10a,10b and \
+	10a+9+10b+9 <= 100; [isolate[] -> unroll[3]] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate7.c b/lib/Analysis/isl/test_inputs/codegen/isolate7.c
new file mode 100644
index 0000000..1eac202
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate7.c
@@ -0,0 +1,29 @@
+{
+  for (int c0 = 0; c0 < n - 31; c0 += 32)
+    for (int c1 = 0; c1 <= n; c1 += 32) {
+      if (n >= c1 + 32) {
+        for (int c2 = 0; c2 <= 31; c2 += 1)
+          for (int c3 = 0; c3 <= 31; c3 += 1)
+            S_1(c0 + c2, c1 + c3);
+      } else {
+        for (int c2 = 0; c2 <= 31; c2 += 1) {
+          for (int c3 = 0; c3 < n - c1; c3 += 1)
+            S_1(c0 + c2, c1 + c3);
+          S_2(c0 + c2);
+        }
+      }
+    }
+  for (int c1 = 0; c1 < n; c1 += 32) {
+    if (n >= c1 + 32) {
+      for (int c2 = 0; c2 < (n + 32) % 32; c2 += 1)
+        for (int c3 = 0; c3 <= 31; c3 += 1)
+          S_1(-((n + 32) % 32) + n + c2, c1 + c3);
+    } else {
+      for (int c2 = 0; c2 < n - c1; c2 += 1) {
+        for (int c3 = 0; c3 < n - c1; c3 += 1)
+          S_1(c1 + c2, c1 + c3);
+        S_2(c1 + c2);
+      }
+    }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/isolate7.st b/lib/Analysis/isl/test_inputs/codegen/isolate7.st
new file mode 100644
index 0000000..673eb08
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/isolate7.st
@@ -0,0 +1,16 @@
+# Check that no expressions of the form ((-n + 2147483648) % 32) are produced.
+domain: "[n] -> { S_2[i] : i >= 0 and i <= -1 + n; S_1[i, j] : j >= 0 and j <= -1 + n and i >= 0 and i <= -1 + n }"
+child:
+  context: "[n] -> { [] : n <= 2147483647 and n >= 0 }"
+  child:
+    schedule: "[n] -> [{ S_1[i, j] -> [(32*floor((i)/32))]; S_2[i] -> [(32*floor((i)/32))] }, { S_1[i, j] -> [(32*floor((j)/32))]; S_2[i] -> [(32*floor((n)/32))] }]"
+    permutable: 1
+    options: "[n] -> { atomic[i0] : i0 >= 0 and i0 <= 1; isolate[[] -> [i0, i1]] : (exists (e0 = floor((i0)/32), e1 = floor((i1)/32): 32e0 = i0 and 32e1 = i1 and i0 >= 0 and i0 <= -32 + n and i1 >= 0 and i1 <= n)) or (exists (e0 = floor((i0)/32), e1 = floor((i1)/32): 32e0 = i0 and 32e1 = i1 and i0 >= 0 and i0 <= -32 + n and i1 >= -31 + n and i1 <= -31 + 2n)) }"
+    child:
+          schedule: "[n] -> [{ S_1[i, j] -> [(i - 32*floor((i)/32))]; S_2[i] -> [(i - 32*floor((i)/32))] }, { S_1[i, j] -> [(j - 32*floor((j)/32))]; S_2[i] -> [(n - 32*floor((n)/32))] }]"
+          permutable: 1
+          options: "{ separate[i0] : i0 >= 0 and i0 <= 1 }"
+          child:
+            sequence:
+            - filter: "[n] -> { S_1[i, j] }"
+            - filter: "[n] -> { S_2[i] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.c b/lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.c
new file mode 100644
index 0000000..97b4544
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.c
@@ -0,0 +1,2 @@
+if (8 * a + 64 * b >= t0 + 2 * t + 512 * floord(-t0 - 8 * a + 64 * b + 2 * t - 1, 512) + 512 && t0 + 512 * floord(-t0 - 8 * a + 64 * b + 2 * t - 1, 512) >= -511 && t0 + 512 * floord(-t0 - 8 * a + 64 * b + 2 * t - 1, 512) <= 1310206)
+  S_0(t, -((-t0 - 8 * a + 64 * b + 2 * t + 511) % 512) - 8 * a + 64 * b + 2 * t + 511);
diff --git a/lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.in b/lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.in
new file mode 100644
index 0000000..9eadc1b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/jacobi_kernel4.in
@@ -0,0 +1,4 @@
+# Check that an affine value is extracted for the final dimension
+[t0,a,b,t] -> { S_0[t, i] -> [i, t0] : exists (e0 = [(t0 - i)/512]:  512e0 = t0 - i and 64b >= 2t + i - 8a and 64b <= -2t + i + 8a and 4a <= 3 + t and 4a >= t and t >= 0 and t <= 1999 and i >= 1 and i <= 1310718 and a >= 0 and a <= 500 and 8b <= 163839 + a and b <= 20480 and 8b >= 1 - a and b >= 0 and 32b <= 655359 - t + 4a and 32b >= 1 + t - 4a and t0 >= 0 and t0 <= 511) }
+[t0,a,b,t] -> { :  t <= -1 + 4a + 32b and t >= 0 and t <= 4a and t >= -3 + 4a and t <= 1999 and t <= 655359 + 4a - 32b and t0 >= 0 and t0 <= 511 }
+[t0] -> {  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/lu.c b/lib/Analysis/isl/test_inputs/codegen/lu.c
new file mode 100644
index 0000000..022d6f2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/lu.c
@@ -0,0 +1,18 @@
+for (int c0 = 0; c0 < n - 1; c0 += 32)
+  for (int c1 = c0; c1 < n; c1 += 32)
+    for (int c2 = c0; c2 < n; c2 += 32) {
+      if (c1 >= c0 + 32) {
+        for (int c3 = c0; c3 <= min(c0 + 31, c2 + 30); c3 += 1)
+          for (int c4 = c1; c4 <= min(n - 1, c1 + 31); c4 += 1)
+            for (int c5 = max(c2, c3 + 1); c5 <= min(n - 1, c2 + 31); c5 += 1)
+              S_6(c3, c4, c5);
+      } else {
+        for (int c3 = c0; c3 <= min(min(n - 2, c0 + 31), c2 + 30); c3 += 1) {
+          for (int c5 = max(c2, c3 + 1); c5 <= min(n - 1, c2 + 31); c5 += 1)
+            S_2(c3, c5);
+          for (int c4 = c3 + 1; c4 <= min(n - 1, c0 + 31); c4 += 1)
+            for (int c5 = max(c2, c3 + 1); c5 <= min(n - 1, c2 + 31); c5 += 1)
+              S_6(c3, c4, c5);
+        }
+      }
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/lu.in b/lib/Analysis/isl/test_inputs/codegen/lu.in
new file mode 100644
index 0000000..ea884f5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/lu.in
@@ -0,0 +1,4 @@
+# Check that the stride of the second loop is properly detected
+[n] -> { S_2[k, j] -> [o0, o0, o2, k, k, j, 1] : exists (e0 = floor((o2)/32), e1 = floor((o0)/32): 32e0 = o2 and 32e1 = o0 and o0 <= k and o0 >= -31 + k and k >= 0 and j <= -1 + n and o2 <= j and o2 >= -31 + j and j >= 1 + k); S_6[k, i, j] -> [o0, o1, o2, k, i, j, 0] : exists (e0 = floor((o0)/32), e1 = floor((o1)/32), e2 = floor((o2)/32): 32e0 = o0 and 32e1 = o1 and 32e2 = o2 and o0 <= k and o0 >= -31 + k and o1 <= i and o1 >= -31 + i and o2 <= j and o2 >= -31 + j and k >= 0 and i >= 1 + k and j <= -1 + n and j >= 1 + k and i <= -1 + n) }
+{  :  }
+{ [a,b,c,d,e,f,g] -> atomic[x] : x < 3; [a,b,c,d,e,f,g] -> separate[x] : x >= 3  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/mod.c b/lib/Analysis/isl/test_inputs/codegen/mod.c
new file mode 100644
index 0000000..dcd8319
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/mod.c
@@ -0,0 +1,2 @@
+if (2 * (n % 100) == 3 * (m % 200))
+  A();
diff --git a/lib/Analysis/isl/test_inputs/codegen/mod.in b/lib/Analysis/isl/test_inputs/codegen/mod.in
new file mode 100644
index 0000000..7a04c5a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/mod.in
@@ -0,0 +1,4 @@
+# check that modulo constraint is generated correctly
+[n, m] -> { A[] -> [] : 2 * (n % 100) = 3 * (m % 200) }
+[n, m] -> { : m, n >= 0 }
+{}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/README b/lib/Analysis/isl/test_inputs/codegen/omega/README
new file mode 100644
index 0000000..80e27fd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/README
@@ -0,0 +1,5 @@
+The tests in this directory have been adapted from the corresponding omega+
+test cases.
+The options have been derived semi-automatically and may not always
+correspond to the intended meaning of the specified "effort" in the omega+
+test cases.
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/basics-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/basics-0.c
new file mode 100644
index 0000000..53995e9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/basics-0.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 5; c0 <= 8; c0 += 1)
+    s0(c0);
+  for (int c0 = 10; c0 <= 16; c0 += 2)
+    s0(c0);
+  for (int c0 = 20; c0 <= 25; c0 += 1)
+    s0(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/basics-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/basics-0.in
new file mode 100644
index 0000000..025da3d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/basics-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1] -> [In_1] : (In_1 >= 5 and In_1 <= 8) or (exists (e0 = [(In_1)/2]: 2e0 = In_1 and In_1 >= 10 and In_1 <= 16)) or (In_1 >= 20 and In_1 <= 25) }
+{  :  }
+{ [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/basics-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/basics-1.c
new file mode 100644
index 0000000..d3d6970
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/basics-1.c
@@ -0,0 +1,3 @@
+for (int c0 = -9; c0 <= 9; c0 += 1)
+  for (int c1 = max(1, -c0 + 1); c1 <= min(10, -c0 + 10); c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/basics-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/basics-1.in
new file mode 100644
index 0000000..82e1093
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/basics-1.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_2 >= 1 - In_1 and In_2 >= 1 and In_2 <= 10 - In_1 and In_2 <= 10 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.c
new file mode 100644
index 0000000..464ee49
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.c
@@ -0,0 +1,9 @@
+{
+  for (int c1 = 2; c1 <= n; c1 += 1)
+    s0(c1);
+  for (int c1 = 1; c1 < n; c1 += 1) {
+    for (int c3 = c1 + 1; c3 <= n; c3 += 1)
+      s1(c3, c1);
+    s2(c1 + 1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.in
new file mode 100644
index 0000000..81fde50
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[i] -> [0, i, 0, 0] : i >= 2 and i <= n; s1[i, j] -> [1, j, 0, i] : j >= 1 and j <= -1 + i and i <= n; s2[i] -> [1, -1 + i, 1, 0] : i >= 2 and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.c
new file mode 100644
index 0000000..464ee49
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.c
@@ -0,0 +1,9 @@
+{
+  for (int c1 = 2; c1 <= n; c1 += 1)
+    s0(c1);
+  for (int c1 = 1; c1 < n; c1 += 1) {
+    for (int c3 = c1 + 1; c3 <= n; c3 += 1)
+      s1(c3, c1);
+    s2(c1 + 1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.in
new file mode 100644
index 0000000..b5abf29
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/chosol-1.in
@@ -0,0 +1,3 @@
+[n] -> { s0[i] -> [0, i, 0, 0] : i >= 2 and i <= n; s1[i, j] -> [1, j, 0, i] : j >= 1 and j <= -1 + i and i <= n; s2[i] -> [1, -1 + i, 1, 0] : i >= 2 and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 1; [i0, i1, i2, i3] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.c
new file mode 100644
index 0000000..6340134
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= 8; c0 += 1)
+  for (int c1 = 0; c1 <= 7; c1 += 1) {
+    if (c0 >= 2 && c0 <= 6 && c1 <= 4)
+      s1(c0, c1);
+    if (c1 + 1 >= c0)
+      s0(c0, c1);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.in
new file mode 100644
index 0000000..a3fa3b1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-0.in
@@ -0,0 +1,3 @@
+{ s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_1 <= 6 and In_2 >= 0 and In_2 <= 4; s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_2 >= -1 + In_1 and In_2 <= 7 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 1; [i0, i1] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.c
new file mode 100644
index 0000000..1c554dc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.c
@@ -0,0 +1,16 @@
+for (int c0 = 1; c0 <= 8; c0 += 1) {
+  if (c0 >= 2) {
+    if (c0 <= 6)
+      for (int c1 = 0; c1 < c0 - 1; c1 += 1)
+        s1(c0, c1);
+    for (int c1 = c0 - 1; c1 <= 4; c1 += 1) {
+      s1(c0, c1);
+      s0(c0, c1);
+    }
+    for (int c1 = max(5, c0 - 1); c1 <= 7; c1 += 1)
+      s0(c0, c1);
+  } else {
+    for (int c1 = 0; c1 <= 7; c1 += 1)
+      s0(1, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.in
new file mode 100644
index 0000000..c6f7fa5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-1.in
@@ -0,0 +1,3 @@
+{ s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_1 <= 6 and In_2 >= 0 and In_2 <= 4; s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_2 >= -1 + In_1 and In_2 <= 7 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.c
new file mode 100644
index 0000000..f92e583
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.c
@@ -0,0 +1,17 @@
+{
+  for (int c1 = 0; c1 <= 7; c1 += 1)
+    s0(1, c1);
+  for (int c0 = 2; c0 <= 6; c0 += 1) {
+    for (int c1 = 0; c1 < c0 - 1; c1 += 1)
+      s1(c0, c1);
+    for (int c1 = c0 - 1; c1 <= 4; c1 += 1) {
+      s1(c0, c1);
+      s0(c0, c1);
+    }
+    for (int c1 = 5; c1 <= 7; c1 += 1)
+      s0(c0, c1);
+  }
+  for (int c0 = 7; c0 <= 8; c0 += 1)
+    for (int c1 = c0 - 1; c1 <= 7; c1 += 1)
+      s0(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.in
new file mode 100644
index 0000000..03a7b5d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/code_gen-2.in
@@ -0,0 +1,3 @@
+{ s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_1 <= 6 and In_2 >= 0 and In_2 <= 4; s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_2 >= -1 + In_1 and In_2 <= 7 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= -1; [i0, i1] -> separate[o0] : o0 >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/collard-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/collard-0.c
new file mode 100644
index 0000000..413fbda
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/collard-0.c
@@ -0,0 +1,16 @@
+{
+  for (int c4 = 1; c4 <= n; c4 += 1)
+    s2(c4);
+  for (int c1 = 1; c1 < n; c1 += 1) {
+    for (int c4 = 0; c4 < n - c1; c4 += 1)
+      s0(c1, n - c4);
+    for (int c3 = 0; c3 < n - c1; c3 += 1)
+      for (int c4 = c1 + 1; c4 <= n; c4 += 1)
+        s1(c1, n - c3, c4);
+  }
+  for (int c1 = 1; c1 <= n; c1 += 1) {
+    s4(c1);
+    for (int c3 = c1 + 1; c3 <= n; c3 += 1)
+      s3(c3, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/collard-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/collard-0.in
new file mode 100644
index 0000000..d803da7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/collard-0.in
@@ -0,0 +1,3 @@
+[n] -> { s1[i, j, k] -> [1, i, 1, n - j, k] : j >= 1 + i and k >= 1 + i and i >= 1 and j <= n and k <= n; s2[i] -> [0, 0, 0, 0, i] : i >= 1 and i <= n; s4[i] -> [2, i, 0, 0, 0] : i >= 1 and i <= n; s0[i, j] -> [1, i, 0, n - i, n - j] : i >= 1 and j >= 1 + i and j <= n; s3[i, j] -> [2, j, 1, i, j] : j >= 1 and j <= -1 + i and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 4; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.c
new file mode 100644
index 0000000..3e403dd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.c
@@ -0,0 +1,2 @@
+for (int c0 = 0; c0 <= 99; c0 += 1)
+  s0(c0 % 10, c0 / 10);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.in
new file mode 100644
index 0000000..0c2b107
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [i + 10j] : i >= 0 and i <= 9 and j >= 0 and j <= 9 }
+{  :  }
+{ [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.c
new file mode 100644
index 0000000..98953fb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.c
@@ -0,0 +1,2 @@
+for (int c0 = 0; c0 <= 99; c0 += 1)
+  s0(c0, c0 % 10, c0 / 10);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.in
new file mode 100644
index 0000000..e0c7273
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/dagstuhl1-1.in
@@ -0,0 +1,3 @@
+{s0[p,i,j] -> [p,i,j] : 0 <= i,j <= 9 && p = i+10j}
+{  :  }
+{ [p,i,j] -> separate[o0] : o0 >= 2; [p,i,j] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.c
new file mode 100644
index 0000000..fbec13a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.c
@@ -0,0 +1,7 @@
+for (int c0 = 0; c0 < n - 1; c0 += 1) {
+  for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+    s0(c0 + 1, n - c3);
+  for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+    for (int c6 = c0 + 2; c6 <= n; c6 += 1)
+      s1(c0 + 1, n - c3, c6);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.in
new file mode 100644
index 0000000..688f958
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[i, j] -> [-1 + i, 0, n - i, n - j] : i >= 1 and j >= 1 + i and j <= n; s1[i, j, k] -> [-1 + i, 1, n - i, n - j] : j >= 1 + i and k >= 1 + i and i >= 1 and j <= n and k <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.c
new file mode 100644
index 0000000..768a04f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.c
@@ -0,0 +1,17 @@
+{
+  for (int c3 = 1; c3 <= n; c3 += 1)
+    s2(c3);
+  for (int c0 = 0; c0 < n - 1; c0 += 1) {
+    for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+      s0(c0 + 1, n - c3);
+    for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+      for (int c6 = c0 + 2; c6 <= n; c6 += 1)
+        s1(c0 + 1, n - c3, c6);
+  }
+  for (int c0 = n - 1; c0 < 2 * n - 1; c0 += 1) {
+    if (c0 >= n)
+      for (int c2 = -n + c0 + 2; c2 <= n; c2 += 1)
+        s3(c2, -n + c0 + 1);
+    s4(-n + c0 + 2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.in
new file mode 100644
index 0000000..c9135ff
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-1.in
@@ -0,0 +1,3 @@
+[n] -> { s1[i, j, k] -> [-1 + i, 1, n - i, n - j] : j >= 1 + i and k >= 1 + i and i >= 1 and j <= n and k <= n; s3[i, j] -> [-1 + n + j, 0, i, j] : j >= 1 and j <= -1 + i and i <= n; s4[i] -> [-2 + n + i, 1, 0, 0] : i >= 1 and i <= n; s0[i, j] -> [-1 + i, 0, n - i, n - j] : i >= 1 and j >= 1 + i and j <= n; s2[i] -> [0, 0, 0, i] : i >= 1 and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.c
new file mode 100644
index 0000000..768a04f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.c
@@ -0,0 +1,17 @@
+{
+  for (int c3 = 1; c3 <= n; c3 += 1)
+    s2(c3);
+  for (int c0 = 0; c0 < n - 1; c0 += 1) {
+    for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+      s0(c0 + 1, n - c3);
+    for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+      for (int c6 = c0 + 2; c6 <= n; c6 += 1)
+        s1(c0 + 1, n - c3, c6);
+  }
+  for (int c0 = n - 1; c0 < 2 * n - 1; c0 += 1) {
+    if (c0 >= n)
+      for (int c2 = -n + c0 + 2; c2 <= n; c2 += 1)
+        s3(c2, -n + c0 + 1);
+    s4(-n + c0 + 2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.in
new file mode 100644
index 0000000..6d9a162
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc1-2.in
@@ -0,0 +1,3 @@
+[n] -> { s1[i, j, k] -> [-1 + i, 1, n - i, n - j] : j >= 1 + i and k >= 1 + i and i >= 1 and j <= n and k <= n; s3[i, j] -> [-1 + n + j, 0, i, j] : j >= 1 and j <= -1 + i and i <= n; s4[i] -> [-2 + n + i, 1, 0, 0] : i >= 1 and i <= n; s0[i, j] -> [-1 + i, 0, n - i, n - j] : i >= 1 and j >= 1 + i and j <= n; s2[i] -> [0, 0, 0, i] : i >= 1 and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 1; [i0, i1, i2, i3] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.c
new file mode 100644
index 0000000..fbec13a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.c
@@ -0,0 +1,7 @@
+for (int c0 = 0; c0 < n - 1; c0 += 1) {
+  for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+    s0(c0 + 1, n - c3);
+  for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+    for (int c6 = c0 + 2; c6 <= n; c6 += 1)
+      s1(c0 + 1, n - c3, c6);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.in
new file mode 100644
index 0000000..688f958
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[i, j] -> [-1 + i, 0, n - i, n - j] : i >= 1 and j >= 1 + i and j <= n; s1[i, j, k] -> [-1 + i, 1, n - i, n - j] : j >= 1 + i and k >= 1 + i and i >= 1 and j <= n and k <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.c
new file mode 100644
index 0000000..768a04f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.c
@@ -0,0 +1,17 @@
+{
+  for (int c3 = 1; c3 <= n; c3 += 1)
+    s2(c3);
+  for (int c0 = 0; c0 < n - 1; c0 += 1) {
+    for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+      s0(c0 + 1, n - c3);
+    for (int c3 = 0; c3 < n - c0 - 1; c3 += 1)
+      for (int c6 = c0 + 2; c6 <= n; c6 += 1)
+        s1(c0 + 1, n - c3, c6);
+  }
+  for (int c0 = n - 1; c0 < 2 * n - 1; c0 += 1) {
+    if (c0 >= n)
+      for (int c2 = -n + c0 + 2; c2 <= n; c2 += 1)
+        s3(c2, -n + c0 + 1);
+    s4(-n + c0 + 2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.in
new file mode 100644
index 0000000..c9135ff
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/fc2-1.in
@@ -0,0 +1,3 @@
+[n] -> { s1[i, j, k] -> [-1 + i, 1, n - i, n - j] : j >= 1 + i and k >= 1 + i and i >= 1 and j <= n and k <= n; s3[i, j] -> [-1 + n + j, 0, i, j] : j >= 1 and j <= -1 + i and i <= n; s4[i] -> [-2 + n + i, 1, 0, 0] : i >= 1 and i <= n; s0[i, j] -> [-1 + i, 0, n - i, n - j] : i >= 1 and j >= 1 + i and j <= n; s2[i] -> [0, 0, 0, i] : i >= 1 and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.c
new file mode 100644
index 0000000..db7f437
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.c
@@ -0,0 +1,2 @@
+for (int c0 = 4 * floord(m - 1, 12) + 4; c0 <= floord(n, 3); c0 += 4)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.in
new file mode 100644
index 0000000..45faa57
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-0.in
@@ -0,0 +1,3 @@
+[m, n] -> { s0[In_1] -> [In_1] : exists (e0 = [(In_1)/4]: 4e0 = In_1 and 3In_1 >= m and 3In_1 <= n) }
+{  :  }
+[m, n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.c
new file mode 100644
index 0000000..bc87982
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.c
@@ -0,0 +1,2 @@
+for (int c0 = floord(m, 4); c0 <= n; c0 += 1)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.in
new file mode 100644
index 0000000..7ae72ab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-1.in
@@ -0,0 +1,3 @@
+[m, n] -> { s0[In_1] -> [In_1] : 4In_1 >= -3 + m and In_1 <= n }
+{  :  }
+[m, n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.c
new file mode 100644
index 0000000..ff5f3c3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.c
@@ -0,0 +1,2 @@
+for (int c0 = 4 * floord(m, 4); c0 <= n; c0 += 1)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.in
new file mode 100644
index 0000000..73e1b8e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-2.in
@@ -0,0 +1,3 @@
+[m, n] -> { s0[In_1] -> [In_1] : exists (e0 = [(m)/4]: 4e0 <= m and 4e0 >= -3 + m and 4e0 <= In_1 and In_1 <= n) }
+{  :  }
+[m, n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.c
new file mode 100644
index 0000000..e3c9728
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.c
@@ -0,0 +1,2 @@
+for (int c0 = 3 * floord(m, 3) + 4 * floord(m, 4); c0 <= n; c0 += 1)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.in
new file mode 100644
index 0000000..1ff7e2c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-3.in
@@ -0,0 +1,3 @@
+[m, n] -> { s0[In_1] -> [In_1] : exists (e0 = [(m)/3], e1 = [(m)/4]: 4e1 <= m and 3e0 <= m and 4e1 >= -3 + m and 3e0 >= -2 + m and In_1 <= n and 4e1 <= In_1 - 3e0) }
+{  :  }
+[m, n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.c b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.c
new file mode 100644
index 0000000..dc6ba0a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.c
@@ -0,0 +1,3 @@
+if (n >= 3 * floord(n + 1, 3))
+  for (int c0 = m; c0 <= 5 * floord(n + 1, 3); c0 += 1)
+    s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.in b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.in
new file mode 100644
index 0000000..7a726c3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-4.in
@@ -0,0 +1,3 @@
+[n, m] -> { s0[In_1] -> [In_1] : exists (e0 = [(1 + n)/3]: In_1 >= m and 5e0 >= In_1 and 3e0 <= n and 3e0 >= -1 + n) }
+{  :  }
+[n, m] -> { [i0] -> atomic[o0] : o0 <= -1; [i0] -> separate[o0] : o0 >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.c b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.c
new file mode 100644
index 0000000..3e9f47d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.c
@@ -0,0 +1,2 @@
+for (int c0 = 4 * floord(m, 32); c0 <= n; c0 += 1)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.in b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.in
new file mode 100644
index 0000000..cc24250
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-5.in
@@ -0,0 +1,3 @@
+[m, n] -> { s0[In_1] -> [In_1] : exists (e0 = [(m)/32]: 32e0 <= m and 32e0 >= -31 + m and 4e0 <= In_1 and In_1 <= n) }
+{  :  }
+[m, n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.c b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.c
new file mode 100644
index 0000000..743b0c9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.c
@@ -0,0 +1,3 @@
+if (m >= 8 * floord(m + 1, 8))
+  for (int c0 = 4 * floord(m + 1, 32); c0 <= n; c0 += 1)
+    s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.in b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.in
new file mode 100644
index 0000000..78d2be9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/floor_bound-6.in
@@ -0,0 +1,3 @@
+[m, n] -> { s0[In_1] -> [In_1] : exists (e0 = [(1 + m)/8], e1 = [(e0)/4]: 8e0 <= m and 8e0 >= -6 + m and 4e1 <= In_1 and In_1 <= n and 32e1 <= 1 + m and 32e1 >= -30 + m) }
+{  :  }
+[m, n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gc-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/gc-0.c
new file mode 100644
index 0000000..d8234a3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gc-0.c
@@ -0,0 +1,2 @@
+for (int c0 = 2; c0 <= 8; c0 += 2)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gc-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/gc-0.in
new file mode 100644
index 0000000..063e353
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gc-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1] -> [In_1] : exists (e0 = [(In_1)/2]: 2e0 = In_1 and In_1 >= 2 and In_1 <= 8) }
+{  :  }
+{ [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ge-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/ge-0.c
new file mode 100644
index 0000000..1c22a5d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ge-0.c
@@ -0,0 +1,7 @@
+for (int c0 = 2; c0 <= n; c0 += 1)
+  for (int c1 = 1; c1 <= n; c1 += 1) {
+    for (int c3 = 1; c3 < min(c0, c1); c3 += 1)
+      s1(c3, c0, c1);
+    if (c0 >= c1 + 1)
+      s0(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ge-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/ge-0.in
new file mode 100644
index 0000000..edd7c36
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ge-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[k, i] -> [i, k, 1, 0] : k >= 1 and i >= 1 + k and i <= n; s1[k, i, j] -> [i, j, 0, k] : i >= 1 + k and j >= 1 + k and k >= 1 and i <= n and j <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ge-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/ge-1.c
new file mode 100644
index 0000000..1c22a5d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ge-1.c
@@ -0,0 +1,7 @@
+for (int c0 = 2; c0 <= n; c0 += 1)
+  for (int c1 = 1; c1 <= n; c1 += 1) {
+    for (int c3 = 1; c3 < min(c0, c1); c3 += 1)
+      s1(c3, c0, c1);
+    if (c0 >= c1 + 1)
+      s0(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ge-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/ge-1.in
new file mode 100644
index 0000000..4a08142
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ge-1.in
@@ -0,0 +1,3 @@
+[n] -> { s0[k, i] -> [i, k, 1, 0] : k >= 1 and i >= 1 + k and i <= n; s1[k, i, j] -> [i, j, 0, k] : i >= 1 + k and j >= 1 + k and k >= 1 and i <= n and j <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 1; [i0, i1, i2, i3] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/gist-0.c
new file mode 100644
index 0000000..4608d61
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= n; c0 += 4)
+  for (int c1 = c0; c1 <= n; c1 += 3)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/gist-0.in
new file mode 100644
index 0000000..b2f3366
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-1 + In_1)/4], e1 = [(-3 - In_1 + 4In_2)/12]: 4e0 = -1 + In_1 and 12e1 = -3 - In_1 + 4In_2 and In_1 >= 1 and In_2 >= In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/gist-1.c
new file mode 100644
index 0000000..8f1c692
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-1.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= n; c0 += 4)
+  for (int c1 = c0; c1 <= n; c1 += 8)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/gist-1.in
new file mode 100644
index 0000000..ecbf8e7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-1.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-1 + In_1)/4], e1 = [(-In_1 + In_2)/8]: 4e0 = -1 + In_1 and 8e1 = -In_1 + In_2 and In_1 >= 1 and In_2 >= In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/gist-2.c
new file mode 100644
index 0000000..3174987
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-2.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= n; c0 += 256)
+  for (int c1 = c0; c1 <= n; c1 += 8)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/gist-2.in
new file mode 100644
index 0000000..63edb52
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-2.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-1 + In_1)/256], e1 = [(-1 + In_2)/8]: 256e0 = -1 + In_1 and 8e1 = -1 + In_2 and In_1 >= 1 and In_2 >= In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/gist-3.c
new file mode 100644
index 0000000..513f385
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-3.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 < n; c0 += 4)
+  for (int c1 = c0 + 1; c1 <= n; c1 += 6)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/gist-3.in
new file mode 100644
index 0000000..43cac12
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-3.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-1 + In_1)/4], e1 = [(-1 - In_1 + In_2)/6]: 4e0 = -1 + In_1 and 6e1 = -1 - In_1 + In_2 and In_1 >= 1 and In_2 >= 1 + In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-4.c b/lib/Analysis/isl/test_inputs/codegen/omega/gist-4.c
new file mode 100644
index 0000000..a6f6fd0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-4.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= n; c0 += 6)
+  for (int c1 = c0; c1 <= n; c1 += 4)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-4.in b/lib/Analysis/isl/test_inputs/codegen/omega/gist-4.in
new file mode 100644
index 0000000..f67f837
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-4.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-1 + In_1)/6], e1 = [(-2 - In_1 + 3In_2)/12]: 6e0 = -1 + In_1 and 12e1 = -2 - In_1 + 3In_2 and In_1 >= 1 and In_2 >= In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-5.c b/lib/Analysis/isl/test_inputs/codegen/omega/gist-5.c
new file mode 100644
index 0000000..c2df61f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-5.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= n; c0 += 12)
+  for (int c1 = c0; c1 <= n; c1 += 8)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/gist-5.in b/lib/Analysis/isl/test_inputs/codegen/omega/gist-5.in
new file mode 100644
index 0000000..8b192c1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/gist-5.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-1 + In_1)/12], e1 = [(-2 - In_1 + 3In_2)/24]: 12e0 = -1 + In_1 and 24e1 = -2 - In_1 + 3In_2 and In_1 >= 1 and In_2 >= In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.c
new file mode 100644
index 0000000..e430f2b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.c
@@ -0,0 +1,2 @@
+if ((n - m - 1) % 3 == 0)
+  s0(n, m);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.in
new file mode 100644
index 0000000..52964e2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-0.in
@@ -0,0 +1,3 @@
+[n, m] -> { s0[n, m] -> [n, m] : exists (e0 = [(-2 - n + m)/3]: 3e0 = -2 - n + m) }
+{  :  }
+[n, m] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.c
new file mode 100644
index 0000000..3994a61
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.c
@@ -0,0 +1,2 @@
+if ((n + m + 1) % 2 == 0)
+  s0(n, m);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.in
new file mode 100644
index 0000000..141f585
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/guard1-1.in
@@ -0,0 +1,3 @@
+[n, m] -> { s0[n, m] -> [n, m] : exists (e0 = [(-1 - n + m)/2]: 2e0 = -1 - n + m) }
+{  :  }
+[n, m] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.c
new file mode 100644
index 0000000..c676558
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.c
@@ -0,0 +1,4 @@
+if (P2 >= 0 && P2 <= 3 && P1 == P2)
+  for (int c0 = 0; c0 <= min(2, -P2 + 4); c0 += 1)
+    for (int c2 = (-P2 - c0 + 6) % 3; c2 <= 3; c2 += 3)
+      s0(c0, c0, c2, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.in
new file mode 100644
index 0000000..e697792
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/hpf-0.in
@@ -0,0 +1,3 @@
+[P1, P2] -> { s0[In_1, In_1, In_3, In_3] -> [In_1, In_1, In_3, In_3] : exists (e0 = [(-2P2 - 2In_1 + In_3)/3]: P1 = P2 and 3e0 = -2P2 - 2In_1 + In_3 and P2 >= 0 and P2 <= 3 and In_1 <= 4 - P2 and In_1 >= 0 and In_1 <= 2 and In_3 >= 0 and In_3 <= 3) }
+{  :  }
+[P2, P1] -> { [i0, i1, i2, i3] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.c
new file mode 100644
index 0000000..d2e100b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.c
@@ -0,0 +1,13 @@
+if (m <= 1) {
+  for (int c0 = 1; c0 <= n; c0 += 1)
+    for (int c1 = 1; c1 <= n; c1 += 1)
+      s2(c0, c1);
+} else if (n >= m + 1) {
+  for (int c0 = 1; c0 <= n; c0 += 1)
+    for (int c1 = 1; c1 <= n; c1 += 1)
+      s0(c0, c1);
+} else {
+  for (int c0 = 1; c0 <= n; c0 += 1)
+    for (int c1 = 1; c1 <= n; c1 += 1)
+      s1(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.in
new file mode 100644
index 0000000..93f3f7c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-0.in
@@ -0,0 +1,3 @@
+[n, m] -> { s2[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= n and In_2 >= 1 and In_2 <= n and m <= 1; s0[In_1, In_2] -> [In_1, In_2] : m >= 2 and m <= -1 + n and In_1 >= 1 and In_1 <= n and In_2 >= 1 and In_2 <= n; s1[In_1, In_2] -> [In_1, In_2] : In_1 <= n and In_2 <= n and m >= n and In_1 >= 1 and In_2 >= 1 and m >= 2 }
+{  :  }
+[n, m] -> { [i0, i1] -> atomic[o0] : o0 <= 1; [i0, i1] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.c
new file mode 100644
index 0000000..5e2cd82
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.c
@@ -0,0 +1,9 @@
+for (int c0 = 1; c0 <= 100; c0 += 1) {
+  if (n >= 2)
+    s0(c0);
+  for (int c1 = 1; c1 <= 100; c1 += 1) {
+    s2(c0, c1);
+    if (n >= 2)
+      s1(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.in
new file mode 100644
index 0000000..0258439
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-1.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1] -> [In_1,0] : In_1 >= 1 and In_1 <= 100 and n >= 2; s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and n >= 2; s2[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 }
+{  :  }
+[n] -> { [i0,i1] -> separate[o0] : o0 >= 2; [i0,i1] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.c
new file mode 100644
index 0000000..b3f4a24
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.c
@@ -0,0 +1,12 @@
+for (int c0 = 1; c0 <= 100; c0 += 1) {
+  if (n >= 2) {
+    s0(c0);
+    for (int c1 = 1; c1 <= 100; c1 += 1) {
+      s2(c0, c1);
+      s1(c0, c1);
+    }
+  } else {
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      s2(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.in
new file mode 100644
index 0000000..0a220ee
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-2.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1] -> [In_1,0] : In_1 >= 1 and In_1 <= 100 and n >= 2; s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and n >= 2; s2[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 }
+{  :  }
+[n] -> { [i0,i1] -> separate[o0] : o0 >= 1; [i0,i1] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.c
new file mode 100644
index 0000000..94dc201
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.c
@@ -0,0 +1,13 @@
+if (n >= 2) {
+  for (int c0 = 1; c0 <= 100; c0 += 1) {
+    s0(c0);
+    for (int c1 = 1; c1 <= 100; c1 += 1) {
+      s2(c0, c1);
+      s1(c0, c1);
+    }
+  }
+} else {
+  for (int c0 = 1; c0 <= 100; c0 += 1)
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      s2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.in
new file mode 100644
index 0000000..a0315f1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-3.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1] -> [In_1,0] : In_1 >= 1 and In_1 <= 100 and n >= 2; s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and n >= 2; s2[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 }
+{  :  }
+[n] -> { [i0,i1] -> separate[o0] : o0 >= 0; [i0,i1] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.c b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.c
new file mode 100644
index 0000000..fa81628
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.c
@@ -0,0 +1,7 @@
+for (int c0 = 4; c0 <= 100; c0 += 4) {
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    s0(c0, c1);
+  if (c0 >= 8 && c0 <= 96)
+    for (int c1 = 10; c1 <= 100; c1 += 1)
+      s1(c0 + 2, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.in b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.in
new file mode 100644
index 0000000..30dc8dc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-4.in
@@ -0,0 +1,3 @@
+{ s1[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-2 + In_1)/4]: 4e0 = -2 + In_1 and In_1 >= 10 and In_1 <= 98 and In_2 >= 10 and In_2 <= 100); s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(In_1)/4]: 4e0 = In_1 and In_1 >= 4 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100) }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 1; [i0, i1] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.c b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.c
new file mode 100644
index 0000000..fa81628
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.c
@@ -0,0 +1,7 @@
+for (int c0 = 4; c0 <= 100; c0 += 4) {
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    s0(c0, c1);
+  if (c0 >= 8 && c0 <= 96)
+    for (int c1 = 10; c1 <= 100; c1 += 1)
+      s1(c0 + 2, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.in b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.in
new file mode 100644
index 0000000..87a40f4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/if_then-5.in
@@ -0,0 +1,3 @@
+{ s1[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-2 + In_1)/4]: 4e0 = -2 + In_1 and In_1 >= 10 and In_1 <= 98 and In_2 >= 10 and In_2 <= 100); s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(In_1)/4]: 4e0 = In_1 and In_1 >= 4 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100) }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.c
new file mode 100644
index 0000000..c15c86b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.c
@@ -0,0 +1,2 @@
+for (int c0 = 2; c0 <= 9; c0 += 1)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.in
new file mode 100644
index 0000000..8b87678
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter1-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1] -> [In_1] : In_1 >= 2 and In_1 <= 9 }
+{  :  }
+{ [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.c
new file mode 100644
index 0000000..5506929
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= 10; c0 += 1)
+  for (int c1 = 10; c1 <= 100; c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.in
new file mode 100644
index 0000000..16ea0df
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter2-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 10 and In_2 >= 10 and In_2 <= 100 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.c
new file mode 100644
index 0000000..43b6e3a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 2; c0 <= 8; c0 += 1)
+  for (int c1 = c0 + 1; c1 <= 9; c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.in
new file mode 100644
index 0000000..fc26493
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter3-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_2 >= 1 + In_1 and In_2 <= 9 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.c
new file mode 100644
index 0000000..65e3702
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 2; c0 <= 9; c0 += 1)
+  for (int c1 = c0 + 1; c1 <= 2 * c0; c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.in
new file mode 100644
index 0000000..94001d5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter4-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_2 >= 1 + In_1 and In_2 <= 2In_1 and In_1 <= 9 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.c
new file mode 100644
index 0000000..66c7c09
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 2; c0 <= 9; c0 += 1)
+  for (int c1 = c0 + 1; c1 <= min(16, 2 * c0); c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.in
new file mode 100644
index 0000000..1e4f739
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter5-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_2 >= 1 + In_1 and In_2 <= 2In_1 and In_2 <= 16 and In_1 <= 9 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.c
new file mode 100644
index 0000000..a0346b6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= 5; c0 += 1)
+  for (int c1 = 12; c1 <= 17; c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.in
new file mode 100644
index 0000000..1b8ed2b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 1 and In_1 <= 5 and In_2 >= 12 and In_2 <= 17 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.c
new file mode 100644
index 0000000..daccd39
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.c
@@ -0,0 +1,2 @@
+for (int c0 = 46; c0 <= 70; c0 += 12)
+  s0(c0, (17 * c0 - 170) / 12);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.in
new file mode 100644
index 0000000..4ee2ad6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter6-1.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, o1] : 12In_2 = -170 + 17In_1 and 12o1 = -170 + 17In_1 and In_1 >= 46 and In_1 <= 70 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.c
new file mode 100644
index 0000000..2606890
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.c
@@ -0,0 +1,2 @@
+for (int c0 = 1; c0 <= 3; c0 += 2)
+  s0(c0, (-3 * c0 + 15) / 2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.in
new file mode 100644
index 0000000..90d3efb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter7-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, o1] : 2In_2 = 15 - 3In_1 and 2o1 = 15 - 3In_1 and In_1 <= 3 and In_1 >= 1 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.c
new file mode 100644
index 0000000..a33fc49
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.c
@@ -0,0 +1,2 @@
+for (int c0 = max(exprVar2 + 1, exprVar2 + 8 * floord(-exprVar2 + exprVar1 - 1, 8) + 9); c0 <= 16; c0 += 8)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.in
new file mode 100644
index 0000000..6829280
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter8-0.in
@@ -0,0 +1,3 @@
+[exprVar2, exprVar3, exprVar1] -> { s0[In_1] -> [In_1] : exists (e0 = [(-1 - exprVar2 + In_1)/8]: exprVar3 = 0 and 8e0 = -1 - exprVar2 + In_1 and exprVar1 >= 1 and In_1 >= 1 + exprVar1 and In_1 <= 16 and In_1 >= 1 + exprVar2) }
+[exprVar3, exprVar2, exprVar1] -> {  : exists (e0: exprVar3 = 0 and 8e0 >= -15 + exprVar2 and exprVar2 <= 15 and exprVar1 >= 1 and 8e0 <= exprVar2 - exprVar1) }
+[exprVar2, exprVar3, exprVar1] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.c
new file mode 100644
index 0000000..baedaa0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.c
@@ -0,0 +1,11 @@
+for (int c0 = 1; c0 <= 15; c0 += 1) {
+  if (((-exprVar1 + 15) % 8) + c0 <= 15) {
+    s1(c0);
+    s3(c0);
+    s2(c0);
+    s0(c0);
+    s4(c0);
+  }
+  if (((-exprVar1 + 15) % 8) + c0 <= 15 || (exprVar1 - c0 + 1) % 8 == 0)
+    s5(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.in
new file mode 100644
index 0000000..9596d73
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/iter9-0.in
@@ -0,0 +1,3 @@
+[exprVar2, exprVar1] -> { s3[In_1] -> [In_1] : exists (e0: exprVar2 = 0 and 8e0 >= -15 + exprVar1 and exprVar1 <= 15 and In_1 >= 1 and 8e0 <= exprVar1 - In_1); s4[In_1] -> [In_1] : exists (e0: exprVar2 = 0 and 8e0 >= -15 + exprVar1 and exprVar1 <= 15 and In_1 >= 1 and 8e0 <= exprVar1 - In_1); s1[In_1] -> [In_1] : exists (e0: exprVar2 = 0 and 8e0 >= -15 + exprVar1 and exprVar1 <= 15 and In_1 >= 1 and 8e0 <= exprVar1 - In_1); s5[In_1] -> [In_1] : (exists (e0: exprVar2 = 0 and 8e0 >= -15 + exprVar1 and exprVar1 <= 15 and In_1 >= 1 and 8e0 <= exprVar1 - In_1)) or (exists (e0 = [(-1 - exprVar1 + In_1)/8]: exprVar2 = 0 and 8e0 = -1 - exprVar1 + In_1 and In_1 >= 1 + exprVar1 and In_1 >= 1 and In_1 <= 15)); s0[In_1] -> [In_1] : exists (e0: exprVar2 = 0 and 8e0 >= -15 + exprVar1 and exprVar1 <= 15 and In_1 >= 1 and 8e0 <= exprVar1 - In_1); s2[In_1] -> [In_1] : exists (e0: exprVar2 = 0 and 8e0 >= -15 + exprVar1 and exprVar1 <= 15 and In_1 >= 1 and 8e0 <= exprVar1 - In_1) }
+[exprVar2, exprVar1] -> {  : exprVar2 = 0 and exprVar1 <= 15 }
+[exprVar2, exprVar1] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.c
new file mode 100644
index 0000000..5594244
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.c
@@ -0,0 +1,5 @@
+for (int c0 = 0; c0 <= 15; c0 += 1)
+  for (int c1 = max(2 * c0 - 15, c0 / 2); c1 <= min(15, c0 + 1); c1 += 1)
+    for (int c2 = max(max(max(1, 67 * c0 - (c0 + 1) / 3), 67 * c1 - (c1 + 2) / 3), 133 * c0 - 67 * c1 + (c0 + c1 + 1) / 3 - 66); c2 <= min(min(1000, 100 * c0 + 99), 133 * c0 - 67 * c1 + (c0 + c1 + 2) / 3 + 132); c2 += 1)
+      for (int c3 = max(max(c2, 200 * c0 - c2), 100 * c1 + (c2 + 1) / 2); c3 <= min(min(2 * c2 + 1, 200 * c0 - c2 + 199), 100 * c1 + (c2 + 1) / 2 + 99); c3 += 1)
+        s0(c0, c1, c2, c3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.in
new file mode 100644
index 0000000..cf99c81
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur00-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4] -> [In_1, In_2, In_3, In_4] : In_3 >= 1 and In_4 >= In_3 and In_4 <= 1 + 2In_3 and In_3 <= 1000 and In_4 >= 200In_1 - In_3 and In_4 <= 199 + 200In_1 - In_3 and 2In_4 >= 200In_2 + In_3 and 2In_4 <= 199 + 200In_2 + In_3 }
+{  :  }
+{ [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.c
new file mode 100644
index 0000000..5594244
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.c
@@ -0,0 +1,5 @@
+for (int c0 = 0; c0 <= 15; c0 += 1)
+  for (int c1 = max(2 * c0 - 15, c0 / 2); c1 <= min(15, c0 + 1); c1 += 1)
+    for (int c2 = max(max(max(1, 67 * c0 - (c0 + 1) / 3), 67 * c1 - (c1 + 2) / 3), 133 * c0 - 67 * c1 + (c0 + c1 + 1) / 3 - 66); c2 <= min(min(1000, 100 * c0 + 99), 133 * c0 - 67 * c1 + (c0 + c1 + 2) / 3 + 132); c2 += 1)
+      for (int c3 = max(max(c2, 200 * c0 - c2), 100 * c1 + (c2 + 1) / 2); c3 <= min(min(2 * c2 + 1, 200 * c0 - c2 + 199), 100 * c1 + (c2 + 1) / 2 + 99); c3 += 1)
+        s0(c0, c1, c2, c3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.in
new file mode 100644
index 0000000..cf99c81
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4] -> [In_1, In_2, In_3, In_4] : In_3 >= 1 and In_4 >= In_3 and In_4 <= 1 + 2In_3 and In_3 <= 1000 and In_4 >= 200In_1 - In_3 and In_4 <= 199 + 200In_1 - In_3 and 2In_4 >= 200In_2 + In_3 and 2In_4 <= 199 + 200In_2 + In_3 }
+{  :  }
+{ [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.c
new file mode 100644
index 0000000..5594244
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.c
@@ -0,0 +1,5 @@
+for (int c0 = 0; c0 <= 15; c0 += 1)
+  for (int c1 = max(2 * c0 - 15, c0 / 2); c1 <= min(15, c0 + 1); c1 += 1)
+    for (int c2 = max(max(max(1, 67 * c0 - (c0 + 1) / 3), 67 * c1 - (c1 + 2) / 3), 133 * c0 - 67 * c1 + (c0 + c1 + 1) / 3 - 66); c2 <= min(min(1000, 100 * c0 + 99), 133 * c0 - 67 * c1 + (c0 + c1 + 2) / 3 + 132); c2 += 1)
+      for (int c3 = max(max(c2, 200 * c0 - c2), 100 * c1 + (c2 + 1) / 2); c3 <= min(min(2 * c2 + 1, 200 * c0 - c2 + 199), 100 * c1 + (c2 + 1) / 2 + 99); c3 += 1)
+        s0(c0, c1, c2, c3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.in
new file mode 100644
index 0000000..bc9611d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur01-1.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4] -> [In_1, In_2, In_3, In_4] : In_3 >= 1 and In_4 >= In_3 and In_4 <= 1 + 2In_3 and In_3 <= 1000 and In_4 >= 200In_1 - In_3 and In_4 <= 199 + 200In_1 - In_3 and 2In_4 >= 200In_2 + In_3 and 2In_4 <= 199 + 200In_2 + In_3 }
+{  :  }
+{ [i0, i1, i2, i3] -> atomic[o0] : o0 <= 1; [i0, i1, i2, i3] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.c
new file mode 100644
index 0000000..8b61d26
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.c
@@ -0,0 +1,7 @@
+for (int c0 = 0; c0 <= 3; c0 += 1)
+  for (int c1 = max(0, 2 * c0 - 3); c1 <= min(3, c0 + 1); c1 += 1)
+    for (int c2 = c0; c2 <= min(min(3, 2 * c0 - c1 + 1), 3 * c1 + 2); c2 += 1)
+      for (int c3 = max(max(max(0, c1 - (-c1 + 3) / 3), c0 - (-c2 + 3) / 3), c2 + floord(3 * c1 - c2 - 1, 6)); c3 <= min(3, c0 + 1); c3 += 1)
+        for (int c4 = max(max(max(max(-200 * c1 + 400 * c3 - 199, 250 * c3 + 1), 667 * c0 - 333 * c1 - (c0 + c1 + 3) / 3 - 332), 333 * c1 + c1 / 3), 333 * c2 + (c2 + 1) / 3); c4 <= min(min(min(min(1000, 500 * c0 + 499), -200 * c1 + 400 * c3 + 400), 333 * c2 - (-c2 + 3) / 3 + 333), 333 * c3 - (-c3 + 3) / 3 + 334); c4 += 1)
+          for (int c5 = max(max(max(c4, 1000 * c0 - c4), 1000 * c3 - 2 * c4 + 2), 500 * c1 + (c4 + 1) / 2); c5 <= min(min(min(2 * c4 + 1, 1000 * c0 - c4 + 999), 1000 * c3 - 2 * c4 + 1001), 500 * c1 + (c4 + 1) / 2 + 499); c5 += 1)
+            s0(c0, c1, c2, c3, c4, c5);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.in
new file mode 100644
index 0000000..890f413
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur03-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5, In_6] -> [In_1, In_2, In_3, In_4, In_5, In_6] : In_6 >= In_5 and In_6 <= 1 + 2In_5 and In_5 <= 1000 and In_6 >= 1000In_1 - In_5 and In_6 <= 999 + 1000In_1 - In_5 and In_6 >= 2 + 1000In_4 - 2In_5 and In_6 <= 1001 + 1000In_4 - 2In_5 and In_4 >= 0 and 2In_6 >= 1000In_2 + In_5 and 2In_6 <= 999 + 1000In_2 + In_5 and 3In_5 >= -1 + 1000In_3 and 3In_5 <= 998 + 1000In_3 }
+{  :  }
+{ [i0, i1, i2, i3, i4, i5] -> separate[o0] : o0 >= 5; [i0, i1, i2, i3, i4, i5] -> atomic[o0] : o0 <= 4 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.c
new file mode 100644
index 0000000..d0046d9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.c
@@ -0,0 +1,8 @@
+for (int c0 = 0; c0 <= 3; c0 += 1)
+  for (int c1 = max(0, 2 * c0 - 3); c1 <= min(c0 + 1, -c0 + 6); c1 += 1)
+    for (int c2 = c0; c2 <= min(min(3, 2 * c0 - c1 + 1), 3 * c1 + 2); c2 += 1)
+      for (int c3 = max(max(max(0, c1 - (-c1 + 3) / 3), c0 - (-c2 + 3) / 3), c2 + floord(3 * c1 - c2 - 1, 6)); c3 <= min(3, c0 + 1); c3 += 1)
+        for (int c5 = max(max(max(max(0, 2 * c3 - 4), c1 - (-c1 + 3) / 3), c2 - (c2 + 3) / 3), c3 - (c3 + 3) / 3); c5 <= min(min(c1 + 1, c3), -c2 + 2 * c3 - (c2 + 3) / 3 + 2); c5 += 1)
+          for (int c6 = max(max(max(max(max(-200 * c1 + 400 * c3 - 199, 250 * c3 + 1), 1000 * c0 - 500 * c5 - 501), 667 * c0 - 333 * c1 - (c0 + c1 + 3) / 3 - 332), 333 * c1 + c1 / 3), 333 * c2 + (c2 + 1) / 3); c6 <= min(min(min(min(min(min(1000, 500 * c0 + 499), -200 * c1 + 400 * c3 + 400), 500 * c5 + 501), 1000 * c0 - 500 * c5 + 997), 333 * c2 - (-c2 + 3) / 3 + 333), 333 * c3 - (-c3 + 3) / 3 + 334); c6 += 1)
+            for (int c7 = max(max(max(max(500 * c5 + 2, c6), 1000 * c0 - c6), 1000 * c3 - 2 * c6 + 2), 500 * c1 + (c6 + 1) / 2); c7 <= min(min(min(min(500 * c5 + 501, 2 * c6 + 1), 1000 * c0 - c6 + 999), 1000 * c3 - 2 * c6 + 1001), 500 * c1 + (c6 + 1) / 2 + 499); c7 += 1)
+              s0(c0, c1, c2, c3, c2 / 3, c5, c6, c7);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.in
new file mode 100644
index 0000000..c50a0da
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lefur04-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5, In_6, In_7, In_8] -> [In_1, In_2, In_3, In_4, In_5, In_6, In_7, In_8] : In_7 >= 1000In_5 and In_8 >= In_7 and In_8 <= 501 + 500In_6 and In_8 <= 1 + 2In_7 and In_7 <= 999 + 1000In_5 and In_7 <= 1000 and In_8 >= 1000In_1 - In_7 and In_8 <= 999 + 1000In_1 - In_7 and 2In_8 >= 1000In_2 + In_7 and 2In_8 <= 999 + 1000In_2 + In_7 and 3In_7 >= -1 + 1000In_3 and 3In_7 <= 998 + 1000In_3 and In_8 >= 2 + 500In_6 and In_6 >= 0 and In_8 >= 2 + 1000In_4 - 2In_7 and In_8 <= 1001 + 1000In_4 - 2In_7 }
+{  :  }
+{ [i0, i1, i2, i3, i4, i5, i6, i7] -> atomic[o0] : o0 <= 6; [i0, i1, i2, i3, i4, i5, i6, i7] -> separate[o0] : o0 >= 7 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.c
new file mode 100644
index 0000000..f7b1ae9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.c
@@ -0,0 +1,9 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    for (int c2 = 1; c2 <= 100; c2 += 1)
+      for (int c3 = 1; c3 <= 100; c3 += 1)
+        for (int c4 = 1; c4 <= 100; c4 += 1) {
+          s1(c0, c1, c2, c3, c4);
+          if (c0 <= 60)
+            s0(c0, c1, c2, c3, c4);
+        }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.in
new file mode 100644
index 0000000..31ae11a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 5; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 4 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.c
new file mode 100644
index 0000000..b522fd9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.c
@@ -0,0 +1,14 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    for (int c2 = 1; c2 <= 100; c2 += 1)
+      for (int c3 = 1; c3 <= 100; c3 += 1) {
+        if (c0 >= 61) {
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+        } else {
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+        }
+      }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.in
new file mode 100644
index 0000000..44de4ac
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-1.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 4; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.c
new file mode 100644
index 0000000..00e7b16
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.c
@@ -0,0 +1,15 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    for (int c2 = 1; c2 <= 100; c2 += 1) {
+      if (c0 >= 61) {
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+      } else {
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+      }
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.in
new file mode 100644
index 0000000..241fbb9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-2.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.c
new file mode 100644
index 0000000..6249150
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.c
@@ -0,0 +1,16 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1) {
+    if (c0 >= 61) {
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+    } else {
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+    }
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.in
new file mode 100644
index 0000000..a50a9ec
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-3.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 2; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.c
new file mode 100644
index 0000000..b981ad8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.c
@@ -0,0 +1,17 @@
+for (int c0 = 1; c0 <= 100; c0 += 1) {
+  if (c0 >= 61) {
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+  } else {
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.in
new file mode 100644
index 0000000..db7d85c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-4.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 1; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.c
new file mode 100644
index 0000000..2a24f68
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.c
@@ -0,0 +1,16 @@
+{
+  for (int c0 = 1; c0 <= 60; c0 += 1)
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+  for (int c0 = 61; c0 <= 100; c0 += 1)
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.in
new file mode 100644
index 0000000..2f9d578
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift1-5.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 0; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.c
new file mode 100644
index 0000000..181d6e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.c
@@ -0,0 +1,9 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    for (int c2 = 1; c2 <= 100; c2 += 1)
+      for (int c3 = 1; c3 <= 100; c3 += 1)
+        for (int c4 = 1; c4 <= 100; c4 += 1) {
+          s1(c0, c1, c2, c3, c4);
+          if (c0 >= 5 && c0 <= 60)
+            s0(c0, c1, c2, c3, c4);
+        }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.in
new file mode 100644
index 0000000..5df0444
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 5 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 5; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 4 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.c
new file mode 100644
index 0000000..625c734
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.c
@@ -0,0 +1,17 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    for (int c2 = 1; c2 <= 100; c2 += 1)
+      for (int c3 = 1; c3 <= 100; c3 += 1) {
+        if (c0 >= 61) {
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+        } else if (c0 <= 4) {
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+        } else {
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+        }
+      }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.in
new file mode 100644
index 0000000..7ef2a8d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-1.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 5 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 4; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.c
new file mode 100644
index 0000000..63e897c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.c
@@ -0,0 +1,19 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1)
+    for (int c2 = 1; c2 <= 100; c2 += 1) {
+      if (c0 >= 61) {
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+      } else if (c0 <= 4) {
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+      } else {
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+      }
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.in
new file mode 100644
index 0000000..3e9a978
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-2.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 5 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.c
new file mode 100644
index 0000000..f87f197
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.c
@@ -0,0 +1,21 @@
+for (int c0 = 1; c0 <= 100; c0 += 1)
+  for (int c1 = 1; c1 <= 100; c1 += 1) {
+    if (c0 >= 61) {
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+    } else if (c0 <= 4) {
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+    } else {
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+    }
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.in
new file mode 100644
index 0000000..0580f07
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-3.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 5 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 2; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.c
new file mode 100644
index 0000000..65ae7ae
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.c
@@ -0,0 +1,23 @@
+for (int c0 = 1; c0 <= 100; c0 += 1) {
+  if (c0 >= 61) {
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+  } else if (c0 <= 4) {
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+  } else {
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.in
new file mode 100644
index 0000000..d64462a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-4.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 5 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 1; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.c b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.c
new file mode 100644
index 0000000..16bd6db
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.c
@@ -0,0 +1,22 @@
+{
+  for (int c0 = 1; c0 <= 4; c0 += 1)
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+  for (int c0 = 5; c0 <= 60; c0 += 1)
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1) {
+            s1(c0, c1, c2, c3, c4);
+            s0(c0, c1, c2, c3, c4);
+          }
+  for (int c0 = 61; c0 <= 100; c0 += 1)
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      for (int c2 = 1; c2 <= 100; c2 += 1)
+        for (int c3 = 1; c3 <= 100; c3 += 1)
+          for (int c4 = 1; c4 <= 100; c4 += 1)
+            s1(c0, c1, c2, c3, c4);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.in b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.in
new file mode 100644
index 0000000..37a57be
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lift2-5.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 5 and In_1 <= 60 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100; s1[In_1, In_2, In_3, In_4, In_5] -> [In_1, In_2, In_3, In_4, In_5] : In_1 >= 1 and In_1 <= 100 and In_2 >= 1 and In_2 <= 100 and In_3 >= 1 and In_3 <= 100 and In_4 >= 1 and In_4 <= 100 and In_5 >= 1 and In_5 <= 100 }
+{  :  }
+{ [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 0; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu-0.c
new file mode 100644
index 0000000..e71f47b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-0.c
@@ -0,0 +1,10 @@
+for (int c0 = 1; c0 < n; c0 += 64)
+  for (int c1 = c0 - 1; c1 <= n; c1 += 64)
+    for (int c2 = c0; c2 <= n; c2 += 1) {
+      for (int c3 = c0; c3 <= min(min(c0 + 63, c1 + 62), c2 - 1); c3 += 1)
+        for (int c4 = max(c1, c3 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s1(c3, c4, c2);
+      if (c0 + 63 >= c2)
+        for (int c4 = max(c1, c2 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s0(c2, c4);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu-0.in
new file mode 100644
index 0000000..510d677
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-0.in
@@ -0,0 +1,3 @@
+[n] -> { s1[k, i, j] -> [t1, t2, j, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and i >= 1 + k and j >= 1 + k and k >= 1 and i <= n and j <= n); s0[k, i] -> [t1, t2, k, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and k >= 1 and i >= 1 + k and i <= n) }
+{  :  }
+[n] -> { [t1, t2, i2, i3, i4] -> separate[o0] : o0 >= 5; [t1, t2, i2, i3, i4] -> atomic[o0] : o0 <= 4 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu-1.c
new file mode 100644
index 0000000..e71f47b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-1.c
@@ -0,0 +1,10 @@
+for (int c0 = 1; c0 < n; c0 += 64)
+  for (int c1 = c0 - 1; c1 <= n; c1 += 64)
+    for (int c2 = c0; c2 <= n; c2 += 1) {
+      for (int c3 = c0; c3 <= min(min(c0 + 63, c1 + 62), c2 - 1); c3 += 1)
+        for (int c4 = max(c1, c3 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s1(c3, c4, c2);
+      if (c0 + 63 >= c2)
+        for (int c4 = max(c1, c2 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s0(c2, c4);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu-1.in
new file mode 100644
index 0000000..2e8f7ef
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-1.in
@@ -0,0 +1,3 @@
+[n] -> { s1[k, i, j] -> [t1, t2, j, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and i >= 1 + k and j >= 1 + k and k >= 1 and i <= n and j <= n); s0[k, i] -> [t1, t2, k, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and k >= 1 and i >= 1 + k and i <= n) }
+{  :  }
+[n] -> { [t1, t2, i2, i3, i4] -> separate[o0] : o0 >= 4; [t1, t2, i2, i3, i4] -> atomic[o0] : o0 <= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu-2.c
new file mode 100644
index 0000000..e71f47b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-2.c
@@ -0,0 +1,10 @@
+for (int c0 = 1; c0 < n; c0 += 64)
+  for (int c1 = c0 - 1; c1 <= n; c1 += 64)
+    for (int c2 = c0; c2 <= n; c2 += 1) {
+      for (int c3 = c0; c3 <= min(min(c0 + 63, c1 + 62), c2 - 1); c3 += 1)
+        for (int c4 = max(c1, c3 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s1(c3, c4, c2);
+      if (c0 + 63 >= c2)
+        for (int c4 = max(c1, c2 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s0(c2, c4);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu-2.in
new file mode 100644
index 0000000..ab2ec41
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-2.in
@@ -0,0 +1,3 @@
+[n] -> { s1[k, i, j] -> [t1, t2, j, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and i >= 1 + k and j >= 1 + k and k >= 1 and i <= n and j <= n); s0[k, i] -> [t1, t2, k, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and k >= 1 and i >= 1 + k and i <= n) }
+{  :  }
+[n] -> { [t1, t2, i2, i3, i4] -> separate[o0] : o0 >= 3; [t1, t2, i2, i3, i4] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu-3.c
new file mode 100644
index 0000000..3fd0d4e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-3.c
@@ -0,0 +1,14 @@
+for (int c0 = 1; c0 < n; c0 += 64)
+  for (int c1 = c0 - 1; c1 <= n; c1 += 64) {
+    for (int c2 = c0; c2 <= min(n, c0 + 63); c2 += 1) {
+      for (int c3 = c0; c3 <= min(c1 + 62, c2 - 1); c3 += 1)
+        for (int c4 = max(c1, c3 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s1(c3, c4, c2);
+      for (int c4 = max(c1, c2 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+        s0(c2, c4);
+    }
+    for (int c2 = c0 + 64; c2 <= n; c2 += 1)
+      for (int c3 = c0; c3 <= min(c0 + 63, c1 + 62); c3 += 1)
+        for (int c4 = max(c1, c3 + 1); c4 <= min(n, c1 + 63); c4 += 1)
+          s1(c3, c4, c2);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu-3.in
new file mode 100644
index 0000000..817db46
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu-3.in
@@ -0,0 +1,3 @@
+[n] -> { s1[k, i, j] -> [t1, t2, j, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and i >= 1 + k and j >= 1 + k and k >= 1 and i <= n and j <= n); s0[k, i] -> [t1, t2, k, k, i] : exists (e0 = [(-1 + t1)/64], e1 = [(t2)/64]: 64e0 = -1 + t1 and 64e1 = t2 and t1 >= -63 + k and t1 <= k and t2 >= -63 + i and t2 <= i and k >= 1 and i >= 1 + k and i <= n) }
+{  :  }
+[n] -> { [t1, t2, i2, i3, i4] -> separate[o0] : o0 >= 2; [t1, t2, i2, i3, i4] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.c
new file mode 100644
index 0000000..da2571a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= n; c0 += 1)
+  for (int c1 = 2; c1 <= n; c1 += 1) {
+    for (int c3 = 1; c3 < min(c0, c1); c3 += 1)
+      s1(c3, c1, c0);
+    if (c1 >= c0 + 1)
+      s0(c0, c1);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.in
new file mode 100644
index 0000000..5aae58c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[k, j] -> [k, j, 1, 0] : k >= 1 and j >= 1 + k and j <= n; s1[k, j, i] -> [i, j, 0, k] : j >= 1 + k and i >= 1 + k and k >= 1 and j <= n and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.c
new file mode 100644
index 0000000..da2571a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= n; c0 += 1)
+  for (int c1 = 2; c1 <= n; c1 += 1) {
+    for (int c3 = 1; c3 < min(c0, c1); c3 += 1)
+      s1(c3, c1, c0);
+    if (c1 >= c0 + 1)
+      s0(c0, c1);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.in
new file mode 100644
index 0000000..06a860c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-1.in
@@ -0,0 +1,3 @@
+[n] -> { s0[k, j] -> [k, j, 1, 0] : k >= 1 and j >= 1 + k and j <= n; s1[k, j, i] -> [i, j, 0, k] : j >= 1 + k and i >= 1 + k and k >= 1 and j <= n and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 1; [i0, i1, i2, i3] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.c
new file mode 100644
index 0000000..561ae11
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.c
@@ -0,0 +1,11 @@
+if (n >= 2)
+  for (int c0 = 1; c0 <= n; c0 += 1) {
+    for (int c1 = 2; c1 <= c0; c1 += 1)
+      for (int c3 = 1; c3 < c1; c3 += 1)
+        s1(c3, c1, c0);
+    for (int c1 = c0 + 1; c1 <= n; c1 += 1) {
+      for (int c3 = 1; c3 < c0; c3 += 1)
+        s1(c3, c1, c0);
+      s0(c0, c1);
+    }
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.in
new file mode 100644
index 0000000..6ad8a44
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_ijk-2.in
@@ -0,0 +1,3 @@
+[n] -> { s0[k, j] -> [k, j, 1, 0] : k >= 1 and j >= 1 + k and j <= n; s1[k, j, i] -> [i, j, 0, k] : j >= 1 + k and i >= 1 + k and k >= 1 and j <= n and i <= n }
+{  :  }
+[n] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 0; [i0, i1, i2, i3] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.c
new file mode 100644
index 0000000..3309454
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.c
@@ -0,0 +1,13 @@
+if (ub >= lb)
+  for (int c0 = 1; c0 <= ub; c0 += 1)
+    for (int c1 = c0; c1 <= n; c1 += 1) {
+      if (c0 >= lb && c1 >= c0 + 1) {
+        s0(c0, c1);
+        if (n >= ub + 1)
+          s2(c0, c1);
+      } else if (lb >= c0 + 1) {
+        s3(c0, c1, lb, c0, c1);
+      }
+      for (int c3 = max(lb, c0); c3 <= ub; c3 += 1)
+        s1(c0, c1, c3);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.in
new file mode 100644
index 0000000..0dd0953
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-0.in
@@ -0,0 +1,3 @@
+[n, lb, ub] -> { s1[k, i, j] -> [k, i, 1, j, 0, 0, 0, 0] : k >= 1 and j >= k and j <= n and j <= ub and i >= k and i <= n and j >= lb; s3[k, i, lb, k, i] -> [k, i, 1, lb, -1, k, i, 0] : k >= 1 and k <= -1 + lb and lb <= n and ub >= lb and i >= k and i <= n; s0[k, i] -> [k, i, 0, 0, 0, 0, 0, 0] : k >= 1 and k >= lb and i >= 1 + k and i <= n and k <= ub; s2[k, i] -> [k, i, 0, 0, 1, 0, 0, 0] : k >= 1 and k >= lb and k <= ub and ub <= -1 + n and i >= 1 + k and i <= n }
+[lb, n, ub] -> {  : ub <= n and lb >= 1 }
+[n, lb, ub] -> { [i0, i1, i2, i3, i4, i5, i6, i7] -> atomic[o0] : o0 <= 7; [i0, i1, i2, i3, i4, i5, i6, i7] -> separate[o0] : o0 >= 8 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.c
new file mode 100644
index 0000000..3309454
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.c
@@ -0,0 +1,13 @@
+if (ub >= lb)
+  for (int c0 = 1; c0 <= ub; c0 += 1)
+    for (int c1 = c0; c1 <= n; c1 += 1) {
+      if (c0 >= lb && c1 >= c0 + 1) {
+        s0(c0, c1);
+        if (n >= ub + 1)
+          s2(c0, c1);
+      } else if (lb >= c0 + 1) {
+        s3(c0, c1, lb, c0, c1);
+      }
+      for (int c3 = max(lb, c0); c3 <= ub; c3 += 1)
+        s1(c0, c1, c3);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.in
new file mode 100644
index 0000000..5d628be
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/lu_spmd-1.in
@@ -0,0 +1,3 @@
+[n, lb, ub] -> { s1[k, i, j] -> [k, i, 1, j, 0, 0, 0, 0] : k >= 1 and j >= k and j <= n and j <= ub and i >= k and i <= n and j >= lb; s3[k, i, lb, k, i] -> [k, i, 1, lb, -1, k, i, 0] : k >= 1 and k <= -1 + lb and lb <= n and ub >= lb and i >= k and i <= n; s0[k, i] -> [k, i, 0, 0, 0, 0, 0, 0] : k >= 1 and k >= lb and i >= 1 + k and i <= n and k <= ub; s2[k, i] -> [k, i, 0, 0, 1, 0, 0, 0] : k >= 1 and k >= lb and k <= ub and ub <= -1 + n and i >= 1 + k and i <= n }
+[lb, n, ub] -> {  : ub <= n and lb >= 1 }
+[n, lb, ub] -> { [i0, i1, i2, i3, i4, i5, i6, i7] -> atomic[o0] : o0 <= 6; [i0, i1, i2, i3, i4, i5, i6, i7] -> separate[o0] : o0 >= 7 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m1-0.c
new file mode 100644
index 0000000..bb14935
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m1-0.c
@@ -0,0 +1,6 @@
+for (int c0 = 1; c0 <= 9; c0 += 1)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    s0(c0, c1);
+    if (c0 == 5)
+      s1(5, c1);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m1-0.in
new file mode 100644
index 0000000..ca2b8a9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m1-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [i, j, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[5, j] -> [5, j, 1] : j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m1-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m1-1.c
new file mode 100644
index 0000000..580c5af
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m1-1.c
@@ -0,0 +1,14 @@
+for (int c0 = 1; c0 <= 9; c0 += 1) {
+  if (c0 >= 6) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s0(c0, c1);
+  } else if (c0 <= 4) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s0(c0, c1);
+  } else {
+    for (int c1 = 1; c1 <= 9; c1 += 1) {
+      s0(5, c1);
+      s1(5, c1);
+    }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m1-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m1-1.in
new file mode 100644
index 0000000..08dbf45
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m1-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [i, j, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[5, j] -> [5, j, 1] : j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m10-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m10-0.c
new file mode 100644
index 0000000..2b51c7b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m10-0.c
@@ -0,0 +1,7 @@
+for (int c0 = 1; c0 <= 18; c0 += 1)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    if (c0 % 2 == 0)
+      s0(c1, c0 / 2);
+    if (c0 <= 9)
+      s1(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m10-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m10-0.in
new file mode 100644
index 0000000..3046811
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m10-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [4j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [2j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m10-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m10-1.c
new file mode 100644
index 0000000..2275457
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m10-1.c
@@ -0,0 +1,15 @@
+for (int c0 = 1; c0 <= 18; c0 += 1) {
+  if (c0 >= 2 && c0 <= 9) {
+    for (int c1 = 1; c1 <= 9; c1 += 1) {
+      if (c0 % 2 == 0)
+        s0(c1, c0 / 2);
+      s1(c1, c0);
+    }
+  } else if (c0 == 1) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s1(c1, 1);
+  } else if (c0 % 2 == 0) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s0(c1, c0 / 2);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m10-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m10-1.in
new file mode 100644
index 0000000..81dfc3b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m10-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [4j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [2j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m11-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m11-0.c
new file mode 100644
index 0000000..bf727b3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m11-0.c
@@ -0,0 +1,6 @@
+for (int c0 = 1; c0 <= min(4, floord(2 * m - 1, 17) + 1); c0 += 1)
+  for (int c1 = 1; c1 <= min(2, -2 * c0 + (2 * m + 3 * c0 - 4) / 10 + 3); c1 += 1)
+    for (int c2 = 0; c2 <= min(2, -c0 - c1 + (2 * m + 3 * c0 + 10 * c1 + 6) / 20 + 1); c2 += 1)
+      for (int c3 = 8 * c0 + (c0 + 1) / 2 - 8; c3 <= min(min(30, m - 5 * c1 - 10 * c2 + 5), 8 * c0 + c0 / 2); c3 += 1)
+        for (int c4 = 5 * c1 + 10 * c2 - 4; c4 <= min(5 * c1 + 10 * c2, m - c3 + 1); c4 += 1)
+          s0(c0, c1, c2, c3, c4, -9 * c0 + c3 + c0 / 2 + 9, -5 * c1 - 5 * c2 + c4 + 5);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m11-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m11-0.in
new file mode 100644
index 0000000..d85fcf2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m11-0.in
@@ -0,0 +1,3 @@
+[m] -> { s0[In_1, In_2, In_3, In_4, In_5, In_6, 5 - 5In_2 - 5In_3 + In_5] -> [In_1, In_2, In_3, In_4, In_5, In_6, 5 - 5In_2 - 5In_3 + In_5] : In_2 >= 1 and 2In_3 >= 1 - In_2 and In_2 <= 2 and 2In_3 <= 6 - In_2 and In_4 <= 30 and In_1 >= 1 and 2In_6 <= 18 - 17In_1 + 2In_4 and 2In_6 >= 17 - 17In_1 + 2In_4 and In_5 <= 5In_2 + 10In_3 and In_5 >= -4 + 5In_2 + 10In_3 and 2In_4 <= 17In_1 and 2In_4 >= -16 + 17In_1 and In_5 <= 1 + m - In_4 }
+{  :  }
+[m] -> { [i0, i1, i2, i3, i4, i5, i6] -> atomic[o0] : o0 <= 5; [i0, i1, i2, i3, i4, i5, i6] -> separate[o0] : o0 >= 6 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m12-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m12-0.c
new file mode 100644
index 0000000..2dc6ab1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m12-0.c
@@ -0,0 +1,3 @@
+for (int c1 = 1; c1 <= n; c1 += 1)
+  for (int c2 = 1; c2 <= m; c2 += 1)
+    s0(1, c1, c2, 0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m12-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m12-0.in
new file mode 100644
index 0000000..0c988ab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m12-0.in
@@ -0,0 +1,3 @@
+[m, n] -> { s0[1, In_2, In_3, 0] -> [1, In_2, In_3, 0] : In_3 >= 1 and In_3 <= m and In_2 >= 1 and In_2 <= n }
+{  :  }
+[m, n] -> { [i0, i1, i2, i3] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m12-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m12-1.c
new file mode 100644
index 0000000..f72181e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m12-1.c
@@ -0,0 +1,25 @@
+{
+  for (int c1 = 1; c1 <= n; c1 += 1)
+    for (int c2 = 1; c2 <= m; c2 += 1) {
+      s0(1, c1, c2, 0);
+      s1(1, c1, c2, 0);
+    }
+  for (int c1 = 1; c1 <= n; c1 += 1) {
+    s3(2, c1, 0, 0);
+    s2(2, c1, 0, 0);
+  }
+  for (int c1 = 1; c1 <= m; c1 += 1) {
+    for (int c3 = 1; c3 <= n; c3 += 1) {
+      s4(3, c1, 1, c3);
+      s5(3, c1, 1, c3);
+    }
+    for (int c3 = 1; c3 <= n; c3 += 1) {
+      s7(3, c1, 2, c3);
+      s6(3, c1, 2, c3);
+    }
+  }
+  for (int c1 = 1; c1 <= m; c1 += 1) {
+    s8(4, c1, 0, 0);
+    s9(4, c1, 0, 0);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m12-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m12-1.in
new file mode 100644
index 0000000..355075f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m12-1.in
@@ -0,0 +1,3 @@
+[m, n] -> { s1[1, In_2, In_3, 0] -> [1, In_2, In_3, 0] : In_3 >= 1 and In_3 <= m and In_2 >= 1 and In_2 <= n; s2[2, In_2, 0, 0] -> [2, In_2, 0, 0] : In_2 >= 1 and In_2 <= n; s3[2, In_2, 0, 0] -> [2, In_2, 0, 0] : In_2 >= 1 and In_2 <= n; s8[4, In_2, 0, 0] -> [4, In_2, 0, 0] : In_2 >= 1 and In_2 <= m; s0[1, In_2, In_3, 0] -> [1, In_2, In_3, 0] : In_3 >= 1 and In_3 <= m and In_2 >= 1 and In_2 <= n; s7[3, In_2, 2, In_4] -> [3, In_2, 2, In_4] : In_4 >= 1 and In_4 <= n and In_2 >= 1 and In_2 <= m; s4[3, In_2, 1, In_4] -> [3, In_2, 1, In_4] : In_4 >= 1 and In_4 <= n and In_2 >= 1 and In_2 <= m; s6[3, In_2, 2, In_4] -> [3, In_2, 2, In_4] : In_4 >= 1 and In_4 <= n and In_2 >= 1 and In_2 <= m; s9[4, In_2, 0, 0] -> [4, In_2, 0, 0] : In_2 >= 1 and In_2 <= m; s5[3, In_2, 1, In_4] -> [3, In_2, 1, In_4] : In_4 >= 1 and In_4 <= n and In_2 >= 1 and In_2 <= m }
+{  :  }
+[m, n] -> { [i0, i1, i2, i3] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m2-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m2-0.c
new file mode 100644
index 0000000..08ee8dc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m2-0.c
@@ -0,0 +1,12 @@
+for (int c0 = 2; c0 <= 9; c0 += 1) {
+  if (c0 >= 5) {
+    s1(c0, 1);
+    for (int c1 = 2; c1 <= 9; c1 += 1) {
+      s1(c0, c1);
+      s0(c0, c1);
+    }
+  } else {
+    for (int c1 = 2; c1 <= 9; c1 += 1)
+      s0(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m2-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m2-0.in
new file mode 100644
index 0000000..ae7780e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m2-0.in
@@ -0,0 +1,3 @@
+{ s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 5 and In_1 <= 9 and In_2 >= 1 and In_2 <= 9; s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_1 <= 9 and In_2 >= 2 and In_2 <= 9 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m2-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m2-1.c
new file mode 100644
index 0000000..09255e0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m2-1.c
@@ -0,0 +1,12 @@
+{
+  for (int c0 = 2; c0 <= 4; c0 += 1)
+    for (int c1 = 2; c1 <= 9; c1 += 1)
+      s0(c0, c1);
+  for (int c0 = 5; c0 <= 9; c0 += 1) {
+    s1(c0, 1);
+    for (int c1 = 2; c1 <= 9; c1 += 1) {
+      s1(c0, c1);
+      s0(c0, c1);
+    }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m2-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m2-1.in
new file mode 100644
index 0000000..32302bb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m2-1.in
@@ -0,0 +1,3 @@
+{ s1[In_1, In_2] -> [In_1, In_2] : In_1 >= 5 and In_1 <= 9 and In_2 >= 1 and In_2 <= 9; s0[In_1, In_2] -> [In_1, In_2] : In_1 >= 2 and In_1 <= 9 and In_2 >= 2 and In_2 <= 9 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= -1; [i0, i1] -> separate[o0] : o0 >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m3-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m3-0.c
new file mode 100644
index 0000000..d3d6970
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m3-0.c
@@ -0,0 +1,3 @@
+for (int c0 = -9; c0 <= 9; c0 += 1)
+  for (int c1 = max(1, -c0 + 1); c1 <= min(10, -c0 + 10); c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m3-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m3-0.in
new file mode 100644
index 0000000..82e1093
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m3-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_2 >= 1 - In_1 and In_2 >= 1 and In_2 <= 10 - In_1 and In_2 <= 10 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m4-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m4-0.c
new file mode 100644
index 0000000..a528073
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m4-0.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= 9; c0 += 1)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    s0(c1, c0);
+    s1(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m4-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m4-0.in
new file mode 100644
index 0000000..b7912a3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m4-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m4-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m4-1.c
new file mode 100644
index 0000000..a528073
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m4-1.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= 9; c0 += 1)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    s0(c1, c0);
+    s1(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m4-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m4-1.in
new file mode 100644
index 0000000..c9e17d9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m4-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m7-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m7-0.c
new file mode 100644
index 0000000..d9f93d9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m7-0.c
@@ -0,0 +1,6 @@
+for (int c0 = 1; c0 <= 9; c0 += 1)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    s0(c1, c0);
+    if (c0 % 2 == 0)
+      s1(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m7-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m7-0.in
new file mode 100644
index 0000000..45a1850
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m7-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [j, i, 1] : exists (e0 = [(j)/2]: 2e0 = j and i >= 1 and i <= 9 and j >= 2 and j <= 8) }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m7-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m7-1.c
new file mode 100644
index 0000000..d33abe9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m7-1.c
@@ -0,0 +1,11 @@
+for (int c0 = 1; c0 <= 9; c0 += 1) {
+  if ((c0 + 1) % 2 == 0) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s0(c1, c0);
+  } else {
+    for (int c1 = 1; c1 <= 9; c1 += 1) {
+      s0(c1, c0);
+      s1(c1, c0);
+    }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m7-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m7-1.in
new file mode 100644
index 0000000..f4b6f6f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m7-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [j, i, 1] : exists (e0 = [(j)/2]: 2e0 = j and i >= 1 and i <= 9 and j >= 2 and j <= 8) }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m8-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m8-0.c
new file mode 100644
index 0000000..9aaed9e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m8-0.c
@@ -0,0 +1,6 @@
+for (int c0 = 2; c0 <= 8; c0 += 2)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    if (c0 % 4 == 0)
+      s0(c1, c0);
+    s1(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m8-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m8-0.in
new file mode 100644
index 0000000..e9a0e39
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m8-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [j, i, 0] : exists (e0 = [(j)/4]: 4e0 = j and i >= 1 and i <= 9 and j >= 4 and j <= 8); s1[i, j] -> [j, i, 1] : exists (e0 = [(j)/2]: 2e0 = j and i >= 1 and i <= 9 and j >= 2 and j <= 8) }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m8-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m8-1.c
new file mode 100644
index 0000000..4f8a00f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m8-1.c
@@ -0,0 +1,11 @@
+for (int c0 = 2; c0 <= 8; c0 += 2) {
+  if ((c0 + 2) % 4 == 0) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s1(c1, c0);
+  } else {
+    for (int c1 = 1; c1 <= 9; c1 += 1) {
+      s0(c1, c0);
+      s1(c1, c0);
+    }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m8-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m8-1.in
new file mode 100644
index 0000000..80e57e4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m8-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [j, i, 0] : exists (e0 = [(j)/4]: 4e0 = j and i >= 1 and i <= 9 and j >= 4 and j <= 8); s1[i, j] -> [j, i, 1] : exists (e0 = [(j)/2]: 2e0 = j and i >= 1 and i <= 9 and j >= 2 and j <= 8) }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m9-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/m9-0.c
new file mode 100644
index 0000000..a528073
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m9-0.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= 9; c0 += 1)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    s0(c1, c0);
+    s1(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m9-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/m9-0.in
new file mode 100644
index 0000000..fc38bf2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m9-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [2j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [2j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m9-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/m9-1.c
new file mode 100644
index 0000000..a528073
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m9-1.c
@@ -0,0 +1,5 @@
+for (int c0 = 1; c0 <= 9; c0 += 1)
+  for (int c1 = 1; c1 <= 9; c1 += 1) {
+    s0(c1, c0);
+    s1(c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/m9-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/m9-1.in
new file mode 100644
index 0000000..398e326
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/m9-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [2j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [2j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/olda-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/olda-0.c
new file mode 100644
index 0000000..b05f991
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/olda-0.c
@@ -0,0 +1,8 @@
+for (int c0 = 1; c0 <= morb; c0 += 1)
+  for (int c1 = 1; c1 <= np; c1 += 1)
+    for (int c2 = 1; c2 <= np; c2 += 1) {
+      if (c2 >= c1)
+        s0(c2, c1, c0);
+      if (c1 >= c2)
+        s1(c1, c2, c0);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/olda-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/olda-0.in
new file mode 100644
index 0000000..88f86f5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/olda-0.in
@@ -0,0 +1,3 @@
+[np, morb] -> { s0[mp, mq, mi] -> [mi, mq, mp, 0] : mq >= 1 and mq <= mp and mp <= np and mi >= 1 and mi <= morb; s1[mp, mq, mi] -> [mi, mp, mq, 1] : mq >= 1 and mq <= mp and mp <= np and mi >= 1 and mi <= morb }
+{  :  }
+[np, morb] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2; [i0, i1, i2, i3] -> separate[o0] : o0 >= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/olda-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/olda-1.c
new file mode 100644
index 0000000..4b30980
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/olda-1.c
@@ -0,0 +1,9 @@
+for (int c0 = 1; c0 <= morb; c0 += 1)
+  for (int c1 = 1; c1 <= np; c1 += 1) {
+    for (int c2 = 1; c2 < c1; c2 += 1)
+      s1(c1, c2, c0);
+    s0(c1, c1, c0);
+    s1(c1, c1, c0);
+    for (int c2 = c1 + 1; c2 <= np; c2 += 1)
+      s0(c2, c1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/olda-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/olda-1.in
new file mode 100644
index 0000000..a3a387f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/olda-1.in
@@ -0,0 +1,3 @@
+[np, morb] -> { s0[mp, mq, mi] -> [mi, mq, mp, 0] : mq >= 1 and mq <= mp and mp <= np and mi >= 1 and mi <= morb; s1[mp, mq, mi] -> [mi, mp, mq, 1] : mq >= 1 and mq <= mp and mp <= np and mi >= 1 and mi <= morb }
+{  :  }
+[np, morb] -> { [i0, i1, i2, i3] -> atomic[o0] : o0 <= 1; [i0, i1, i2, i3] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.c
new file mode 100644
index 0000000..c676558
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.c
@@ -0,0 +1,4 @@
+if (P2 >= 0 && P2 <= 3 && P1 == P2)
+  for (int c0 = 0; c0 <= min(2, -P2 + 4); c0 += 1)
+    for (int c2 = (-P2 - c0 + 6) % 3; c2 <= 3; c2 += 3)
+      s0(c0, c0, c2, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.in
new file mode 100644
index 0000000..5b277a1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft-0.in
@@ -0,0 +1,3 @@
+[P2, P1] -> { s0[In_1, In_1, In_3, In_3] -> [In_1, In_1, In_3, In_3] : exists (e0 = [(-2P2 - 2In_1 + In_3)/3]: P1 = P2 and 3e0 = -2P2 - 2In_1 + In_3 and P2 >= 0 and P2 <= 3 and In_1 <= 4 - P2 and In_1 >= 0 and In_1 <= 2 and In_3 >= 0 and In_3 <= 3) }
+{  :  }
+[P2, P1] -> { [i0, i1, i2, i3] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.c
new file mode 100644
index 0000000..ab1bc72
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.c
@@ -0,0 +1,11 @@
+if (P1 >= 0 && P1 <= 3 && P2 >= 0 && P2 <= 3)
+  for (int c0 = P1 - 1; c0 <= 3; c0 += 1)
+    for (int c2 = 0; c2 <= 7; c2 += 1)
+      for (int c3 = 0; c3 <= 7; c3 += 1)
+        if (4 * P2 >= 2 * c3 + 9 * floord(4 * P2 - 2 * c3 - 1, 9) + 6) {
+          if (P1 >= 1 && c0 + 1 == P1 && 4 * P1 >= 2 * c2 + 9 * floord(4 * P1 - 2 * c2 - 1, 9) + 7) {
+            s0(P1 - 1, P2, c2, c3, ((-4 * P1 + 2 * c2 + 9) % 9) + 1, -4 * P2 + 2 * c3 - 9 * floord(-4 * P2 + 2 * c3, 9));
+          } else if (P1 == 0 && c0 == 3 && c2 % 4 == 0) {
+            s0(3, P2, c2, c3, (-c2 / 4) + 3, -4 * P2 + 2 * c3 - 9 * floord(-4 * P2 + 2 * c3, 9));
+          }
+        }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.in
new file mode 100644
index 0000000..f44b9bf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p.delft2-0.in
@@ -0,0 +1,3 @@
+[P1, P2] -> { s0[In_1, P2, In_3, In_4, In_5, In_6] -> [In_1, P2, In_3, In_4, In_5, In_6] : (exists (e0 = [(8 + 4In_1 + 16In_3 + In_5)/9], e1 = [(12 - 4P1 + 9e0)/16], e2 = [(-2In_1 - 2In_3 + In_5)/3], e3 = [(-5P2 - 2In_4 + In_6)/9]: 3e2 = -2In_1 - 2In_3 + In_5 and 9e3 = -5P2 - 2In_4 + In_6 and P1 >= 0 and In_1 >= 1 + P1 and In_1 <= 3 and P2 >= 0 and P2 <= 3 and In_6 >= 0 and In_6 <= 3 and In_5 >= 0 and In_5 <= 3 and In_5 >= 1 - 4In_1 - 16In_3 and In_5 <= 126 - 4In_1 - 16In_3 and In_6 <= 126 - 4P2 - 16In_4 and 16e1 <= -4P1 + 9e0 and 2In_6 <= P2 + 4In_4 and 9e0 <= 3 + 4In_1 + 16In_3 + In_5 and 9e0 >= 4In_1 + 16In_3 + In_5 and 16e1 >= -3 - 4P1 + 9e0)) or (exists (e0 = [(8 + 4In_1 + 16In_3 + In_5)/9], e1 = [(12 - 4P1 + 9e0)/16], e2 = [(-2In_1 - 2In_3 + In_5)/3], e3 = [(-5P2 - 2In_4 + In_6)/9]: 3e2 = -2In_1 - 2In_3 + In_5 and 9e3 = -5P2 - 2In_4 + In_6 and In_1 >= 0 and In_1 <= -1 + P1 and P1 <= 3 and In_6 >= 0 and In_6 <= 3 and In_6 <= 1 + 2In_4 and P2 >= 0 and P2 <= 3 and In_5 >= 0 and In_5 <= 3 and In_5 >= 1 - 4In_1 - 16In_3 and In_5 <= 126 - 4In_1 - 16In_3 and In_6 <= 126 - 4P2 - 16In_4 and 16e1 <= -4P1 + 9e0 and 9e0 <= 3 + 4In_1 + 16In_3 + In_5 and 9e0 >= 4In_1 + 16In_3 + In_5 and 16e1 >= -3 - 4P1 + 9e0)) }
+{  :  }
+[P1, P2] -> { [i0, i1, i2, i3, i4, i5] -> atomic[o0] : o0 <= 4; [i0, i1, i2, i3, i4, i5] -> separate[o0] : o0 >= 5 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p6-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/p6-0.c
new file mode 100644
index 0000000..53995e9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p6-0.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 5; c0 <= 8; c0 += 1)
+    s0(c0);
+  for (int c0 = 10; c0 <= 16; c0 += 2)
+    s0(c0);
+  for (int c0 = 20; c0 <= 25; c0 += 1)
+    s0(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p6-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/p6-0.in
new file mode 100644
index 0000000..025da3d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p6-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1] -> [In_1] : (In_1 >= 5 and In_1 <= 8) or (exists (e0 = [(In_1)/2]: 2e0 = In_1 and In_1 >= 10 and In_1 <= 16)) or (In_1 >= 20 and In_1 <= 25) }
+{  :  }
+{ [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p6-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/p6-1.c
new file mode 100644
index 0000000..d3d6970
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p6-1.c
@@ -0,0 +1,3 @@
+for (int c0 = -9; c0 <= 9; c0 += 1)
+  for (int c1 = max(1, -c0 + 1); c1 <= min(10, -c0 + 10); c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/p6-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/p6-1.in
new file mode 100644
index 0000000..82e1093
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/p6-1.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : In_2 >= 1 - In_1 and In_2 >= 1 and In_2 <= 10 - In_1 and In_2 <= 10 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.c
new file mode 100644
index 0000000..c65c2e3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.c
@@ -0,0 +1,2 @@
+for (int c0 = 3; c0 <= 9; c0 += 3)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.in
new file mode 100644
index 0000000..e099087
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride1-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1] -> [In_1] : exists (e0 = [(In_1)/3]: 3e0 = In_1 and In_1 >= 3 and In_1 <= 9) }
+{  :  }
+{ [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.c
new file mode 100644
index 0000000..0a7e8e7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= n; c0 += 32)
+  for (int c1 = c0; c1 <= min(n, c0 + 31); c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.in
new file mode 100644
index 0000000..73dc13d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride2-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(In_1)/32]: 32e0 = In_1 and In_2 <= 31 + In_1 and In_1 >= 0 and In_2 >= In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.c
new file mode 100644
index 0000000..8913c80
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 3; c0 <= n; c0 += 32)
+  for (int c1 = c0; c1 <= min(n, c0 + 31); c1 += 1)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.in
new file mode 100644
index 0000000..360d7d0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride3-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(-3 + In_1)/32]: 32e0 = -3 + In_1 and In_2 <= 31 + In_1 and In_1 >= 3 and In_2 >= In_1 and In_2 <= n) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.c
new file mode 100644
index 0000000..ed62b59
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.c
@@ -0,0 +1,2 @@
+for (int c0 = 18; c0 <= 98; c0 += 5)
+  s0(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.in
new file mode 100644
index 0000000..8779c3c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride4-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1] -> [In_1] : exists (e0 = [(-3 + In_1)/5]: 5e0 = -3 + In_1 and In_1 >= 18 and In_1 <= 98) }
+{  :  }
+{ [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.c
new file mode 100644
index 0000000..2eeeb5a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 2; c0 <= min(100, -2 * n + 400); c0 += 2)
+  for (int c1 = 2 * n + c0; c1 <= 400; c1 += 2)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.in
new file mode 100644
index 0000000..c26c547
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride5-0.in
@@ -0,0 +1,3 @@
+[n] -> { s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(In_1)/2], e1 = [(In_2)/2]: 2e0 = In_1 and 2e1 = In_2 and In_1 >= 2 and In_1 <= 100 and In_2 <= 400 and In_2 >= 2n + In_1) }
+{  :  }
+[n] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.c
new file mode 100644
index 0000000..f4df469
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= 101; c0 += 1)
+  for (int c1 = -((c0 - 1) % 2) + c0 + 1; c1 <= 400; c1 += 2)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.in
new file mode 100644
index 0000000..16fda74
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-0.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(In_2)/2]: 2e0 = In_2 and In_1 >= 1 and In_2 >= In_1 and In_2 <= 400 and In_1 <= 101) }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.c
new file mode 100644
index 0000000..070028f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.c
@@ -0,0 +1,3 @@
+for (int c0 = 2; c0 <= 100; c0 += 2)
+  for (int c1 = c0; c1 <= 400; c1 += 2)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.in
new file mode 100644
index 0000000..91eaab2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-1.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(In_1)/2], e1 = [(In_2)/2]: 2e0 = In_1 and 2e1 = In_2 and In_1 >= 2 and In_2 >= In_1 and In_2 <= 400 and In_1 <= 100) }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.c
new file mode 100644
index 0000000..070028f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.c
@@ -0,0 +1,3 @@
+for (int c0 = 2; c0 <= 100; c0 += 2)
+  for (int c1 = c0; c1 <= 400; c1 += 2)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.in
new file mode 100644
index 0000000..91eaab2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride6-2.in
@@ -0,0 +1,3 @@
+{ s0[In_1, In_2] -> [In_1, In_2] : exists (e0 = [(In_1)/2], e1 = [(In_2)/2]: 2e0 = In_1 and 2e1 = In_2 and In_1 >= 2 and In_2 >= In_1 and In_2 <= 400 and In_1 <= 100) }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.c
new file mode 100644
index 0000000..a1f7a18
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.c
@@ -0,0 +1,15 @@
+for (int c0 = 1; c0 <= 36; c0 += 1) {
+  if (c0 <= 3) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s1(c1, c0);
+  } else if (c0 <= 9) {
+    for (int c1 = 1; c1 <= 9; c1 += 1) {
+      if (c0 % 4 == 0)
+        s0(c1, c0 / 4);
+      s1(c1, c0);
+    }
+  } else if (c0 % 4 == 0) {
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s0(c1, c0 / 4);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.in
new file mode 100644
index 0000000..b84f204
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [4j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.c
new file mode 100644
index 0000000..e79d58d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.c
@@ -0,0 +1,14 @@
+{
+  for (int c0 = 1; c0 <= 3; c0 += 1)
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s1(c1, c0);
+  for (int c0 = 4; c0 <= 9; c0 += 1)
+    for (int c1 = 1; c1 <= 9; c1 += 1) {
+      if (c0 % 4 == 0)
+        s0(c1, c0 / 4);
+      s1(c1, c0);
+    }
+  for (int c0 = 3; c0 <= 9; c0 += 1)
+    for (int c1 = 1; c1 <= 9; c1 += 1)
+      s0(c1, c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.in
new file mode 100644
index 0000000..3ec82b9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/stride7-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [4j, i, 0] : i >= 1 and i <= 9 and j >= 1 and j <= 9; s1[i, j] -> [j, i, 1] : i >= 1 and i <= 9 and j >= 1 and j <= 9 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 0; [i0, i1, i2] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.c
new file mode 100644
index 0000000..b12c07d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= 10; c0 += 1)
+  for (int c1 = max(2 * c0 - 4, c0); c1 <= min(2 * c0, c0 + 6); c1 += 1)
+    s0(2 * c0 - c1, -c0 + c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.in
new file mode 100644
index 0000000..f4af716
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [i + j, i + 2j] : i >= 0 and i <= 4 and j >= 0 and j <= 6 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.c
new file mode 100644
index 0000000..51ab952
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.c
@@ -0,0 +1,3 @@
+for (int c0 = 0; c0 <= 14; c0 += 1)
+  for (int c1 = max(2 * c0 - 12, -c0 + 3 * ((c0 + 1) / 2)); c1 <= min(2 * c0, c0 / 2 + 9); c1 += 3)
+    s0((2 * c0 - c1) / 3, (-c0 + 2 * c1) / 3);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.in
new file mode 100644
index 0000000..504b220
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [2i + j, i + 2j] : i >= 0 and i <= 4 and j >= 0 and j <= 6 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.c
new file mode 100644
index 0000000..9748950
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.c
@@ -0,0 +1,2 @@
+for (int c0 = -3; c0 <= 96; c0 += 1)
+  s0(c0, c0 + 4);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.in
new file mode 100644
index 0000000..bc9af0c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-2.in
@@ -0,0 +1,3 @@
+{ s0[i, 4 + i] -> [i, 4 + i] : i >= -3 and i <= 96 }
+{  :  }
+{ [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.c
new file mode 100644
index 0000000..86c197f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.c
@@ -0,0 +1 @@
+s0(n + 19);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.in
new file mode 100644
index 0000000..ea1ac1a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-3.in
@@ -0,0 +1,3 @@
+[n] -> { s0[19 + n] -> [19 + n] }
+{  :  }
+[n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.c b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.c
new file mode 100644
index 0000000..27b3199
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.c
@@ -0,0 +1 @@
+s0(n + 1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.in b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.in
new file mode 100644
index 0000000..ecb07cd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/substitution-4.in
@@ -0,0 +1,3 @@
+[n] -> { s0[i] -> [i] : exists (e0 = [(-1 - n + i)/18]: 18e0 = -1 - n + i and i <= 16 + n and i >= 1 + n) }
+{  :  }
+[n] -> { [i0] -> separate[o0] : o0 >= 0; [i0] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.c
new file mode 100644
index 0000000..bb3ef7f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.c
@@ -0,0 +1,4 @@
+for (int c0 = 1; c0 <= min(n, 2 * b - 1); c0 += 1)
+  for (int c1 = max(-n + 1, -b + 1); c1 <= min(b - c0, n - c0); c1 += 1)
+    for (int c2 = max(1, c0 + c1); c2 <= min(n, n + c1); c2 += 1)
+      s0(-c0 - c1 + c2 + 1, -c1 + c2, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.in
new file mode 100644
index 0000000..28a7deb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-0.in
@@ -0,0 +1,3 @@
+[n, b] -> { s0[i, j, k] -> [1 - i + j, -j + k, k] : i >= 1 and j >= i and j <= n and k >= 1 and k <= n and k <= -1 + b + i and k >= 1 - b + j }
+{  :  }
+[n, b] -> { [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.c
new file mode 100644
index 0000000..22ec83e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.c
@@ -0,0 +1,4 @@
+for (int c0 = 1; c0 <= min(n, 2 * b - 1); c0 += 1)
+  for (int c1 = -b + 1; c1 <= b - c0; c1 += 1)
+    for (int c2 = max(1, c0 + c1); c2 <= min(n, n + c1); c2 += 1)
+      s0(-c0 - c1 + c2 + 1, -c1 + c2, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.in
new file mode 100644
index 0000000..496aebe
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-1.in
@@ -0,0 +1,3 @@
+[n, b] -> { s0[i, j, k] -> [1 - i + j, -j + k, k] : i >= 1 and j >= i and j <= n and k >= 1 and k <= n and k <= -1 + b + i and k >= 1 - b + j }
+[b, n] -> {  : b >= 1 and n >= b }
+[n, b] -> { [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.c b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.c
new file mode 100644
index 0000000..bb3ef7f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.c
@@ -0,0 +1,4 @@
+for (int c0 = 1; c0 <= min(n, 2 * b - 1); c0 += 1)
+  for (int c1 = max(-n + 1, -b + 1); c1 <= min(b - c0, n - c0); c1 += 1)
+    for (int c2 = max(1, c0 + c1); c2 <= min(n, n + c1); c2 += 1)
+      s0(-c0 - c1 + c2 + 1, -c1 + c2, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.in b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.in
new file mode 100644
index 0000000..28a7deb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-2.in
@@ -0,0 +1,3 @@
+[n, b] -> { s0[i, j, k] -> [1 - i + j, -j + k, k] : i >= 1 and j >= i and j <= n and k >= 1 and k <= n and k <= -1 + b + i and k >= 1 - b + j }
+{  :  }
+[n, b] -> { [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.c b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.c
new file mode 100644
index 0000000..22ec83e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.c
@@ -0,0 +1,4 @@
+for (int c0 = 1; c0 <= min(n, 2 * b - 1); c0 += 1)
+  for (int c1 = -b + 1; c1 <= b - c0; c1 += 1)
+    for (int c2 = max(1, c0 + c1); c2 <= min(n, n + c1); c2 += 1)
+      s0(-c0 - c1 + c2 + 1, -c1 + c2, c2);
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.in b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.in
new file mode 100644
index 0000000..496aebe
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/syr2k-3.in
@@ -0,0 +1,3 @@
+[n, b] -> { s0[i, j, k] -> [1 - i + j, -j + k, k] : i >= 1 and j >= i and j <= n and k >= 1 and k <= n and k <= -1 + b + i and k >= 1 - b + j }
+[b, n] -> {  : b >= 1 and n >= b }
+[n, b] -> { [i0, i1, i2] -> separate[o0] : o0 >= 2; [i0, i1, i2] -> atomic[o0] : o0 <= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.c
new file mode 100644
index 0000000..db05735
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.c
@@ -0,0 +1,15 @@
+{
+  for (int c1 = 0; c1 <= 1; c1 += 1) {
+    if (c1 == 1) {
+      s0(1, 1, 1, 0, 0);
+      s0(1, 1, 1, N - 1, 0);
+    } else {
+      for (int c3 = 0; c3 < N; c3 += 1)
+        s0(1, 0, 1, c3, 0);
+    }
+  }
+  for (int c1 = 0; c1 <= floord(T - 1, 1000); c1 += 1)
+    for (int c2 = 1000 * c1 + 1; c2 <= min(N + T - 3, N + 1000 * c1 + 997); c2 += 1)
+      for (int c3 = max(0, -N - 1000 * c1 + c2 + 2); c3 <= min(min(999, T - 1000 * c1 - 1), -1000 * c1 + c2 - 1); c3 += 1)
+        s1(2, 1000 * c1 + c3, 1, -1000 * c1 + c2 - c3, 1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.in
new file mode 100644
index 0000000..b1f92ea
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check-sblock-0.in
@@ -0,0 +1,3 @@
+[T, N] -> { s1[2, t, 1, i, 1] -> [2, tb, t + i, t - 1000tb, 0] : 1000tb <= t and 1000tb >= -999 + t and i >= 1 and i <= -2 + N and t >= 0 and t <= -1 + T; s0[1, 0, 1, In_4, 0] -> [1, 0, 1, In_4, 0] : In_4 >= 0 and In_4 <= -1 + N; s0[1, 1, 1, 0, 0] -> [1, 1, 1, 0, 0]; s0[1, 1, 1, -1 + N, 0] -> [1, 1, 1, -1 + N, 0] }
+[T, N] -> {  : T >= 0 and N >= 4 }
+[N] -> { [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.c
new file mode 100644
index 0000000..484bd1f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.c
@@ -0,0 +1,13 @@
+{
+  for (int c1 = 0; c1 < N; c1 += 1)
+    s0(1, c1, 1, 0, 0);
+  for (int c1 = 0; c1 <= floord(T - 1, 500); c1 += 1)
+    for (int c2 = 1000 * c1; c2 <= min(N + 2 * T - 3, N + 1000 * c1 + 997); c2 += 1) {
+      for (int c3 = max(0, -((N + c2) % 2) - N - 1000 * c1 + c2 + 2); c3 <= min(min(998, 2 * T - 1000 * c1 - 2), -1000 * c1 + c2 - 2); c3 += 2) {
+        s1(2, 1000 * c1 + c3, 0, -1000 * c1 + c2 - c3, 1);
+        s2(2, 1000 * c1 + c3 + 1, 0, -1000 * c1 + c2 - c3 - 1, 1);
+      }
+      if (2 * T >= c2 + 1 && 1000 * c1 + 999 >= c2)
+        s1(2, ((c2 + 1) % 2) + c2 - 1, 0, -((c2 + 1) % 2) + 1, 1);
+    }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.in
new file mode 100644
index 0000000..ce585b0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-check0-0.in
@@ -0,0 +1,3 @@
+[T, N] -> { s1[2, t, 0, i, 1] -> [2, tb, t + i, t - 1000tb, 1] : exists (e0 = [(t - 1000tb)/2]: 2e0 = t - 1000tb and 1000tb <= t and 1000tb >= -999 + t and i >= 0 and i <= -1 + N and t >= 0 and t <= -2 + 2T); s0[1, In_2, 1, 0, 0] -> [1, In_2, 1, 0, 0] : In_2 >= 0 and In_2 <= -1 + N; s2[2, t, 0, i, 1] -> [2, tb, t + i, t - 1000tb, 1] : exists (e0 = [(-1 + t - 1000tb)/2]: 2e0 = -1 + t - 1000tb and 1000tb <= t and 1000tb >= -999 + t and i >= 1 and i <= -2 + N and t >= 1 and t <= -1 + 2T) }
+[T, N] -> {  : T >= 0 and N >= 4 }
+[N] -> { [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 3; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.c
new file mode 100644
index 0000000..b5569c9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.c
@@ -0,0 +1,36 @@
+{
+  for (int c1 = -1; c1 < T; c1 += 1)
+    for (int c2 = 0; c2 < N; c2 += 1) {
+      if (c1 == -1) {
+        s0(1, -1, c2, 0, 0);
+      } else if (c2 == 0) {
+        s0(1, c1, 0, 0, 0);
+      } else if (c2 + 1 == N) {
+        s0(1, c1, N - 1, 0, 0);
+      }
+    }
+  for (int c1 = 0; c1 <= floord(T - 1, 500); c1 += 1) {
+    for (int c3 = -((c1 + 9) / 8) + 2; c3 <= floord(N - 500 * c1 - 3, 4000) + 1; c3 += 1)
+      for (int c4 = max(500 * c1 + 1, 1000 * c1 + 4000 * c3 - 3999); c4 <= min(min(N + T - 3, 1000 * c1 + 4000 * c3 - 3000), 2 * N - 4000 * c3 + 3995); c4 += 1)
+        for (int c5 = max(0, -N - 500 * c1 + c4 + 2); c5 <= min(min(T - 500 * c1 - 1, -500 * c1 + c4 - 1), -500 * c1 - 2000 * c3 + (c4 + 1) / 2 + 1999); c5 += 1)
+          s1(2, 500 * c1 + c5, 1, -500 * c1 + c4 - c5, 1);
+    for (int c3 = max(-((T + 4000) / 4000) + 2, -((c1 + 9) / 8) + 2); c3 <= floord(N - 500 * c1 - 3, 4000) + 1; c3 += 1)
+      for (int c4 = max(1000 * c1 + 4000 * c3 - 3999, -4000 * c3 + 4000); c4 <= min(min(2 * T + 4000 * c3 - 4000, 1000 * c1 + 4000 * c3 - 3000), 2 * N - 4000 * c3 + 3995); c4 += 1)
+        s2(2, -2000 * c3 + (c4 + 1) / 2 + 1999, 1, 2000 * c3 + c4 - (c4 + 1) / 2 - 1999, 1);
+    for (int c3 = -((c1 + 7) / 8) + 1; c3 <= min(floord(N + T - 1000 * c1 - 1004, 4000) + 1, floord(N - 500 * c1 - 504, 4000) + 1); c3 += 1)
+      for (int c4 = max(500 * c1 + 1, 1000 * c1 + 4000 * c3 - 2999); c4 <= min(min(N + T - 3, N + 500 * c1 + 497), 1000 * c1 + 4000 * c3); c4 += 1)
+        for (int c5 = max(0, -N - 500 * c1 + c4 + 2); c5 <= min(min(499, T - 500 * c1 - 1), -500 * c1 + c4 - 1); c5 += 1)
+          s3(2, 500 * c1 + c5, 1, -500 * c1 + c4 - c5, 1);
+    for (int c3 = max(-((T + 4000) / 4000) + 1, -((c1 + 9) / 8) + 1); c3 <= floord(N - 500 * c1 - 3, 4000); c3 += 1)
+      for (int c4 = max(-4000 * c3, 1000 * c1 + 4000 * c3 + 1); c4 <= min(min(2 * N - 4000 * c3 - 5, 2 * T + 4000 * c3), 1000 * c1 + 4000 * c3 + 1000); c4 += 1)
+        s4(2, -2000 * c3 + (c4 + 1) / 2 - 1, 1, 2000 * c3 + c4 - (c4 + 1) / 2 + 1, 1);
+    for (int c3 = -((c1 + 8) / 8) + 1; c3 <= min(floord(N + T - 1000 * c1 - 4, 4000), floord(N - 500 * c1 + 496, 4000)); c3 += 1)
+      for (int c4 = max(1000 * c1 + 4000 * c3 + 1, -4000 * c3 + 2); c4 <= min(min(min(N + T - 3, N + 500 * c1 + 497), 2 * T + 4000 * c3 - 2), 1000 * c1 + 4000 * c3 + 998); c4 += 1)
+        for (int c5 = max(-N - 500 * c1 + c4 + 2, -500 * c1 - 2000 * c3 + (c4 + 1) / 2); c5 <= min(min(499, T - 500 * c1 - 1), -500 * c1 + c4 - 1); c5 += 1)
+          s5(2, 500 * c1 + c5, 1, -500 * c1 + c4 - c5, 1);
+  }
+  if (T >= 1)
+    for (int c3 = -((T + 3998) / 4000) + 1; c3 <= floord(N - T - 2, 4000) + 1; c3 += 1)
+      for (int c4 = max(T, 2 * T + 4000 * c3 - 4001); c4 < min(N + T - 2, 2 * T + 4000 * c3 - 1); c4 += 1)
+        s6(2, T - 1, 1, -T + c4 + 1, 1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.in
new file mode 100644
index 0000000..0f86a1c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-mp-i_ts-m_b-0.in
@@ -0,0 +1,3 @@
+[T, N] -> { s1[2, t, 1, i, 1] -> [2, tb, 1, proc, t + i, t - 500tb, 0] : 4000proc >= 3000 + t + i - 1000tb and 500tb <= t and 4000proc <= 3999 - t + i and i >= 1 and i <= -2 + N and t >= 0 and t <= -1 + T; s0[1, -1, c, 0, 0] -> [1, -1, c, 0, 0, 0, 0] : c >= 0 and c <= -1 + N; s0[1, b, 0, 0, 0] -> [1, b, 0, 0, 0, 0, 0] : b >= 0 and b <= -1 + T; s0[1, b, -1 + N, 0, 0] -> [1, b, -1 + N, 0, 0, 0, 0] : b >= 0 and b <= -1 + T; s6[2, -1 + T, 1, i, 1] -> [3, tb, 7, proc, -1 + T + i, -1 + T - 500tb, 0] : 500tb <= -1 + T and 500tb >= -500 + T and 4000proc >= 1 - T + i and 4000proc <= 4000 - T + i and i >= 1 and i <= -2 + N and T >= 1; s3[2, t, 1, i, 1] -> [2, tb, 3, proc, t + i, t - 500tb, 0] : 500tb <= t and 500tb >= -499 + t and 4000proc <= 2999 + t + i - 1000tb and 4000proc >= t + i - 1000tb and i >= 1 and i <= -2 + N and t >= 0 and t <= -1 + T; s2[2, t, 1, i, 1] -> [2, tb, 2, proc, t + i, t - 500tb, 0] : 500tb <= t and 500tb >= -499 + t and 4000proc <= 3999 - t + i and 4000proc >= 3998 - t + i and i >= 1 and i <= -2 + N and t >= 0 and t <= -1 + T; s4[2, t, 1, i, 1] -> [2, tb, 4, Out_4, t + i, t - 500tb, 0] : 500tb <= t and 500tb >= -499 + t and 4000Out_4 <= -1 - t + i and 4000Out_4 >= -2 - t + i and i >= 1 and i <= -2 + N and t >= 0 and t <= -1 + T; s5[2, t, 1, i, 1] -> [2, tb, 5, proc, t + i, t - 500tb, 0] : 500tb >= -499 + t and 4000proc <= -1 + t + i - 1000tb and 4000proc >= -t + i and i >= 1 and i <= -2 + N and t >= 0 and t <= -1 + T }
+[T, N] -> {  : T >= 0 and N >= 4 }
+[N, T] -> { [i0, i1, i2, i3, i4, i5, i6] -> atomic[o0] : o0 <= 5; [i0, i1, i2, i3, i4, i5, i6] -> separate[o0] : o0 >= 6 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.c
new file mode 100644
index 0000000..9eff756
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.c
@@ -0,0 +1,10 @@
+{
+  for (int c1 = 0; c1 < N; c1 += 1)
+    s0(1, c1, 1, 0, 0);
+  for (int c1 = 0; c1 < T; c1 += 1) {
+    for (int c3 = 0; c3 < N; c3 += 1)
+      s1(2, c1, 0, c3, 1);
+    for (int c3 = 1; c3 < N - 1; c3 += 1)
+      s2(2, c1, 1, c3, 1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.in
new file mode 100644
index 0000000..153ba7e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/ts1d-orig0-0.in
@@ -0,0 +1,3 @@
+[T, N] -> { s1[2, In_2, 0, In_4, 1] -> [2, In_2, 0, In_4, 1] : In_4 >= 0 and In_4 <= -1 + N and In_2 >= 0 and In_2 <= -1 + T; s0[1, In_2, 1, 0, 0] -> [1, In_2, 1, 0, 0] : In_2 >= 0 and In_2 <= -1 + N; s2[2, In_2, 1, In_4, 1] -> [2, In_2, 1, In_4, 1] : In_4 >= 1 and In_4 <= -2 + N and In_2 >= 0 and In_2 <= -1 + T }
+[T, N] -> {  : T >= 0 and N >= 4 }
+[N] -> { [i0, i1, i2, i3, i4] -> separate[o0] : o0 >= 4; [i0, i1, i2, i3, i4] -> atomic[o0] : o0 <= 3 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.c
new file mode 100644
index 0000000..32ea68e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.c
@@ -0,0 +1,27 @@
+{
+  for (int c0 = a3; c0 <= min(min(a1 - 1, b3), a2 - 1); c0 += 1)
+    s2(c0);
+  for (int c0 = a1; c0 <= min(b1, a2 - 1); c0 += 1) {
+    s0(c0);
+    if (c0 >= a3 && b3 >= c0)
+      s2(c0);
+  }
+  for (int c0 = max(max(a1, b1 + 1), a3); c0 <= min(b3, a2 - 1); c0 += 1)
+    s2(c0);
+  for (int c0 = a2; c0 <= b2; c0 += 1) {
+    if (c0 >= a1 && b1 >= c0)
+      s0(c0);
+    s1(c0);
+    if (c0 >= a3 && b3 >= c0)
+      s2(c0);
+  }
+  for (int c0 = max(max(a3, a2), b2 + 1); c0 <= min(a1 - 1, b3); c0 += 1)
+    s2(c0);
+  for (int c0 = max(max(a1, a2), b2 + 1); c0 <= b1; c0 += 1) {
+    s0(c0);
+    if (c0 >= a3 && b3 >= c0)
+      s2(c0);
+  }
+  for (int c0 = max(max(max(max(a1, b1 + 1), a3), a2), b2 + 1); c0 <= b3; c0 += 1)
+    s2(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.in
new file mode 100644
index 0000000..4cf37cb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-0.in
@@ -0,0 +1,3 @@
+[a3, b3, a2, b2, a1, b1] -> { s2[i] -> [i, 2] : i >= a3 and i <= b3; s0[i] -> [i, 0] : i >= a1 and i <= b1; s1[i] -> [i, 1] : i >= a2 and i <= b2 }
+{  :  }
+[a1, b1] -> { [i0, i1] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.c
new file mode 100644
index 0000000..a09f705
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.c
@@ -0,0 +1,55 @@
+{
+  for (int c0 = a2; c0 <= min(min(a1 - 1, a3 - 1), b2); c0 += 1)
+    s1(c0);
+  for (int c0 = a3; c0 <= min(min(a1 - 1, b3), a2 - 1); c0 += 1)
+    s2(c0);
+  for (int c0 = max(a3, a2); c0 <= min(min(a1 - 1, b3), b2); c0 += 1) {
+    s1(c0);
+    s2(c0);
+  }
+  for (int c0 = max(max(a3, b3 + 1), a2); c0 <= min(a1 - 1, b2); c0 += 1)
+    s1(c0);
+  for (int c0 = a1; c0 <= min(min(b1, a3 - 1), a2 - 1); c0 += 1)
+    s0(c0);
+  for (int c0 = max(a1, a2); c0 <= min(min(b1, a3 - 1), b2); c0 += 1) {
+    s0(c0);
+    s1(c0);
+  }
+  for (int c0 = max(a1, a3); c0 <= min(min(b1, b3), a2 - 1); c0 += 1) {
+    s0(c0);
+    s2(c0);
+  }
+  for (int c0 = max(max(a1, a3), b3 + 1); c0 <= min(b1, a2 - 1); c0 += 1)
+    s0(c0);
+  for (int c0 = max(max(a1, a3), a2); c0 <= min(min(b1, b3), b2); c0 += 1) {
+    s0(c0);
+    s1(c0);
+    s2(c0);
+  }
+  for (int c0 = max(max(max(a1, a3), b3 + 1), a2); c0 <= min(b1, b2); c0 += 1) {
+    s0(c0);
+    s1(c0);
+  }
+  for (int c0 = max(max(a1, a2), b2 + 1); c0 <= min(b1, a3 - 1); c0 += 1)
+    s0(c0);
+  for (int c0 = max(max(a3, a2), b2 + 1); c0 <= min(a1 - 1, b3); c0 += 1)
+    s2(c0);
+  for (int c0 = max(max(max(a1, a3), a2), b2 + 1); c0 <= min(b1, b3); c0 += 1) {
+    s0(c0);
+    s2(c0);
+  }
+  for (int c0 = max(max(max(max(a1, a3), b3 + 1), a2), b2 + 1); c0 <= b1; c0 += 1)
+    s0(c0);
+  for (int c0 = max(max(a1, b1 + 1), a2); c0 <= min(a3 - 1, b2); c0 += 1)
+    s1(c0);
+  for (int c0 = max(max(a1, b1 + 1), a3); c0 <= min(b3, a2 - 1); c0 += 1)
+    s2(c0);
+  for (int c0 = max(max(max(a1, b1 + 1), a3), a2); c0 <= min(b3, b2); c0 += 1) {
+    s1(c0);
+    s2(c0);
+  }
+  for (int c0 = max(max(max(max(a1, b1 + 1), a3), b3 + 1), a2); c0 <= b2; c0 += 1)
+    s1(c0);
+  for (int c0 = max(max(max(max(a1, b1 + 1), a3), a2), b2 + 1); c0 <= b3; c0 += 1)
+    s2(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.in
new file mode 100644
index 0000000..75c96d4
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak1-1.in
@@ -0,0 +1,3 @@
+[a3, b3, a2, b2, a1, b1] -> { s2[i] -> [i, 2] : i >= a3 and i <= b3; s0[i] -> [i, 0] : i >= a1 and i <= b1; s1[i] -> [i, 1] : i >= a2 and i <= b2 }
+{  :  }
+[a1, b1] -> { [i0, i1] -> separate[o0] : o0 >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.c
new file mode 100644
index 0000000..96e9f19
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.c
@@ -0,0 +1,25 @@
+if (c2 >= d2 + 1) {
+  for (int c0 = a1; c0 <= b1; c0 += 1)
+    for (int c1_0 = c1; c1_0 <= d1; c1_0 += 1)
+      s0(c0, c1_0);
+} else {
+  for (int c0 = a1; c0 <= min(b1, a2 - 1); c0 += 1)
+    for (int c1_0 = c1; c1_0 <= d1; c1_0 += 1)
+      s0(c0, c1_0);
+  for (int c0 = a2; c0 <= b2; c0 += 1) {
+    if (c0 >= a1 && b1 >= c0)
+      for (int c1_0 = c1; c1_0 <= min(d1, c2 - 1); c1_0 += 1)
+        s0(c0, c1_0);
+    for (int c1_0 = c2; c1_0 <= d2; c1_0 += 1) {
+      if (c0 >= a1 && b1 >= c0 && c1_0 >= c1 && d1 >= c1_0)
+        s0(c0, c1_0);
+      s1(c0, c1_0);
+    }
+    if (c0 >= a1 && b1 >= c0)
+      for (int c1_0 = max(c1, d2 + 1); c1_0 <= d1; c1_0 += 1)
+        s0(c0, c1_0);
+  }
+  for (int c0 = max(max(a1, a2), b2 + 1); c0 <= b1; c0 += 1)
+    for (int c1_0 = c1; c1_0 <= d1; c1_0 += 1)
+      s0(c0, c1_0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.in
new file mode 100644
index 0000000..da7a695
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-0.in
@@ -0,0 +1,3 @@
+[a2, b2, c2, d2, a1, b1, c1, d1] -> { s0[i, j] -> [i, j, 0] : i >= a1 and i <= b1 and j >= c1 and j <= d1; s1[i, j] -> [i, j, 1] : i >= a2 and i <= b2 and j >= c2 and j <= d2 }
+{  :  }
+[a1, b1, c1, d1] -> { [i0, i1, i2] -> separate[o0] : o0 >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.c
new file mode 100644
index 0000000..58c2971
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.c
@@ -0,0 +1,34 @@
+if (c2 >= d2 + 1) {
+  for (int c0 = a1; c0 <= b1; c0 += 1)
+    for (int c1_0 = c1; c1_0 <= d1; c1_0 += 1)
+      s0(c0, c1_0);
+} else {
+  for (int c0 = a1; c0 <= min(b1, a2 - 1); c0 += 1)
+    for (int c1_0 = c1; c1_0 <= d1; c1_0 += 1)
+      s0(c0, c1_0);
+  for (int c0 = a2; c0 <= b2; c0 += 1) {
+    if (a1 >= c0 + 1) {
+      for (int c1_0 = c2; c1_0 <= d2; c1_0 += 1)
+        s1(c0, c1_0);
+    } else if (c0 >= b1 + 1) {
+      for (int c1_0 = c2; c1_0 <= d2; c1_0 += 1)
+        s1(c0, c1_0);
+    } else {
+      for (int c1_0 = c2; c1_0 <= min(c1 - 1, d2); c1_0 += 1)
+        s1(c0, c1_0);
+      for (int c1_0 = c1; c1_0 <= min(d1, c2 - 1); c1_0 += 1)
+        s0(c0, c1_0);
+      for (int c1_0 = max(c1, c2); c1_0 <= min(d1, d2); c1_0 += 1) {
+        s0(c0, c1_0);
+        s1(c0, c1_0);
+      }
+      for (int c1_0 = max(max(c1, d1 + 1), c2); c1_0 <= d2; c1_0 += 1)
+        s1(c0, c1_0);
+      for (int c1_0 = max(c1, d2 + 1); c1_0 <= d1; c1_0 += 1)
+        s0(c0, c1_0);
+    }
+  }
+  for (int c0 = max(max(a1, a2), b2 + 1); c0 <= b1; c0 += 1)
+    for (int c1_0 = c1; c1_0 <= d1; c1_0 += 1)
+      s0(c0, c1_0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.in
new file mode 100644
index 0000000..c92ac3c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak2-1.in
@@ -0,0 +1,3 @@
+[a2, b2, c2, d2, a1, b1, c1, d1] -> { s0[i, j] -> [i, j, 0] : i >= a1 and i <= b1 and j >= c1 and j <= d1; s1[i, j] -> [i, j, 1] : i >= a2 and i <= b2 and j >= c2 and j <= d2 }
+{  :  }
+[a1, b1, c1, d1] -> { [i0, i1, i2] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.c
new file mode 100644
index 0000000..06be04a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.c
@@ -0,0 +1,8 @@
+for (int c0 = a; c0 <= b + 20; c0 += 1) {
+  if (b >= c0)
+    s0(c0);
+  if (c0 >= a + 10 && b + 10 >= c0)
+    s1(c0);
+  if (c0 >= a + 20)
+    s2(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.in
new file mode 100644
index 0000000..a4c4de9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-0.in
@@ -0,0 +1,3 @@
+[a, b] -> { s2[i] -> [i, 2] : i >= 20 + a and i <= 20 + b; s0[i] -> [i, 0] : i >= a and i <= b; s1[i] -> [i, 1] : i >= 10 + a and i <= 10 + b }
+{  :  }
+[a, b] -> { [i0, i1] -> atomic[o0] : o0 <= 0; [i0, i1] -> separate[o0] : o0 >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.c
new file mode 100644
index 0000000..3045b21
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.c
@@ -0,0 +1,21 @@
+{
+  for (int c0 = a; c0 <= min(a + 9, b); c0 += 1)
+    s0(c0);
+  for (int c0 = a + 10; c0 <= min(a + 19, b); c0 += 1) {
+    s0(c0);
+    s1(c0);
+  }
+  for (int c0 = max(a + 10, b + 1); c0 <= min(a + 19, b + 10); c0 += 1)
+    s1(c0);
+  for (int c0 = a + 20; c0 <= b; c0 += 1) {
+    s0(c0);
+    s1(c0);
+    s2(c0);
+  }
+  for (int c0 = max(a + 20, b + 1); c0 <= b + 10; c0 += 1) {
+    s1(c0);
+    s2(c0);
+  }
+  for (int c0 = max(a + 20, b + 11); c0 <= b + 20; c0 += 1)
+    s2(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.in
new file mode 100644
index 0000000..ae319e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak3-1.in
@@ -0,0 +1,3 @@
+[a, b] -> { s2[i] -> [i, 2] : i >= 20 + a and i <= 20 + b; s0[i] -> [i, 0] : i >= a and i <= b; s1[i] -> [i, 1] : i >= 10 + a and i <= 10 + b }
+{  :  }
+[a, b] -> { [i0, i1] -> atomic[o0] : o0 <= -1; [i0, i1] -> separate[o0] : o0 >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.c
new file mode 100644
index 0000000..5cefe4b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.c
@@ -0,0 +1,4 @@
+for (int c0 = max(max(max(max(a1, a2), a3), a4), a5); c0 <= min(min(min(min(b1, b2), b3), b4), b5); c0 += 1) {
+  s0(c0);
+  s1(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.in
new file mode 100644
index 0000000..9862df2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-0.in
@@ -0,0 +1,3 @@
+[a1, a2, a3, a4, a5, b1, b2, b3, b4, b5] -> { s0[i] -> [i, 0] : i >= a1 and i >= a2 and i >= a3 and i >= a4 and i >= a5 and i <= b1 and i <= b2 and i <= b3 and i <= b4 and i <= b5; s1[i] -> [i, 1] : i >= a1 and i >= a2 and i >= a3 and i >= a4 and i >= a5 and i <= b1 and i <= b2 and i <= b3 and i <= b4 and i <= b5 }
+{  :  }
+[a1, a2, a3, a4, a5, b1, b2, b3, b4, b5] -> { [i0, i1] -> separate[o0] : o0 >= 1; [i0, i1] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.c
new file mode 100644
index 0000000..5cefe4b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.c
@@ -0,0 +1,4 @@
+for (int c0 = max(max(max(max(a1, a2), a3), a4), a5); c0 <= min(min(min(min(b1, b2), b3), b4), b5); c0 += 1) {
+  s0(c0);
+  s1(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.in
new file mode 100644
index 0000000..076cdd1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/wak4-1.in
@@ -0,0 +1,3 @@
+[a1, a2, a3, a4, a5, b1, b2, b3, b4, b5] -> { s0[i] -> [i, 0] : i >= a1 and i >= a2 and i >= a3 and i >= a4 and i >= a5 and i <= b1 and i <= b2 and i <= b3 and i <= b4 and i <= b5; s1[i] -> [i, 1] : i >= a1 and i >= a2 and i >= a3 and i >= a4 and i >= a5 and i <= b1 and i <= b2 and i <= b3 and i <= b4 and i <= b5 }
+{  :  }
+[a1, a2, a3, a4, a5, b1, b2, b3, b4, b5] -> { [i0, i1] -> separate[o0] : o0 >= 0; [i0, i1] -> atomic[o0] : o0 <= -1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/x-0.c b/lib/Analysis/isl/test_inputs/codegen/omega/x-0.c
new file mode 100644
index 0000000..f890920
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/x-0.c
@@ -0,0 +1,14 @@
+for (int c0 = 1; c0 <= 11; c0 += 1) {
+  for (int c1 = max(1, c0 - 3); c1 <= min(c0, -c0 + 8); c1 += 1)
+    s1(c1, c0 - c1 + 1);
+  for (int c1 = max(1, -c0 + 9); c1 <= min(c0 - 4, -c0 + 12); c1 += 1)
+    s0(c1, c0 + c1 - 8);
+  for (int c1 = max(c0 - 3, -c0 + 9); c1 <= min(c0, -c0 + 12); c1 += 1) {
+    s0(c1, c0 + c1 - 8);
+    s1(c1, c0 - c1 + 1);
+  }
+  for (int c1 = max(c0 - 3, -c0 + 13); c1 <= min(8, c0); c1 += 1)
+    s1(c1, c0 - c1 + 1);
+  for (int c1 = max(c0 + 1, -c0 + 9); c1 <= min(8, -c0 + 12); c1 += 1)
+    s0(c1, c0 + c1 - 8);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/x-0.in b/lib/Analysis/isl/test_inputs/codegen/omega/x-0.in
new file mode 100644
index 0000000..24340ef
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/x-0.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [8 - i + j, i, 0] : i >= 1 and i <= 8 and j >= 1 and j <= 4; s1[i, j] -> [-1 + i + j, i, 1] : i >= 1 and i <= 8 and j >= 1 and j <= 4 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/x-1.c b/lib/Analysis/isl/test_inputs/codegen/omega/x-1.c
new file mode 100644
index 0000000..f890920
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/x-1.c
@@ -0,0 +1,14 @@
+for (int c0 = 1; c0 <= 11; c0 += 1) {
+  for (int c1 = max(1, c0 - 3); c1 <= min(c0, -c0 + 8); c1 += 1)
+    s1(c1, c0 - c1 + 1);
+  for (int c1 = max(1, -c0 + 9); c1 <= min(c0 - 4, -c0 + 12); c1 += 1)
+    s0(c1, c0 + c1 - 8);
+  for (int c1 = max(c0 - 3, -c0 + 9); c1 <= min(c0, -c0 + 12); c1 += 1) {
+    s0(c1, c0 + c1 - 8);
+    s1(c1, c0 - c1 + 1);
+  }
+  for (int c1 = max(c0 - 3, -c0 + 13); c1 <= min(8, c0); c1 += 1)
+    s1(c1, c0 - c1 + 1);
+  for (int c1 = max(c0 + 1, -c0 + 9); c1 <= min(8, -c0 + 12); c1 += 1)
+    s0(c1, c0 + c1 - 8);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/omega/x-1.in b/lib/Analysis/isl/test_inputs/codegen/omega/x-1.in
new file mode 100644
index 0000000..24340ef
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/omega/x-1.in
@@ -0,0 +1,3 @@
+{ s0[i, j] -> [8 - i + j, i, 0] : i >= 1 and i <= 8 and j >= 1 and j <= 4; s1[i, j] -> [-1 + i + j, i, 1] : i >= 1 and i <= 8 and j >= 1 and j <= 4 }
+{  :  }
+{ [i0, i1, i2] -> separate[o0] : o0 >= 1; [i0, i1, i2] -> atomic[o0] : o0 <= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/README b/lib/Analysis/isl/test_inputs/codegen/pldi2012/README
new file mode 100644
index 0000000..316e838
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/README
@@ -0,0 +1,2 @@
+These examples are taken from the "Polyhedra Scanning Revisited" paper
+by Chun Chen.
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.c b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.c
new file mode 100644
index 0000000..5e2cd82
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.c
@@ -0,0 +1,9 @@
+for (int c0 = 1; c0 <= 100; c0 += 1) {
+  if (n >= 2)
+    s0(c0);
+  for (int c1 = 1; c1 <= 100; c1 += 1) {
+    s2(c0, c1);
+    if (n >= 2)
+      s1(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.in b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.in
new file mode 100644
index 0000000..9314917
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_b.in
@@ -0,0 +1,5 @@
+[n] -> { s0[i] -> [i,0] : 1 <= i <= 100 and n > 1;
+	 s1[i,j] -> [i,j] : 1 <= i,j <= 100 and n > 1;
+	 s2[i,j] -> [i,j] : 1 <= i,j <= 100 }
+[n] -> {  :  }
+[n] -> { [i,j] -> separate[x] : x >= 2 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.c b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.c
new file mode 100644
index 0000000..b3f4a24
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.c
@@ -0,0 +1,12 @@
+for (int c0 = 1; c0 <= 100; c0 += 1) {
+  if (n >= 2) {
+    s0(c0);
+    for (int c1 = 1; c1 <= 100; c1 += 1) {
+      s2(c0, c1);
+      s1(c0, c1);
+    }
+  } else {
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      s2(c0, c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.in b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.in
new file mode 100644
index 0000000..06a3266
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_c.in
@@ -0,0 +1,5 @@
+[n] -> { s0[i] -> [i,0] : 1 <= i <= 100 and n > 1;
+	 s1[i,j] -> [i,j] : 1 <= i,j <= 100 and n > 1;
+	 s2[i,j] -> [i,j] : 1 <= i,j <= 100 }
+[n] -> {  :  }
+[n] -> { [i,j] -> separate[x] : x >= 1 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.c b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.c
new file mode 100644
index 0000000..94dc201
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.c
@@ -0,0 +1,13 @@
+if (n >= 2) {
+  for (int c0 = 1; c0 <= 100; c0 += 1) {
+    s0(c0);
+    for (int c1 = 1; c1 <= 100; c1 += 1) {
+      s2(c0, c1);
+      s1(c0, c1);
+    }
+  }
+} else {
+  for (int c0 = 1; c0 <= 100; c0 += 1)
+    for (int c1 = 1; c1 <= 100; c1 += 1)
+      s2(c0, c1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.in b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.in
new file mode 100644
index 0000000..339e39d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure7_d.in
@@ -0,0 +1,5 @@
+[n] -> { s0[i] -> [i,0] : 1 <= i <= 100 and n > 1;
+	 s1[i,j] -> [i,j] : 1 <= i,j <= 100 and n > 1;
+	 s2[i,j] -> [i,j] : 1 <= i,j <= 100 }
+[n] -> {  :  }
+[n] -> { [i,j] -> separate[x] : x >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.c b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.c
new file mode 100644
index 0000000..4608d61
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 <= n; c0 += 4)
+  for (int c1 = c0; c1 <= n; c1 += 3)
+    s0(c0, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.in b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.in
new file mode 100644
index 0000000..df6543c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_a.in
@@ -0,0 +1,4 @@
+[n] -> { s0[i,j] -> [i,j] : exists alpha, beta: 1 <= i <= n and i <= j <= n and
+			    i = 1 + 4 alpha and j = i + 3 beta}
+[n] -> { : }
+[n] -> {}
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.c b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.c
new file mode 100644
index 0000000..9455969
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.c
@@ -0,0 +1,8 @@
+{
+  for (int c0 = 2; c0 < n - 1; c0 += 4) {
+    s1(c0);
+    s0(c0 + 2);
+  }
+  if (n >= 1 && n % 4 >= 2)
+    s1(-(n % 4) + n + 2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.in b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.in
new file mode 100644
index 0000000..2effb0a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/pldi2012/figure8_b.in
@@ -0,0 +1,4 @@
+[n] -> { s0[i] -> [i] : exists alpha: 1 <= i <= n and i = 4 alpha;
+	 s1[i] -> [i] : exists alpha: 1 <= i <= n and i = 4 alpha + 2 }
+[n] -> { : }
+[n] -> { }
diff --git a/lib/Analysis/isl/test_inputs/codegen/redundant.c b/lib/Analysis/isl/test_inputs/codegen/redundant.c
new file mode 100644
index 0000000..057416e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/redundant.c
@@ -0,0 +1,11 @@
+for (int c0 = 0; c0 <= 2; c0 += 1)
+  for (int c1 = max(0, b0 - 4 * c0 - 1); c1 <= 1; c1 += 1) {
+    if (b0 >= 1 && 4 * c0 + c1 >= 1)
+      for (int c2 = 1; c2 <= 2; c2 += 1)
+        for (int c3 = 1; c3 <= 14; c3 += 1)
+          write(c0, c1, 8 * b0 + c2 - 5, c3);
+    for (int c2 = max(max(3, -8 * b0 + 6), 8 * c0 - 12); c2 <= min(min(7, -8 * b0 + 17), 8 * c0 + 6); c2 += 1)
+      if (4 * c0 + c1 + 1 >= 2 * ((2 * c1 + c2 - 1) / 4) && 2 * ((2 * c1 + c2 - 1) / 4) + 7 >= 4 * c0 + c1 && (2 * c1 + c2 - 1) % 4 >= 1 && ((2 * c1 + c2 - 1) % 4) + 11 >= 2 * c2)
+        for (int c3 = 1; c3 <= 14; c3 += 1)
+          write(c0, c1, 8 * b0 + c2 - 5, c3);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/redundant.st b/lib/Analysis/isl/test_inputs/codegen/redundant.st
new file mode 100644
index 0000000..e766f74
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/redundant.st
@@ -0,0 +1,6 @@
+# Check that b1 >= 1 is not dropped by mistake in 4 * c0 + c1 >= 1 part
+domain: "[b0] -> { write[i0, o1, o2, o3] : ((exists (e0 = floor((4 + o2)/8), e1 = floor((5 + o2)/8), e2 = floor((4 + o2)/262144), e3, e4: o1 <= 1 and o1 >= 0 and o2 <= 12 and o2 >= 1 and o3 <= 14 and o3 >= 1 and 8e0 <= 4 + o2 and 8e1 <= 5 + o2 and 262144e2 <= 4 - 8b0 + o2 and 262144e2 >= -262139 + o2 and 262144e2 <= 4 + o2 and 262144e2 >= -3 - 8b0 + o2 and 4e4 <= 1 - 8i0 + 2o1 - o2 + 8e0 and 4e4 <= 4 - 8i0 + 2o1 + o2 - 8e0 and 4e4 >= 2o1 + o2 - 8e1 - 8e3 and 4e4 >= -3 + 2o1 + o2 - 8e0 - 8e3 and 4e4 >= -6 + 2o1 - o2 + 8e0 - 8e3 and 2e4 >= -9 + o1 and 2e4 <= -1 + o1 and 4e4 <= -6 + 2o1 - o2 + 8e1 - 8e3 and 4e4 >= -3 - 8i0 + 2o1 + o2 - 8e0 and 4e4 >= -6 - 8i0 + 2o1 - o2 + 8e0)) or (exists (e0 = floor((4 + o2)/8), e1 = floor((5 + o2)/8), e2 = floor((4 + o2)/262144), e3, e4: o1 <= 1 and o1 >= 0 and o2 <= 12 and o2 >= 1 and o3 <= 14 and o3 >= 1 and 8e0 <= 4 + o2 and 8e1 >= -2 + o2 and 262144e2 <= 4 - 8b0 + o2 and 262144e2 >= -262139 + o2 and 262144e2 <= 4 + o2 and 262144e2 >= -3 - 8b0 + o2 and 4e4 <= 1 - 8i0 + 2o1 - o2 + 8e0 and 4e4 <= 4 - 8i0 + 2o1 + o2 - 8e0 and 4e4 >= -3 + 2o1 + o2 - 8e0 - 8e3 and 4e4 >= -6 + 2o1 - o2 + 8e0 - 8e3 and 2e4 >= -9 + o1 and 2e4 <= -1 + o1 and 4e4 <= 1 + 2o1 - o2 + 8e0 - 8e3 and 4e4 <= 4 + 2o1 + o2 - 8e0 - 8e3 and 4e4 <= -1 + 2o1 + o2 - 8e1 - 8e3 and 4e4 >= -3 - 8i0 + 2o1 + o2 - 8e0 and 4e4 >= -6 - 8i0 + 2o1 - o2 + 8e0)) or (exists (e0 = floor((2 + o2)/8), e1 = floor((4 + o2)/8), e2 = floor((4 + o2)/262144), e3, e4: o1 <= 1 and o1 >= 0 and o2 <= 13 and o2 >= 3 and o3 <= 14 and o3 >= 1 and 8e0 >= -5 + o2 and 8e1 <= 4 + o2 and 262144e2 <= 4 - 8b0 + o2 and 262144e2 >= -262139 + o2 and 262144e2 <= 4 + o2 and 262144e2 >= -3 - 8b0 + o2 and 4e4 <= 1 - 8i0 + 2o1 - o2 + 8e1 and 4e4 <= 4 - 8i0 + 2o1 + o2 - 8e1 and 4e4 >= -3 + 2o1 + o2 - 8e1 - 8e3 and 4e4 >= -6 + 2o1 - o2 + 8e1 - 8e3 and 2e4 >= -9 + o1 and 2e4 <= -1 + o1 and 4e4 <= 1 + 2o1 - o2 + 8e1 - 8e3 and 4e4 <= -4 + 2o1 + o2 - 8e0 - 8e3 and 4e4 <= 4 + 2o1 + o2 - 8e1 - 8e3 and 4e4 >= -3 - 8i0 + 2o1 + o2 - 8e1 and 4e4 >= -6 - 8i0 + 2o1 - o2 + 8e1))) and b0 >= 0 and i0 <= 2 and i0 >= 0 and b0 <= 2 }"
+child:
+  context: "[b0] -> { [] : b0 <= 2 and b0 >= 0 }"
+  child:
+    schedule: "[b0] -> [{ write[i0, o1, o2, o3] -> [i0] }, { write[i0, i1, i2, i3] -> [(i1)] }, { write[i0, i1, i2, i3] -> [(5 - 8b0 + i2)] }, { write[i0,i1, i2, i3] -> [(i3)] }]"
diff --git a/lib/Analysis/isl/test_inputs/codegen/roman.c b/lib/Analysis/isl/test_inputs/codegen/roman.c
new file mode 100644
index 0000000..d7e4077
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/roman.c
@@ -0,0 +1,32 @@
+{
+  for (int c1 = 0; c1 <= min(np1 - i, -i + 1); c1 += 1) {
+    S_9(c1);
+    S_12(c1);
+  }
+  for (int c1 = max(0, -i + 2); c1 <= -((-np1 + i + 4294967295) % 4294967296) + 4294967295; c1 += 1) {
+    S_9(c1);
+    S_10(c1);
+    for (int c3 = 0; c3 <= min(19, i + c1 - 3); c3 += 1) {
+      S_15(c1, c3);
+      for (int c5 = 0; c5 < c3; c5 += 1) {
+        S_16(c1, c3, c5);
+        S_17(c1, c3, c5);
+      }
+      S_16(c1, c3, c3);
+      S_18(c1, c3);
+      S_24(c1, c3);
+      S_19(c1, c3);
+    }
+    if (i + c1 <= 21) {
+      S_15(c1, i + c1 - 2);
+      for (int c5 = 0; c5 < i + c1 - 2; c5 += 1) {
+        S_16(c1, i + c1 - 2, c5);
+        S_17(c1, i + c1 - 2, c5);
+      }
+      S_16(c1, i + c1 - 2, i + c1 - 2);
+      S_18(c1, i + c1 - 2);
+      S_24(c1, i + c1 - 2);
+    }
+    S_12(c1);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/roman.in b/lib/Analysis/isl/test_inputs/codegen/roman.in
new file mode 100644
index 0000000..55182a6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/roman.in
@@ -0,0 +1,5 @@
+# Older versions of isl would get confused on this input due to disappearing
+# div constraints.
+[np1, i] -> { S_17[i0, i1, i2] -> [0, i0, 2, i1, 1, i2, 1] : exists (e0 = [(np1 - i)/4294967296], e1 = [(-2 + i + i0)/4294967296], e2 = [(i1)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20 and i1 >= 0 and 4294967296e1 <= -2 + i + i0 and 4294967296e1 >= -4294967297 + i + i0 and 4294967296e1 <= -2 + i + i0 - i1 and i1 <= 19 and i2 >= 0 and 4294967296e2 <= i1 and 4294967296e2 >= -4294967295 + i1 and 4294967296e2 <= i1 - i2 and i2 <= 19 and i0 >= 2 - i and i2 <= -1 + i1); S_18[i0, i1] -> [0, i0, 2, i1, 2, 0, 0] : exists (e0 = [(np1 - i)/4294967296], e1 = [(-2 + i + i0)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20 and i1 >= 0 and 4294967296e1 <= -2 + i + i0 and 4294967296e1 >= -4294967297 + i + i0 and 4294967296e1 <= -2 + i + i0 - i1 and i1 <= 19 and i0 >= 2 - i); S_24[i0, i1] -> [0, i0, 2, i1, 3, 0, 0] : exists (e0 = [(np1 - i)/4294967296], e1 = [(-2 + i + i0)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20 and i1 >= 0 and 4294967296e1 <= -2 + i + i0 and 4294967296e1 >= -4294967297 + i + i0 and 4294967296e1 <= -2 + i + i0 - i1 and i1 <= 19 and i0 >= 2 - i); S_15[i0, i1] -> [0, i0, 2, i1, 0, 0, 0] : exists (e0 = [(np1 - i)/4294967296], e1 = [(-2 + i + i0)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20 and i1 >= 0 and 4294967296e1 <= -2 + i + i0 and 4294967296e1 >= -4294967297 + i + i0 and 4294967296e1 <= -2 + i + i0 - i1 and i1 <= 19 and i0 >= 2 - i); S_9[i0] -> [0, i0, 0, 0, 0, 0, 0] : exists (e0 = [(np1 - i)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20); S_10[i0] -> [0, i0, 1, 0, 0, 0, 0] : exists (e0 = [(np1 - i)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20 and i0 >= 2 - i); S_19[i0, i1] -> [0, i0, 2, i1, 4, 0, 0] : exists (e0 = [(np1 - i)/4294967296], e1 = [(-2 + i + i0)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20 and i1 >= 0 and 4294967296e1 <= -2 + i + i0 and 4294967296e1 >= -4294967297 + i + i0 and 4294967296e1 <= -2 + i + i0 - i1 and i1 <= 19 and i0 >= 2 - i and i1 <= -3 + i + i0); S_12[i0] -> [0, i0, 3, 0, 0, 0, 0] : exists (e0 = [(np1 - i)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20); S_16[i0, i1, i2] -> [0, i0, 2, i1, 1, i2, 0] : exists (e0 = [(np1 - i)/4294967296], e1 = [(-2 + i + i0)/4294967296], e2 = [(i1)/4294967296]: i0 >= 0 and 4294967296e0 <= np1 - i and 4294967296e0 >= -4294967295 + np1 - i and 4294967296e0 <= np1 - i - i0 and i0 <= 20 and i1 >= 0 and 4294967296e1 <= -2 + i + i0 and 4294967296e1 >= -4294967297 + i + i0 and 4294967296e1 <= -2 + i + i0 - i1 and i1 <= 19 and i2 >= 0 and 4294967296e2 <= i1 and 4294967296e2 >= -4294967295 + i1 and 4294967296e2 <= i1 - i2 and i2 <= 19 and i0 >= 2 - i) }
+[np1, i] -> {  : exists (e0 = [(np1 - i)/4294967296]: 4294967296e0 <= np1 - i and 4294967296e0 >= -20 + np1 - i and np1 >= -2147483648 and np1 <= 2147483647 and i >= -2147483648 and i <= 2147483647) }
+[np1, i] -> { [i0, i1, i2, i3, i4, i5, i6] -> separate[o0] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/separate.c b/lib/Analysis/isl/test_inputs/codegen/separate.c
new file mode 100644
index 0000000..14d91be
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separate.c
@@ -0,0 +1,8 @@
+{
+  a(0);
+  for (int c0 = 1; c0 <= 9; c0 += 1) {
+    a(c0);
+    b(c0 - 1);
+  }
+  b(9);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/separate.in b/lib/Analysis/isl/test_inputs/codegen/separate.in
new file mode 100644
index 0000000..07ea4aa
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separate.in
@@ -0,0 +1,3 @@
+{ a[i] -> [i, 0] : 0 <= i < 10; b[i] -> [i+1, 1] : 0 <= i < 10 }
+{ : }
+{ [i, d] -> separate[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/separate.st b/lib/Analysis/isl/test_inputs/codegen/separate.st
new file mode 100644
index 0000000..2eed716
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separate.st
@@ -0,0 +1,8 @@
+domain: "{ a[i] : 0 <= i < 10; b[i] : 0 <= i < 10 }"
+child:
+  schedule: "[{ a[i] -> [i]; b[i] -> [i+1] }]"
+  options: "{ separate[x] }"
+  child:
+    sequence:
+    - filter: "{ a[i] }"
+    - filter: "{ b[i] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/separate2.c b/lib/Analysis/isl/test_inputs/codegen/separate2.c
new file mode 100644
index 0000000..76ee58d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separate2.c
@@ -0,0 +1,8 @@
+for (int c0 = 0; c0 <= 1; c0 += 1)
+  for (int c5 = 0; c5 <= 31; c5 += 1)
+    for (int c6 = max(0, 2 * (length % 16) + 2 * c5 - 62); c6 <= 30; c6 += 1) {
+      if (2 * length + c6 >= 2 * (length % 16) + 2 && c6 + 62 >= 2 * (length % 16) + 2 * c5 && 2 * (length % 16) >= c6 + 2 && 2 * (length % 16) + 2 * c5 >= c6 && 2 * (length % 32) + c6 == 2 * (length % 16) + 2 * c5 && (2 * c5 - c6) % 32 == 0)
+        S_3(c0, 0, (c6 / 2) - (length % 16) + length);
+      if (length <= 15 && length >= c5 + 1 && c6 >= 1 && length >= c6)
+        S_0(c0, c5, c6 - 1);
+    }
diff --git a/lib/Analysis/isl/test_inputs/codegen/separate2.in b/lib/Analysis/isl/test_inputs/codegen/separate2.in
new file mode 100644
index 0000000..8f4ebf1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separate2.in
@@ -0,0 +1,4 @@
+# Check that rational affine expressions are printer properly.
+[tsteps, length] -> { S_0[iter, i, j] -> [iter, 0, o2, o3, 0, o5, o6, 4] : exists (e0 = [(o2)/32], e1 = [(o3)/32], e2 = [(-i + o5)/32], e3 = [(-31 + j - o6)/32]: tsteps = 2 and 32e0 = o2 and 32e1 = o3 and 32e2 = -i + o5 and 32e3 = -31 + j - o6 and o2 <= i and o2 >= -31 + i and o3 <= 1 + j and o3 >= -30 + j and o5 >= 0 and o5 <= 31 and o6 >= 0 and o6 <= 31 and i <= -1 + length and i >= 0 and iter >= 0 and iter <= 1 and j <= -1 + length and j >= 0 and o2 >= -31 + length and o3 >= -30 + 2length); S_3[iter, 0, j] -> [iter, 0, o2, o3, o4, o5, o6, 2] : exists (e0 = [(o2)/32], e1 = [(o3)/32], e2 = [(o4)/32], e3 = [(-2o5 + o6)/32], e4 = [(j - o5)/32]: tsteps = 2 and 32e0 = o2 and 32e1 = o3 and 32e2 = o4 and 32e3 = -2o5 + o6 and 32e4 = j - o5 and iter <= 1 and j <= -1 + length and o2 <= j and o2 >= -31 + j and o3 <= 2j and o3 >= -30 + 2j and o4 >= 0 and o4 <= 31 and o5 >= 0 and o5 <= 31 and o6 >= 0 and o6 <= 30 and j >= 1 and iter >= 0 and o2 >= -31 + length and o3 >= -30 + 2length) }
+[tsteps, length] -> {  : length >= 1 and length <= 1024 and tsteps = 2 }
+{ [o0,o1,o2,o3,o4,o5,o6,o7] -> separate[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class.c b/lib/Analysis/isl/test_inputs/codegen/separation_class.c
new file mode 100644
index 0000000..daac0d7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class.c
@@ -0,0 +1,17 @@
+{
+  for (int c0 = 0; c0 <= 8; c0 += 1) {
+    for (int c1 = 0; c1 <= -c0 + 8; c1 += 1)
+      for (int c2 = 10 * c0; c2 <= 10 * c0 + 9; c2 += 1)
+        for (int c3 = 10 * c1; c3 <= 10 * c1 + 9; c3 += 1)
+          A(c2, c3);
+    for (int c1 = -c0 + 9; c1 <= -c0 + 10; c1 += 1)
+      for (int c2 = 10 * c0; c2 <= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
+        for (int c3 = 10 * c1; c3 <= min(10 * c1 + 9, -c2 + 100); c3 += 1)
+          A(c2, c3);
+  }
+  for (int c0 = 9; c0 <= 10; c0 += 1)
+    for (int c1 = 0; c1 <= -c0 + 10; c1 += 1)
+      for (int c2 = 10 * c0; c2 <= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
+        for (int c3 = 10 * c1; c3 <= min(10 * c1 + 9, -c2 + 100); c3 += 1)
+          A(c2, c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class.in b/lib/Analysis/isl/test_inputs/codegen/separation_class.in
new file mode 100644
index 0000000..f42ea27
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class.in
@@ -0,0 +1,6 @@
+{ A[i,j] -> [([i/10]),[j/10],i,j] : 0 <= i,j and i + j <= 100 }
+{ : }
+{ [a,b,c,d] -> separation_class[[0]->[0]] :
+	exists b': 0 <= 10a,10b' and 10a+9+10b'+9 <= 100;
+  [a,b,c,d] -> separation_class[[1]->[0]] :
+	0 <= 10a,10b and 10a+9+10b+9 <= 100 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class2.c b/lib/Analysis/isl/test_inputs/codegen/separation_class2.c
new file mode 100644
index 0000000..80be0a7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class2.c
@@ -0,0 +1,15 @@
+{
+  for (int c0 = 0; c0 < -(n % 8) + n; c0 += 8) {
+    for (int c1 = 0; c1 < -(n % 8) + n; c1 += 8)
+      for (int c2 = 0; c2 <= 7; c2 += 1)
+        for (int c3 = 0; c3 <= 7; c3 += 1)
+          A(c0 + c2, c1 + c3);
+    for (int c2 = 0; c2 <= 7; c2 += 1)
+      for (int c3 = 0; c3 < n % 8; c3 += 1)
+        A(c0 + c2, -(n % 8) + n + c3);
+  }
+  for (int c1 = 0; c1 < n; c1 += 8)
+    for (int c2 = 0; c2 < n % 8; c2 += 1)
+      for (int c3 = 0; c3 <= min(7, n - c1 - 1); c3 += 1)
+        A(-(n % 8) + n + c2, c1 + c3);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class2.in b/lib/Analysis/isl/test_inputs/codegen/separation_class2.in
new file mode 100644
index 0000000..5469626
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class2.in
@@ -0,0 +1,3 @@
+[n] -> { A[i,j] -> [it,jt, ip, jp] : 0 <= i,j < n and ip = i % 8 and it = i - ip and jp = j % 8 and jt = j - jp}
+[n] -> { : n >= 10}
+[n] -> { [it, jt, ip, jp] -> separation_class[[x]->[1]]: (exists id, jd: 0 <= x <= 3 and it < n - id and jt < n - jd and id = n %8 and jd = n %8)}
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class3.c b/lib/Analysis/isl/test_inputs/codegen/separation_class3.c
new file mode 100644
index 0000000..cea4e04
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class3.c
@@ -0,0 +1,31 @@
+for (int c0 = 0; c0 <= 4; c0 += 1) {
+  if (c0 == 0) {
+    S_0(0, 4);
+  } else {
+    S_0(2 * c0 - 1, 1);
+    if (c0 == 4) {
+      for (int c6 = 3; c6 <= 5; c6 += 1)
+        S_0(7, c6);
+    } else {
+      for (int c4 = 2 * c0 - 1; c4 <= 2 * c0; c4 += 1)
+        for (int c6 = -2 * c0 + c4 + 4; c6 <= 2 * c0 - c4 + 4; c6 += 1)
+          S_0(c4, c6);
+    }
+  }
+  for (int c4 = max(0, 2 * c0 - 1); c4 <= min(7, 2 * c0); c4 += 1)
+    for (int c6 = -2 * c0 + c4 + 8; c6 <= 8; c6 += 1)
+      S_0(c4, c6);
+  if (c0 >= 1 && c0 <= 3) {
+    for (int c2 = 0; c2 <= 1; c2 += 1)
+      for (int c4 = 2 * c0 - 1; c4 <= 2 * c0; c4 += 1)
+        for (int c6 = 2 * c0 + 4 * c2 - c4 + 1; c6 <= -2 * c0 + 4 * c2 + c4 + 3; c6 += 1)
+          S_0(c4, c6);
+  } else if (c0 == 4) {
+    for (int c2 = 0; c2 <= 1; c2 += 1)
+      S_0(7, 4 * c2 + 2);
+  } else {
+    for (int c2 = 0; c2 <= 1; c2 += 1)
+      for (int c6 = 4 * c2 + 1; c6 <= 4 * c2 + 3; c6 += 1)
+        S_0(0, c6);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class3.in b/lib/Analysis/isl/test_inputs/codegen/separation_class3.in
new file mode 100644
index 0000000..1aaf251
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class3.in
@@ -0,0 +1,4 @@
+{ S_0[t, i] -> [o0, 1, o2, 0, t, 0, i] : 4o2 >= -4 + t + i - 2o0 and 4o2 >= -3 - t + i + 2o0 and 2o0 <= 1 + t and 2o0 >= t and 4o2 <= -1 + t + i - 2o0 and t >= 0 and t <= 7 and i >= 1 and i <= 8; S_0[t, i] -> [o0, 0, o2, 0, t, 0, i] : 4o2 >= t + i - 2o0 and 4o2 <= -t + i + 2o0 and 2o0 <= 1 + t and 2o0 >= t and t >= 0 and t <= 7 and i >= 1 and i <= 8 }
+{:}
+{ [i0, 1, i2, i3, i4, i5, i6] -> separation_class[[2] -> [0]] : i2 <= 1 and i2 >= 0 and i0 <= 3 and i0 >= 1; [i0, 0, 1, i3, i4, i5, i6] -> separation_class[[2] -> [0]] : i0 <= 3 and i0 >= 1; [i0, i1, i2, i3, i4, i5, i6] -> unroll[1] }
+
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class4.c b/lib/Analysis/isl/test_inputs/codegen/separation_class4.c
new file mode 100644
index 0000000..6d877d67
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class4.c
@@ -0,0 +1,22 @@
+for (int c0 = 0; c0 <= 128; c0 += 1) {
+  if (c0 <= 127) {
+    if (c0 == 0) {
+      for (int c3 = 0; c3 <= 1; c3 += 1)
+        for (int c5 = c3 + 58; c5 <= -c3 + 61; c5 += 1)
+          S_0(c3, c5);
+    } else {
+      for (int c2 = 1; c2 <= 2; c2 += 1)
+        for (int c3 = max(4 * c0 - 2, 4 * c0 + 6 * c2 - 12); c3 <= min(4 * c0 + 1, 4 * c0 + 6 * c2 - 7); c3 += 1)
+          for (int c5 = max(4 * c0 - c3 + 57, -4 * c0 + c3 + 58); c5 <= min(4 * c0 - c3 + 61, -4 * c0 + c3 + 62); c5 += 1)
+            S_0(c3, c5);
+    }
+    for (int c2 = 1; c2 <= 2; c2 += 1)
+      for (int c3 = max(4 * c0, 4 * c0 + 6 * c2 - 10); c3 <= min(4 * c0 + 3, 4 * c0 + 6 * c2 - 5); c3 += 1)
+        for (int c5 = max(-4 * c0 + c3 + 59, 4 * c0 - c3 + 62); c5 <= min(-4 * c0 + c3 + 63, 4 * c0 - c3 + 66); c5 += 1)
+          S_0(c3, c5);
+  } else {
+    for (int c3 = 510; c3 <= 511; c3 += 1)
+      for (int c5 = -c3 + 569; c5 < c3 - 449; c5 += 1)
+        S_0(c3, c5);
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/separation_class4.in b/lib/Analysis/isl/test_inputs/codegen/separation_class4.in
new file mode 100644
index 0000000..c04dd79
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/separation_class4.in
@@ -0,0 +1,10 @@
+# Check that isl is not confused by the combination of separation classes
+# and unroll.
+{ S_0[t, i] -> [o0, 1, o9, t] : 4o0 >= -3 + t and 4o0 <= t and i >= 60 and i <= 65 and 6o9 >= 5 + t - 4o0 and 6o9 <= 10 + t - 4o0 and 4o0 <= -62 + t + i and 4o0 >= 59 + t - i and o0 >= 0 and o0 <= 127 and t <= 511 and t >= 0 and 4o0 >= -66 + t + i and 4o0 <= 63 + t - i;
+S_0[t, i] -> [o0, 0, o9, t] : 4o0 >= -1 + t and 4o0 <= 2 + t and i >= 57 and i <= 62 and 6o9 >= 7 + t - 4o0 and 6o9 <= 12 + t - 4o0 and t >= 0 and t <= 511 and 4o0 <= -57 + t + i and 4o0 >= 58 + t - i and o0 >= 0 and o0 <= 128 and 4o0 >= -61 + t + i and 4o0 <= 62 + t - i }
+{ : }
+{ [i0, i1, i2, t] -> unroll[1];
+[i0, 1, i2, t] -> separation_class[[1] -> [0]]
+	: 0 <= i0 <= 127;
+[i0, 0, i2, t] -> separation_class[[1] -> [0]]
+	: 1 <= i0 <= 127}
diff --git a/lib/Analysis/isl/test_inputs/codegen/shift.c b/lib/Analysis/isl/test_inputs/codegen/shift.c
new file mode 100644
index 0000000..f4156bc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/shift.c
@@ -0,0 +1,4 @@
+for (int c0 = 0; c0 <= 9; c0 += 1) {
+  A(c0);
+  B(c0);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/shift.in b/lib/Analysis/isl/test_inputs/codegen/shift.in
new file mode 100644
index 0000000..702c527
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/shift.in
@@ -0,0 +1,3 @@
+{ A[i] -> [2i]: 0 <= i < 10; B[i] -> [2i+1] : 0 <= i < 10 }
+{ : }
+{ }
diff --git a/lib/Analysis/isl/test_inputs/codegen/shift2.c b/lib/Analysis/isl/test_inputs/codegen/shift2.c
new file mode 100644
index 0000000..a0571c9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/shift2.c
@@ -0,0 +1,56 @@
+for (int c0 = 0; c0 <= 1; c0 += 1) {
+  for (int c1 = 0; c1 < length - 1; c1 += 32) {
+    for (int c2 = c1; c2 < length; c2 += 32) {
+      if (c1 == 0)
+        for (int c3 = 0; c3 <= min(length, 2 * c2 - 31); c3 += 32)
+          for (int c5 = 0; c5 <= min(31, length - c2 - 1); c5 += 1)
+            for (int c6 = max(0, -c3 + 1); c6 <= min(31, length - c3); c6 += 1)
+              S_0(c0, c2 + c5, c3 + c6 - 1);
+      for (int c3 = 2 * c2; c3 <= min(2 * length - 2, 2 * c2 + 62); c3 += 32)
+        for (int c4 = 0; c4 <= min(min(31, length - c1 - 2), (c3 / 2) - c1 + 14); c4 += 1) {
+          if (c1 == 0 && c2 == 0 && c4 == 0)
+            for (int c6 = max(0, -c3 + 1); c6 <= min(31, length - c3); c6 += 1)
+              S_0(c0, 0, c3 + c6 - 1);
+          if (c1 == 0 && c3 == 2 * c2 + 32 && c4 == 0)
+            for (int c5 = max(0, -c2 + 1); c5 <= 15; c5 += 1)
+              for (int c6 = 0; c6 <= min(31, length - 2 * c2 - 32); c6 += 1)
+                S_0(c0, c2 + c5, 2 * c2 + c6 + 31);
+          for (int c5 = max((c3 / 2) - c2, c1 - c2 + c4 + 1); c5 <= min(length - c2 - 1, (c3 / 2) - c2 + 15); c5 += 1) {
+            if (c1 == 0 && c4 == 0)
+              for (int c6 = max(0, -c3 + 1); c6 <= min(length - c3, 2 * c2 - c3 + 2 * c5 - 1); c6 += 1)
+                S_0(c0, c2 + c5, c3 + c6 - 1);
+            S_3(c0, c1 + c4, c2 + c5);
+            if (c1 == 0 && c4 == 0 && length >= 2 * c2 + 2 * c5)
+              S_0(c0, c2 + c5, 2 * c2 + 2 * c5 - 1);
+            if (c1 == 0 && c4 == 0)
+              for (int c6 = 2 * c2 - c3 + 2 * c5 + 1; c6 <= min(31, length - c3); c6 += 1)
+                S_0(c0, c2 + c5, c3 + c6 - 1);
+          }
+          if (c1 == 0 && c3 == 2 * c2 && c4 == 0)
+            for (int c5 = 16; c5 <= min(31, length - c2 - 1); c5 += 1)
+              for (int c6 = max(0, -2 * c2 + 1); c6 <= min(31, length - 2 * c2); c6 += 1)
+                S_0(c0, c2 + c5, 2 * c2 + c6 - 1);
+          if (c1 == 0 && c3 + 30 >= 2 * length && c4 == 0)
+            S_4(c0);
+        }
+      if (c1 == 0) {
+        for (int c3 = 2 * c2 + 64; c3 <= length; c3 += 32)
+          for (int c5 = 0; c5 <= 31; c5 += 1)
+            for (int c6 = 0; c6 <= min(31, length - c3); c6 += 1)
+              S_0(c0, c2 + c5, c3 + c6 - 1);
+        if (c2 + 16 == length)
+          S_4(c0);
+      }
+    }
+    if (c1 == 0 && length % 32 == 0)
+      S_4(c0);
+  }
+  if (length <= 1)
+    for (int c5 = 0; c5 <= length; c5 += 1) {
+      if (c5 == length) {
+        S_4(c0);
+      } else {
+        S_0(c0, 0, 0);
+      }
+    }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/shift2.in b/lib/Analysis/isl/test_inputs/codegen/shift2.in
new file mode 100644
index 0000000..3c05fac
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/shift2.in
@@ -0,0 +1,5 @@
+# Check that the shifting code is not confused by domains that
+# have a non-obviously fixed value.
+[tsteps, length] -> { S_4[iter] -> [iter, 0, o2, o3, 0, o5, o6, 3] : exists (e0 = [(o2)/32], e1 = [(o3)/32], e2 = [(-length + o5)/32], e3 = [(-2length + o6)/32]: tsteps = 2 and 32e0 = o2 and 32e1 = o3 and 32e2 = -length + o5 and 32e3 = -2length + o6 and o2 <= length and o2 >= -31 + length and o3 <= 2length and o3 >= -30 + 2length and o5 >= 0 and o5 <= 31 and o6 >= 0 and o6 <= 30 and iter <= 1 and iter >= 0); S_3[iter, i, j] -> [iter, o1, o2, o3, o4, o5, o6, 2] : exists (e0 = [(o1)/32], e1 = [(o2)/32], e2 = [(o3)/32], e3 = [(-i + o4)/32], e4 = [(-j + o5)/32], e5 = [(-2j + o6)/32]: tsteps = 2 and 32e0 = o1 and 32e1 = o2 and 32e2 = o3 and 32e3 = -i + o4 and 32e4 = -j + o5 and 32e5 = -2j + o6 and o1 <= i and o1 >= -31 + i and o2 <= j and o2 >= -31 + j and o3 <= 2j and o3 >= -30 + 2j and o4 >= 0 and o4 <= 31 and o5 >= 0 and o5 <= 31 and o6 >= 0 and o6 <= 30 and j >= 1 + i and i >= 0 and iter <= 1 and iter >= 0 and j <= -1 + length); S_0[iter, i, j] -> [iter, 0, o2, o3, 0, o5, o6, 4] : exists (e0 = [(o2)/32], e1 = [(o3)/32], e2 = [(-i + o5)/32], e3 = [(-31 + j - o6)/32]: tsteps = 2 and 32e0 = o2 and 32e1 = o3 and 32e2 = -i + o5 and 32e3 = -31 + j - o6 and o2 <= i and o2 >= -31 + i and o3 <= 1 + j and o3 >= -30 + j and o5 >= 0 and o5 <= 31 and o6 >= 0 and o6 <= 31 and i <= -1 + length and i >= 0 and iter >= 0 and iter <= 1 and j <= -1 + length and j >= 0) }
+[tsteps, length] -> {  : length >= 0 and length <= 1024 and tsteps = 2 }
+{ }
diff --git a/lib/Analysis/isl/test_inputs/codegen/shift_unroll.c b/lib/Analysis/isl/test_inputs/codegen/shift_unroll.c
new file mode 100644
index 0000000..2a38286
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/shift_unroll.c
@@ -0,0 +1,14 @@
+for (int c0 = 0; c0 <= 9; c0 += 1) {
+  A(c0, 0);
+  A(c0, 1);
+  A(c0, 2);
+  A(c0, 3);
+  A(c0, 4);
+  A(c0, 5);
+  A(c0, 6);
+  A(c0, 7);
+  A(c0, 8);
+  A(c0, 9);
+  for (int c2 = 0; c2 <= 9; c2 += 1)
+    B(c0, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/shift_unroll.in b/lib/Analysis/isl/test_inputs/codegen/shift_unroll.in
new file mode 100644
index 0000000..4b773c2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/shift_unroll.in
@@ -0,0 +1,3 @@
+{ A[i,j] -> [2i,0,j]: 0 <= i,j < 10; B[i,j] -> [2i+1,1,j] : 0 <= i,j < 10 }
+{ : }
+{ [i,0,j] -> unroll[2] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/single_valued.c b/lib/Analysis/isl/test_inputs/codegen/single_valued.c
new file mode 100644
index 0000000..e071002
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/single_valued.c
@@ -0,0 +1,2 @@
+if (2 * ((t1 - 1) % 64) + 8 >= t1)
+  S(-(2 * ((t1 - 1) % 64)) + t1 + 126);
diff --git a/lib/Analysis/isl/test_inputs/codegen/single_valued.in b/lib/Analysis/isl/test_inputs/codegen/single_valued.in
new file mode 100644
index 0000000..d729942
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/single_valued.in
@@ -0,0 +1,5 @@
+# Check that isl recognizes that the inverse schedule is single-valued
+# and does not end up in an infinite recursion.
+[t1] -> {S[c2] -> [c2]: t1 <= c2 <= 134 and (c2+t1) % 128 = 0 and c2 > 0}
+[t1] -> {: t1 > 0}
+[t1] -> {}
diff --git a/lib/Analysis/isl/test_inputs/codegen/sor1d-part.c b/lib/Analysis/isl/test_inputs/codegen/sor1d-part.c
new file mode 100644
index 0000000..096d34d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/sor1d-part.c
@@ -0,0 +1,3 @@
+for (int c0 = 1; c0 < max((6 * M + 3 * N + 188) / 200 - 2, (N + 93) / 100 + 3 * ((2 * M + N - 4) / 200) - 1); c0 += 1)
+  for (int c1 = max(0, floord(-N + 100 * c0 + 106, 300)); c1 <= min((2 * M + N - 4) / 200 - 1, (c0 - 1) / 3); c1 += 1)
+    S2(c0 - c1, c1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/sor1d-part.st b/lib/Analysis/isl/test_inputs/codegen/sor1d-part.st
new file mode 100644
index 0000000..9bbf3d3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/sor1d-part.st
@@ -0,0 +1,10 @@
+# Check that a proper upper bound is generated for the outer loop.
+# Earlier versions of isl would generate an incorrect bound.
+domain: "[M, N] -> { S2[i0, i1] : i1 >= 0 and  200i1 >= -193 - N + 100i0 and i0 >= 0 and 200i1 <= -204 + 2M + N and 2i1 <= -1 + i0 and 100i1 >= -94 - N + 50i0 and 100i1 >= -94 - N }"
+child:
+  context: "[M, N] -> { [] : M >= 0 and N >= 4 }"
+  child:
+    schedule: "[M, N] -> [{ S2[i0, i1] -> [(i0 + i1)]}]"
+    options: "[M, N] -> { separate[i0] }"
+    child:
+          schedule: "[M, N] -> [{ S2[i0, i1] -> [(i1)]}]"
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride.c b/lib/Analysis/isl/test_inputs/codegen/stride.c
new file mode 100644
index 0000000..5b68829
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 <= 100; c0 += 2) {
+  for (int c3 = 0; c3 <= 100; c3 += 1)
+    A(c0, c3);
+  for (int c2 = 0; c2 <= 100; c2 += 1)
+    B(c0, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride.in b/lib/Analysis/isl/test_inputs/codegen/stride.in
new file mode 100644
index 0000000..b01c566
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride.in
@@ -0,0 +1,6 @@
+# Check that we find a common stride on the first dimension
+# even if it is imposed by different inner dimensions
+{ A[i,k] -> [i,0,j,k] : 0 <= i,k <= 100 and i = 2 j;
+  B[i,k] -> [i,1,k,j] : 0 <= i,k <= 100 and i = 2 j }
+{ : }
+{ }
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride5.c b/lib/Analysis/isl/test_inputs/codegen/stride5.c
new file mode 100644
index 0000000..5954439
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride5.c
@@ -0,0 +1,3 @@
+if (n % 2 == 0)
+  for (int c0 = (-n / 2) + 2 * floord(n - 1, 4) + 2; c0 <= 100; c0 += 2)
+    S(c0);
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride5.in b/lib/Analysis/isl/test_inputs/codegen/stride5.in
new file mode 100644
index 0000000..a67a802
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride5.in
@@ -0,0 +1,3 @@
+[n] -> { S[t] -> [t] : exists e : 2 t - n = 4e and 0 <= t <= 100 }
+[n] -> { : }
+{ }
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride6.c b/lib/Analysis/isl/test_inputs/codegen/stride6.c
new file mode 100644
index 0000000..c09e8b5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride6.c
@@ -0,0 +1,4 @@
+for (int c1 = -1024; c1 <= 0; c1 += 32)
+  for (int c2 = max(-((niter - 1) % 32) + niter - 1, -((niter - c1) % 32) + niter - c1 - 32); c2 <= min(niter + 1022, niter - c1 - 1); c2 += 32)
+    for (int c5 = max(max(0, -c1 - 1023), niter - c1 - c2 - 32); c5 <= min(min(31, -c1), niter - c1 - c2 - 1); c5 += 1)
+      S_4(niter - 1, -c1 - c5);
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride6.in b/lib/Analysis/isl/test_inputs/codegen/stride6.in
new file mode 100644
index 0000000..86ca54a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride6.in
@@ -0,0 +1,3 @@
+[niter] -> { S_4[-1 + niter, i] -> [o0, o1, o2, o3, o4, o5, o6, o7, 4] : exists (e0 = [(o0)/32], e1 = [(o1)/32], e2 = [(o2)/32], e3 = [(o3)/32], e4 = [(-31i + o5)/32], e5 = [(-i - o4 + o6)/32], e6 = [(-o4 + o7)/32], e7 = [(-1 + niter - o4)/32]: 32e0 = o0 and 32e1 = o1 and 32e2 = o2 and 32e3 = o3 and 32e4 = -31i + o5 and 32e5 = -i - o4 + o6 and 32e6 = -o4 + o7 and 32e7 = -1 + niter - o4 and o0 <= -1 + niter and o0 >= -32 + niter and o1 <= -i and o1 >= -31 - i and o2 <= -1 + niter + i and o2 >= -32 + niter + i and o3 <= 1023 + niter and o3 >= 992 + niter and o4 >= 0 and o4 <= 31 and o5 >= 0 and o5 <= 31 and o6 >= 0 and o6 <= 31 and o7 >= 0 and o7 <= 31 and i <= 1023 and i >= 0 and niter >= 1) }
+[niter] -> {  : niter <= 8192 and niter >= 1 }
+[niter] -> {  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride7.c b/lib/Analysis/isl/test_inputs/codegen/stride7.c
new file mode 100644
index 0000000..b64c66d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride7.c
@@ -0,0 +1,6 @@
+for (int c0 = 2; c0 <= 200; c0 += 64) {
+  for (int c2 = c0 - 1; c2 <= 120; c2 += 1)
+    s2(c0, c2);
+  for (int c2 = 122; c2 <= c0 + 62; c2 += 1)
+    s4(c0, c2);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/stride7.in b/lib/Analysis/isl/test_inputs/codegen/stride7.in
new file mode 100644
index 0000000..cac9cac
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/stride7.in
@@ -0,0 +1,7 @@
+# Check that no redundant guards are introduced
+{ s4[a, b] -> [a, 2, b] : exists (e0 = floor((-2 + a)/64):
+    64e0 = -2 + a and a <= 200 and b <= 62 + a and b >= 122);
+  s2[a, b] -> [a, 2, b] : exists (e0 = floor((-2 + a)/64):
+    64e0 = -2 + a and a >= 2 and b <= 120 and b >= -1 + a and a <= 100) }
+{ : }
+{ }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll.c b/lib/Analysis/isl/test_inputs/codegen/unroll.c
new file mode 100644
index 0000000..63594bb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll.c
@@ -0,0 +1,5 @@
+{
+  A(0);
+  A(100000000);
+  A(200000000);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll.in b/lib/Analysis/isl/test_inputs/codegen/unroll.in
new file mode 100644
index 0000000..65561e2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll.in
@@ -0,0 +1,5 @@
+# Test that unrolling takes into account stride constraints.
+# If it didn't, it would run essentially forever on this example.
+[n] -> { A[i] -> [i] : exists a : i = 100000000 a and 0 <= a <= 2 }
+{:}
+{ [i] -> unroll[0] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll10.c b/lib/Analysis/isl/test_inputs/codegen/unroll10.c
new file mode 100644
index 0000000..061954e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll10.c
@@ -0,0 +1,29 @@
+if (m >= 1 && n >= 1) {
+  A(0);
+  if (m >= 2 && n >= 2) {
+    A(1);
+    if (m >= 3 && n >= 3) {
+      A(2);
+      if (m >= 4 && n >= 4) {
+        A(3);
+        if (m >= 5 && n >= 5) {
+          A(4);
+          if (m >= 6 && n >= 6) {
+            A(5);
+            if (m >= 7 && n >= 7) {
+              A(6);
+              if (m >= 8 && n >= 8) {
+                A(7);
+                if (m >= 9 && n >= 9) {
+                  A(8);
+                  if (m >= 10 && n >= 10)
+                    A(9);
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll10.in b/lib/Analysis/isl/test_inputs/codegen/unroll10.in
new file mode 100644
index 0000000..5890c4e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll10.in
@@ -0,0 +1,4 @@
+# Check that all information is taken into account while trying to unroll
+[m,n] -> { A[i] -> [i] : 0 <= i < n,m }
+[m,n] -> { : m <= 10 or n <= 10 }
+{ [i] -> unroll[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll10.st b/lib/Analysis/isl/test_inputs/codegen/unroll10.st
new file mode 100644
index 0000000..77c5b19
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll10.st
@@ -0,0 +1,7 @@
+# Check that all information is taken into account while trying to unroll
+domain: "[m,n] -> { A[i] : 0 <= i < n,m }"
+child:
+  context: "[m,n] -> { [] : m <= 10 or n <= 10 }"
+  child:
+    schedule: "[{ A[i] -> [i] }]"
+    options: "{ unroll[x] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll11.c b/lib/Analysis/isl/test_inputs/codegen/unroll11.c
new file mode 100644
index 0000000..c1fc529
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll11.c
@@ -0,0 +1,8 @@
+{
+  if (t1 >= 126)
+    S(0, t1 - 384);
+  S(0, t1 - 256);
+  if (t1 >= 126)
+    S(1, t1 - 384);
+  S(1, t1 - 256);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll11.in b/lib/Analysis/isl/test_inputs/codegen/unroll11.in
new file mode 100644
index 0000000..79445e2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll11.in
@@ -0,0 +1,10 @@
+# Check that the most appropriate lower bound is selected
+[t1,t2]->{ S[i,j] -> [i,j] : exists (alpha, beta :
+    0 <= i <= 1 &&
+    t1 = j+128alpha &&
+    0 <= j+2beta < 128 &&
+    510 <= t2+2beta <= 514 &&
+    0 <= 2beta - t2 <= 5
+)}
+[t1,t2] -> {: 125 <= t1 <= 127 and 254 <= t2 < 257}
+{[i,j] -> unroll[x]}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll2.c b/lib/Analysis/isl/test_inputs/codegen/unroll2.c
new file mode 100644
index 0000000..7ae38be
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll2.c
@@ -0,0 +1,11 @@
+{
+  A(0);
+  A(1);
+  A(2);
+  A(3);
+  for (int c0 = 4; c0 <= 99996; c0 += 1)
+    A(c0);
+  A(99997);
+  A(99998);
+  A(99999);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll2.in b/lib/Analysis/isl/test_inputs/codegen/unroll2.in
new file mode 100644
index 0000000..0fb36ab
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll2.in
@@ -0,0 +1,5 @@
+# Check that the different disjuncts in the unroll option
+# are handled separately.
+{ A[i] -> [i] : 0 <= i < 100000 }
+{ : }
+{ [i] -> unroll[0] : i < 4 or i > 99996 }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll3.c b/lib/Analysis/isl/test_inputs/codegen/unroll3.c
new file mode 100644
index 0000000..f6f390d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll3.c
@@ -0,0 +1,2 @@
+if ((t1 + 121) % 128 <= 123)
+  write_shared_A(((t1 + 121) % 128) + 1);
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll3.in b/lib/Analysis/isl/test_inputs/codegen/unroll3.in
new file mode 100644
index 0000000..098e501
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll3.in
@@ -0,0 +1,6 @@
+# Check that the entire schedule is completely unrolled and
+# in particular that no spurious loop is introduced.
+[t1] -> { write_shared_A[i2] -> [1, 3, 6 + i2, 0, t1] : (exists (e0 = [(-6 + t1 - i2)/128]: 128e0 = -6 + t1 - i2 and i2 <= 122 and i2 >= 1 and t1 >= 0 and t1 <= 127)) or (exists (e0 = [(-6 + t1 - i2)/128]: 128e0 = -6 + t1 - i2 and i2 >= 123 and i2 <= 124 and t1 <= 127 and t1 >= 0 )) }
+[t1] -> { : t1 >= 0 and t1 <= 127 }
+[t1] -> { [i0, i1, i2, i3, i4] -> unroll[o0] }
+
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll4.c b/lib/Analysis/isl/test_inputs/codegen/unroll4.c
new file mode 100644
index 0000000..6d4c341
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll4.c
@@ -0,0 +1,16 @@
+{
+  write_shared_A(3, ((t1 + 3) % 4) + 1, ((t2 + 31) % 32) + 1);
+  if (t2 >= 1 && t2 <= 2 && t1 % 3 == 0)
+    write_shared_A(3, (-t1 / 3) + 4, t2 + 32);
+  if (((-((t1 + 3) % 4) + t2 + 30) % 32) + t1 >= ((t1 + 3) % 4) + ((t2 + 1) % 2) - 4 * ((-t1 + 4) / 4) + 1)
+    write_shared_A(3, ((t1 + 3) % 4) + 5, -((((t1 + 3) % 4) - t2 + 33) % 32) + t1 + 4 * ((-t1 + 4) / 4) + 32);
+  if (t1 >= 1 && t2 >= t1 + 1 && t2 <= 4)
+    write_shared_A(3, t1 + 4, t2 + 32);
+  write_shared_A(4, ((t1 + 3) % 4) + 1, ((t2 + 31) % 32) + 1);
+  if (t2 >= 1 && t2 <= 2 && t1 % 3 == 0)
+    write_shared_A(4, (-t1 / 3) + 4, t2 + 32);
+  if (((-((t1 + 3) % 4) + t2 + 30) % 32) + t1 >= ((t1 + 3) % 4) + ((t2 + 1) % 2) - 4 * ((-t1 + 4) / 4) + 1)
+    write_shared_A(4, ((t1 + 3) % 4) + 5, -((((t1 + 3) % 4) - t2 + 33) % 32) + t1 + 4 * ((-t1 + 4) / 4) + 32);
+  if (t1 >= 1 && t2 >= t1 + 1 && t2 <= 4)
+    write_shared_A(4, t1 + 4, t2 + 32);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll4.in b/lib/Analysis/isl/test_inputs/codegen/unroll4.in
new file mode 100644
index 0000000..d8be866
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll4.in
@@ -0,0 +1,5 @@
+# Check that the generated code does not contain two declarations
+# of the same variable in the same scope.
+[t1, t2, g] -> { write_shared_A[a, b, c] -> [0, a, b, c] : exists (e0, e1 = [(-t1 + b)/4], e2 = [(-t2 + c)/32]: 4e1 = -t1 + b and 32e2 = -t2 + c and e0 <= 2 + 3g and e0 >= 3g and a <= 4 and a >= 3 and t2 >= 0 and t1 <= 3 and 2e0 >= 5 - c + 6g and 2e0 <= 36 - c + 6g and 2e0 >= 5 - b + 6g and 2e0 <= 8 - b + 6g and 2e0 <= 638 - c and 2e0 <= 638 - b and 2e0 >= 2 - a + 6g and 2e0 >= -8 + a + 6g and 2e0 <= 1 + a + 6g and 2e0 <= 11 - a + 6g and e0 >= 0 and e0 <= 254 and t1 >= 0 and t2 <= 31 and b >= 1 and b <= 126 and c >= 1 and c <= 126 and g <= 3 and g >= 0) }
+[t1, t2, g] -> { : g <= 3 and g >= 0 and t1 >= 0 and t1 <= 3 and t2 >= 0 and t2 <= 5 }
+[t1, t2] -> { [i0, i1, i2, i3] -> unroll[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll6.c b/lib/Analysis/isl/test_inputs/codegen/unroll6.c
new file mode 100644
index 0000000..1d8cc5e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll6.c
@@ -0,0 +1,8 @@
+{
+  if (g >= 0 && nn >= 128 * g + 6 && nn >= ((t1 + 127) % 128) + 128 * g + 3)
+    for (int c1 = 393214; c1 < nn - 1; c1 += 393216)
+      A(c1, ((t1 + 127) % 128) + 128 * g + 1, ((t1 + 127) % 128) + 1);
+  if (t1 >= 1 && t1 <= 2 && nn >= t1 + 128 * g + 130 && t1 + 128 * g >= -127)
+    for (int c1 = 393214; c1 < nn - 1; c1 += 393216)
+      A(c1, t1 + 128 * g + 128, t1 + 128);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll6.in b/lib/Analysis/isl/test_inputs/codegen/unroll6.in
new file mode 100644
index 0000000..b4338e3
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll6.in
@@ -0,0 +1,7 @@
+# Check that the right lower bound is chosen for unrolling.
+# Older versions of isl would pick a lower bound that resulted
+# in a number of slices that exceeds the maximal value of an integer
+# and then only generated code for a truncated number (zero) of slices.
+[nn, t1, g] -> { A[a, b, c] -> [c] : exists (e0 = [(2 + a)/393216], e1 = [(t1 - c)/128]: 128g = b - c and 393216e0 = 2 + a and 128e1 = t1 - c and c <= 130 and c >= 6 - nn + b and c <= 128 + b and nn >= 137 and t1 >= 0 and c >= 1 and a <= -2 + nn and a >= 1 and nn <= 9223372036854775807 and b >= 1 and b <= -2 + nn and t1 <= 127) }
+[nn, t1, g] -> { : nn <= 9223372036854775807 and nn >= 137 and t1 >= 0 and t1 <= 127 }
+{ [c] -> unroll[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll7.c b/lib/Analysis/isl/test_inputs/codegen/unroll7.c
new file mode 100644
index 0000000..8392185
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll7.c
@@ -0,0 +1,10 @@
+{
+  S(0, 0);
+  S(0, 3);
+  S(0, 4);
+  S(1, 1);
+  S(1, 4);
+  S(2, 2);
+  S(3, 3);
+  S(4, 4);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll7.in b/lib/Analysis/isl/test_inputs/codegen/unroll7.in
new file mode 100644
index 0000000..494e597
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll7.in
@@ -0,0 +1,5 @@
+# Check that some code is generated.
+# Older versions of isl would abort on unknown divs.
+{ S[i,j] -> [i,j]: exists (alpha, beta: j=i+4alpha +3beta and 0 <= alpha < 24 and 0 <= beta and 0 <= i,j < 5) }
+{ : }
+{ [i,j] -> unroll[x] }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll8.c b/lib/Analysis/isl/test_inputs/codegen/unroll8.c
new file mode 100644
index 0000000..b3ca142
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll8.c
@@ -0,0 +1,6 @@
+for (int c0 = 0; c0 <= 99; c0 += 1) {
+  A(c0, 0);
+  A(c0, 1);
+  B(c0, 0);
+  B(c0, 1);
+}
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll8.st b/lib/Analysis/isl/test_inputs/codegen/unroll8.st
new file mode 100644
index 0000000..94fb49e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll8.st
@@ -0,0 +1,5 @@
+# Check that options are adjusted by shifted stride detection
+domain: "{ A[i,j] : 0 <= i < 100 and 0 <= j < 2; B[i,j] : 0 <= i < 100 and 0 <= j < 2 }"
+child:
+  schedule: "[{ A[i,j] -> [2i]; B[i,j] -> [2i+1] }, { A[i,j] -> [j]; B[i,j] -> [j]}]"
+  options: "{ unroll[1] }"
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll9.c b/lib/Analysis/isl/test_inputs/codegen/unroll9.c
new file mode 100644
index 0000000..b00ea41
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll9.c
@@ -0,0 +1,7 @@
+for (int c0 = 0; c0 <= 99; c0 += 1)
+  for (int c1 = 0; c1 <= 99; c1 += 1) {
+    A(c1, 0, c0);
+    A(c1, 1, c0);
+    B(c1, 0, c0);
+    B(c1, 1, c0);
+  }
diff --git a/lib/Analysis/isl/test_inputs/codegen/unroll9.st b/lib/Analysis/isl/test_inputs/codegen/unroll9.st
new file mode 100644
index 0000000..653da41
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/codegen/unroll9.st
@@ -0,0 +1,7 @@
+# Check that options are interpreted locally
+domain: "{ A[i,j,k] : 0 <= i,k < 100 and 0 <= j < 2; B[i,j,k] : 0 <= i,k < 100 and 0 <= j < 2 }"
+child:
+  schedule: "[{ A[i,j,k] -> [k]; B[i,j,k] -> [k] }]"
+  child:
+    schedule: "[{ A[i,j,k] -> [2i]; B[i,j,k] -> [2i+1] }, { A[i,j,k] -> [j]; B[i,j,k] -> [j]}]"
+    options: "{ unroll[1] }"
diff --git a/lib/Analysis/isl/test_inputs/convex0.polylib b/lib/Analysis/isl/test_inputs/convex0.polylib
new file mode 100644
index 0000000..cbc4d3b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex0.polylib
@@ -0,0 +1,11 @@
+2 3
+1 1 0
+1 -1 1
+
+2 3
+1 1 -1
+1 -1 2
+
+2 3
+1 1 0
+1 -1 2
diff --git a/lib/Analysis/isl/test_inputs/convex1.polylib b/lib/Analysis/isl/test_inputs/convex1.polylib
new file mode 100644
index 0000000..b563d8d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex1.polylib
@@ -0,0 +1,17 @@
+# {j,N | 0<=j<=N-1; 2<=N}
+4 4
+1   1  0   0
+1  -1  1  -1
+1   0  1  -2
+1   0  0   1
+# {j, N | 1<=j<=N; 1<=N}
+4 4
+1  1  0  -1
+1 -1  1   0
+1  0  1  -1
+1  0  0   1
+# {j,N | 0<=j<=N; 2<=j+N}
+3 4
+   1    1    1   -2
+   1    1    0    0
+   1   -1    1    0
diff --git a/lib/Analysis/isl/test_inputs/convex10.polylib b/lib/Analysis/isl/test_inputs/convex10.polylib
new file mode 100644
index 0000000..3d58cbf
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex10.polylib
@@ -0,0 +1,17 @@
+3 4
+1 54 1 -4
+1 2 -1 58
+1 0 -1 6
+
+4 4
+1 54 1 -4
+1 2 -1 58
+1 0 1 -7
+1 -4 1 0
+
+4 4
+1  54    1   -4
+1   2   -1   58
+1   0   -1  116
+1   0    0    1
+
diff --git a/lib/Analysis/isl/test_inputs/convex11.polylib b/lib/Analysis/isl/test_inputs/convex11.polylib
new file mode 100644
index 0000000..f664114
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex11.polylib
@@ -0,0 +1,14 @@
+3 4
+1 0 -1 6
+1 -1 1 1
+1 1 1 -10
+
+3 4
+1 1 0 -4
+1 -1 -1 8
+1 -1 1 1
+
+3 4
+1 0 -1 6
+1 1 0 -4
+1 -1 1 1
diff --git a/lib/Analysis/isl/test_inputs/convex12.polylib b/lib/Analysis/isl/test_inputs/convex12.polylib
new file mode 100644
index 0000000..e476630
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex12.polylib
@@ -0,0 +1,12 @@
+3 5
+1   0    0    1    1
+1   0    1    0    1
+1  -1   -1    0   -2
+
+3 5
+1   0    0    1    2
+1   1   -1    0    0
+1   1    0    0   -1
+
+1 5
+1   0    0    1    2
diff --git a/lib/Analysis/isl/test_inputs/convex13.polylib b/lib/Analysis/isl/test_inputs/convex13.polylib
new file mode 100644
index 0000000..1b35912
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex13.polylib
@@ -0,0 +1,17 @@
+3 5
+1   0    0   -1    3
+1   0   -1    0    2
+1   1    1    1   -4
+
+3 5
+1   0    0    1    0
+1   1    0    0   -1
+1   1    2    0    1
+
+6 5
+1   3    2    0   -1
+1   3    0    2   -3
+1   1    0    1   -1
+1   1    1    1    0
+1   1    1    0    0
+1   1    0    0    1
diff --git a/lib/Analysis/isl/test_inputs/convex14.polylib b/lib/Analysis/isl/test_inputs/convex14.polylib
new file mode 100644
index 0000000..caaa8f5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex14.polylib
@@ -0,0 +1,14 @@
+3 4
+0 1 0 2
+1 0 1 0
+1 0 -1 2
+
+3 4
+1 1 0 0
+1 0 1 0
+1 0 -1 2
+
+3 4
+1 1 0 2
+1 0 1 0
+1 0 -1 2
diff --git a/lib/Analysis/isl/test_inputs/convex15.polylib b/lib/Analysis/isl/test_inputs/convex15.polylib
new file mode 100644
index 0000000..0118fa8
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex15.polylib
@@ -0,0 +1,66 @@
+17 8
+1    -1    -8     0    16     0     0    37
+1     1     0   -48     0     2     0    -3
+1     0   -16   -32    16     1     0    14
+1    -1    24     0     0     1     0    18
+1    -1     8    16     0     0     1    21
+1     0     0   -16     0     1     1    -2
+1     1    32    16   -32     0     0    -1
+1    -1    16    16     0     0     0    28
+1     1    -8   -32     0     1     0    -1
+1     0     0     0     0     1     0    -1
+1     0    16    16   -16     0     1    -1
+1     1     8     0   -16     0     0     0
+1     0     3     2    -2     0     0     0
+1     0     1     2    -1     0     0     0
+1     0    -1    -1     1     0     0     0
+1    -1     8     0     0     1     2     4
+1    -1   -24   -32    32     1     0    36
+
+13 8
+1    -1     0     0     0     1     3    -4
+1     1     0   -48     0     2     0    -2
+1     0     0     0     0     1     0    -1
+1     0    -8     0     0     0     1    -1
+1     0     3     2    -2     0     0     0
+1     1   -16   -16     0     0     0     0
+1     1   -24     0     0     0     0     0
+1     0     1     0     0     0     0     0
+1     0    -3    -2     2     0     0     1
+1    -1     0    16     0     0     2    13
+1    -1    24     0     0     1     0    20
+1    -1    16    16     0     0     0    29
+1    -1     0    48     0     0     0    45
+
+31 8
+   1    0    1    0    0    0    0    0 
+   1    0    0  -16    0    1    1   -2 
+   1    0    0    0    0    1    0   -1 
+   1   -1    8    0    0    1    2    4 
+   1    0    3    2   -2    0    0    0 
+   1   -1   24    0    0    1    0   20 
+   1    1    0  -48    0    2    0   -2 
+   1   -1  -24  -32   32    1    0   36 
+   1    0    0    0    0    0    1   -1 
+   1   -1   24   64  -16    0    0   45 
+   1  -15  120  112    0   15   38   52 
+   1    1   24   32  -32    0    0    0 
+   1    0   -2   -2    2    0    0    1 
+   1   -1    8   16    0    0    1   21 
+   1  -15  120  352    0    0   23  307 
+   1    1   -8  -32    0    1    0   -1 
+   1    1   -8    0    0    0    0    0 
+   1    1   -8  -16    0    0    0    0 
+   1    0   16   16  -16    0    1   -1 
+   1   -1   16   16    0    0    0   29 
+   1   -1   -8    0   16    0    0   37 
+   1   -1    8   32    0    0    0   37 
+   1    1    8    0  -16    0    0    0 
+   1  -15  360  592 -240    0   23  307 
+   1   -1   -6    2   14    0    2   20 
+   1  -15  360  352 -240   15   38   52 
+   1   -1    8   48    0    0    0   45 
+   1    0  -16  -32   16    1    0   14 
+   1   -1   -6  -14   14    1    3    3 
+   1    1  -38  -78   30    2    0   13 
+   1    1   -3  -50    2    2    0   -1 
diff --git a/lib/Analysis/isl/test_inputs/convex2.polylib b/lib/Analysis/isl/test_inputs/convex2.polylib
new file mode 100644
index 0000000..0bfd737
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex2.polylib
@@ -0,0 +1,24 @@
+# {i,j,N | 1<=i<=N; 0<=j<=N-1; 2<=N}
+6 5
+1  1  0  0 -1
+1 -1  0  1  0
+1  0  1  0  0
+1  0 -1  1 -1 
+1  0  0  1 -2
+1  0  0  0  1
+# {i,j,N | 1<=i<=N; 1<=j<=N; 2<=N}
+6 5
+1  1  0  0 -1
+1 -1  0  1  0
+1  0  1  0 -1
+1  0 -1  1  0
+1  0  0  1 -2
+1  0  0  0  1
+# {i,j,N | 1<=i<=N; 0<=j<=N; 2<=N}
+6 5
+   1    0    0    1   -2
+   1   -1    0    1    0
+   1    0   -1    1    0
+   1    1    0    0   -1
+   1    0    1    0    0
+   1    0    0    0    1
diff --git a/lib/Analysis/isl/test_inputs/convex3.polylib b/lib/Analysis/isl/test_inputs/convex3.polylib
new file mode 100644
index 0000000..ea612c6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex3.polylib
@@ -0,0 +1,10 @@
+1 4
+1 1 1 -6
+
+3 4
+1 1 1 -3
+1 1 0 -5
+1 -1 0 10
+
+1 4
+1 1 1 -3
diff --git a/lib/Analysis/isl/test_inputs/convex4.polylib b/lib/Analysis/isl/test_inputs/convex4.polylib
new file mode 100644
index 0000000..0c08653
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex4.polylib
@@ -0,0 +1,9 @@
+1 4
+1 1 1 -6
+
+2 4
+0 1 0 -1
+0 0 1 -4
+
+1 4
+1 1 1 -5
diff --git a/lib/Analysis/isl/test_inputs/convex5.polylib b/lib/Analysis/isl/test_inputs/convex5.polylib
new file mode 100644
index 0000000..3aae7c2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex5.polylib
@@ -0,0 +1,12 @@
+2 4
+0 1 0 -2
+0 0 1 -6
+
+2 4
+0 1 0 -1
+0 0 1 -4
+
+3 4
+0 -2 1 -2
+1  1 0 -1
+1 -1 0  2
diff --git a/lib/Analysis/isl/test_inputs/convex6.polylib b/lib/Analysis/isl/test_inputs/convex6.polylib
new file mode 100644
index 0000000..1bdb4e1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex6.polylib
@@ -0,0 +1,17 @@
+3 4
+1   1    1   -2
+1  -1    1    2
+1   0   -1    2
+
+3 4
+1   0    1   -1
+1   1   -1    1
+1  -1   -1    5
+
+6 4
+1  -1    0    4
+1   1    0    0
+1   1    2   -2
+1  -1    2    2
+1   1   -2    4
+1  -1   -2    8
diff --git a/lib/Analysis/isl/test_inputs/convex7.polylib b/lib/Analysis/isl/test_inputs/convex7.polylib
new file mode 100644
index 0000000..70eb483
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex7.polylib
@@ -0,0 +1,9 @@
+1 4
+0 0 1 0
+
+2 4
+1 1 -1 1
+1 -1 -1 1
+
+1 4
+1 0 -1 1
diff --git a/lib/Analysis/isl/test_inputs/convex8.polylib b/lib/Analysis/isl/test_inputs/convex8.polylib
new file mode 100644
index 0000000..ea1b757
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex8.polylib
@@ -0,0 +1,24 @@
+4 5
+1   1    1    1    0
+1   0   -1    0    0
+1  -1    0    0    2
+1   1    1   -1    0
+
+4 5
+1  -1    1    0    2
+1   1   -2   -2   -1
+1  -1    0    2    3
+1   1    0    0   -1
+
+10 5
+1   1    0    1    0
+1   1    1    0    0
+1   0    1    1    2
+1  -3    1   -1    8
+1  -3    1    1    8
+1   0    1   -1    2
+1   1    0   -1    0
+1   1   -2   -1    0
+1  -1   -3    2    6
+1   1   -5   -2    2
+
diff --git a/lib/Analysis/isl/test_inputs/convex9.polylib b/lib/Analysis/isl/test_inputs/convex9.polylib
new file mode 100644
index 0000000..f68fca0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/convex9.polylib
@@ -0,0 +1,14 @@
+4 4
+1 1 0 0
+1 -1 0 1
+1 0 1 0
+1 0 -1 10
+
+2 4
+1 1 0 -10
+0 0 -1 5
+
+3 4
+1 1 0 0
+1 0 1 0
+1 0 -1 10
diff --git a/lib/Analysis/isl/test_inputs/devos.pwqp b/lib/Analysis/isl/test_inputs/devos.pwqp
new file mode 100644
index 0000000..b452544
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/devos.pwqp
@@ -0,0 +1 @@
+[U] -> { [i0] -> ((1/3 * U + 2/3 * i0) - [(U + 2i0)/3]) : 2i0 >= -3 - U and 2i0 <= -U and U >= 0 and U <= 10 }
diff --git a/lib/Analysis/isl/test_inputs/equality1.pwqp b/lib/Analysis/isl/test_inputs/equality1.pwqp
new file mode 100644
index 0000000..eb16a4b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/equality1.pwqp
@@ -0,0 +1 @@
+[n] -> { [x] -> 1 + [(x+1)/3] : exists a : x = 3a +1 && 0 <= x <= n }
diff --git a/lib/Analysis/isl/test_inputs/equality2.pwqp b/lib/Analysis/isl/test_inputs/equality2.pwqp
new file mode 100644
index 0000000..1629a65
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/equality2.pwqp
@@ -0,0 +1 @@
+[n] -> { [x,y] -> x^2 * y : n = 2x + 4y and 0 <= x,y <= 10 }
diff --git a/lib/Analysis/isl/test_inputs/equality3.pwqp b/lib/Analysis/isl/test_inputs/equality3.pwqp
new file mode 100644
index 0000000..c6f8c3a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/equality3.pwqp
@@ -0,0 +1 @@
+[m,n] -> { [x,y] -> x^2 * y : n = 2x + 4y and 0 <= x,y <= 10 and 3 n = 5 m }
diff --git a/lib/Analysis/isl/test_inputs/equality4.pwqp b/lib/Analysis/isl/test_inputs/equality4.pwqp
new file mode 100644
index 0000000..49da2e7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/equality4.pwqp
@@ -0,0 +1 @@
+[m,n] -> { [x,y] -> x^2 * y + m + 13 * n: n = 2x + 4y and 0 <= x,y <= 10 and 3 n = 5 m }
diff --git a/lib/Analysis/isl/test_inputs/equality5.pwqp b/lib/Analysis/isl/test_inputs/equality5.pwqp
new file mode 100644
index 0000000..09cb752
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/equality5.pwqp
@@ -0,0 +1 @@
+[m,n] -> { [x,y,z] -> x^2 * y + z + m + 13 * n: n = 2x + 4y and 0 <= x,y <= 10 and 3 n = 5 m and z = x + y }
diff --git a/lib/Analysis/isl/test_inputs/esced.pip b/lib/Analysis/isl/test_inputs/esced.pip
new file mode 100644
index 0000000..dbf56ff
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/esced.pip
@@ -0,0 +1,27 @@
+0 2
+
+-1
+
+16 18
+1 0 0 0 0 0 0 0 0 -1 0 0 1 0 0 0 0 0
+1 0 0 0 0 0 0 0 0 0 -1 0 0 1 0 0 0 0
+1 0 0 0 0 0 0 0 0 0 0 -1 0 0 1 0 0 0
+1 0 0 0 0 0 0 0 0 0 0 0 0 1 -1 0 0 0
+1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
+1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0
+
+
+0 0 0 0 -1 0 0 0 0 1 -1 0 0 0 0 0 0 0
+0 0 0 0 0 -1 0 0 0 0 0 1 0 0 0 0 0 0
+
+0 -1 0 0 0 0 0 0 0 0 1 -1 0 0 0 0 0 0
+
+0 0 0 0 0 0 -1 0 0 0 0 0 1 -1 0 -1 0 0
+0 0 0 0 0 0 0 -1 0 0 0 0 0 0 1 0 0 0
+0 0 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 1 0
+
+0 0 0 0 0 0 0 0 0 0 0 0 0 1 -1 0 0 0
+0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 1 -1 0
+
+1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -1
+1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 -1
diff --git a/lib/Analysis/isl/test_inputs/ex.pip b/lib/Analysis/isl/test_inputs/ex.pip
new file mode 100644
index 0000000..a405450
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/ex.pip
@@ -0,0 +1,9 @@
+1 5
+1 -1  1  1  0 
+
+-1
+
+3 7
+1  0 -1  0  1  0  0 
+1 -1  0  0  0  1  0 
+1  1  1 -1  0  0  0 
diff --git a/lib/Analysis/isl/test_inputs/ex2.pip b/lib/Analysis/isl/test_inputs/ex2.pip
new file mode 100644
index 0000000..bb59848
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/ex2.pip
@@ -0,0 +1,9 @@
+1 5
+1 -1 1 1 0
+
+-1
+
+3 7
+1 0 -1 0 1 0 0
+1 -1 0 0 0 1 0
+1 1 1 -1 0 0 0
diff --git a/lib/Analysis/isl/test_inputs/exist.pip b/lib/Analysis/isl/test_inputs/exist.pip
new file mode 100644
index 0000000..3e026e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/exist.pip
@@ -0,0 +1,5 @@
+[n] -> { : n mod 2 = 0 }
+
+-1
+
+[n] -> { [i] : n <= i }
diff --git a/lib/Analysis/isl/test_inputs/exist2.pip b/lib/Analysis/isl/test_inputs/exist2.pip
new file mode 100644
index 0000000..441190a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/exist2.pip
@@ -0,0 +1,5 @@
+[n, a, b] -> { : exists e : 1 <= a <= 7e and 9e <= b <= n }
+
+-1
+
+[n, a, b] -> { [i] : n <= 2i }
diff --git a/lib/Analysis/isl/test_inputs/faddeev.pwqp b/lib/Analysis/isl/test_inputs/faddeev.pwqp
new file mode 100644
index 0000000..e7db61d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/faddeev.pwqp
@@ -0,0 +1 @@
+[N] -> { [i, j, k] -> (((4 + 6 * N + 2 * N^2) + (-2 - 2 * N) * j) + ((-2 - N) + j) * k) : j = 1 + i and k = 1 + i and i >= 3 and N <= 100 and i <= N and N >= 10 }
diff --git a/lib/Analysis/isl/test_inputs/fimmel.pip b/lib/Analysis/isl/test_inputs/fimmel.pip
new file mode 100644
index 0000000..a6dee41
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/fimmel.pip
@@ -0,0 +1,12 @@
+0 4
+
+-1
+
+7 6
+1 2  6 0 0 -9
+1 5 -3 0 0 0
+1 2 -10 0 0 15
+1 -2 6 0 0 -3
+1 -2 -6 0 0 17
+1 0 1 -1 0 0
+1 1 0 0 -1 0
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop-tree.ai b/lib/Analysis/isl/test_inputs/flow/kill_loop-tree.ai
new file mode 100644
index 0000000..835e1c0
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop-tree.ai
@@ -0,0 +1,11 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+kill: "{ T[9] -> a[] }"
+schedule:
+  domain: "{ T[i]; S[] }"
+  child:
+    sequence:
+    - filter: "{ T[i] }"
+      child:
+        schedule: "[{ T[i] -> [(i)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop-tree.flow b/lib/Analysis/isl/test_inputs/flow/kill_loop-tree.flow
new file mode 100644
index 0000000..ef089e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop.ai b/lib/Analysis/isl/test_inputs/flow/kill_loop.ai
new file mode 100644
index 0000000..619028f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+must_source: { T[i] -> a[] : 0 <= i < 10 }
+kill: { T[9] -> a[] }
+schedule_map: { T[i] -> [0,i]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop.flow b/lib/Analysis/isl/test_inputs/flow/kill_loop.flow
new file mode 100644
index 0000000..ef089e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop.flow
@@ -0,0 +1,4 @@
+must_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.ai b/lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.ai
new file mode 100644
index 0000000..19d5ff6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.ai
@@ -0,0 +1,11 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+kill: "{ K[] -> a[] }"
+schedule:
+  domain: "{ T[i]; S[]; K[] }"
+  child:
+    sequence:
+    - filter: "{ T[i]; K[] }"
+      child:
+        schedule: "[{ T[i] -> [(i)]; K[] -> [(10)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.flow b/lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.flow
new file mode 100644
index 0000000..ec75edb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop2-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{  }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop2.ai b/lib/Analysis/isl/test_inputs/flow/kill_loop2.ai
new file mode 100644
index 0000000..622bc21
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop2.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+must_source: { T[i] -> a[] : 0 <= i < 10 }
+kill: { K[] -> a[] }
+schedule_map: { T[i] -> [0,i]; K[] -> [0,10]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop2.flow b/lib/Analysis/isl/test_inputs/flow/kill_loop2.flow
new file mode 100644
index 0000000..ec75edb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop2.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{  }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.ai b/lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.ai
new file mode 100644
index 0000000..b14325b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.ai
@@ -0,0 +1,11 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+kill: "{ K[] -> a[] }"
+schedule:
+  domain: "{ T[i]; S[]; K[] }"
+  child:
+    sequence:
+    - filter: "{ T[i]; K[] }"
+      child:
+        schedule: "[{ T[i] -> [(i)]; K[] -> [(9)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.flow b/lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.flow
new file mode 100644
index 0000000..51d2e2a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop3-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop3.ai b/lib/Analysis/isl/test_inputs/flow/kill_loop3.ai
new file mode 100644
index 0000000..436e13c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop3.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+must_source: { T[i] -> a[] : 0 <= i < 10 }
+kill: { K[] -> a[] }
+schedule_map: { T[i] -> [0,i]; K[] -> [0,9]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_loop3.flow b/lib/Analysis/isl/test_inputs/flow/kill_loop3.flow
new file mode 100644
index 0000000..51d2e2a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_loop3.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.ai b/lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.ai
new file mode 100644
index 0000000..9159e47
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.ai
@@ -0,0 +1,11 @@
+sink: "{ S[] -> a[] }"
+may_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+kill: "{ T[4] -> a[] }"
+schedule:
+  domain: "{ T[i]; S[] }"
+  child:
+    sequence:
+    - filter: "{ T[i] }"
+      child:
+        schedule: "[{ T[i] -> [(i)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.flow b/lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.flow
new file mode 100644
index 0000000..7a89b0d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i] -> [S[] -> a[]] : 4 <= i <= 9 }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop.ai b/lib/Analysis/isl/test_inputs/flow/kill_may_loop.ai
new file mode 100644
index 0000000..5d197f6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+may_source: { T[i] -> a[] : 0 <= i < 10 }
+kill: { T[4] -> a[] }
+schedule_map: { T[i] -> [0,i]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop.flow b/lib/Analysis/isl/test_inputs/flow/kill_may_loop.flow
new file mode 100644
index 0000000..7a89b0d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i] -> [S[] -> a[]] : 4 <= i <= 9 }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.ai b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.ai
new file mode 100644
index 0000000..fb5d88f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.ai
@@ -0,0 +1,11 @@
+sink: "{ S[] -> a[] }"
+may_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+kill: "{ T[9] -> a[] }"
+schedule:
+  domain: "{ T[i]; S[] }"
+  child:
+    sequence:
+    - filter: "{ T[i] }"
+      child:
+        schedule: "[{ T[i] -> [(i)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.flow b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.flow
new file mode 100644
index 0000000..51d2e2a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop2.ai b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2.ai
new file mode 100644
index 0000000..09aaf70
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+may_source: { T[i] -> a[] : 0 <= i < 10 }
+kill: { T[9] -> a[] }
+schedule_map: { T[i] -> [0,i]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop2.flow b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2.flow
new file mode 100644
index 0000000..51d2e2a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop2.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.ai b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.ai
new file mode 100644
index 0000000..8097695
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.ai
@@ -0,0 +1,11 @@
+sink: "{ S[] -> a[] }"
+may_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+kill: "{ K[] -> a[] }"
+schedule:
+  domain: "{ T[i]; S[]; K[] }"
+  child:
+    sequence:
+    - filter: "{ T[i]; K[] }"
+      child:
+        schedule: "[{ T[i] -> [(i)]; K[] -> [(4)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.flow b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.flow
new file mode 100644
index 0000000..7a89b0d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i] -> [S[] -> a[]] : 4 <= i <= 9 }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop3.ai b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3.ai
new file mode 100644
index 0000000..b1d2d6c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+may_source: { T[i] -> a[] : 0 <= i < 10 }
+kill: { K[] -> a[] }
+schedule_map: { T[i] -> [0,i]; K[] -> [0,4]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/kill_may_loop3.flow b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3.flow
new file mode 100644
index 0000000..7a89b0d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/kill_may_loop3.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i] -> [S[] -> a[]] : 4 <= i <= 9 }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/loop-tree.ai b/lib/Analysis/isl/test_inputs/flow/loop-tree.ai
new file mode 100644
index 0000000..e7fa351
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/loop-tree.ai
@@ -0,0 +1,10 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+schedule:
+  domain: "{ T[i]; S[] }"
+  child:
+    sequence:
+    - filter: "{ T[i] }"
+      child:
+        schedule: "[{ T[i] -> [(i)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/loop-tree.flow b/lib/Analysis/isl/test_inputs/flow/loop-tree.flow
new file mode 100644
index 0000000..ef089e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/loop-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/loop.ai b/lib/Analysis/isl/test_inputs/flow/loop.ai
new file mode 100644
index 0000000..88c6efa
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/loop.ai
@@ -0,0 +1,3 @@
+sink: { S[] -> a[] }
+must_source: { T[i] -> a[] : 0 <= i < 10 }
+schedule_map: { T[i] -> [0,i]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/loop.flow b/lib/Analysis/isl/test_inputs/flow/loop.flow
new file mode 100644
index 0000000..ef089e5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/loop.flow
@@ -0,0 +1,4 @@
+must_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/may_loop-tree.ai b/lib/Analysis/isl/test_inputs/flow/may_loop-tree.ai
new file mode 100644
index 0000000..de44645
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/may_loop-tree.ai
@@ -0,0 +1,10 @@
+sink: "{ S[] -> a[] }"
+may_source: "{ T[i] -> a[] : 0 <= i <= 9 }"
+schedule:
+  domain: "{ T[i]; S[] }"
+  child:
+    sequence:
+    - filter: "{ T[i] }"
+      child:
+        schedule: "[{ T[i] -> [(i)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/may_loop-tree.flow b/lib/Analysis/isl/test_inputs/flow/may_loop-tree.flow
new file mode 100644
index 0000000..f944ee2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/may_loop-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i] -> [S[] -> a[]] : 0 <= i <= 9 }"
+must_no_source: "{  }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/may_loop.ai b/lib/Analysis/isl/test_inputs/flow/may_loop.ai
new file mode 100644
index 0000000..0a52ce5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/may_loop.ai
@@ -0,0 +1,3 @@
+sink: { S[] -> a[] }
+may_source: { T[i] -> a[] : 0 <= i < 10 }
+schedule_map: { T[i] -> [0,i]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/may_loop.flow b/lib/Analysis/isl/test_inputs/flow/may_loop.flow
new file mode 100644
index 0000000..f944ee2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/may_loop.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i] -> [S[] -> a[]] : 0 <= i <= 9 }"
+must_no_source: "{  }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.ai b/lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.ai
new file mode 100644
index 0000000..960bafb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.ai
@@ -0,0 +1,11 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[i] -> a[] : 2*floor((i)/2) = i and 0 <= i <= 9 }"
+may_source: "{ T[i] -> a[] : 2*floor((1 + i)/2) = 1 + i and 0 <= i <= 9 }"
+schedule:
+  domain: "{ T[i]; S[] }"
+  child:
+    sequence:
+    - filter: "{ T[i] }"
+      child:
+        schedule: "[{ T[i] -> [(i)] }]"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.flow b/lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.flow
new file mode 100644
index 0000000..76033be
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/mixed_loop-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]]; T[i = 8] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/mixed_loop.ai b/lib/Analysis/isl/test_inputs/flow/mixed_loop.ai
new file mode 100644
index 0000000..c797820
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/mixed_loop.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+must_source: { T[i] -> a[] : 0 <= i < 10 and i mod 2 = 0 }
+may_source: { T[i] -> a[] : 0 <= i < 10 and i mod 2 = 1 }
+schedule_map: { T[i] -> [0,i]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/mixed_loop.flow b/lib/Analysis/isl/test_inputs/flow/mixed_loop.flow
new file mode 100644
index 0000000..76033be
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/mixed_loop.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[i = 9] -> [S[] -> a[]]; T[i = 8] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi.ai b/lib/Analysis/isl/test_inputs/flow/multi.ai
new file mode 100644
index 0000000..c76ed66
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi.ai
@@ -0,0 +1,10 @@
+sink: "{ [S_2[] -> __pet_ref_4[]] -> a[] }"
+must_source: "{ [S_0[] -> __pet_ref_0[]] -> a[]; [S_2[] -> __pet_ref_3[]] -> b[]; [S_1[] -> __pet_ref_1[]] -> a[]; [S_1[] -> __pet_ref_2[]] -> a[] }"
+may_source: "{ [S_1[] -> __pet_ref_2[]] -> a[]; [S_1[] -> __pet_ref_1[]] -> a[]; [S_2[] -> __pet_ref_3[]] -> b[]; [S_0[] -> __pet_ref_0[]] -> a[] }"
+schedule:
+  domain: "{ [S_1[] -> __pet_ref_1[]]; [S_1[] -> __pet_ref_2[]]; [S_2[] -> __pet_ref_3[]]; [S_0[] -> __pet_ref_0[]]; [S_2[] -> __pet_ref_4[]] }"
+  child:
+    sequence:
+    - filter: "{ [S_0[] -> __pet_ref_0[]] }"
+    - filter: "{ [S_1[] -> __pet_ref_1[]]; [S_1[] -> __pet_ref_2[]] }"
+    - filter: "{ [S_2[] -> __pet_ref_3[]]; [S_2[] -> __pet_ref_4[]] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi.flow b/lib/Analysis/isl/test_inputs/flow/multi.flow
new file mode 100644
index 0000000..da6b0a1
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ [S_1[] -> __pet_ref_2[]] -> [[S_2[] -> __pet_ref_4[]] -> a[]]; [S_1[] -> __pet_ref_1[]] -> [[S_2[] -> __pet_ref_4[]] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source-tree.ai b/lib/Analysis/isl/test_inputs/flow/multi_source-tree.ai
new file mode 100644
index 0000000..cf5826e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source-tree.ai
@@ -0,0 +1,8 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[] -> a[]; U[] -> a[] }"
+schedule:
+  domain: "{ U[]; S[]; T[] }"
+  child:
+    sequence:
+    - filter: "{ T[]; U[] }"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source-tree.flow b/lib/Analysis/isl/test_inputs/flow/multi_source-tree.flow
new file mode 100644
index 0000000..e8f953a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; U[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source.ai b/lib/Analysis/isl/test_inputs/flow/multi_source.ai
new file mode 100644
index 0000000..1ce3689
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source.ai
@@ -0,0 +1,3 @@
+sink: { S[] -> a[] }
+must_source: { T[] -> a[]; U[] -> a[] }
+schedule_map: { T[] -> [0]; U[] -> [0]; S[] -> [1] }
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source.flow b/lib/Analysis/isl/test_inputs/flow/multi_source.flow
new file mode 100644
index 0000000..e8f953a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; U[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source2-tree.ai b/lib/Analysis/isl/test_inputs/flow/multi_source2-tree.ai
new file mode 100644
index 0000000..d88d96b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source2-tree.ai
@@ -0,0 +1,9 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[] -> a[] }"
+may_source: "{ U[] -> a[] }"
+schedule:
+  domain: "{ U[]; S[]; T[] }"
+  child:
+    sequence:
+    - filter: "{ T[]; U[] }"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source2-tree.flow b/lib/Analysis/isl/test_inputs/flow/multi_source2-tree.flow
new file mode 100644
index 0000000..e8f953a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source2-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; U[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source2.ai b/lib/Analysis/isl/test_inputs/flow/multi_source2.ai
new file mode 100644
index 0000000..ba9f46e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source2.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+must_source: { T[] -> a[] }
+may_source: { U[] -> a[] }
+schedule_map: { T[] -> [0]; U[] -> [0]; S[] -> [1] }
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source2.flow b/lib/Analysis/isl/test_inputs/flow/multi_source2.flow
new file mode 100644
index 0000000..e8f953a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source2.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; U[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source3-tree.ai b/lib/Analysis/isl/test_inputs/flow/multi_source3-tree.ai
new file mode 100644
index 0000000..7cd2465
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source3-tree.ai
@@ -0,0 +1,13 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[] -> a[]; U[] -> a[] }"
+may_source: "{ V[] -> a[] }"
+schedule:
+  domain: "{ S[]; U[]; T[]; V[] }"
+  child:
+    sequence:
+    - filter: "{ U[]; T[]; V[] }"
+      child:
+        sequence:
+        - filter: "{ T[]; U[] }"
+        - filter: "{ V[] }"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source3-tree.flow b/lib/Analysis/isl/test_inputs/flow/multi_source3-tree.flow
new file mode 100644
index 0000000..b037575
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source3-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; U[] -> [S[] -> a[]]; V[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source3.ai b/lib/Analysis/isl/test_inputs/flow/multi_source3.ai
new file mode 100644
index 0000000..e2e3d47
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source3.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+must_source: { T[] -> a[]; U[] -> a[] }
+may_source: { V[] -> a[] }
+schedule_map: { T[] -> [0,0]; U[] -> [0,0]; V[] -> [0,1]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source3.flow b/lib/Analysis/isl/test_inputs/flow/multi_source3.flow
new file mode 100644
index 0000000..b037575
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source3.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; U[] -> [S[] -> a[]]; V[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source4-tree.ai b/lib/Analysis/isl/test_inputs/flow/multi_source4-tree.ai
new file mode 100644
index 0000000..431ac76
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source4-tree.ai
@@ -0,0 +1,13 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[] -> a[]; U[] -> a[] }"
+may_source: "{ V[] -> a[] }"
+schedule:
+  domain: "{ S[]; U[]; T[]; V[] }"
+  child:
+    sequence:
+    - filter: "{ U[]; T[]; V[] }"
+      child:
+        sequence:
+        - filter: "{ U[] }"
+        - filter: "{ V[]; T[] }"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source4-tree.flow b/lib/Analysis/isl/test_inputs/flow/multi_source4-tree.flow
new file mode 100644
index 0000000..8bf4111
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source4-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; V[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source4.ai b/lib/Analysis/isl/test_inputs/flow/multi_source4.ai
new file mode 100644
index 0000000..8ce0ebe
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source4.ai
@@ -0,0 +1,4 @@
+sink: { S[] -> a[] }
+must_source: { T[] -> a[]; U[] -> a[] }
+may_source: { V[] -> a[] }
+schedule_map: { T[] -> [0,1]; U[] -> [0,0]; V[] -> [0,1]; S[] -> [1,0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/multi_source4.flow b/lib/Analysis/isl/test_inputs/flow/multi_source4.flow
new file mode 100644
index 0000000..8bf4111
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/multi_source4.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]]; V[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source-tree.ai b/lib/Analysis/isl/test_inputs/flow/no_source-tree.ai
new file mode 100644
index 0000000..e3eea6d
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source-tree.ai
@@ -0,0 +1,3 @@
+sink: "{ S[] -> a[] }"
+schedule:
+  domain: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source-tree.flow b/lib/Analysis/isl/test_inputs/flow/no_source-tree.flow
new file mode 100644
index 0000000..2ed34cd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{  }"
+must_no_source: "{ S[] -> a[] }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source.ai b/lib/Analysis/isl/test_inputs/flow/no_source.ai
new file mode 100644
index 0000000..52b07d6
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source.ai
@@ -0,0 +1,2 @@
+sink: { S[] -> a[] }
+schedule_map: { S[] -> [] }
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source.flow b/lib/Analysis/isl/test_inputs/flow/no_source.flow
new file mode 100644
index 0000000..2ed34cd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{  }"
+must_no_source: "{ S[] -> a[] }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source2-tree.ai b/lib/Analysis/isl/test_inputs/flow/no_source2-tree.ai
new file mode 100644
index 0000000..1ef6e52
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source2-tree.ai
@@ -0,0 +1,8 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[] -> a[] }"
+schedule:
+  domain: "{ S[]; T[] }"
+  child:
+    sequence:
+    - filter: "{ S[] }"
+    - filter: "{ T[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source2-tree.flow b/lib/Analysis/isl/test_inputs/flow/no_source2-tree.flow
new file mode 100644
index 0000000..2ed34cd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source2-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{  }"
+must_no_source: "{ S[] -> a[] }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source2.ai b/lib/Analysis/isl/test_inputs/flow/no_source2.ai
new file mode 100644
index 0000000..b13e798
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source2.ai
@@ -0,0 +1,3 @@
+sink: { S[] -> a[] }
+must_source: { T[] -> a[] }
+schedule_map: { T[] -> [1]; S[] -> [0] }
diff --git a/lib/Analysis/isl/test_inputs/flow/no_source2.flow b/lib/Analysis/isl/test_inputs/flow/no_source2.flow
new file mode 100644
index 0000000..2ed34cd
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/no_source2.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{  }"
+must_no_source: "{ S[] -> a[] }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/single_may_source-tree.ai b/lib/Analysis/isl/test_inputs/flow/single_may_source-tree.ai
new file mode 100644
index 0000000..f05980a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_may_source-tree.ai
@@ -0,0 +1,8 @@
+sink: "{ S[] -> a[] }"
+may_source: "{ T[] -> a[] }"
+schedule:
+  domain: "{ S[]; T[] }"
+  child:
+    sequence:
+    - filter: "{ T[] }"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/single_may_source-tree.flow b/lib/Analysis/isl/test_inputs/flow/single_may_source-tree.flow
new file mode 100644
index 0000000..3034b85
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_may_source-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/single_may_source.ai b/lib/Analysis/isl/test_inputs/flow/single_may_source.ai
new file mode 100644
index 0000000..58d0a7f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_may_source.ai
@@ -0,0 +1,3 @@
+sink: { S[] -> a[] }
+may_source: { T[] -> a[] }
+schedule_map: { T[] -> [0]; S[] -> [1] }
diff --git a/lib/Analysis/isl/test_inputs/flow/single_may_source.flow b/lib/Analysis/isl/test_inputs/flow/single_may_source.flow
new file mode 100644
index 0000000..3034b85
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_may_source.flow
@@ -0,0 +1,4 @@
+must_dependence: "{  }"
+may_dependence: "{ T[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{ S[] -> a[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/single_source-tree.ai b/lib/Analysis/isl/test_inputs/flow/single_source-tree.ai
new file mode 100644
index 0000000..3af5f2f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_source-tree.ai
@@ -0,0 +1,8 @@
+sink: "{ S[] -> a[] }"
+must_source: "{ T[] -> a[] }"
+schedule:
+  domain: "{ S[]; T[] }"
+  child:
+    sequence:
+    - filter: "{ T[] }"
+    - filter: "{ S[] }"
diff --git a/lib/Analysis/isl/test_inputs/flow/single_source-tree.flow b/lib/Analysis/isl/test_inputs/flow/single_source-tree.flow
new file mode 100644
index 0000000..e72b8d7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_source-tree.flow
@@ -0,0 +1,4 @@
+must_dependence: "{ T[] -> [S[] -> a[]] }"
+may_dependence: "{ T[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/flow/single_source.ai b/lib/Analysis/isl/test_inputs/flow/single_source.ai
new file mode 100644
index 0000000..0a00e5b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_source.ai
@@ -0,0 +1,3 @@
+sink: { S[] -> a[] }
+must_source: { T[] -> a[] }
+schedule_map: { T[] -> [0]; S[] -> [1] }
diff --git a/lib/Analysis/isl/test_inputs/flow/single_source.flow b/lib/Analysis/isl/test_inputs/flow/single_source.flow
new file mode 100644
index 0000000..e72b8d7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/flow/single_source.flow
@@ -0,0 +1,4 @@
+must_dependence: "{ T[] -> [S[] -> a[]] }"
+may_dependence: "{ T[] -> [S[] -> a[]] }"
+must_no_source: "{  }"
+may_no_source: "{  }"
diff --git a/lib/Analysis/isl/test_inputs/gist1.polylib b/lib/Analysis/isl/test_inputs/gist1.polylib
new file mode 100644
index 0000000..802a4eb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/gist1.polylib
@@ -0,0 +1,14 @@
+4 5
+0 1 0 0 -1
+0 0 1 0 1
+0 0 0 1 -3
+1 0 0 0 1
+
+4 5
+0 1 0 0 -1
+0 0 1 1 -2
+1 0 0 1 0
+1 0 0 -1 3
+
+1 5
+0 0 1 0 1
diff --git a/lib/Analysis/isl/test_inputs/linearExample.pwqp b/lib/Analysis/isl/test_inputs/linearExample.pwqp
new file mode 100644
index 0000000..24c5394
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/linearExample.pwqp
@@ -0,0 +1 @@
+[N, M, L] -> { [i, j, k] -> ((1/2 * i + 5 * j) + 1/7 * k) : i >= 0 and k >= -N + i and k >= -M - j and j <= L + i and L >= 0 and L >= -M }
diff --git a/lib/Analysis/isl/test_inputs/max.pip b/lib/Analysis/isl/test_inputs/max.pip
new file mode 100644
index 0000000..e8af57b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/max.pip
@@ -0,0 +1,9 @@
+0 3
+
+-1
+
+4 5
+1 -1  0  1  0
+1  0 -1  1  0
+1 -1  3 -2 12
+1  2 -1 -1  3
diff --git a/lib/Analysis/isl/test_inputs/neg.pwqp b/lib/Analysis/isl/test_inputs/neg.pwqp
new file mode 100644
index 0000000..596a7d7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/neg.pwqp
@@ -0,0 +1 @@
+[n] -> { [i0] -> i0^2 : i0 >= -20 - n and i0 <= n and i0 <= -1 and n >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/negative.pip b/lib/Analysis/isl/test_inputs/negative.pip
new file mode 100644
index 0000000..45090a5
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/negative.pip
@@ -0,0 +1,9 @@
+1 3
+#  n  1
+1  1 -1 # n >= 1
+-1
+
+2 4
+#  i  n  1
+1  1  0  1 # i >= -1
+1 -1  1  0 # i <= n
diff --git a/lib/Analysis/isl/test_inputs/philippe.pwqp b/lib/Analysis/isl/test_inputs/philippe.pwqp
new file mode 100644
index 0000000..1c56e7a
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/philippe.pwqp
@@ -0,0 +1 @@
+[N] -> { [i, j] -> ((1/2 * i + 1/2 * i^2) + j) : i <= N and j >= 0 and j <= i }
diff --git a/lib/Analysis/isl/test_inputs/philippe3vars.pwqp b/lib/Analysis/isl/test_inputs/philippe3vars.pwqp
new file mode 100644
index 0000000..8d07496
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/philippe3vars.pwqp
@@ -0,0 +1 @@
+[N] -> { [i, j, k] -> (((1/2 * i + 1/2 * i^2) + j) + k^3) : i >= 0 and k >= -N + i and k >= -j and j <= i }
diff --git a/lib/Analysis/isl/test_inputs/philippe3vars3pars.pwqp b/lib/Analysis/isl/test_inputs/philippe3vars3pars.pwqp
new file mode 100644
index 0000000..f81b8cc
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/philippe3vars3pars.pwqp
@@ -0,0 +1 @@
+[N, M, L] -> { [i, j, k] -> (((1/2 * i + 1/2 * i^2) + j) + k^3) : i >= 0 and k >= -N + i and k >= -M - j and j <= L + i and L >= 0 and L >= -M }
diff --git a/lib/Analysis/isl/test_inputs/philippeNeg.pwqp b/lib/Analysis/isl/test_inputs/philippeNeg.pwqp
new file mode 100644
index 0000000..24dc805
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/philippeNeg.pwqp
@@ -0,0 +1 @@
+[N] -> { [i, j] -> ((1/2 * i + 1/2 * i^2) + j) : i <= N and j >= -1 and j <= i }
diff --git a/lib/Analysis/isl/test_inputs/philippePolynomialCoeff.pwqp b/lib/Analysis/isl/test_inputs/philippePolynomialCoeff.pwqp
new file mode 100644
index 0000000..e6327c7
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/philippePolynomialCoeff.pwqp
@@ -0,0 +1 @@
+[N, M] -> { [i, j] -> ((N * i + (1/5 * N + N^2) * i^2) + 5 * j) : i <= N and j >= 0 and j <= i and M >= 0 }
diff --git a/lib/Analysis/isl/test_inputs/philippePolynomialCoeff1P.pwqp b/lib/Analysis/isl/test_inputs/philippePolynomialCoeff1P.pwqp
new file mode 100644
index 0000000..ae01d2f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/philippePolynomialCoeff1P.pwqp
@@ -0,0 +1 @@
+[N] -> { [i, j] -> ((N * i + (1/5 * N + N^2) * i^2) + 5 * j) : i <= N and j >= 0 and j <= i }
diff --git a/lib/Analysis/isl/test_inputs/product.pwqp b/lib/Analysis/isl/test_inputs/product.pwqp
new file mode 100644
index 0000000..ee48b85
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/product.pwqp
@@ -0,0 +1 @@
+[N] -> { [i0, i1, i2] -> (i0^3 * i1^2 + N * i1 * i2) : i0 >= 0 and i0 <= N and i1 >= 0 and i1 <= N and i2 >= 0 and i2 <= N }
diff --git a/lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.sc b/lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.sc
new file mode 100644
index 0000000..f90bd88
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.sc
@@ -0,0 +1,5 @@
+# Check that the Feautrier schedule is not confused by
+# compressed nodes in a subgraph of the original dependence graph.
+# OPTIONS: --schedule-algorithm=feautrier
+domain: { A[]; B[0]; C[] }
+validity: { A[] -> B[0] }
diff --git a/lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.st b/lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.st
new file mode 100644
index 0000000..8d6c654
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/schedule/feautrier_compressed.st
@@ -0,0 +1,11 @@
+domain: "{ B[0]; C[]; A[] }"
+child:
+  set:
+  - filter: "{ B[i0]; A[] }"
+    child:
+      schedule: "[{ B[i0] -> [(1)]; A[] -> [(0)] }]"
+      child:
+        set:
+        - filter: "{ A[] }"
+        - filter: "{ B[i0] }"
+  - filter: "{ C[] }"
diff --git a/lib/Analysis/isl/test_inputs/seghir-vd.pip b/lib/Analysis/isl/test_inputs/seghir-vd.pip
new file mode 100644
index 0000000..b5395fb
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/seghir-vd.pip
@@ -0,0 +1,17 @@
+0 6
+
+-1
+
+9 8
+ 0 0 0 1 1 0 0 2
+ 1 2 1 0 0 1 0 0
+ 1 0 1 0 -1 0 0 -1
+ 1 -2 -1 0 0 0 0 -1
+ 1 7 3 0 0 0 0 -1
+ 1 -6 -4 0 1 0 3 1
+ 1 -7 -3 0 0 1 6 4
+ 1 0 0 0 0 0 1 0
+ 1 0 0 0 0 0 0 1
+
+Urs_parms
+Urs_unknowns
diff --git a/lib/Analysis/isl/test_inputs/set.omega b/lib/Analysis/isl/test_inputs/set.omega
new file mode 100644
index 0000000..ac8485f
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/set.omega
@@ -0,0 +1 @@
+{[y]: Exists ( alpha : 2alpha = y)}
diff --git a/lib/Analysis/isl/test_inputs/small.pip b/lib/Analysis/isl/test_inputs/small.pip
new file mode 100644
index 0000000..59557d2
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/small.pip
@@ -0,0 +1,9 @@
+0 2
+
+-1
+
+4 4
+1  1  0  0
+1  0  1  0
+1  1 -3 12
+1 -2  1  3
diff --git a/lib/Analysis/isl/test_inputs/sor1d.pip b/lib/Analysis/isl/test_inputs/sor1d.pip
new file mode 100644
index 0000000..1bef89e
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/sor1d.pip
@@ -0,0 +1,28 @@
+2 4
+ 1	1	0	0
+ 1	0	1	0
+
+-1
+
+20 8
+ 
+ 0	-1	0	0	0	0	0	2
+ 0	0	-1	0	0	0	0	1
+ 0	0	0	-1	0	0	0	2
+ 0	0	0	0	-1	0	0	4
+ 1	0	0	0	1	0	0	-2
+ 1	-2	0	2	1	0	0	-4
+ 1	0	0	0	-1	0	1	-1
+ 1	2	0	-2	-1	0	0	5
+ 1	0	0	1	0	0	0	-1
+ 1	0	-2	1	0	0	0	0
+ 1	-2	0	2	0	0	1	-5
+ 1	0	0	-1	0	1	0	0
+ 1	0	2	-1	0	0	0	1
+ 1	2	0	-2	0	0	0	3
+ 1	0	1	0	0	0	0	0
+ 1	-2	4	0	0	0	1	-3
+ 1	0	-2	0	0	1	0	0
+ 1	2	-4	0	0	0	0	3
+ 1	2	0	0	0	0	0	1
+ 1	-2	0	0	0	2	1	-5
diff --git a/lib/Analysis/isl/test_inputs/split.pwqp b/lib/Analysis/isl/test_inputs/split.pwqp
new file mode 100644
index 0000000..1804563
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/split.pwqp
@@ -0,0 +1 @@
+[n] -> { [x] -> -1 + [(x+5)/7] : -n - 20 <= x <= n }
diff --git a/lib/Analysis/isl/test_inputs/square.pip b/lib/Analysis/isl/test_inputs/square.pip
new file mode 100644
index 0000000..7bb3f0c
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/square.pip
@@ -0,0 +1,9 @@
+0 3
+
+-1
+
+4 5
+1  1  0  0  0
+1 -1  0  1  0
+1  0  1  0  0
+1  0 -1  1  0
diff --git a/lib/Analysis/isl/test_inputs/sven.pip b/lib/Analysis/isl/test_inputs/sven.pip
new file mode 100644
index 0000000..8602769
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/sven.pip
@@ -0,0 +1,7 @@
+0 3
+
+-1
+
+2 3
+1  1 -4
+1 -1 10
diff --git a/lib/Analysis/isl/test_inputs/test3Deg3Var.pwqp b/lib/Analysis/isl/test_inputs/test3Deg3Var.pwqp
new file mode 100644
index 0000000..d9a9ea9
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/test3Deg3Var.pwqp
@@ -0,0 +1 @@
+[p] -> { [n, m] -> (n + n^3) : n >= 1 and m >= n and m <= p }
diff --git a/lib/Analysis/isl/test_inputs/tobi.pip b/lib/Analysis/isl/test_inputs/tobi.pip
new file mode 100644
index 0000000..c31beae
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/tobi.pip
@@ -0,0 +1,15 @@
+2 3
+1 1 -281
+1 -1 14000
+
+-1
+
+6 6
+0  -392     0     8    -1     0
+0   392     8     0     1     0
+1    -1     0     0     0     0
+1     1     0     0     0    35
+1   392     0     0     1     0
+1  -392     0     0    -1   280
+
+Urs_unknowns
diff --git a/lib/Analysis/isl/test_inputs/toplas.pwqp b/lib/Analysis/isl/test_inputs/toplas.pwqp
new file mode 100644
index 0000000..9c09995
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/toplas.pwqp
@@ -0,0 +1 @@
+[n] -> { [i0, i1] -> (((4 * n - n^2) + (-3/2 + 2 * n) * i0 - 1/2 * i0^2) - i1) : i1 >= -1 + 3n - i0 and i1 >= -1 + 2n - i0 and i0 >= 0 and i1 <= -2 + 4n - i0 and i0 <= -2 + 4n and i0 <= -1 + 3n and i1 >= 0 and i1 <= -1 + n }
diff --git a/lib/Analysis/isl/test_inputs/unexpanded.pwqp b/lib/Analysis/isl/test_inputs/unexpanded.pwqp
new file mode 100644
index 0000000..5626d3b
--- /dev/null
+++ b/lib/Analysis/isl/test_inputs/unexpanded.pwqp
@@ -0,0 +1 @@
+{ [x, y] -> ((x - x^2) * y + (-x + x^2) * y^2) : x >= 0 and x <= 2 and y >= 0 and y <= 2 }
-- 
1.8.3.1

